; Original script details:
;   Name:     AHK Picture Viewer
;   Version:  1.0.0 on Oct 4, 2010 by SBC
;   Platform: Windows XP or later
;   Author:   SBC - http://sites.google.com/site/littlescripting/
;   Found on: https://autohotkey.com/board/topic/58226-ahk-picture-viewer/
;
; New script details:
;   Name:     Quick Picto Viewer
;   Version:  [see change logs file]
;   Platform: Windows XP*, Windows 7 or later; Preferred is Windows 10.
;   Author:   Marius Șucan - http://marius.sucan.ro/
;   GitHub:   https://github.com/marius-sucan/Quick-Picto-Viewer
;
; *It can run on Windows XP, but various features might not work.
; You must provide all the following files found in Windows 10
; installations x32/x64 in the same folder with the QPV binary:
; api-ms-win-core-*-l1-1-0.dll [43 files]
; api-ms-win-crt-*-l1-1-0.dll [15 files]
; api-ms-win-core-file-l1-2-0.dll
; api-ms-win-core-file-l2-1-0.dll
; api-ms-win-core-localization-l1-2-0.dll
; api-ms-win-core-synch-l1-2-0.dll
; ucrtbase.dll
;
; The following DLLs are included in the Quick Picto Viewer package:
; FreeImage.dll
; msvcr100.dll
; sqlite3.dll
; vcomp140.dll
; vcruntime140.dll
;
; Script main functionalities:
; Display images and creates slideshows using GDI+ and FreeImage
; 85 supported image formats: jpeg, jpg, bmp, png, gif, tif, emf
; hdr, exr, webp, raw and many more...
;
; Original Licence: GPL. Please reffer to this page for more information. http://www.gnu.org/licenses/gpl.html
; Current licence: I do not know , I do not care. Licences are for obedient entities.
;
;@Ahk2Exe-AddResource LIB Lib\module-interface.ahk
;@Ahk2Exe-AddResource LIB Lib\module-fim-thumbs.ahk
;@Ahk2Exe-SetName Quick Picto Viewer
;@Ahk2Exe-SetDescription Quick Picto Viewer
;@Ahk2Exe-SetVersion 5.2.5
;@Ahk2Exe-SetCopyright Marius Şucan (2019-2021)
;@Ahk2Exe-SetCompanyName marius.sucan.ro
;@Ahk2Exe-SetMainIcon qpv-icon.ico
;
;___________ Auto Execute Section ____

#NoEnv
#NoTrayIcon
#MaxHotkeysPerInterval, 500
#MaxThreads, 255
#MaxThreadsPerHotkey, 1
#MaxThreadsBuffer, Off
#MaxMem, 9924
#IfTimeout, 35
#SingleInstance, off
#UseHook, Off
SetWorkingDir, %A_ScriptDir%
#Include Lib\Gdip_All.ahk           ; graphics display interface plus v1.1, extended compilation editon
#Include Lib\Gdi.ahk                ; graphics display interface written by Marius Șucan
#Include Lib\SGdiPrint.ahk
; #Include Lib\guicontroltips.ahk
#Include Lib\freeimage-wrapper.ahk  ; used to load exotic file formats ; written by Marius Șucan
#Include Lib\MCI.ahk                ; media controller interface [ used for audio annotations/files associated with images ]
#Include Lib\wia.ahk                ; windows image acquisition ; used for acquiring images from scanners 
; #Include Lib\wic.ahk              ; windows image component ; I would like to finish this implementation one day...
#Include Lib\Class_SQLiteDB.ahk     ; used for slideshow databases and maintaining a list of viewed images [if activated]
#Include Lib\msgbox2.ahk
#Include Lib\hashtable.ahk
#Include Lib\file-get-prop-lib.ahk  ; used to get file properties on Alt+Enter [ File Information panel ]

SetWinDelay, 1
SetBatchLines, -1

Global PVhwnd := 1, hGDIwin := 1, hGDIthumbsWin := 1, pPen4 := "", pPen5 := "", pPen6 := "", unCompiledExePath := "", pBrushZ := ""
   , glPG := "", glOBM := "", glHbitmap := "", glHDC := "", pPen1 := "", pPen1d, pPen2 := "", pPen3 := ""
   , pBrushHatch := "", pBrushWinBGR := "", pBrushA := "", pBrushB := "", pBrushC := "", pBrushD := "", currentPixFmt := ""
   , pBrushE := "", pBrushHatchLow, hGuiTip := 1, hSetWinGui := 1, undoSelLevelsArray := []
   , prevFullThumbsUpdate := 1, winGDIcreated := 0, ThumbsWinGDIcreated := 0, currentFilesListModified := 0
   , hPicOnGui1 := "", scriptStartTime := A_TickCount, lastEditRHChange :=1, doubleBlurPreviewArea := 0
   , newStaticFoldersListCache := [], lastEditRWChange := 1, QPVjournal := [], pPen7 := "", hQPVtoolbar
   , mainCompiledExe := "", mainCompiledPath := "", wasInitFIMlib := 0, hGDIselectWin, allowNextSlide := 1
   , filteredMap2mainList := [], thumbsCacheFolder := A_ScriptDir "\thumbs-cache", hSNDsong
   , resultedFilesList := [], currentFileIndex := "", maxFilesIndex := 0, gdiBitmapIDentire := 0
   , appTitle := "Quick Picto Viewer", FirstRun := 1, hSNDmediaFile := "", mouseToolTipWinCreated := 0
   , bckpResultedFilesList := [], bckpMaxFilesIndex := 0, DynamicFoldersList := "", lastPointerUseZeit := 1
   , animGIFplaying := 0, startPageIndex := 0, RandyIMGids := [], IMGdecalageY := 1, IMGdecalageX := 1
   , RandyIMGnow := 0, GDIPToken := "", gdiBitmapSmall := "", hSNDmedia := "", imgIndexEditing := 0
   , AprevGdiBitmap := "", BprevGdiBitmap := "", msgDisplayTime := 3000, gdiBitmapIDcall := ""
   , slideShowRunning := 0, CurrentSLD := "", markedSelectFile := 0, IMGlargerViewPort := 0
   , ResolutionWidth := "", ResolutionHeight := "", prevStartIndex := 1, mustReloadThumbsList := 0
   , gdiBitmap := "", mainSettingsFile := "quick-picto-viewer.ini", mainRecentsFile := "quick-picto-viewer-recents.ini"
   , mustOpenStartFolder := "", mainFavesFile := "quick-picto-viewer-favourites.ini", miniFavesFile := "quick-picto-viewer-minifaves.ini"
   , RegExFilesPattern := "i)^(.\:\\).*(\.(ico|dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif))$"
   , RegExFIMformPtrn := "i)(.\\*\.(DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f))$"
   , saveTypesRegEX := "i)(.\.(bmp|j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp|gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|xpm))$"
   , saveTypesFriendly := ".BMP, .GIF, .HDP, .J2K, .JFIF, .JIF, .JNG, .JP2, .JPE, .JPG, .JXR, .PNG, .PPM, .TGA, .TIF, ..WDP, .WEBP or .XPM"
   , saveAlphaTypesRegEX := "i)(.\.(j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp))$"
   , openFptrn1 := "*.png;*.bmp;*.gif;*.jpg;*.tif;*.tga;*.webp;*.jpeg", prevLoadedImageIndex := 0
   , openFptrn2 := "*.dds;*.emf;*.exr;*.g3;*.hdp;*.iff;*.j2c;*.j2k;*.jbg;*.jif;*.jng;*.jp2;*.jxr;*.koa;*.lbm;*.mng;*.pbm;*.pcd;*.pct;*.pcx;*.pfm;*.pgm;*.pic;*.ppm;*.psd;*.ras;*.sgi;*.wap;*.wbm;*.wbmp;*.wdp;*.wmf;*.xbm;*.xpm"
   , openFptrn3 := "*.3fr;*.arw;*.bay;*.bmq;*.cap;*.cine;*.cr2;*.crw;*.cs1;*.dc2;*.dcr;*.drf;*.dsc;*.erf;*.fff;*.hdr;*.ia;*.iiq;*.k25;*.kc2;*.kdc;*.mdc;*.mef;*.mos;*.mrw;*.nef;*.nrw;*.orf;*.pef;*.ptx;*.pxn;*.qtk;*.raf;*.raw;*.rdc;*.rw2;*.rwz;*.sr2;*.srf;*.x3f"
   , openFptrn4 := "*.tiff;*.targa;*.jpe;*.dib;*.pict;*.rle", userJpegQuality := 90
   , saveImgFormatsList := {1:"bmp", 2:"gif", 3:"hdp", 4:"j2k", 5:"jfif", 6:"jng", 7:"jp2", 8:"jpg", 9:"jxr", 10:"png", 11:"ppm", 12:"tga", 13:"tif", 14:"wdp", 15:"webp", 16:"xpm"}
   , dialogSaveFptrn := "Portable Network Graphics (*.png)|WebP (*.webp)|Common JPEG (*.jpg;*.jpeg)|TrueVision Targa (*.tga)|Tagged Image File Format (*.tif;*.tiff)|Non-animated Compuserve GIF (*.gif)|Windows Bitmap (*.bmp)|HD Photo (*.hdp)|JPEG File Interchange Format (*.jfif)|JNG (*.jng)|JPEG 2000 (*.jp2;*.j2k)|JPEG-XR (*.jxr)|Portable PixelMap (*.ppm)|WDP (*.wdp)|XPM (*.xpm)"
   , dialogSaveIndexes := {1:"png", 2:"webp", 3:"jpg", 4:"tga", 5:"tif", 6:"gif", 7:"bmp", 8:"hdp", 9:"jfif", 10:"jng", 11:"jp2", 12:"jxr", 13:"ppm", 14:"wdp", 15:"xpm"}
   , LargeUIfontValue := 14, AnyWindowOpen := 0, toolTipGuiCreated := 0, panelWinCollapsed :=0 
   , PrefsLargeFonts := 0, OSDbgrColor := "252525", OSDtextColor := "FEFDFC", initialCustomShapeCoords := ""
   , PasteFntSize := 35, OSDfntSize := 23, OSDFontName := "Arial", prevOpenFolderPath := ""
   , mustGenerateStaticFolders := 1, lastWinDrag := 1, img2resizePath := "", colorPickerModeNow := 0
   , prevFileMovePath := "", lastGIFdestroy := 1, prevAnimGIFwas := "", prevFilesSortMode
   , thumbsW := 300, thumbsH := 300, thumbsDisplaying := 0, scrollAxis := 0, userSeenSessionImagesArray := new hashtable()
   , othumbsW := 300, othumbsH := 300, ForceRegenStaticFolders := 0, vPselRotation := 0
   , CountFilesFolderzList := 0, RecursiveStaticRescan := 0, imgSelLargerViewPort := 0, dynamicLiveObjVisible := 1
   , UsrMustInvertFilter := 0, userActionConflictingFile := 1, LastWasFastDisplay := 0, hEditA := 0
   , prevFileSavePath := "", imgHUDbaseUnit := Round(OSDfntSize*2.5), lastLongOperationAbort := 1
   , lastOtherWinClose := 1, UsrCopyMoveOperation := 2, editingSelectionNow := 0, EntryMarkedMoveIndex := 0
   , ForceNoColorMatrix := 0, prevFastDisplay := 1, hSNDmediaDuration, lastMenuBarUpdated := 1
   , imgSelX1 := 0, imgSelY1 := 0, imgSelX2 := -1, imgSelY2 := -1, adjustNowSel := 0, hasHamDistCached := 0
   , prevImgSelX1 := 0, prevImgSelY1 := 0, prevImgSelX2 := -1, prevImgSelY2 := -1, prevSelDotX := "", prevSelDotY := "", prevSelDotAx := "", prevSelDotAy := ""
   , selDotX := "", selDotY := "", selDotAx := "", selDotAy := "", selDotBx := "", selDotBy := "", selDotCx := "", selDotCy := "", selDotDx := "", selDotDy := ""
   , prcSelX1 := 0, prcSelX2 := 0.5, prcSelY1 := 0, prcSelY2 := 0.5, pBrushF := "", lastWasLowQuality := 0
   , SelDotsSize := imgHUDbaseUnit//4, ViewPortBMPcache := "", startZeitIMGload := 0, cachedAllSessionsSeen := new hashtable()
   , imageLoading := 0, PrevGuiSizeEvent := 0, imgSelOutViewPort := 0, prevGUIresize := 1, prevLastImg := []
   , imgEditPanelOpened := 0, jpegDoCrop := 0, jpegDesiredOperation := 1, copyMoveDoLastOption := 0
   , rDesireWriteFMT := "jpg", FIMfailed2init := 0, prevMaxSelX := "", prevMaxSelY := "", prevDestPosX := "", prevDestPosY := ""
   , hCursBusy := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32514, "Ptr")  ; IDC_WAIT
   , CCLVO := "-E0x200 +Border -Hdr -Multi +ReadOnly Report AltSubmit gInvokeStandardDialogColorPicker", FontList := []
   , totalFramesIndex := "", pVwinTitle := "", AprevImgCall := "", BprevImgCall := "", prevSetWinPosX := "", prevSetWinPosY := ""
   , coreIMGzeitLoad := 0, desiredFrameIndex := 0, prevDrawingMode := 0, sqlFailedInit := 0, currentImgModified := 0
   , currIMGdetails := [], AbackupIMGdetails := [], BbackupIMGdetails := [], mainLoadedIMGdetails := []
   , diffIMGdecX := 0, diffIMGdecY := 0, prevGDIvpCache := "", oldZoomLevel := 0, fullPath2exe := "", hasMemThumbsCached := 0
   , hitTestSelectionPath := "", scrollBarHy := 0, scrollBarVx := 0, HistogramBMP := "", internalColorDepth := 0
   , drawModeBzeit := 1, drawModeAzeit := 1, drawModeCzeit := 1, prevColorAdjustZeit := 1, AutoCropBordersSize := 15
   , GDIfadeVPcache := "", executingCanceableOperation := 1, hCropCornersPic, UserMemBMP := "", userSearchString := ""
   , systemCores := 1, realSystemCores := 1, hasInitSpecialMode := 0, CountGIFframes := 0, prevSlideShowStop := 1
   , prevTryThumbsUpdate := 1, thumbsSizeQuality := 245, prevFullIndexThumbsUpdate := -1, userClipBMPpaste
   , UserNewWidth := 0, UserNewHeight := 0, UserNewDPI := 0, viewportStampBMP := "", tinyPrevAreaCoordY := 1
   , ThumbsStatusBarH := 0, activeSQLdb := "", SLDtypeLoaded := 0, sldsPattern := "i)(.\.(sld|sldb))$"
   , imgThumbsCacheIDsArray := [], imgThumbsCacheArray := [], viewportIDstampBMP := 0, qpvMainDll, sqlDBrowID := 1
   , prevVPselRotation, prevrotateSelBoundsKeepRatio, prevEllipseSelectMode, currentSelUndoLevel := 1, liveDrawingBrushTool := 0
   , seenImagesDB := "", mustRecordSeenImgs := 0, hEditField := "", gdiBMPvPsize := "", maxGDIbmpSize := 533654021
   , GDIcacheSRCfileA := "", idGDIcacheSRCfileA := "", GDIcacheSRCfileB := "", idGDIcacheSRCfileB := "", prevOpenedWindow := []
   , startLongOperation := 1, thisIMGisDownScaled := 0, simpleOpRotationAngle := 1, UserTextArea := ""
   , runningLongOperation := 0, hasReachedMaxUndoLevels := 0, GIFframesPlayied := 0, allImagesWereSeen := 0
   , 2NDglHbitmap := "", 2NDglHDC := "", 2NDglOBM := "", 2NDglPG := "", mainThreadHwnd := "", imgDecLX := "", imgDecLY := ""
   , undoLevelsArray := [], currentUndoLevel := 0, maxUndoLevels := 50, undoLevelsRecorded := 0, hGDIinfosWin := ""
   , zeitSillyPrevent := 1, PrintPosX, PrintPosY, PrintPosW, PrintPosH, tinyPrevAreaCoordX := 1, UsrEditFileDestination := ""
   , hLVmainu := 0, tempBtnVisible := "null", tempBtnGuiBtnArray := [], lastRenameUndo := [], userMultiCoresLimit := 100
   , drawingShapeNow := 0, customShapePoints := [], prevResizedVPimgW := "", prevResizedVPimgH := "", PenuDrawLive := ""
   , initialDrawingStartCoords := [], drawingLiveMode := 0, cardinalCurveCustomShape := 0, openingPanelNow := 0
   , closedLineCustomShape := 1, tensionCurveCustomShape := 0.5, userDefinedSelCoords := 0, thisSearchString := ""
   , SelectionCoordsType := 1, PasteInPlaceAlphaFile := "", infoBoxGdiCached := "", watchFolderDetails := "", isNowFakeWinOpen := 0
   , FilteruMinRange, FilteruMaxRange, userFilterSizeProperty := 1, qpvCanvasHasInit := 0, coreDesiredPixFmt := "0xE200B"
   , FilteruDateMinRange, FilteruDateMaxRange, InternalFilterString, userFilterProperty := 1, userFindDupePresets := 1
   , HUDobjNavBoxu := [], HUDobjHistoBoxu := [], globalhFIFimg := 0, userAddedFavesCount := 0, bckpCurrentFileIndex := 0
   , maxFavesEntries := 198765, gdipLastError := 0, hasDrawnImageMap := 0, hasDrawnHistoMap := 0, lastZeitFileSelect := 1
   , isWinXP := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_2003" || A_OSVersion="WIN_2000") ? 1 : 0, mustSnapLiveDrawPoints := 0
   , QPVpid := GetCurrentProcessId(), preventUndoLevels := 0, maxMemUndoLevels := 979394, delayiedHUDmsg := "", hamLowLim := 0, hamUppLim := 0
   , delayiedHUDperc := 0, delayedfunc2exec := 0, lastOSDtooltipInvoked := 1, lastTimeToggleThumbs := 1, dupesStringFilter := ""
   , CurrentPanelTab := 0, debugModa := !A_IsCompiled, createdGDIobjsArray := [], countGDIobjects := 0, uiPasteInPlaceAlphaFile
   , oldCustomShapePoints := [], TVlistFolders, hfdTreeWinGui, folderTreeWinOpen := 0, VPstampBMPx := 0, VPstampBMPy := 0
   , reviewSelectedIndexes := [], toBeExcludedIndexes := [], fimMultiPage := 0, fimMultiBMP := 0, staticlistViewFilteru
   , listViewReviewFilteru := "", IMGentirelylargerThanVP := 0, mustPreventMenus := 0, hquickMenuSearchWin := 0
   , VisibleQuickMenuSearchWin := 0, userQuickMenusEdit := "", preventHUDelements := 0, OSDwinFadedBrushBGR := 0
   , gdiAmbientalTexBrush := "", GDIbrushWinBGR := "", GDIbrushHatch := "", vpImgPanningNow := 0, viewportDynamicOBJcoords := []
   , mustCaptureCloneBrush := 0, hCropCornersPic2, globalWinStates := [], userAlphaMaskBmpPainted := "", lastPaintEventID := 1
   , prevImgEditZeit := 1, hudBTNfuncu, hudBTNtypeFuncu, hudBTNheightFuncu, hudBTNwidthFuncu, TouchToolbarGUIcreated := 0
   , tlbrIconzList := [], ToolBarBtnWidth := 45, UserToolbarY := 60, UserToolbarX := 200, currentKbdBTNtlbr := 1
   , ToolbarWinW := 0, ToolbarWinH := 0, isToolbarKBDnav := 0
   , QPVregEntry := "HKEY_CURRENT_USER\SOFTWARE\Quick Picto Viewer"
   , appVersion := "5.2.5", vReleaseDate := "15/08/2021"

 ; User settings
   , askDeleteFiles := 1, enableThumbsCaching := 1, OnConvertKeepOriginals := 1, usrAutoCropGenerateSelection := 0
   , thumbsAratio := 3, thumbsZoomLevel := 1, zatAdjust := 0, lummyAdjust := 0, doSlidesTransitions := 0
   , specialColorFXmode := 1, uiColorCurveFXmode := 2, uiColorCurveFXchannel := 4
   , WindowBgrColor := "141414", slideShowDelay := 3000, userMultiDelChoice := 2, ambiTexBrushSize := 150
   , IMGresizingMode := 1, SlideHowMode := 1, TouchScreenMode := 1, screenSaverMode := 0
   , lumosAdjust := 1, GammosAdjust := 0, userimgQuality := 0, userCustomImgSelRatio := 0
   , imgFxMode := 1, FlipImgH := 0, FlipImgV := 0, satAdjust := 1, imageAligned := 5
   , filesFilter := "", isAlwaysOnTop := 0, IntensityAlphaChannel := 1, zoomLevel := 1
   , skipDeadFiles := 0, userHQraw  := 0, isTitleBarHidden := 1, lumosGrayAdjust := 0
   , MustLoadSLDprefs := 0, animGIFsSupport := 1, move2recycler := 1, deleteFileActAfter := 1
   , SLDcacheFilesList := 1, autoRemDeadEntry := 0, ResizeWithCrop := 1, ResizeMustPerform := 1
   , easySlideStoppage := 1, ResizeInPercentage := 0, usrAdaptiveThreshold := 1, autoPlaySlidesAudio := 0
   , ResizeKeepAratio := 1, ResizeQualityHigh := 1, ResizeRotationUser := "Rotate: 0°"
   , ResizeApplyEffects := 1, autoAdjustMode := 1, doSatAdjusts := 1, SimpleOperationsScaleXImgFactor := "100 %"
   , ResizeDestFolder, ResizeUseDestDir := 0, chnRdecalage := 0.0, chnGdecalage := 0.0
   , chnBdecalage := 0.0, alwaysOpenwithFIM := 0, bwDithering := 0, showHistogram := 0
   , userUnsprtWriteFMT := 1, userDesireWriteFMT := 9, hueAdjust := 0, syncSlideShow2Audios := 0
   , DisplayTimeUser := 3, FontBolded := 1, FontItalica := 0, showInfoBoxHUD := 0, usrAutoCropDeviation := 0
   , usrTextureBGR := 0, realGammos := 1, imgThreshold := 0, relativeImgSelCoords := 1
   , vpIMGrotation := 0, usrTextAlign := "Left", autoPlaySNDs := 0, usrAutoCropDeviationSnap := 1
   , ResizeCropAfterRotation := 1, usrColorDepth := 1, ColorDepthDithering := 1, mediaSNDvolume := 80
   , borderAroundImage := 0, performAutoCropNow := 0, usrAutoCropColorTolerance := 5, usrAutoCropImgThreshold := 0.005 
   , SimpleOperationsDoCrop := 0, SimpleOperationsRotateAngle := 1, SimpleOperationsScaleYImgFactor := "100 %"
   , SimpleOperationsNoPromptOnSave := 0, SimpleOperationsFlipV := 0, SimpleOperationsFlipH := 0
   , usrAutoCropDeviationPixels := 0, multilineStatusBar := 0, AutoCropAdaptiveMode := 1, allowGIFsPlayEntirely := 0
   , allowMultiCoreMode := 0, AutoDownScaleIMGs := 0, minimizeMemUsage := 0, GIFspeedDelay := 35
   , maxMemThumbsCache := 300, resetImageViewOnChange := 0, FillAreaRemBGR := 0, blurAreaPixelizeMethod := 1
   , EraseAreaFader := 0, EraseAreaOpacity := 190, blurAreaOpacity := 250, blurAreaAmount := 10
   , FillAreaOpacity := 250, FillAreaColor := OSDbgrColor, FillAreaShape := 1, FillAreaInverted := 0
   , PasteInPlaceAlignment := 3, PasteInPlaceOpacity := 128, PasteInPlaceAdaptMode := 1, PasteInPlaceQuality := 1
   , PasteInPlaceOrientation := 1, showImgAnnotations := 0, blurAreaSoftEdges := 1, blurAreaInverted := 0
   , PasteInPlaceBlurAmount := 0, PasteInPlaceCropSel := 1, PasteInPlaceCropAngular := 0

Global PasteInPlaceGamma := 0, PasteInPlaceSaturation := 0, PasteInPlaceHue := 0, PasteInPlaceLight := 0
   , EllipseSelectMode := 0, thumbsListViewMode := 1, userimgGammaCorrect := 0, FillAreaGradientAngle := 0
   , adjustCanvasCentered := 1, adjustCanvasMode := 1, adjustCanvasNoBgr := 1, LimitSelectBoundsImg := 1, FillAreaDoContour := 0
   , DrawLineAreaColor := "ff3366", DrawLineAreaDashStyle := 1, DrawLineAreaContourAlign := 1, DrawLineAreaKeepBounds := 1
   , DrawLineAreaContourThickness := 20, DrawLineAreaOpacity := 255, DrawLineAreaBorderTop := 1, DrawLineAreaBorderBottom := 0
   , DrawLineAreaBorderLeft := 1, DrawLineAreaBorderRight := 0, DrawLineAreaBorderCenter := 1, DrawLineAreaBorderArcA := 0
   , DrawLineAreaBorderArcC := 0, DrawLineAreaBorderArcD := 1, DrawLineAreaCapsStyle := 1, DrawLineAreaDoubles := 0
   , PasteInPlaceEraseInitial := 1, PasteInPlaceLivePreview := 1, DrawLineAreaBorderArcB := 0, EraseAreaInvert := 0
   , PasteInPlaceToolMode := 0, NewDocUseColor := 1, PredefinedDocsSizes := 1, NewImageReverseDimensions := 0, FillAreaGlassy := 1
   , FillAreaColorMode := 1, FillAreaColorReversed := 0, FillArea2ndColor := "FF2211", FillArea2ndOpacity := 200
   , FillAreaGradientPosA := 5, FillAreaGradientPosB := 100, FillAreaGradientScale := 100, FillAreaGradientWrapped := 1
   , TextInAreaFontName := "Arial", TextInAreaFontSize := 15, TextInAreaBorderSize := 5, GammosGrayAdjust := 0
   , TextInAreaFontBold := 0, TextInAreaFontItalic := 0, TextInAreaFontUline := 0, TextInAreaAlign := 1, TextInAreaBgrUnified := 0
   , TextInAreaFontColor := "eeFFaa", TextInAreaFontOpacity := 250, TextInAreaRoundBoxBgr := 1, TextInAreaValign := 1
   , TextInAreaBgrColor := "229933", TextInAreaBgrOpacity := 100, TextInAreaOnlyBorder := 0, TextInAreaBlurAmount := 0
   , TextInAreaBorderOut := 1, TextInAreaBorderColor := "334400", TextInAreaBorderOpacity := 200, TextInAreaCharSpacing := 0
   , TextInAreaUsrMarginz := 0, TextInAreaBlurBorderAmount := 0, TextInAreaDoBlurs := 0, TextInAreaLineAngle := 0
   , TextInAreaFontLineSpacing := 0, TextInAreaCutOutMode := 0, TextInAreaBgrEntire := 0, TextInAreaFontStrike := 0
   , TextInAreaLivePreview := 1, showMainMenuBar := 0, markSearchMatches := 1, showSelectionGrid := 0, blurAreaTwice := 0
   , allowRecordHistory := 1, FillAreaLivePreview := 1, TextInAreaPaintBgr := 1, rotateSelBoundsKeepRatio := 1
   , highlightAlreadySeenImages := 1, useCachedSLDdata := 1, PreserveDateTimeOnSave := 0, PrintAdaptToFit := 1
   , PrintDimensionsXYWH := "0|0|50|50", PrintColorMode := 1, PrintOrientation := 0, PrintUseViewportColors := 1
   , userAllowWindowDrag := 0, FillAreaClosedPath := 1, FillAreaCustomShape := "", PasteInPlaceAlphaMaskMode := 1
   , PasteInPlaceAlphaMaskClrA := 0, PasteInPlaceAlphaMaskClrB := 255, closeEditPanelOnApply := 1, FillAreaCurveTension := 2
   , alphaMaskOffsetX := 0, alphaMaskOffsetY := 0, alphaMaskReplaceMode := 0, PasteInPlaceAlphaChannelFile := 5
   , blurAreaMode := 1, FillAreaBlendMode := 1, PasteInPlaceApplyColorFX := 0, blurAreaPixelizeAmount := 0
   , dynamicThumbsColumns := 0, thumbsColumns := 8, TextInAreaAutoWrap := 1, histogramMode := 2, cmrRAWtoneMapParamB := 0
   , showHUDnavIMG := 0, HUDnavBoxSize := 75, PrintTxtSize := 300, cmrRAWtoneMapAlgo := 1, cmrRAWtoneMapParamA := 1.85
   , mainWinPos := 0, mainWinMaximized := 2, mainWinSize := 0, UserExternalApp := "", UserExternalEditApp := ""
   , lockSelectionAspectRatio := 1, desiredSelAspectRatio := 0, adjustingSelDotNow := 0, cycleFavesOpenIMG := 0
   , slidesFXrandomize := 0, IDedgesCenterAmount := 1, IDedgesXuAmount := 2, IDedgesYuAmount := 1, IDedgesInvert := 0
   , IDedgesEmphasis := 0, IDedgesContrast := 0, IDedgesBlendMode := 0, IDedgesOpacity := 255, IDedgesAfterBlur := 1
   , IDedgesEmbossLvl := 1, UserAddNoiseIntensity := 35, UserAddNoiseMode := 0, reverseOrderOnSort := 0
   , userSearchWhat := 1, OnSortdoFilesCheck := 0, QuickFileActFolder1 := "", QuickFileActFolder2 := ""
   , QuickFileActFolder3 := "", QuickFileActFolder4 := "", QuickFileActFolder5 := "", QuickFileActAfter1 := 1
   , QuickFileActAfter2 := 1, QuickFileActAfter3 := 1, QuickFileActAfter4 := 1, QuickFileActAfter5 := 1
   , QuickFileActAfter6 := 1, QuickFileActFolder6 := "", userFilterWhat := 1, userFilterStringPos := 1
   , userFilterStringIsNot := 0, userFilterDoString := 1, UsrEditFilter, QuickFileActConflict := 4
   , preventDBentryRemoval := 0, findDupesPrecision := 5, hashInnerTrimLeft := 0, hashInnerTrimRight := 0
   , hashOuterTrimLeft := 0, hashOuterTrimRight := 0, hashSimpleTrimLeft := 0, hashSimpleTrimRight := 0
   , UIcheckinnerpixelz := 0, UIcheckouterpixelz := 0, UIcheckpixelzHash := 0, DesatureAreaAmount := 100
   , DesatureAreaHue := 0, DesatureAreaAlternate := 0, skipSeenImageSlides := 0, blurAreaSoftLevel := 2
   , BlurAreaBlendMode := 1, PasteInPlaceBlurEdgesSoft := 0, preventDeleteMatchingSearch := 0
   , protectedFolderPath := "", preventDeleteFromProtectedPath := 0, preventDeleteFromProtectedSubPaths := 0
   , excludePreviousDupesFromList := 0, userFindDupesHamDistLvl := 1, userFindDupesFilterHamDist := 0
   , userFilterInvertThis := 0, UserHamDistStringFilter := "", UserHamDistCacheFilterMonoGroups := 1
   , UserHamDistStringInvert := 0, lockZoomLevel := 0, showViewPortGrid := 0, vpGridColor := "998899"
   , vpGridAlpha := 150, vpGridThickness := 1, vpGridSize := 35, vpGridStepu := 4, vpGridFixedSize := 0
   , PasteInPlaceAutoExpandIMG := 0, SlidesMusicSong := "", PrintStrechedSize := 0, brushToolSize := 50
   , BrushToolAopacity := 200, BrushToolBopacity := 120, BrushToolAcolor := "ff9900", BrushToolBcolor := "3399FF"
   , BrushToolSoftness := 60, BrushToolWetness := 0, BrushToolDryingRate := 0, BrushToolType := 1
   , BrushToolUseSecondaryColor := 0, BrushToolAspectRatio := 0, BrushToolAngle := 0, BrushToolOutsideSelection := 1
   , BrushToolBlurStrength := 0, brushToolStepping := 0, brushToolDoubleSize := 0, BrushToolOverDraw := 1
   , BrushToolDynamicCloner := 0, BrushToolEraserRestore := 0, BrushToolRandomSize := 0, BrushToolRandomSoftness := 0
   , BrushToolRandomAspectRatio := 0, BrushToolRandomAngle := 0, BrushToolRandomPosX := 0, BrushToolRandomPosY := 0
   , BrushToolRandomHue := 0, BrushToolRandomSat := 0, BrushToolRandomLight := 0, BrushToolRandomDark := 0 
   , BrushToolTexture := 1, BrushToolAutoAngle := 1, ShowAdvToolbar := 1, ToolbarOpacity := 255
   , BrushToolApplyColorFX := 0, PasteInPlaceBlendMode := 1, PasteInPlaceGlassy := 1, ToolbarScaleFactor := 1
   , ToolbarBgrColor := "212121", TLBRverticalAlign := 1, TLBRtwoColumns := 1, FillAreaApplyColorFX := 0


EnvGet, realSystemCores, NUMBER_OF_PROCESSORS
addJournalEntry("Application started: PID " QPVpid ".`nCPU cores identified: " realSystemCores ".")

If (realSystemCores>100)
   realSystemCores := 100

RegRead, InitCheckReg, %QPVregEntry%, Running
RegRead, InitTimeReg, %QPVregEntry%, LastStartTime
If (Abs(A_TickCount - InitTimeReg)<600 && IsNumber(InitTimeReg) && InitCheckReg=1 && InitTimeReg>1)
{
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

If !A_IsCompiled
   Try Menu, Tray, Icon, qpv-icon.ico

DetectHiddenWindows, On
CoordMode, Mouse, Screen
CoordMode, ToolTip, Screen
OnExit, doCleanup

initCompiled(A_IsCompiled)
thisGDIPversion := Gdip_LibrarySubVersion()
GDIPToken := Gdip_Startup()
If (!GDIPToken || thisGDIPversion<1.86)
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+...`n`nThe program will now exit.`n`nRequired GDI+ library wrapper: v1.84 - extended compilation edition.
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

; RegRead, initArgu, %QPVregEntry%, initArgu
If (InitCheckReg=2)
{
   initExternalCoreMode()
   Return
}

RegWrite, REG_SZ, %QPVregEntry%, Running, 1
RegWrite, REG_SZ, %QPVregEntry%, LastStartTime, % A_TickCount
IniRead, FirstRun, % mainSettingsFile, General, FirstRun, @
If (FirstRun!=0)
{
   writeMainSettings()
   FirstRun := 0
   IniWrite, % FirstRun, % mainSettingsFile, General, FirstRun
} Else loadMainSettings(0)

OnMessage(0x202, "WM_LBUTTONUP")
OnMessage(0x200, "WM_MOUSEMOVE")
OnMessage(0x203, "OnLButtonDblClk")
Loop, 9
    OnMessage(255+A_Index, "PreventKeyPressBeep")   ; 0x100 to 0x108

Global interfaceThread
If !A_IsCompiled
   interfaceThread := ahkthread("#Include *i Lib\module-interface.ahk")
Else If (sz := GetRes(data, 0, "MODULE-INTERFACE.AHK", "LIB"))
   interfaceThread := ahkThread(StrGet(&data, sz, "utf-8"))

; the interface is a separate thread to allow users 
; enjoy a more responsive user interface when the main thread
; is busy processing
externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarHidden "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized "$" IMGresizingMode
externObj .= "$" OSDbgrColor "$" OSDtextColor "$" LargeUIfontValue "$" PrefsLargeFonts "$" OSDFontName "$" FontBolded
initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
fnOutputDebug("extern UI HWNDs: " initGUI)
If !InStr(initGUI, "|")
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize the interface. The application will now exit...
   hasInitSpecialMode := 1
   ForceExitNow()
   Return
} Else
{
   handleUIhwnd(initGui)
   externObj := ""
}

createGDIPcanvas()
InitGDIpStuff()

Global multiCoreThumbsInitGood := "n",thumbThread1,thumbThread2,thumbThread3,thumbThread4,thumbThread5,thumbThread6,thumbThread7,thumbThread8,thumbThread9,thumbThread10,thumbThread11
,thumbThread12,thumbThread13,thumbThread14,thumbThread15,thumbThread16,thumbThread17,thumbThread18,thumbThread19,thumbThread20,thumbThread21
,thumbThread22,thumbThread23,thumbThread24,thumbThread25,thumbThread26,thumbThread27,thumbThread28,thumbThread29,thumbThread30,thumbThread31
,thumbThread32,thumbThread33,thumbThread34,thumbThread35,thumbThread36,thumbThread37,thumbThread38,thumbThread39,thumbThread40,thumbThread41
,thumbThread42,thumbThread43,thumbThread44,thumbThread45,thumbThread46,thumbThread47,thumbThread48,thumbThread49,thumbThread50,thumbThread51
,thumbThread52,thumbThread53,thumbThread54,thumbThread55,thumbThread56,thumbThread57,thumbThread58,thumbThread59,thumbThread60,thumbThread61
,thumbThread62,thumbThread63,thumbThread64,thumbThread65,thumbThread66,thumbThread67,thumbThread68,thumbThread69,thumbThread70,thumbThread71
,thumbThread72,thumbThread73,thumbThread74,thumbThread75,thumbThread76,thumbThread77,thumbThread78,thumbThread79,thumbThread80,thumbThread81
,thumbThread82,thumbThread83,thumbThread84,thumbThread85,thumbThread86,thumbThread87,thumbThread88,thumbThread89,thumbThread90,thumbThread91
,thumbThread92,thumbThread93,thumbThread94,thumbThread95,thumbThread96,thumbThread97,thumbThread98,thumbThread99,thumbThread100,

If (A_PtrSize=4)
{
   allowMultiCoreMode := 0
   minimizeMemUsage := 1
   maxUndoLevels := 2
   coreDesiredPixFmt := "0x21808"
}

; OnMessage(0x205, "WM_RBUTTONUP")
TriggerMenuBarUpdate()
addJournalEntry("Finished initialization of " appTitle " v" appVersion ".")
If (qpvCanvasHasInit=1)
   doWelcomeNow := intializeWithGivenArguments()

; MsgBox, % A_TickCount - scriptStartTime
If (doWelcomeNow=1 && qpvCanvasHasInit=1)
   SetTimer, drawWelcomeImg, -25
If (ShowAdvToolbar=1)
   SetTimer, createGUItoolbar, -125

If (A_Is64bitOS=1 && A_PtrSize!=8)
   SetTimer, giveWarningX64, -500

Return

;_____________________________________ Hotkeys _________________

identifyThisWin() {
  Static prevR, lastInvoked := 1
  If (A_TickCount - lastInvoked < 150)
     Return prevR

  prevR := WinActive("ahk_class AutoHotkeyGUI ahk_group QPVwindows") ? 1 : 0
  lastInvoked := A_TickCount
  Return prevR
}

HKifs(q:=0) {
   whichBitmap := useGdiBitmap() ? 1 : 0
   If (q="imgEditSolo")
      r := (!AnyWindowOpen && openingPanelNow!=1 && currentFileIndex=0 && !CurrentSLD && thumbsDisplaying!=1 && whichBitmap=1) ? 1 : 0
   Else If (q="imgsLoaded")
      r := (!AnyWindowOpen && openingPanelNow!=1 && CurrentSLD && maxFilesIndex>0) ? 1 : 0
   Else If (q="liveEdit")
      r := (AnyWindowOpen && openingPanelNow!=1 && imgEditPanelOpened=1 && whichBitmap=1) ? 1 : 0
   Else If (q="general")
      r := (!AnyWindowOpen && imgEditPanelOpened!=1) ? 1 : 0

   If (drawingShapeNow=1)
      r := 0

   Return r
}

#If (WinActive("ahk_id " hQPVtoolbar) && ShowAdvToolbar=1)
    +Tab::
    Tab::
    Esc::
    AppsKey::
       ; currentKbdBTNtlbr := 0
       isToolbarKBDnav := 0
       WinActivate, ahk_id %PVhwnd%
       displayNowToolbarHelp(3)
    Return

    vk48:: ; H
    F1::
      displayNowToolbarHelp(1)
    Return

    Left::
    BackSpace::
    Up::
       moveMouseToolbar(-1, 1)
    Return

    Right::
    Delete::
    Down::
       moveMouseToolbar(1, 1)
    Return

    PgUp::
    Home::
       moveMouseToolbar(-1, 4)
    Return

    PgDn::
    End::
       moveMouseToolbar(1, 4)
    Return

    Space::
    Enter::
       invokeKbdToolbarAct(0)
    Return

    +Space::
    +Enter::
       invokeKbdToolbarAct("right")
    Return

    vk30::
    vk31::
    vk32::
    vk33::
    vk34::
    vk35::
    vk36::
    vk37::
    vk38::
    vk39::
       currentKbdBTNtlbr := 0
       v := SubStr(A_ThisHotkey, 4, 1)
       If !v
          v := 10
       moveMouseToolbar(1, v)
    Return

#IF

#If (identifyThisWin()=1)
    ^vk4F::    ; Ctrl+O
       If HKifs("general")
          OpenDialogFiles()
    Return

    vk4F::    ; O
       imgPath := getIDimage(currentFileIndex)
       If HKifs("imgsLoaded")
          OpenThisFileMenu()
       Else If ((HKifs("general") && (!CurrentSLD || StrLen(gdiBitmap)<3)) && !FileRexists(imgPath))
          OpenDialogFiles()
    Return

    vk57 up::   ; w to-do  to do
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 && thumbsDisplaying!=1)
          flipSelectionWH()
    ; MsgBox, % ClipboardGetDropEffect()
; msgbox, % calculateNCR2(10201) ; OSD: looping... 10 202......0... combin=52025101
     ; reorderStoredHash("010110000010101011111001111101010111", "1001011011111111010010010101")
    ; If !activeSQLdb.Exec("ALTER TABLE images ADD entireHush TEXT;")
       ; TEMPgenerateHush()
    ; ToolTip, % extractSQLqueryFromFilter() , , , 2
            ; PanelChangeHamDistThreshold()
            ; testWicArkive()
    ; testWICwhatever()
   ; ; testWICresizeSpeed()
    Sleep, 1
    Return

    ^+vk4E::    ; Ctrl+Shift+N
       If HKifs("general")
          OpenNewQPVinstance()
    Return

    ^vk4E::    ; Ctrl+N
       If HKifs("general")
          PanelNewImage()
    Return

    +vkC0::    ; Shift+[~]
       If HKifs("general")
          PanelJournalWindow()
    Return

    F12::
       If HKifs("general")
          PanelPrefsWindow()
    Return

    vk50::    ; P
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          PanelBrushTool()
    Return

    !vk50::    ; Alt+P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingLines("draw")
    Return

    +vk50::    ; Shift+P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingShapes("draw")
    Return

    ^vk50::    ; Ctrl+P
       If (!AnyWindowOpen && imageLoading!=1 && (HKifs("imgEditSolo") || HKifs("imgsLoaded")))
          PanelPrintImage()
    Return

    ~vkBA up::   ; ;
       PanelQuickSearchMenuOptions()
    Return

    ^NumpadAdd::
    ^vkBB::    ; Ctrl+[=]
       changeOSDfontSize(1)
    Return

    ^NumpadSub::
    ^vkBD::   ; Ctrl+[-]
       changeOSDfontSize(-1)
    Return

    +vk4F::    ; Shift+O
       If HKifs("general")
          OpenFolders()
    Return

    ~+F10::
       toggleAppToolbar()
    Return

    ~F10::
    ~!F10::
       If (drawingShapeNow!=1)
          ToggleQuickBaru()
    Return

    ^AppsKey::
    +AppsKey::
       InitSecondMenu()
    Return

    #AppsKey::
    !AppsKey::
    AppsKey::
       Suspend, Permit
       InitGuiContextMenu(A_ThisHotkey)
    Return

    ; ~RButton::
    ~^RButton::
    ~+RButton::
       Suspend, Permit
       InitGuiContextMenu(A_ThisHotkey)
    Return

    ~Insert Up::
       If (HKifs("general") && imageLoading!=1)
          addNewFile2list()
    Return

    ^vk56 Up::   ; Ctrl+V
       If (HKifs("general") && imageLoading!=1)
          PasteClipboardIMG()
    Return

    +Esc::
       restartAppu()
    Return

    F1::
       HelpWindow()
    Return

    ~F9 Up::
      If (HKifs("imgsLoaded") && folderTreeWinOpen=1)
         FolderTreeFindActiveFile()
    Return

    ^F4::
       If (drawingShapeNow=1)
       {
          stopDrawingShape()
          Return
       } Else If AnyWindowOpen
       {
          CloseWindow()
          Return
       } Else If (thumbsDisplaying=1)
       {
          MenuReturnIMGedit()
          Return
       }

       closeDocuments()
    Return

    !F4::
    Esc::
       escRoutine()
    Return

    ~vk44 Up::   ; D
      If (liveDrawingBrushTool=1)
         BtnSetClonerBrushSource()
      Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
         toggleLiveEditObject()
    Return

    vk4C::     ; L
      If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 || showViewPortGrid=1) && thumbsDisplaying!=1)
         toggleLimitSelection()
      Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         toggleListViewModeThumbs()
    Return

    +^vk56 Up::   ; Ctrl+Shift+V
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelPasteInPlace()
    Return

    ~^vk44 Up::   ; Ctrl+D
      If (HKifs("imgsLoaded") && ((thumbsDisplaying=1) || (editingSelectionNow!=1 && markedSelectFile)))
         dropFilesSelection()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         resetImgSelection()
    Return

    ~^vk43 Up::    ; Ctrl+C
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCopyFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CopyImage2clip()
    Return

    ~^vk58 Up::    ; Ctrl+X
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCutFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CutSelectedArea()
    Return

    ^vk5A::    ; Ctrl+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction()
    Return

    vk5A::    ; Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgNavBox()
    Return

    ^vk59::    ; Ctrl+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction()
    Return

    ^+vk5A::    ; Ctrl+Shift+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelUndoAct()
    Return

    ^+vk59::    ; Ctrl+Shift+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelRedoAct()
    Return

    ^!vk5A::    ; Ctrl+Alt+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction("j")
    Return

    ^!vk59::    ; Ctrl+Alt+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction("j")
    Return

    vk45::   ; E
      If (AnyWindowOpen=64) ; PanelBrushTool()
         ToggleEditImgSelection()
      Else If (thumbsDisplaying=1)
         QuickSelectFilesSameFolder()
      Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
         livePreviewsImageEditing(1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         ToggleEditImgSelection()
         If (editingSelectionNow=1)
            CreateGuiButton("Selection options,,invokeSelectionAreaMenu", 0, msgDisplayTime//1.5 + 500)
      }
    Return

    +vk45::   ; Shift+E
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>2)
      {
         activateFilesListFilterBasedOnFolder(currentFileIndex)
      } Else
      {
         imgLiveEdit := (HKifs("liveEdit") && (AnyWindowOpen=25 || AnyWindowOpen=10 || AnyWindowOpen=55 || AnyWindowOpen=64)) ? 1 : 0
         If (HKifs("imgEditSolo") || imgLiveEdit=1 || HKifs("imgsLoaded"))
            toggleEllipseSelection()
      }
    Return

    !vk45::   ; Alt+E
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelIMGselProperties()
    Return

    ~^vk53 Up::   ; Ctrl+S
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelSaveImg()
    Return

    ^vk4C::     ; Ctrl+L
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelDrawLines()
    Return

    +vk4C::     ; Shift+L
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (thumbsDisplaying!=1)
      {
         If (editingSelectionNow!=1 || EllipseSelectMode!=2)
            MenuStartDrawingSelectionArea()
         Else
            MenuResumeDrawingShapes()
      }
    Return

    !vk4C Up::     ; Alt+L
      If HKifs("imgsLoaded")
         CalculateSelectedFilesSizes()
    Return

    !BackSpace::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         tlbrFillShape()          ; PanelFillSelectedArea()
    Return

    !vk59::   ; Alt+Y
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelImgAutoCrop()
    Return

    vk59::   ; Y
      If (liveDrawingBrushTool=1)
         toggleBrushDeformers()
    Return

    ~vk49::   ; I
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleInfoBoxu()
    Return

    vkDB::   ; [
      If (liveDrawingBrushTool=1)
         changeBrushSize(-1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(-1)
    Return

    vkDD::   ; ]
      If (liveDrawingBrushTool=1)
         changeBrushSize(1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(1)
    Return

    +vkDB::   ; Shift+[
      If (liveDrawingBrushTool=1)
         changeBrushSoftness(-1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(-1)
    Return

    +vkDD::   ; Shift+]
      If (liveDrawingBrushTool=1)
         changeBrushSoftness(1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(1)
    Return

    ^vkDB::   ; Ctrl+[
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(-1)
    Return

    ^vkDD::   ; Ctrl+]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(1)
    Return

    !vkDB::   ; Alt+[
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(-1)
    Return

    !vkDD::   ; Alt+]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(1)
    Return

    vkDC Up::   ; \
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         MenuToggleColorAdjustments()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ResetImageView()
    Return

    ^vkDC Up::   ; Ctrl+\
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         btnResetImageView()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         HardResetImageView()
    Return

    +vkDC Up::   ; Shift+\
      If HKifs("liveEdit")
      {
         resetSelectionRotation()
      } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1 && vPselRotation>0)
            resetSelectionRotation()
         Else
            toggleColorAdjustments()
      }
    Return

    vkBF Up::   ; /
    NumpadDiv Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
      {
         IMGresizingMode := 0
         ToggleImageSizingMode()
      }
    Return

    NumpadMult Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
      {
         ; IMGresizingMode := 3
         IMGdecalageX := IMGdecalageY := zoomLevel := 1
         ToggleImageSizingMode("custom")
      }
    Return

    +NumpadAdd::
    +vkBB::    ; Shift+[=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(1)
    Return

    +NumpadSub::
    +vkBD::   ; Shift+[-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(-1)
    Return

    !vkBD::   ; Alt+[-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         changeGridSize(-1)
    Return

    !vkBB::   ; Alt+[=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         changeGridSize(1)
    Return

    NumpadAdd::
    vkBB::    ; [=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         ChangeZoom(1)
    Return

    NumpadSub::
    vkBD::   ; [-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         ChangeZoom(-1)
    Return

    vk47::    ; G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(1)
    Return

    +vk47::    ; Shift+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(-1)
    Return

    !vk47::    ; Alt+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleHistogramMode()
    Return

    ~^vk52 Up::     ; Ctrl+R
      If HKifs("imgsLoaded")
         PanelSimpleResizeRotate()
    Return

    ~!vk52 Up::     ; Alt+R
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ResizeIMGviewportSelection()
    Return

    vk52::     ; R
      If (liveDrawingBrushTool=1 || AnyWindowOpen=64)
         toggleBrushTypeEraser()
      Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile)
         PanelReviewSelectedFiles()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         makeSquareSelection()
    Return

    +vk52::     ; Shift+R
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         MenuSelRotation()
    Return

    ^vk54 Up::     ; Ctrl+T
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelTransformSelectedArea()
    Return

    +vk54 Up::     ; Shift+T
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelInsertTextArea()
    Return

    +vk49 Up::     ; Shift+I
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
         invertFilesSelection()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         InvertSelectedArea()
    Return

    ^vk47 Up::     ; Ctrl+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelDesatureSelectedArea()
    Return

    +vk42 Up::     ; Shift+B
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelBlurSelectedArea()
    Return

    vk42 Up::     ; B
      If (liveDrawingBrushTool=1 || AnyWindowOpen=64)
         toggleBrushTypes()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ToggleImgFavourites(0, 0, 1)
    Return

    ~^vk48::    ; Ctrl+H
      If (HKifs("imgsLoaded") && maxFilesIndex>1)
         PanelSearchAndReplaceIndex()
    Return

    ~vk48::    ; H
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (EllipseSelectMode=2 && editingSelectionNow=1)
            flipWHcustomShape("h")
         Else
            VPflipImgH()
      }
    Return

    ~vk56::    ; V
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (EllipseSelectMode=2 && editingSelectionNow=1)
            flipWHcustomShape("V")
         Else
            VPflipImgV()
      }
    Return

    ~+vk48::    ; Shift+H
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipHimage()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaH()
    Return

    ~+vk56::    ; Shift+V
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipVimage()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaV()
    Return

    ~vk55 Up::  ;  U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelColorsAdjusterWindow()
    Return

    ~+vk55 Up::    ; Shift+U
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListApplyColors()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ApplyColorAdjustsSelectedArea()
    Return

    ~^+vk55 Up::    ; Ctrl+Shift+U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ApplyColorAdjustsSelectedArea("outside")
    Return

    vk46::     ; F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(1)
    Return

    +vk46::     ; Shift+F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(-1)
    Return

    +vk51::  ; Shift+Q
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (liveDrawingBrushTool!=1)
         ToggleImgColorDepth(-1)
    Return

    vk51::  ; Q
      If (liveDrawingBrushTool=1 || AnyWindowOpen=64)
         toggleBrushTypeFX()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgColorDepth(1)
    Return

    ~Delete Up::
      If ((HKifs("imgEditSolo") || HKifs("liveEdit")) && thumbsDisplaying!=1 && editingSelectionNow=1)
         PanelEraseSelectedArea()
      Else If HKifs("imgsLoaded")
         deleteKeyAction()
    Return

    ~!Delete Up::
      If (HKifs("imgsLoaded") && maxFilesIndex>1 && currentFileIndex>0)
         singleInListEntriesRemover()
    Return

    ~+Delete Up::
      If HKifs("imgsLoaded")
      {
         DeleteActivePicture()
         Sleep, 350
         If (maxFilesIndex>1 && currentFileIndex>0)
            singleInListEntriesRemover()
      }
    Return

    vk41::     ; A
      If HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (AnyWindowOpen>1) || (drawingShapeNow=1)
         ToggleIMGalign()
    Return

    +vk41::     ; Shift+A
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         toggleImgSelectionAspectRatio()
    Return

    !vk41::     ; Alt+A
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelAdjustImageCanvasSize()
    Return

    ^vk41::     ; Ctrl+A
      If HKifs("liveEdit")
         selectEntireImage()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
            selectAllFiles()
         Else
            selectEntireImage()
      }
    Return

    +vk39::    ; Shift+9
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipRotateMinus()
    Return

    vk39::    ; 9
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(A_ThisHotkey, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(-1)
         Else
            changeImgRotationInVP(-1)
      }
    Return

    +vk30::    ; Shift+0
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipRotatePlus()
    Return

    vk30::    ; 0
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(A_ThisHotkey, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(1)
         Else
            changeImgRotationInVP(1)
      }
    Return

    Up::
    +Up::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("U", A_ThisHotkey)
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Upu", A_ThisHotkey)
    Return

    Down::
    +Down::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("D", A_ThisHotkey)
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Down", A_ThisHotkey)
    Return

    ^WheelUp::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         ChangeZoom(1, "WheelUp")
    Return

    ^WheelDown::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1)
         ChangeZoom(-1, "WheelDown")
    Return

    !Left::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 1)
    Return

    !Right::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 1)
    Return

    !Up::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-2, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 1)
    Return

    !Down::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(2, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 1)
    Return

    !+Left::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-1, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 2)
    Return

    !+Right::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(1, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 2)
    Return

    !+Up::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-2, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 2)
    Return

    !+Down::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(2, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 2)
    Return

    F8::
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         openPreviousPanel()
    Return

    Space::
      If (HKifs("imgsLoaded") && drawingShapeNow!=1)
      {
         If ((thumbsDisplaying=1 || markedSelectFile) && slideShowRunning!=1)
            markThisFileNow()
         ; Else If (imageLoading!=1 && IMGlargerViewPort=1 && IMGresizingMode=4 && slideShowRunning!=1)
         ;    changeMcursor("move")
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - lastOtherWinClose>350) && (A_TickCount - prevSlideShowStop>950) ; && (drawingShapeNow!=1)
            InfoToggleSlideShowu()
      } Else if (!CurrentSLD && !maxFilesIndex && StrLen(UserMemBMP)<3)
         toggleScreenSaverMode()
    Return 

    ^vk57::    ; Ctrl+W
      If HKifs("imgsLoaded")
         setImageWallpaper()
    Return

    +vk4E::    ; Shift+N
      If HKifs("imgsLoaded")
         PanelEditImgCaption()
    Return

    vk4E::    ; N
      If (HKifs("imgsLoaded") && thumbsDisplaying!=1)
         ToggleImgCaptions()
    Return

    ^vk31::   ; Ctrl+1
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortName, -150
    Return

    ^vk32::   ; Ctrl+2
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortPath, -150
    Return

    ^vk33::   ; Ctrl+3
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortFileName, -150
    Return

    ^vk34::   ; Ctrl+4
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortSize, -150
    Return

    ^vk35::   ; Ctrl+5
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortModified, -150
    Return

    ^vk36::   ; Ctrl+6
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortCreated, -150
    Return

    ^vk37::   ; Ctrl+7
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, PanelResolutionSorting, -50
    Return

    ^vk38::   ; Ctrl+8
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, PanelHistogramSorting, -50
    Return

    ^vk30::   ; Ctrl+0
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ReverseListNow, -150
    Return

    ~vk4A Up::    ; J
      If (liveDrawingBrushTool=1 || AnyWindowOpen=64)
         toggleBrushTypeCloner()
      Else If HKifs("imgsLoaded")
         PanelJump2index()
    Return

    ~+Insert Up::
      If HKifs("imgsLoaded")
         addNewFolder2list()
    Return

    ~Tab::
        mainWinTabResponse()
    Return

    ~+Tab::
      ; currentKbdBTNtlbr := 0
      If (AnyWindowOpen && imgEditPanelOpened!=1 || drawingShapeNow=1 || slideShowRunning=1 || AnyWindowOpen=24 || AnyWindowOpen=31)
      {
         If (slideShowRunning=1)
            ToggleSlideShowu()
      } Else If (ShowAdvToolbar=1 && hQPVtoolbar)
      {
         isToolbarKBDnav := 1
         WinActivate, ahk_id %hQPVtoolbar%
         ; moveMouseToolbar(1, 1)
         displayNowToolbarHelp(2)
      }
    Return

    ~^Tab Up::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
         filterToFilesSelection()
    Return

    ~F11::
      If !AnyWindowOpen
         ToggleFullScreenMode()
    Return

    +Enter::
      If HKifs("liveEdit")
         applyIMGeditKeepWin()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CropImageInViewPortToSelection()
    Return

    ^Enter::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         OpenWithNewQPVinstance()
      Else If HKifs("imgsLoaded")
         SoloNewQPVinstance()
    Return

    Enter::
      If (drawingShapeNow=1)
         stopDrawingShape()
      Else If HKifs("liveEdit")
         applyIMGeditFunction()
      Else If (HKifs("imgsLoaded") && (A_TickCount - lastOtherWinClose>250))
         ToggleThumbsMode()
    Return

    !Enter::
      If HKifs("imgsLoaded")
         PanelImageInfos()
    Return

    ~vk43 Up::    ; C
      If (imgEditPanelOpened=1 && AnyWindowOpen)
         changeBrushColorPicker()
      Else If HKifs("imgsLoaded")
         InvokeCopyFiles()
    Return

    ~^vk55 Up::    ; Ctrl+U
      If (HKifs("imgsLoaded") && RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         PanelStaticFolderzManager()
    Return

    ~!vk55 Up::    ; Alt+U
      If HKifs("imgsLoaded")
         PanelDynamicFolderzWindow()
    Return

    ~^vk4B Up::    ; Ctrl+K
      If HKifs("imgsLoaded")
         PanelFileFormatConverter()
    Return

    ~vk4B Up::    ; K
      If (liveDrawingBrushTool=1 || AnyWindowOpen=64)
         toggleBrushDrawInOutModes()
      Else If HKifs("imgsLoaded")
      {
         If RegExMatch(getIDimage(currentFileIndex), "i)(.\.(jpg|jpeg))$") || markedSelectFile
            PanelJpegPerformOperation()
      }
    Return

    ~+vk43 Up::     ; Shift+C
      If HKifs("imgsLoaded")
         CopyImagePath()
    Return

    ~^vk45 Up::   ; Ctrl+E
      If (HKifs("imgsLoaded") || HKifs("imgLiveEdit"))
         OpenThisFileFolder()
    Return

    ~^vk46 Up::   ; Ctrl+F
      If HKifs("imgsLoaded")
         PanelEnableFilesFilter()
    Return

    ~vk53::   ; S
      If (liveDrawingBrushTool=1)
         toggleBrushDoubleSize()
      Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            keepSelectedDupeInGroup()
         Else
            ToggleSlideshowModes()
      }
    Return

    ~+vk53::   ; Shift+S
      If (HKifs("imgsLoaded") && mustRecordSeenImgs=1 && thumbsDisplaying=1)
         ToggleSeenIMGstatus()
    Return

    ~+^vk53 Up::   ; Ctrl+Shift+S
      If HKifs("imgsLoaded")
         PanelSaveSlideShowu()
    Return

    vk54 Up::   ; T
      If (liveDrawingBrushTool=1)
         toggleBrushAirMode()
      Else If (drawingShapeNow=1)
      {
         togglePathCurveTension()
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ToggleThumbsAratio()
         Else
            ToggleImageSizingMode()
      }
    Return

    ~+Space::
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            dropFilesSelection()
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - prevSlideShowStop>950)
            dummyInfoToggleSlideShowu()
      }
    Return

    ~^Space Up::
      If HKifs("imgsLoaded")
      {
         If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If StrLen(filesFilter)>1
            MenuRemFilesListFilter()
      }
    Return

    ~BackSpace::
      If (drawingShapeNow=1)
         reduceCustomShapelength()
      Else If HKifs("imgsLoaded")
         PrevRandyPicture()
    Return

    ~+BackSpace::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         RandomPicture()
      }
    Return

    ^BackSpace::
      If HKifs("imgsLoaded")
         jumpPreviousImage()
    Return

    +vkBE::    ; Shift + ,
      If (liveDrawingBrushTool=1)
         changeBrushWetness(1)
      Else
         ChangeVolume(1)
    Return

    vkBE::    ; [,]
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(-1, 0)
      Else If HKifs("imgsLoaded")
         IncreaseSlideSpeed()
    Return

    vkBC::   ; [.]
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(1, 0)
      Else If HKifs("imgsLoaded")
         DecreaseSlideSpeed()
    Return

    +vkBC::   ; Shift + .
      If (liveDrawingBrushTool=1)
         changeBrushWetness(-1)
      Else
         ChangeVolume(-1)
    Return

    +vkBF Up::   ; Shift+/
      If HKifs("imgsLoaded")
         PanelDefineEntireSlideshowLength()
    Return

    ~F5 Up::
      If HKifs("imgsLoaded") || (liveDrawingBrushTool=1 && AnyWindowOpen=64)
         RefreshImageFileAction()
    Return

    ~!F5 Up::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         DeepRefreshThumbsNow()
    Return

    ~+F5 Up::
      If HKifs("imgsLoaded")
         RefreshFilesList()
    Return

    ~^F5 Up::
      If HKifs("imgsLoaded")
         invertCurrentFolderRecursiveness()
    Return

    ~F2 Up::
      If HKifs("imgsLoaded")
         PanelRenameThisFile()
    Return

    ~+F2 Up::
      If HKifs("imgsLoaded")
         SingularRenameFile()
    Return

    ~^F2 Up::
      If HKifs("imgsLoaded")
         PanelUpdateThisFileIndex()
    Return

    ~vk4D Up::     ; M
      If HKifs("imgsLoaded")
         PanelMoveCopyFiles()
    Return

    ^vk51::  ;  Ctrl+Q-
      If HKifs("imgsLoaded")
         ToggleImgDownScaling()
    Return

    vk58 Up::   ; X
      If (imgEditPanelOpened=1 && AnyWindowOpen)
      {
         ToggleBrushColors()
      } Else If HKifs("imgsLoaded")
      {
         If (animGIFplaying=1)
            DestroyGIFuWin()
         Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
            moveMarkedEntryNow(currentFileIndex)
         Else
            PlayAudioFileAssociatedNow()
      }
    Return

    +vk58 Up::   ; Shift+X
      If HKifs("imgsLoaded")
      {
         If (animGIFplaying=1)
            DestroyGIFuWin()
         Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
            moveMarkedEntryNow(currentFileIndex, "move")
         Else
            StopMediaPlaying()
      }
    Return

    vk38::
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(A_ThisHotkey, 1)
    Return

    vk31::
    vk32::
    vk33::
    vk34::
    vk35::
    vk36::
    vk37::
    +vk31::
    +vk32::
    +vk33::
    +vk34::
    +vk35::
    +vk36::
    +vk37::
      If (liveDrawingBrushTool=1)
         changeBrushOpacity(A_ThisHotkey, 1)
      Else If HKifs("imgsLoaded")
         triggerQuickFileAction(A_ThisHotkey)
    Return

    ^Left::
      If HKifs("imgsLoaded")
         navSelectedFiles(-1)
    Return

    ^Right::
      If HKifs("imgsLoaded")
         navSelectedFiles(1)
    Return

    F3::
      If HKifs("imgsLoaded")
         searchNextIndex(1)
    Return

    +F3::
      If HKifs("imgsLoaded")
         searchNextIndex(-1)
    Return

    ^F3::
      If HKifs("imgsLoaded")
         PanelSearchIndex()
    Return
    
    F4::
      ; If HKifs("imgsLoaded")
         PanelFoldersTree()
    Return

    +F4::
      If HKifs("imgsLoaded")
         invokeFoldersListerMenu()
    Return

    WheelUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Upu", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(1, "WheelUp")
      Else If (HKifs("imgsLoaded"))
         PreviousPicture("key-" A_ThisHotkey)
    Return

    WheelDown::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Down", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(-1, "WheelDown")
      Else If (HKifs("imgsLoaded"))
         NextPicture("key-" A_ThisHotkey)
    Return

    Right::
    +Right::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("R", A_ThisHotkey)
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Right", A_ThisHotkey)
            Else
               NextPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("R", A_ThisHotkey)
    Return

    Left::
    +Left::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("L", A_ThisHotkey)
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Left", A_ThisHotkey)
            Else
               PreviousPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("L", A_ThisHotkey)
    Return

    PgDn::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(-1)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-1, 1)
         arrowKeysAdjustSelectionArea(-1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else
            NextPicture()
      }
    Return

    PgUp::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(1)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(1, 1)
         arrowKeysAdjustSelectionArea(1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else
            PreviousPicture()
      }
    Return

    +PgDn::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(-1)
      }
    Return

    +PgUp::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(1)
      }
    Return

    ^PgUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreUpDownLevel(-1)
    Return

    ^PgDn::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreUpDownLevel(1)
    Return

    !PgUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreSiblingsNav(-1)
    Return

    !PgDn::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreSiblingsNav(1)
    Return

    ~^Home Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(-1)
    Return

    ~^End Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(1)
    Return

    ~Home::
    ~+Home::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(2)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-2, 1)
         arrowKeysAdjustSelectionArea(-2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("Home", A_ThisHotkey)
         Else
            FirstPicture()
      }
    Return

    ~End::
    ~+End::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(-2)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(2, 1)
         arrowKeysAdjustSelectionArea(2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("End", A_ThisHotkey)
         Else
            LastPicture()
      }
    Return
#If

;____________ Functions __________________

initQPVmainDLL() {
   If qpvMainDll
      Return

   DllPath := FreeImage_FoxGetDllPath("qpvmain.dll")
   If (InStr(A_ScriptDir, "sucan twins") && !A_IsCompiled)
   {
      If (A_PtrSize=8)
         DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\x64\Release\qpvmain.dll"
      Else
         DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\Release\qpvmain.dll"
   }
   qpvMainDll := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")
}

intializeWithGivenArguments() {
   thisCounter := folderOpened := sldOpened := doWelcomeNow := 0
   disCount := A_Args.Count()
   Loop, % disCount
   {
      If (A_Index>=950)
      {
         doWelcomeNow := 1
         Break
      } Else If (RegExMatch(A_Args[A_Index], sldsPattern) && RegExMatch(A_Args[A_Index], "i)^(.\:\\..*)") && !sldOpened)
      {
         If FileExist(A_Args[A_Index])
            sldOpened := A_Args[A_Index]
      } Else If (RegExMatch(A_Args[A_Index], "i)^(fd\=\|?.\:\\..*)") && !folderOpened)
      {
         paramSet := SubStr(A_Args[A_Index], 4)
         If FolderExist(StrReplace(paramSet, "|"))
            folderOpened := paramSet
      } Else If (RegExMatch(A_Args[A_Index], RegExFilesPattern) && !folderOpened && !sldOpened)
      {
         filesListu .= A_Args[A_Index] "`n"
         thisCounter++
      } Else If RegExMatch(A_Args[A_Index], "i)^(.?qpv-debug)")
      {
         debugModa := 1
      } Else If RegExMatch(A_Args[A_Index], "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(A_Args[A_Index], 5, InStr(A_Args[A_Index], "=") - 5)
         paramSetValue := SubStr(A_Args[A_Index], InStr(A_Args[A_Index], "=") + 1)
         If (paramSet && paramSetValue!="")
            %paramSet% := paramSetValue
      } Else If RegExMatch(A_Args[A_Index], "i)^(call\_..*\(\))")
      {
         func2exec := SubStr(A_Args[A_Index], 6, InStr(A_Args[A_Index], "(") - 6)
         If (IsFunc(func2exec)=1 && StrLen(func2exec)>2)
            delayedfunc2exec := func2exec
      }
   }
   ; ToolTip, % "l=" disCount , , , 2
   If sldOpened
   {
      OpenSLD(sldOpened)
   } Else If folderOpened
   {
      If InStr(folderOpened, "|")
         tryOpenGivenFolder(folderOpened, 0)
      Else
         OpenFolders(folderOpened)
   } Else If (thisCounter=1 && !sldOpened && !folderOpened)
      OpenArgFile(Trimmer(filesListu))
   Else If (thisCounter>1 && !sldOpened && !folderOpened)
      GuiDroppedFiles(filesListu, nona, none, thisCounter, 0)
   Else Return 1

   If delayedfunc2exec
      SetTimer, runDelayedfunc2exec, -900

   Return doWelcomeNow
}

runDelayedfunc2exec() {
   If IsFunc(delayedfunc2exec)
      %delayedfunc2exec%()
}

OpenSLD(fileNamu, dontStartSlide:=0) {
  mustOpenStartFolder := ""
  If !FileExist(fileNamu)
  {
     showTOOLtip("ERROR: Failed to load files list")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  PopulateIndexFilesStatsInfos("kill")
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  mustRemQuotes := 1
  setImageLoading()
  ForceRegenStaticFolders := 0
  renewCurrentFilesList()
  newStaticFoldersListCache := []
  DynamicFoldersList := CurrentSLD := filesFilter := ""
  zPlitPath(fileNamu, 0, OutFileName, OutDir)
  showTOOLtip("Loading slideshow, please wait`n" OutFileName "`n" OutDir "\")
  setWindowTitle("Loading slideshow, please wait", 1)
  If RegExMatch(fileNamu, "i)(.\.sldb)$")
  {
     r := OpenSLDBdataBase(fileNamu)
     If (maxFilesIndex>0 && r!=-1)
     {
        SLDcacheFilesList := 1
        mustGenerateStaticFolders := 0
        GenerateRandyList()
        SetTimer, ResetImgLoadStatus, -50
        CurrentSLD := fileNamu
        RecentFilesManager(CurrentSLD)
        SLDtypeLoaded := 3
        prevOpenFolderPath := OutDir
        INIaction(1, "prevOpenFolderPath", "General")
        RandomPicture()
        InfoToggleSlideShowu()
     } Else resetMainWin2Welcome()
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  SlidesMusicSong := ""
  FileReadLine, firstLine, % fileNamu, 1
  If InStr(firstLine, "[General]") 
  {
     mustRemQuotes := 0
     IniRead, SlidesMusicSong, % fileNamu, General, SlidesMusicSong, @
     If FileExist(SlidesMusicSong)
        IniRead, autoPlaySlidesAudio, % fileNamu, General, autoPlaySlidesAudio, @

     IniRead, testStaticFolderz, % fileNamu, Folders, Fi1, @
     IniRead, tstSLDcacheFilesList, % fileNamu, General, SLDcacheFilesList, @
     IniRead, testDynaFolderz, % fileNamu, DynamicFolderz, DF1, @
     If StrLen(testDynaFolderz)>4
        DynamicFoldersList := "|hexists|"
       ; DynamicFoldersList := coreLoadDynaFolders(fileNamu)

     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
  }

  mustGenerateStaticFolders := (InStr(firstLine, "[General]") && StrLen(testStaticFolderz)>8) ? 0 : 1
  If (tstSLDcacheFilesList=0)
     mustGenerateStaticFolders := 0

  If (SLDcacheFilesList=1 && InStr(firstLine, "[General]")) || !InStr(firstLine, "[General]")
     res := sldGenerateFilesList(fileNamu, 0, mustRemQuotes)

  currentFilesListModified := 0
  interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  prevOpenFolderPath := OutDir
  INIaction(1, "prevOpenFolderPath", "General")
  If (res="abandoned")
  {
     closeDocuments()
     showDelayedTooltip("Files list operation aborted by user")
     SoundBeep , 300, 100
     Return
  }

  If InStr(firstLine, "[General]") 
  {
     If (maxFilesIndex<3 && DynamicFoldersList="|hexists|")
        ReloadDynamicFolderz(fileNamu)

     If (MustLoadSLDprefs=1)
        readSlideSettings(fileNamu, 0)
  }

  GenerateRandyList()
  CurrentSLD := fileNamu
  SLDtypeLoaded := 2
  currentFileIndex := 1
  currentFilesListModified := 0
  RecentFilesManager(CurrentSLD)
  SetTimer, TriggerMenuBarUpdate, -90
  If (dontStartSlide=1)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime
     ResetImgLoadStatus()
     Return
  }

  ResetImgLoadStatus()
  If (maxFilesIndex>2)
  {
     RandomPicture()
     InfoToggleSlideShowu()
  } Else If (maxFilesIndex>0)
  {
     currentFileIndex := 1
     IDshowImage(1)
  } Else resetMainWin2Welcome()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

resetMainWin2Welcome() {
     Critical, on
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
     { 
        seenImagesDB.Exec("COMMIT TRANSACTION;")
        Sleep, -1
        seenImagesDB.Exec("BEGIN TRANSACTION;")
     }

     ForceRegenStaticFolders := SLDtypeLoaded := 0
     editingSelectionNow := thumbsDisplaying := 0
     renewCurrentFilesList()
     activeSQLdb.CloseDB()
     bckpResultedFilesList := []
     filteredMap2mainList := []
     toBeExcludedIndexes := []
     RandyIMGids := []
     calcScreenLimits()
     updateUIctrl()
     newStaticFoldersListCache := []
     SlidesMusicSong := DynamicFoldersList := CurrentSLD := ""
     filesFilter := EntryMarkedMoveIndex := mustOpenStartFolder := ""
     createGDIPcanvas()
     ToggleVisibilityWindow("show", hGDIwin)
     interfaceThread.ahkassign("thumbsDisplaying", 0)
     interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
     Gdip_GraphicsClear(glPG, "0x00" WindowBgrColor)
     doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, glHDC, 1)
     ToggleVisibilityWindow("hide", hGDIthumbsWin)
     gdiBitmapIDcall := viewportIDstampBMP := AprevImgCall := BprevImgCall := ""
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
     corePasteInPlaceActNow("kill")
     livePreviewInsertTextinArea("kill")
     coreFillSelectedArea("kill")
     livePreviewDesaturateArea("kill")
     coreCreateVPnavBox("kill")
     LoadCachableBitmapFromFile("kill")
     createGradientBrushBitmap("kill", 0, 0, 0, 0)
     createClonedBrushBitmap("kill", 0, 0, 0, 0)
     viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
     gdipObjectsStats(1, "QPV_ShowThumbnails")
     gdipObjectsStats(1)
     ForceRefreshNowThumbsList()
     prevOpenedWindow := ""
     drawWelcomeImg()
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, createGUItoolbar, -150
     SetTimer, ResetImgLoadStatus, -50
}

deleteKeyAction() {
    If !getIDimage(currentFileIndex)
       Return

    If (thumbsDisplaying!=1 && editingSelectionNow=1)
       PanelEraseSelectedArea()
    Else
       DeletePicture()
}

activateFilesListFilterBasedOnFolder(thisIndex) {
   If askAboutFileSave(" and the files list will be filtered to the current image containing folder")
      Return

   r := getIDimage(thisIndex)
   zPlitPath(r, 0, OutFileName, OutDir)
   userFilterProperty := userFilterDoString := 1
   userFilterWhat := 2
   userFilterStringPos := 3
   userFilterInvertThis := userFilterStringIsNot := 0
   UsrEditFilter := OutDir
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   showDelayedTooltip("Files list filtered to current image file path:`n" OutDir "\", 0, 325)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

escRoutine() {
  Sleep, -1
  Return
}

mainWinTabResponse() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked>200)
   {
      If HKifs("liveEdit")
         toggleImgEditPanelWindow()
      Else If HKifs("imgsLoaded")
         markThisFileNow()
      lastInvoked := A_TickCount
   }
 }
GenerateRandyList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   startZeit := A_TickCount
   RandyIMGids := []
   Loop, % maxFilesIndex
       RandyIMGids[A_Index] := A_Index
   RandyIMGids := Random_ShuffleArray(RandyIMGids)
   RandyIMGnow := 1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

OpenThisFileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := getIDimage(currentFileIndex)
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       Try Run, "%folderu%"
       Catch wasError
       {
          If !AnyWindowOpen
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu "\", 0, 0, "error")
       }
    }
}

OpenQPVfileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    If imgPath
    {
       zPlitPath(imgPath, 0, fileNamu, folderu)
       renewCurrentFilesList()
       mustOpenStartFolder := folderu
       currentFileIndex := 1
       resultedFilesList[1, 1] := imgPath
       currentFileIndex := doOpenStartFolder()
       dummyTimerDelayiedImageDisplay(50)
    }
}

setImageWallpaper() {
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !RegExMatch(imgPath, "i)(.\.(bmp|jpg|jpeg|png|tif))$")
   {
      showTOOLtip("Converting Image file format for desktop wallpaper into JPEG")
      file2save := mainCompiledPath "\wallpaper-" OutNameNoExt ".jpg"
      r := coreConvertImgFormat(imgPath, file2save)
      If !r
         imgPath := file2save
      ResetImgLoadStatus()
   }

   GetPhysicalCursorPos(mainX, mainY)
   ActiveMon := MWAGetMonitorMouseIsIn(mainX, mainY)
   If !ActiveMon
      ActiveMon := 1

   dw := new IDesktopWallpaper
   dw.GetMonitorDevicePathAt(ActiveMon - 1, MonitorID)
   dw.SetWallpaper(MonitorID, imgPath)
   dw := Delete IDesktopWallpaper
   showTOOLtip("Image file is now set as desktop wallpaper`n" fileNamu "`n" folderu "\")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenThisFileMenu() {
  Static lastInvoked := 1

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, Ext)
  labelu := "QPVimage." Ext

  RegRead, regEntryA, HKEY_CLASSES_ROOT\.%Ext%
  If (regEntryA=labelu)
     testA := 1

  RegRead, regEntryB, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.%Ext%\UserChoice, ProgId
  If (regEntryB=labelu)
     testB := 1

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  isAssociated := (testA=1 && testB=1) ? 1 : 0
  newInstanceOption := (A_IsCompiled) ? 1 : 0
  InvokeOpenWithMenu(imgPath, newInstanceOption)
}

SoloNewQPVinstance() {
   OpenWithNewQPVinstance("single")
}

OpenWithNewQPVinstance(dummy:=0, givenList:=0, givenCount:=0) {
   filesElected := getSelectedFiles(0, 1)
   markedSelectFile := filesElected
   If (givenList && givenCount && isNumber(givenCount))
      filesElected := givenCount

   ; ToolTip, % givenCount "--" dummy "--" filesElected "--" givenList , , , 2
   If (filesElected>25 && dummy!="single")
   {
      msgBoxWrapper(appTitle ": WARNING", "You are not allowed to spawn in one go more than 25 instances of " appTitle ".", 0, 0, "error")
      Return
   }

   If (filesElected>5 && dummy!="single")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " groupDigits(filesElected) ". Please confirm you want to spawn so many new instances of " appTitle ".", 4, 0, "question")
      If (msgResult="Yes")
         allGood := 1
   } Else allGood := 1

   maxLoops := (givenList && givenCount) ? givenCount + 2 : maxFilesIndex
   If (givenList && givenCount>0 && isNumber(givenCount) && dummy!="single" && allGood=1)
   {
      Loop, Parse, givenList, `n
      {
         imgPath := Trimmer(A_LoopField)
         If StrLen(imgPath)>4
         {
            Sleep, (A_Index>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (markedSelectFile && filesElected>1 && dummy!="single" && allGood=1)
   {
      thisIndex := 0
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisIndex++
         imgPath := resultedFilesList[A_Index, 1]
         If StrLen(imgPath)>4
         {
            Sleep, (thisIndex>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (!markedSelectFile || dummy="single")
   {
      imgPath := getIDimage(currentFileIndex)
      OpenNewQPVinstance(imgPath)
   }
}

OpenNewQPVinstance(imgPath:="") {
   imgPath := StrReplace(imgPath, "||")
   If FolderExist(imgPath)
      imgPath := "fd=" imgPath
   Else If !FileRexists(imgPath)
      imgPath := ""

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening a new instance of " appTitle ".", 0, 0, "error")
}

OpenWithDefaultApp() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the default application.", 0, 0, "error")
    }
}

OpenFileProperties() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()

    Sleep, 25
    If imgPath
    {
       Try Run, Properties "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
    }
}

InvokeOpenWithMenu(imgPath, newInstanceOption) {
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    CurrentSLD := Trimmer(StrReplace(CurrentSLD, "|"))
    IniAction(0, "UserExternalApp", "General", 5)
    pathu := "&X. " PathCompact(UserExternalApp, 28)
    If StrLen(Trimmer(UserExternalApp))<6
       pathu := "NONE CHOSEN"

    IniAction(0, "UserExternalEditApp", "General", 5)
    pathu2 := "&Y. " PathCompact(UserExternalEditApp, 28)
    If StrLen(Trimmer(UserExternalEditApp))<6
       pathu2 := "NONE CHOSEN"
    CreateOpenWithMenu(imgPath)
    Menu, OpenWithMenu, Add,
    If (newInstanceOption=1 && !markedSelectFile)
       Menu, OpenWithMenu, Add, &0. Open file(s) in a new QPV instance, SoloNewQPVinstance
    Menu, OpenWithMenu, Add, &1. Open with default application, OpenWithDefaultApp
    Menu, OpenWithMenu, Add, &2. System «Open with» dialog, invokeSHopenWith
    Menu, OpenWithMenu, Add, &4. Explore containing folder`tCtrl+E, OpenThisFileFolder
    If (CurrentSLD!=OutDir)
       Menu, OpenWithMenu, Add, &5. Open containing folder in QPV, OpenQPVfileFolder
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Choose external application, browseExternalApp
    Menu, OpenWithMenu, Add, %pathu%, OpenImgWithUserExternApp
    Menu, OpenWithMenu, Add, &Choose external editor application, browseExternalEditApp
    Menu, OpenWithMenu, Add, %pathu2%, OpenImgWithUserEditExternApp
    If (!pathu || pathu="none chosen")
       Menu, OpenWithMenu, Disable, %pathu%
    If (!pathu2 || pathu2="none chosen")
       Menu, OpenWithMenu, Disable, %pathu2%
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Cancel, dummy
    showThisMenu("OpenWithMenu")
}

browseExternalApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalApp := imgPath
      IniAction(1, "UserExternalApp", "General")
      OpenImgWithUserExternApp()
   }
}

browseExternalEditApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalEditApp := imgPath
      IniAction(1, "UserExternalEditApp", "General")
      OpenImgWithUserEditExternApp()
   }
}

OpenImgWithUserEditExternApp() {
   destroyGDIfileCache()
   OpenImgWithUserExternApp("editor")
}

OpenImgWithUserExternApp(dummy:=0) {
   ; IniAction(0, "UserExternalApp", "General", 5)
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisAPPpath := (dummy="editor") ? UserExternalEditApp : UserExternalApp
   If !FileExist(thisAPPpath)
   {
      zPlitPath(thisAPPpath, 0, fileNamu, folderu, OutNameNoExt)
      showTOOLtip("ERROR: The file of the external application does not seem to exist anymore`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Try Run, %thisAPPpath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the external application.", 0, 0, "error")
}

incDecSlidesSpeed(direction) {
   If (direction=1)
      IncreaseSlideSpeed()
   Else
      DecreaseSlideSpeed()
}

resetSlideshowTimer(showMsg, ignoreEasyStop:=0, showProgress:=0) {
   ; DestroyGIFuWin()
   If (slideShowRunning!=1 && showMsg!=1)
      Return

   If (easySlideStoppage=1 && slideShowRunning=1 && ignoreEasyStop=0)
      ToggleSlideShowu("stop", 0)
   Else If (slideShowRunning=1)
      ToggleSlideShowu("start", 1)

   If (showMsg=1)
   {
      friendly := (slideShowRunning=1) ? "RUNNING" : "STOPPED"
      delayu := DefineSlidesRate()
      etaTime := "Estimated time: " EstimateSlideShowLength()
      proggy := (showProgress=1) ? slideShowDelay/59125 : 0
      showTOOLtip("Slideshow speed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) "`n" etaTime "`nSlideshow: " friendly, "incDecSlidesSpeed", 2, proggy)
      SetTimer, ResetImgLoadStatus, -50
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

IncreaseSlideSpeed() {
   If (slideShowDelay<1000)
   {
      slideShowDelay += 300
      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }
   
   slideShowDelay += 1000
   If (slideShowDelay>59000)
      slideShowDelay := 59000

   SetTimer, dummyChangeSlideSpeed, -50
}

DecreaseSlideSpeed() {
   If (slideShowDelay<1001)
   {
      slideShowDelay -= 300
      If (slideShowDelay<200)
         slideShowDelay := 100

      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }

   slideShowDelay -= 1000
   SetTimer, dummyChangeSlideSpeed, -50
}

dummyChangeSlideSpeed() {
   resetSlideshowTimer(1, 1, 1)
   INIaction(1, "slideShowDelay", "General")
}

CalculateSelectedFilesSizes() {
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  getSelectedFiles(0, 1)
  If !markedSelectFile
  {
     showTOOLtip("No files currently selected to calculate total files' size.")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  showTOOLtip("Calculating total files' size for selected entries, please wait")
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  doStartLongOpDance()
  maxCdate := maxMdate := maxSizeu := 0
  minCdate := minMdate := minSizeu := 99999999999999
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  Loop, % maxFilesIndex
  {
     isSelected := resultedFilesList[A_Index, 2]
     If (isSelected!=1)
        Continue

     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }

     countFiles++
     If (A_TickCount - prevMSGdisplay>1000)
     {
        etaTime := ETAinfos(countFiles, markedSelectFile, startOperation)
        If failedFiles
           etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

        showTOOLtip("Calculating total files' size, please wait" etaTime, 0, 0, countFiles/markedSelectFile)
        prevMSGdisplay := A_TickCount
     }

     fileInfos := GetFileAttributesEx(resultedFilesList[A_Index, 1])
     If !fileInfos.size
     {
        failedFiles++
        Continue
     }

     totalSize += fileInfos.size
     minSizeu := min(minSizeu, fileInfos.size)
     maxSizeu := max(maxSizeu, fileInfos.size)
     minMdate := min(minMdate, fileInfos.wtime)
     maxMdate := max(maxMdate, fileInfos.wtime)
     minCdate := min(minCdate, fileInfos.ctime)
     maxCdate := max(maxCdate, fileInfos.ctime)
  }
  ; ToolTip, % minCdate , , , 2
  totalSize := Round(totalSize/1024)
  If (totalSize>1023)
  {
     totalSize := Round(totalSize/1024, 1)
     If (totalSize>1023.9)
        totalSize := Round(totalSize/1024, 1) " GB"
     Else totalSize := totalSize " MB"

  } Else totalSize := totalSize " KB"

  minSizeu := Round(minSizeu/1024)
  minSizeu := (minSizeu>1023) ? Round(minSizeu/1024, 1) " MB" : minSizeu " KB"

  maxSizeu := Round(maxSizeu/1024)
  maxSizeu := (maxSizeu>1023) ? Round(maxSizeu/1024, 1) " MB" : maxSizeu " KB"
  CurrentSLD := backCurrentSLD
  Try FormatTime, minCdate, % minCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxCdate, % maxCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, minMdate, % minMdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxMdate, % maxMdate, dd/MM/yyyy, HH:mm
  If (abandonAll=1)
     someErrors := "Operation aborted by user`n"
  showTOOLtip(someErrors "Details for " groupDigits(countFiles) " selected files:`nTotal size: " totalSize "`nFile sizes range: " minSizeu " - " maxSizeu "`nDate modified: " minMdate " - " maxMdate "`nDate created: " minCdate " - " maxCdate)
  SetTimer, ResetImgLoadStatus, -200
  SetTimer, RemoveTooltip, % -msgDisplayTime * 2
}

CopyImageFolderPaths() {
    CopyImagePath("folderz")
}

CopyImagePath(dummy:=0) {
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  folderPathsOnly := (GetKeyState("CapsLock", "T") || dummy="folderz") ? 1 : 0
  friendly := (folderPathsOnly=1) ? "folder" : "file"
  showTOOLtip("Copying " friendly " path(s) to clipboard")
  getSelectedFiles(0, 1)
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue

        imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
        If (folderPathsOnly=1)
        {
           folderu := ""
           zPlitPath(imgPath, 1, fileNamu, folderu)
           listu .= folderu "`n"
        } Else listu .= imgPath "`n"
        countTFilez++
     }

     If countTFilez
     {
        If (folderPathsOnly=1)
           Sort, listu, UD`n
        Try Clipboard := listu
        Catch wasError
            Sleep, 1

        infoText := wasError ? "ERROR: Failed to copy to clipboard the selected file paths`nError code: " wasError : groupdigits(countTFilez) A_Space friendly " paths were copied to clipboard"
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, fileNamu, folderu)
  imgPath := StrReplace(imgPath, "||")
  If (folderPathsOnly=1)
     Try Clipboard := folderu
  Else
     Try Clipboard := imgPath
  Catch wasError
      Sleep, 1

  infoText := wasError ? "ERROR: Failed to copy to clipboard the " friendly " path`nError code: " wasError "`n" : "The " friendly " path copied to clipboard`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ClipboardSetFiles(PathsFilesArray, Method:="copy", foldersMode:=0) {
; function from https://autohotkey.com/board/topic/23162-how-to-copy-a-file-to-the-clipboard/page-4
; by maraskan_user and Lexikos
; modified by Marius Șucan

   FileCount := PathLength := 0

   ; Count files and total string length from given array
   For i, File in PathsFilesArray
   {
      FileCount++
      PathLength += StrLen(File)
   }

   If (!FileCount || !PathLength)
      Return

   pid := DllCall("GetCurrentProcessId","uint")
   hwnd := WinExist("ahk_pid " . pid)
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   hPath := DllCall("GlobalAlloc","uint",0x42,"uint",20 + (PathLength + FileCount + 1) * 2, "UPtr")
   If !hPath
      Return

   pPath := DllCall("GlobalLock","UPtr", hPath, "UPtr")
   NumPut(20, pPath+0), pPath += 16 ; DROPFILES.pFiles = offset of file list
   NumPut(1, pPath+0), pPath += 4 ; fWide = 0 -->ANSI,fWide = 1 -->Unicode

   Offset := 0
   ; Rows are delimited by linefeeds (`r`n).
   for i, File in PathsFilesArray
       offset += StrPut(File, pPath + offset, StrLen(File)+1, "UTF-16") * 2

   DllCall("GlobalUnlock","UPtr",hPath)
   If !DllCall("OpenClipboard","UPtr", hwnd)
      Return

   DllCall("EmptyClipboard")
   err := DllCall("SetClipboardData","uint",0xF,"UPtr",hPath) ; 0xF = CF_HDROP

   ; Write Preferred DropEffect structure to clipboard to switch between copy/cut operations
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   mem := DllCall("GlobalAlloc","uint",0x42,"uint",4,"UPtr")
   If mem
   {
      str := DllCall("GlobalLock","UPtr",mem, "uptr")
   } Else
   {
      DllCall("CloseClipboard")
      Return
   }

   if (Method="copy")
   {
      DllCall("RtlFillMemory","UPtr",str,"UPtr",1,"Int",0x05)
   } else if (Method="cut")
   {
      DllCall("RtlFillMemory","UPtr",str,"UPtr",1,"Int",0x02)
   } else
   {
      DllCall("CloseClipboard")
      Return
   }

   DllCall("GlobalUnlock","UPtr",mem)
   If (foldersMode=1)
   {
      cfFormat := DllCall("RegisterClipboardFormat","Str","DropEffectFolderList")
      err := DllCall("SetClipboardData","uint",cfFormat,"UPtr",mem)
   }   

   cfFormat := DllCall("RegisterClipboardFormat","Str","Preferred DropEffect")
   err := DllCall("SetClipboardData","uint",cfFormat,"UPtr",mem)
   DllCall("CloseClipboard")
   return err
}

MenuExplorerCopyFiles() {
    CopyMoveFilesExplorer("copy")
}

MenuExplorerCutFiles() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut")
}

CopyMoveFilesExplorer(userOption:="copy") {
  userOption := (userOption="cut") ? "CUT" : "COPY"
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  showTOOLtip("Copying file path(s) to clipboard")
  getSelectedFiles(0, 1)
  newFilesList := []
  countTFilez := 0
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue

        file2rem := getIDimage(A_Index)
        file2rem := StrReplace(file2rem, "||")
        If StrLen(file2rem)<4
           Continue

        countTFilez++
        newFilesList[countTFilez] := file2rem
     }

     If countTFilez
     {
        dataHandle := ClipboardSetFiles(newFilesList, userOption)
        Sleep, 5
        testClipType := IsClipboardFormatAvailable(15)
        infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store the selected files into the clipboard" : "On " countTFilez " files " userOption " was applied.`nThese can now be pasted in any file manager."
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  newFilesList[1] := Trimmer(StrReplace(imgPath, "||"))
  dataHandle := ClipboardSetFiles(newFilesList, userOption)
  zPlitPath(imgPath, 0, fileNamu, folderu)
  Sleep, 5
  Try testClipType := IsClipboardFormatAvailable(15)
  infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store files into clipboard" : "File " userOption " [Explorer mode]...`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

throwErrorNoImageLoaded(noMSG:=0) {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   If (StrLen(whichBitmap)<3 || !imgPath)
   {
      If (noMSG=0)
      {
         showTOOLtip("WARNING: No image file is currently loaded")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
      }
      Return "fail"
   }
}

CopyImage2clip() {
  If (thumbsDisplaying=1)
     Return "fail"

  If throwErrorNoImageLoaded()
     Return "fail"

  whichBitmap := useGdiBitmap()
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (editingSelectionNow=1) ? " selected area" : ""
  If (editingSelectionNow=1 && StrLen(whichBitmap)>2)
  {
     If throwErrorSelectionOutsideBounds(whichBitmap)
        Return "fail"
  }

  setImageLoading()
  If StrLen(whichBitmap)>2
  {
     showTOOLtip("Copying image" friendly " to clipboard, please wait")
     If (editingSelectionNow=1)
        zBitmap := getselectedImageArea(whichBitmap, 1, 0, 2, 0)
     Else
        zBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap)))

     If StrLen(zBitmap)>2
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
        r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        ; If (zBitmap!=whichBitmap)
           trGdip_DisposeImage(zBitmap, 1)
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  If r
     showTOOLtip("Failed to copy the image to clipboard`nError code: " r)
  Else
     showTOOLtip("Image" friendly " copied to clipboard")

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

invertCurrentFolderRecursiveness() {
   If (RegExMatch(CurrentSLD, sldsPattern) || !CurrentSLD)
      Return

   isPipe := InStr(CurrentSLD, "|") ? 1 : 0
   CurrentSLD := StrReplace(CurrentSLD, "|")
   DynamicFoldersList := StrReplace(DynamicFoldersList, "|")
   If (isPipe!=1)
   {
      CurrentSLD := "|" CurrentSLD
      DynamicFoldersList := "|" DynamicFoldersList
   }

   RefreshFilesList()
}

MenuRemFilesListFilter() {
   remFilesListFilter()
   ; SetTimer, RandomPicture, -150
   dummyTimerDelayiedImageDisplay(50)
}

remFilesListFilter(dummy:=0) {
   If (dummy="simple")
   {
      addJournalEntry("Removing files list filter:`n" filesFilter)
      prevFilter := filesFilter
      filesFilter := ""
      FilterFilesIndex(0, 0, prevFilter)
      currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
   } Else coreEnableFiltru("")
}


dummyTimerReloadThisPicture(timeru:=0) {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (timeru>1)
     SetTimer, extraDummyReloadThisPicture, % -timeru, 950
}

extraDummyReloadThisPicture() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyReloadThisPicture, -15
     Return
  }
  ReloadThisPicture()
}

determineLClickstate() {
   If (slideShowRunning=1)
      Return 0

   LbtnDwn := interfaceThread.ahkgetvar.LbtnDwn
   If (GetKeyState("LButton") || LbtnDwn=1)
      Return 1
   Else
      Return 0
}

ReloadThisPicture() {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     delayu := (A_TickCount - prevFastDisplay < 500) ? 90 : 550
     If (determineLClickstate()=1 || GetKeyState("Space", "P"))
     {
        dummyTimerReloadThisPicture(delayu)
        Return
     }

     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

coreReloadThisPicture() {
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

FirstPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := 1
   dummyTimerDelayiedImageDisplay(50)
}

LastPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=maxFilesIndex)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := maxFilesIndex
   dummyTimerDelayiedImageDisplay(50)
}

SettingsGUIAGuiClose:
SettingsGUIAGuiEscape:
   CloseWindow()
Return

OSDguiToolbarGuiClose:
   WinGetPos, X, Y, Width, Height, ahk_id %hQPVtoolbar%
   If (x && y)
   {
      UserToolbarX := x
      UserToolbarY := y
   }

   toggleAppToolbar()
Return

doCleanup:
   TrueCleanup()
Return

TrueCleanup(mustExit:=1) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 900) || (hasInitSpecialMode=1)
      Return

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")

   activeSQLdb.CloseDB()
   seenImagesDB.CloseDB()
   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   WinSet, Region, 0-0 w1 h1, ahk_id %PVhwnd%
   RegWrite, REG_SZ, %QPVregEntry%, Running, 0
   If StrLen(hitTestSelectionPath)>1
   {
      editingSelectionNow := 0
      Gdip_DeletePath(hitTestSelectionPath)
      hitTestSelectionPath := ""
   }

   lastInvoked := A_TickCount
   RemoveTooltip()
   DestroyGIFuWin()

   Sleep, 1
   If (wasInitFIMlib=1)
      FreeImage_FoxInit(0) ; Unload Dll

   disposeCacheIMGs()
   destroyGDIfileCache()
   discardViewPortCaches()
   Gdip_DeleteBrush(pBrushWinBGR)
   Gdip_DeleteBrush(pBrushHatch)
   Gdip_DeleteBrush(pBrushHatchLow)
   Gdip_DeleteBrush(pBrushA)
   Gdip_DeleteBrush(pBrushB)
   Gdip_DeleteBrush(pBrushC)
   Gdip_DeleteBrush(pBrushD)
   Gdip_DeleteBrush(pBrushE)
   Gdip_DeleteBrush(pBrushF)
   Gdip_DeleteBrush(pBrushZ)
   Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   Gdi_DeleteObject(gdiAmbientalTexBrush)
   Gdi_DeleteObject(GDIbrushWinBGR)
   Gdip_DeletePen(pPen1d)
   Loop, 7
      Gdip_DeletePen(pPen%A_Index%)

   mainGdipWinThumbsGrid(1)
   destroyGDIPcanvas()
   Sleep, 1
   GDIPToken := Gdip_Shutdown(GDIPToken)  
   lastInvoked := A_TickCount
   ; If (mustExit=1)
   ;    writeMainSettings()
   lastInvoked := A_TickCount
   fnOutputDebug("Proper exit. Main thread. PID=" QPVpid)
   ForceExitNow("yay")
}

ForceExitNow(dummy:=0) {
   If GDIPToken
      Gdip_Shutdown(GDIPToken)  
   Sleep, 5
   If (dummy!="yay")
      fnOutputDebug("Forced exit. Main thread. PID=" QPVpid)
   Process, Close, % QPVpid
   ExitApp
}

dummySetWindowTitle() {
    setWindowTitle("lol", 0, 1)
}

setWindowTitle(msg, forceThis:=0, useLast:=0) {
    Static prevSet, prevMsg, lastInvoked := 1
    If (A_TickCount - zeitSillyPrevent<200) || (drawingShapeNow=1)
       Return

    msg := StrReplace(msg, "`n", " | ")
    If (useLast!=1)
       addJournalEntry("WinTitle: " msg)

    infoSlideDelay := (slideShowRunning=1 && slideShowDelay<2950) ? 1 : 0
    thisMsg := (useLast=1 && StrLen(prevMsg)>3) ? prevMsg : msg
    If (useLast!=1)
       prevMsg := msg

    If (A_TickCount - lastInvoked<200) && (useLast!=1 && forceThis!=1)
    {
       SetTimer, dummySetWindowTitle, -350
       Return
    }

    If (prevSet!=thisMsg && runningLongOperation!=1 && infoSlideDelay=0 && animGIFplaying!=1 && hasInitSpecialMode!=1) || (forceThis=1)
    {
       prevSet := thisMsg
       WinSetTitle, ahk_id %PVhwnd%,, % thisMsg
       ; fnOutputDebug("WinTitle: " thisMsg)
       lastInvoked := A_TickCount
    }
}

fnOutputDebug(msg) {
   Static prevMsg

   If (debugModa=1)
   {
      If (prevMsg!=msg && slideShowRunning!=1 && slideShowDelay>300)
      {
         prevMsg := msg
         msg := StrReplace(msg, "User journal: wintitle:", "WinTitle:")
         msg := StrReplace(msg, "User journal: dialog box:", "Dialog box:")
         msg := StrReplace(msg, "User journal: osd:", "OSD:")
         OutputDebug, % "QPV: " Trim(msg)
      }
   }
}

MenuDummyToggleThumbsMode() {
   lastOtherWinClose := 5
   ToggleThumbsMode()
}

initAHKhThumbThreads() {
    Static multiCoreInit := 0

    If (multiCoreInit=1 || allowMultiCoreMode!=1 || minimizeMemUsage=1)
       Return

    addJournalEntry("Attempting to initialize " realSystemCores " threads for thumbnails generation")
    initFIMGmodule()
    If (FIMfailed2init=1)
    {
       addJournalEntry("Failed to initialize the auxiliary threads because FreeImage failed to initialize")
       multiCoreThumbsInitGood := 0
    } Else
    {
       ; SoundBeep 300, 100
       If A_IsCompiled
          r := GetRes(dataFile, 0, "MODULE-FIM-THUMBS.AHK", "LIB")

       Loop, % realSystemCores + 1
       {
           If IsObject(thumbThread%A_Index%)
              Continue

           If !A_IsCompiled
              thumbThread%A_Index% := ahkthread("#Include *i Lib\module-fim-thumbs.ahk")
           Else If r
              thumbThread%A_Index% := ahkThread(StrGet(&dataFile, r, "utf-8"))

           Sleep, 1
       }

       Loop, % realSystemCores + 1
       {
           goodInit += thumbThread%A_Index%.ahkFunction("initThisThread", GDIPToken "|" mainCompiledPath)
           Sleep, 1
       }

       multiCoreThumbsInitGood := (goodInit>=realSystemCores+1) ? 1 : 0
       If (multiCoreThumbsInitGood=1)
          addJournalEntry("Succesfully initialized " goodInit " threads.")
       Else
          addJournalEntry("Failed to initialize the auxiliary threads (unknown cause).")
    }

    multiCoreInit := 1
}

getFolderDetails(pathu) {
   FileGetTime, fileMdate, % pathu, M
   FileGetTime, fileCdate, % pathu, C
   FileGetAttrib, fileAttribs, % pathu
   thisFolderDetails := "\" fileMdate "\" fileCdate "\" fileAttribs "\" pathu
   Return thisFolderDetails
}

ToggleThumbsMode() {
   Static multiCoreInit := 0, lastInvoked := 1, prevIndexu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (A_TickCount - lastInvoked<190) || (A_TickCount - lastOtherWinClose<190)
   {
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(mustOpenStartFolder)>3 && !ar)
   {
      currentFileIndex := doOpenStartFolder(didSomething)
      If !didSomething
         Return
   } Else If (thumbsDisplaying=1 && currentFileIndex!=imgIndexEditing)
   {
      ar := askAboutFileSave(" and another image will be loaded", 1, 0, "yes")
      If ar
      {
         If (ar=1)
         {
            SetTimer, PanelSaveImg, -350
            currentFileIndex := imgIndexEditing
         } Else Return
      }
   }

   If (SLDtypeLoaded=1 && FolderExist(StrReplace(CurrentSLD, "|")) && watchFolderDetails && maxFilesIndex>1 && thumbsDisplaying!=1)
   {
      thisFolderDetails := getFolderDetails(StrReplace(CurrentSLD, "|"))
      IF (thisFolderDetails!=watchFolderDetails && !markedSelectFile)
      {
         msgResult := msgBoxWrapper(appTitle ": Folder changed", "The folder currently opened seems to have been changed. Would you like to reload it?", 4, 0, "question")
         If InStr(msgResult, "yes")
            RefreshFilesList()
      }
      watchFolderDetails := thisFolderDetails
   }

   lastInvoked := A_TickCount
   If (maxFilesIndex<1 && thumbsDisplaying!=1)
   {
      showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   interfaceThread.ahkassign("lastCloseInvoked", 0)
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   thisIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)
   If (thumbsDisplaying=1)
   {
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Deactivating thumbs mode")
      If (thisIndexu!=prevIndexu)
         FadeMainWindow()

      thumbsDisplaying := 0
      Global lastOtherWinClose := A_TickCount
      ; fnOutputDebug("Showing hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("show", hGDIwin)
      interfaceThread.ahkassign("thumbsDisplaying", 0)
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)

      ; fnOutputDebug("Hiding hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("hide", hGDIthumbsWin)
      fnOutputDebug("Image view initialized")
      dummyTimerDelayiedImageDisplay(50)
      interfaceThread.ahkPostFunction("UpdateUiStatusBar", 0, 0, "image")
      If hSNDmediaFile
         MCI_Resume(hSNDmedia)
      lastTimeToggleThumbs := A_TickCount
   } Else If (CurrentSLD && maxFilesIndex>0)
   {
      SetTimer, extraDummyReloadThisPicture, Off
      SetTimer, extraDummyDelayiedImageDisplay, Off
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Initializing thumbnails/list view mode")
      prevLoadedImageIndex := currentFileIndex
      If (prevIndexu!=thisIndexu && thumbsListViewMode=1)
         CreateOSDinfoLine("Generating thumbnails, please wait", 0, 1)

      prevIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
      If (thumbsListViewMode=1 && !isWinXP)
         initAHKhThumbThreads()

      If (getCaptionStyle(PVhwnd)=1)
         ToggleTitleBaruNow()
      If hSNDmediaFile
         MCI_Pause(hSNDmedia)

      ; fnOutputDebug("Hiding hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("hide", hGDIwin)
      ; fnOutputDebug("Showing hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("show", hGDIthumbsWin)
      thumbsDisplaying := 1
      fnOutputDebug("Recalculating thumbnail sizes")
      recalculateThumbsSizes()
      UpdateThumbsScreen()
      fnOutputDebug("hGDIinfosWin cleaned...  " hGDIinfosWin "  -- G= " 2NDglPG "  -- hDC= " 2NDglHDC " ")
      clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      interfaceThread.ahkPostFunction("UpdateUiStatusBar", 0, 0, "list")
      RemoveTooltip()
      lastTimeToggleThumbs := A_TickCount
   }
   createGUItoolbar()
   SetTimer, TriggerMenuBarUpdate, -90
   lastInvoked := A_TickCount
}

TriggerMenuBarUpdate(modus:=0) {
   If (showMainMenuBar!=1 && modus!="forced")
      Return

   modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
   If (drawingShapeNow=1)
      moduds := "freeform"
   lastMenuBarUpdated := A_TickCount
   ; fnOutputDebug("Updating menu bar")
   interfaceThread.ahkassign("thumbsDisplaying", thumbsDisplaying)
   interfaceThread.ahkPostFunction("UpdateMenuBar", modus)
}

defineThumbsAratio() {
  friendly := (thumbsAratio=1) ? "Wide (1.81)" : "Tall (0.48)"
  If (thumbsAratio=3)
     friendly := "Square (1.00)"

  Return friendly
}

recalculateThumbsSizes() {
   Static theString := "WAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAW"
   , prevDimensions, columnsPossible, txtResH

   If (thumbsAratio=1)
   {
      othumbsW := 300
      othumbsH := 165
   } Else If (thumbsAratio=2)
   {
      othumbsW := 144
      othumbsH := 300
   } Else If (thumbsAratio=3)
   {
      othumbsW := 300
      othumbsH := 300
   }
 
   If (thumbsZoomLevel<0.35)
     thumbsZoomLevel := 0.35
   Else If (thumbsZoomLevel>3)
     thumbsZoomLevel := 3
 
   thumbsH := Round(othumbsH*thumbsZoomLevel)
   thumbsW := Round(othumbsW*thumbsZoomLevel)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsH>mainHeight || thumbsW>mainWidth)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//2 - 16, mainHeight//2 - 16, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
   }

   If (thumbsColumns>0 && dynamicThumbsColumns=0)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//thumbsColumns, mainHeight, ResizedW, ResizedH)
      z := Round(mainHeight/ResizedH)
      If z
         thumbsH := mainHeight//z
      If ResizedW
         thumbsW := ResizedW

      thumbsW := clampInRange(thumbsW, 80 + Round(OSDfntSize/9), 2048)
      thumbsH := clampInRange(thumbsH, 80 + Round(OSDfntSize/9), 2048)
   }

   If isInRange(max(thumbsW, thumbsH), 0, 150)
      thumbsSizeQuality := 125
   Else If isInRange(max(thumbsW, thumbsH), 151, 290)
      thumbsSizeQuality := 245
   Else If (max(thumbsW, thumbsH)>650)
      thumbsSizeQuality := 755
   Else
      thumbsSizeQuality := 500

   If (thumbsListViewMode>1)
   {
      theseDimensions := mainWidth "=" mainHeight "=" OSDfntSize "=" OSDFontName "=" imgHUDbaseUnit "=" thumbsListViewMode
      If (prevDimensions!=theseDimensions)
      {
         xBitmap := trGdip_CreateBitmap(A_ThisFunc, 30, 30)
         G := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
         borderSize := imgHUDbaseUnit//5
         txtOptions := "x" borderSize " y" borderSize A_Space " Left cEE090909 r1 s" OSDfntSize//1.25
         thisString := theString "`n" theString
         If (thumbsListViewMode>2)
            thisString .= "`n" theString

         dimensions := Gdip_TextToGraphics(G, thisString, txtOptions, OSDFontName, mainWidth, mainHeight, 0, 0)
         txtRes := StrSplit(dimensions, "|")
         txtResW := Ceil(txtRes[3]) + borderSize*2
         txtResH := Ceil(txtRes[4]) + borderSize*2.1
         Gdip_DeleteGraphics(G)
         trGdip_DisposeImage(xBitmap, 1)
         columnsPossible := Round(mainWidth/txtResW)
         prevDimensions := theseDimensions
      }

      thumbsW := mainWidth//columnsPossible - 5
      thumbsH := Round(txtResH)
   }
}

ToggleThumbsAratio() {
  If (thumbsDisplaying!=1)
     Return

  If (thumbsListViewMode>1)
  {
     ToggleImgNavSizeBox()
     Return
  }

  thumbsAratio++
  If (thumbsAratio>3)
     thumbsAratio := 1

  recalculateThumbsSizes()
  showTOOLtip("Thumbnails aspect ratio: " defineThumbsAratio() "`nSize: " thumbsW " x " thumbsH " (pixels)", A_ThisFunc, 1, thumbsAratio/3)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "thumbsAratio", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

thumbsInfoYielder(ByRef maxItemsW, ByRef maxItemsH, ByRef maxItemsPage, ByRef maxPages, ByRef startIndex, ByRef mainWidth, ByRef mainHeight) {
   Static prevRealThumbsIndex := -1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0) ; global vars:
   maxItemsW := mainWidth//thumbsW               ;    prevStartIndex
   If (maxItemsW<4 && thumbsListViewMode=1)
      maxItemsW := mainWidth//Round(thumbsW*0.95)

   maxItemsH := mainHeight//thumbsH              ;    startPageIndex
   If (maxItemsH<7 && thumbsListViewMode=1)
      maxItemsH := mainHeight//Round(thumbsH*0.95)

   If (maxItemsW<2)                                   ;    currentFileIndex ---
      maxItemsW := 1
   If (maxItemsH<2)
      maxItemsH := 1
 
   maxItemsPage := maxItemsW*maxItemsH
   maxPages := Ceil(maxFilesIndex/maxItemsPage)
   If (maxItemsH=1 && maxItemsW>1)
   {
      hasReversed := 1
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   maxItemsLine := maxItemsW ; *maxItemsH
   maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
   If (maxItemsW=1)
   {
      startIndex := Floor(currentFileIndex/maxItemsLine) * maxItemsLine
      If (startIndex<2)
         startIndex := 1

      ; ToolTip, % startIndex  " -- " prevRealThumbsIndex " || " maxItemsW " -- " maxItemsH , , , 2
      If isInRange(startIndex, prevRealThumbsIndex + maxItemsPage*2, prevRealThumbsIndex - maxItemsPage)
      {
         If isInRange(startIndex, prevRealThumbsIndex, prevRealThumbsIndex + maxItemsPage - maxItemsW)
            startIndex := prevRealThumbsIndex
         Else
            startIndex := (startIndex<prevRealThumbsIndex) ? startIndex : startIndex - maxItemsPage + maxItemsW
      } Else startIndex := Floor(currentFileIndex/maxItemsPage) * maxItemsPage

      maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := startIndex
   } Else
   {
      If (prevRealThumbsIndex=-1)
         prevRealThumbsIndex := currentFileIndex - maxItemsPage//2

      minIndex := prevRealThumbsIndex
      minIndex := ((minIndex//maxItemsLine) * maxItemsLine) + 1
      If (prevRealThumbsIndex != minIndex)
         prevRealThumbsIndex := minIndex
      
      maxIndex := prevRealThumbsIndex + maxItemsPage - 1
      ; DebugMsg("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; DebugMsg("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      ; fnOutputDebug("min/max Index: " minIndex " / " maxIndex)
      ; fnOutputDebug("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; fnOutputDebug("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      If (Abs(currentFileIndex-minIndex) <= maxItemsLine) || (Abs(currentFileIndex-maxIndex) <= maxItemsLine) || (currentFileIndex>=minIndex && currentFileIndex<=maxIndex)
      { ; just scrolling
          If (currentFileIndex< minIndex)     ; scrolling up
          {
             startIndex := prevRealThumbsIndex-maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("1: startIndex: " startIndex)
          } Else If (currentFileIndex>maxIndex) ; scrolling down
          {
             startIndex := prevRealThumbsIndex+maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("2: startIndex: " startIndex)
          } Else  ; when changing img index but not changing pages
          {
             startIndex := prevRealThumbsIndex
             ; fnOutputDebug("3: startIndex: " startIndex)
          }
      } Else ; this is for a jump
      {
         thisIndexu := currentFileIndex/maxFilesIndex
         startIndex := Floor(maxTotalLines*thisIndexu)*maxItemsW
         ; startIndex := ((currentFileIndex//maxItemsLine) * maxItemsLine) + 1
         prevRealThumbsIndex := startIndex
         ; fnOutputDebug("4: startIndex: " startIndex)
      }

      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      ; maxuStartIndex := (maxFilesIndex>maxItemsPage) ? maxFilesIndex - maxItemsPage + 1 : maxFilesIndex - 1
      ; fnOutputDebug(startIndex  "s -- " prevRealThumbsIndex "p -- " maxuStartIndex " || " maxItemsW "w -- h" maxItemsH)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := clampInRange(prevRealThumbsIndex, 1, maxuStartIndex)
   }
   If (hasReversed=1)
   {
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   ; DebugMsg("basics:`r`nmaxItemsPage: " maxItemsPage "`r`nmaxItemsLine: " maxItemsLine "`r`nmin: " minIndex "`r`nmax: " maxIndex "`r`ncurrentFileIndex : " currentFileIndex "`r`n")
   Return "a" startIndex maxItemsW maxItemsH maxItemsPage
}

DeepRefreshThumbsNow() {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   If (markedSelectFile>1)
      setForceRefreshThumbsFilesIndex(1)
   Else
      setForceRefreshThumbsFilesIndex(0)

   dummyTimerDelayiedImageDisplay(50)
}

RefreshThumbsList() {
   mustReloadThumbsList := 1
   dummyTimerDelayiedImageDisplay(50)
}

ForceRefreshNowThumbsList() {
   ; mustReloadThumbsList := 1
   prevStartIndex := -1
   ; dummyTimerDelayiedImageDisplay(50)
}

determineNavKeysDown() {
   If GetKeyState("Up", "p")
      Return 1
   Else If GetKeyState("Down", "p")
      Return 1
   Else If GetKeyState("PgUp", "p")
      Return 1
   Else If GetKeyState("PgDn", "p")
      Return 1
   Else Return 0
}

UpdateThumbsScreen(forceReload:=0) {
   Critical, on
   Static lastInvoked := 1, lastInvokeReload := 1
   interfaceThread.ahkassign("thumbsDisplaying", 1)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   If (thumbsDisplaying!=1)
      Return

   SetTimer, dummyTimerDelayiedImageDisplay, Off
   SetTimer, dummyTimerReloadThisPicture, Off
   Gdip_ResetClip(glPG)
   startPageIndex := thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   Gdip_ResetWorldTransform(glPG)
   IMGlargerViewPort := IMGentirelylargerThanVP := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   moda := modus := 0
   ;  ToolTip, % lastInvokeReload , , , 2
   If ((A_TickCount - prevTryThumbsUpdate<230)) && (mustReloadThumbsList!=1 && startPageIndex!=prevFullIndexThumbsUpdate)
   {
      ; lastInvokeReload++
      modus := (thumbsListViewMode>1) ? 2 : 1
      moda := (thumbsListViewMode>2) ? 1 : 0
      ; If (startPageIndex!=prevFullIndexThumbsUpdate)
      prevFullThumbsUpdate := A_TickCount
      If determineNavKeysDown()
      {
         prevTryThumbsUpdate := A_TickCount
         SetTimer, RefreshThumbsList, -650
      } Else
         SetTimer, RefreshThumbsList, -300
   }

   If (thumbsListViewMode>1 && modus>0)
      QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)

   mainGdipWinThumbsGrid(0, modus)
   If (modus=0 && (prevStartIndex!=startPageIndex || mustReloadThumbsList=1 || forceReload=1))
   {
      r := QPV_ShowThumbnails()
      If r
         prevFullIndexThumbsUpdate := startPageIndex
      
      mustReloadThumbsList := 0
   } ; Else r := 1

   prevStartIndex := startPageIndex
   ; prevRealThumbsIndex := startIndex
   lastInvoked := A_TickCount
}

GDIwindowsPosCorrections(whichHwnd:="") {
    Static lastInvoked := 1
    If (A_OSVersion="WIN_7" || isWinXP=1) && (A_TickCount - lastInvoked>150) || (isWinXP=1 && editingSelectionNow=1)
    {
       GetPhysicalCursorPos(mainX, mainY)
       JEE_ClientToScreen(hPicOnGui1, 1, 1, mainX, mainY)
       If whichHwnd
       {
          WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
       } Else
       {
          WinMove, ahk_id %hGDIwin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIthumbsWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIselectWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIinfosWin%,, %mainX%, %mainY%
       }
       lastInvoked := A_TickCount
    } Else If (A_OSVersion="WIN_7" || isWinXP=1)
       SetTimer, GDIwindowsPosCorrections, -50
}

panIMGonScrollBar() {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   GetMouseCoord2wind(PVhwnd, oX, oY)
   oDx := IMGdecalageX
   oDy := IMGdecalageY

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   vpImgPanningNow := 1
   thisIndex := 0
   prevState := "a"
   imgPath := getIDimage(currentFileIndex)
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (imageAligned=5)
      {
         prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
         prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      }

      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      If (scrollAxis=1)
      {
         newDecX := (FlipImgH=1) ? -decX : decX
         IMGdecalageX := (A_Index=1) ? (newDecX + oDx)//2 : newDecX
         diffIMGdecX := mX - oX + 2
      } Else
      {
         newDecY := (FlipImgV=1) ? -decY : decY
         IMGdecalageY := (A_Index=1) ? (newDecY + oDy)//2 : newDecY
         diffIMGdecY := mY - oY + 2
      }

      thisState := "a" IMGdecalageX IMGdecalageY diffIMGdecX diffIMGdecY imgPath
      If (prevState!=thisState)
      {
         thisIndex++
         prevState := thisState
         dummyResizeImageGDIwin()
      }
      If (A_Index<3)
        Sleep, 50
   }

   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
}

ThumbsScrollbar() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   prevFileIndex := currentFileIndex
   prevu := lastu := -2
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      newIndex := ((mY-15)/mainHeight)*100
      newIndex := Ceil((maxFilesIndex/100)*newIndex)
      If (newIndex<1)
         newIndex := 1
      Else If (newIndex>maxFilesIndex)
         newIndex := maxFilesIndex-1

      If (lastu!=newIndex)
      {
         lastu := newIndex
         currentFileIndex := newIndex
         thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
         modus := (thumbsListViewMode>1) ? 2 : 1
         moda := (thumbsListViewMode>2) ? 1 : 0
         If (startIndex!=prevu)
         {
            prevu := startIndex
            If (thumbsListViewMode>1)
               QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)
            Else
               filterDelayiedImageDisplay()
         }
         mainGdipWinThumbsGrid(0, modus)
      }
   }

   If (GetKeyState("Shift", "P"))
   {
      keyu := (currentFileIndex>prevFileIndex) ? "Down" : "Home"
      thumbsSelector(keyu, "+Shift", prevFileIndex)
   }
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(250)
}

simplePanIMGonClick(dummy:=0) {
   GetPhysicalCursorPos(oX, oY)
   oDx := IMGdecalageX, oDy := IMGdecalageY
   lastInvoked := A_TickCount
   thisZeit := vpImgPanningNow := 1
   prevMX := oX, prevMY := oY
   thisIndex := 0
   thisZL := (zoomLevel>8) ? 8 : 0.8 + zoomLevel
   ; ToolTip, % "l=" thisZL , , , 2
   While, (determineLClickstate()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffIMGdecX := Dx := Ceil((mX - oX)*thisZL)
      diffIMGdecY := Dy := Ceil((mY - oY)*thisZL)
      If (dummy="navBox")
      {
         Dx := -3*Dx * (zoomLevel//2 + 1)
         Dy := -3*Dy * (zoomLevel//2 + 1)
      }

      IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      limitPanningDist(oDx, oDy)
      If (!isDotInRect(mX, mY, prevMX - 5, prevMX + 5, prevMY - 5, prevMY + 5) && (A_TickCount - thisZeit>15))
      {
         thisIndex++
         zeitSillyPrevent := A_TickCount
         dummyResizeImageGDIwin()
         prevMX := mX
         prevMY := mY
         thisZeit := A_TickCount
      }

      ; ToolTip, % diffIMGdecX " == " diffIMGdecY , , , 2
      MouseGetPos,,, OutputVarWin
      If (OutputVarWin!=PVhwnd)
      {
         If (A_TickCount - lastInvoked>1550)
            Break
      } Else lastInvoked := A_TickCount
   }

   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

limitPanningDist(ByRef oDx, ByRef oDy) {
   If (imageAligned=5)
   {
      If (oDx>0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := -imgDecLX//2
      Else If (oDx<0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := imgDecLX//2

      If (oDy>0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := -imgDecLY//2
      Else If (oDy<0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := imgDecLY//2
   } Else
   {
      If (oDx>=0)
         oDx := 0
      Else If (oDx<imgDecLX)
         oDx := imgDecLX

      If (oDy>=0)
         oDy := 0
      Else If (oDy<imgDecLY)
         oDy := imgDecLY
   }
}

panIMGonClickNavBox() {
   panIMGonClick("navBox")
}

panIMGonClick(dummy:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If isWinXP
   {
      simplePanIMGonClick(dummy)
      Return
   }

   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := IMGdecalageX, oDy := IMGdecalageY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   vpImgPanningNow := 1
   imgPath := getIDimage(currentFileIndex)
   thisIndex := 0
   While, (determineLClickstate()=1)
   {
      Sleep, 1
      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 5, zX + 5) && isInRange(mY, zY - 5, zY + 5)) ? 1 : 0
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
      If (dummy="navBox")
      {
         Dx := -3*Dx * (zoomLevel//2 + 1)
         Dy := -3*Dy * (zoomLevel//2 + 1)
      }

      gIMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      gIMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>950) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      ; If (dummy!="navBox")
      ;    MouseMove, % oX, % oY, 0

      oDx := gIMGdecalageX, oDy := gIMGdecalageY
      limitPanningDist(oDx, oDy)
      If (A_TickCount - thisZeit>15) ; || (drawModeAzeit<100) || (drawModeBzeit<100)
      {
         thisIndex++
         zeitSillyPrevent := A_TickCount
         IMGdecalageX := gIMGdecalageX
         IMGdecalageY := gIMGdecalageY
         dummyResizeImageGDIwin()
         thisZeit := A_TickCount
      }
   }

   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

winSwipeAction(thisCtrlClicked, mainParam) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   didSomething := 1
   infoImgEditingMode := (editingSelectionNow=1 || imgEditPanelOpened=1) ? 1 : 0
   GetPhysicalCursorPos(oX, oY)
   If (IMGlargerViewPort=1 && thumbsDisplaying!=1 && thisCtrlClicked="PicOnGUI2b")
   || (IMGlargerViewPort=1 && thumbsDisplaying!=1 && (thisCtrlClicked="PicOnGUI3" || thisCtrlClicked="PicOnGUI1") && infoImgEditingMode=1)
   {
      SetTimer, simplePanIMGonClick, -5
      Return 0
   }


   startZeit := A_TickCount
   SelDotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
   dotSize := Round(SelDotsSize*2.5)
   lowerLimitRatio := (IMGresizingMode=4) ? 0.4 : 0.4
   GetPhysicalCursorPos(mX, mY)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   While, (determineLClickstate()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffx := snapToValues(Abs(mX - oX), 1, mainWidth, 10, 0)
      diffy := snapToValues(Abs(mY - oY), 1, mainHeight, 10, 0)
      dirX := (mX - oX) < 0 ? -1 : 1
      dirY := (mY - oY) < 0 ? -1 : 1
      ratioDiffs := diffx/diffy
      If (diffx>45 || diffy>45) && (ratioDiffs<lowerLimitRatio || ratioDiffs>3)
      {
         Sleep, 1
         zeitSillyPrevent := A_TickCount
         swipeAct := (ratioDiffs<lowerLimitRatio) ? 1 : 2
         If (ratioDiffs="")
            swipeAct := 0
      } Else swipeAct := 0 ;  Tooltip
      ; Sleep, 5
      ; ToolTip, % swipeAct " - " thisCtrlClicked " - " ratioDiffs "`n" diffx "==" diffy "`n" dirX "==" dirY

      stepFactor := 1
      doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0
      If (!swipeAct && isDotInRect(mX, mY, oX - dotSize, oX + dotSize, oY - dotSize, oY + dotSize))
      {
         zeitSillyPrevent := 1
         If (thisCtrlClicked="PicOnGUI3")
         {
            If (infoImgEditingMode!=1)
               doNextSlide := 1
         } Else If (thisCtrlClicked="PicOnGUI1" )
         {
            If (infoImgEditingMode!=1)
               doPrevSlide := 1
         } Else If (thisCtrlClicked="PicOnGUI2a")
         {
            doZoomChange := 1
         } Else If (thisCtrlClicked="PicOnGUI2c")
         {
            doZoomChange := -1
         }
      } Else If (swipeAct=1)
      {
         stepFactor := (diffy/mainHeight)*2.95 + 1.25
         ; ToolTip, % stepFactor " = " dirY , , , 2
         doZoomChange := dirY
         ;  ChangeZoom(dirY, 0, stepFactor)
      } Else If (swipeAct=2 && infoImgEditingMode!=1)
      {
         If (dirX=1)
            doNextSlide := 1
         Else If (dirX=-1)
            doPrevSlide := 1
      }

      If ((doNextSlide || doPrevSlide) && totalFramesIndex>1)
      {
         If (mY>mainHeight*0.75)
         {
            doFrameChange := (doNextSlide=1) ? 1 : -1
            doNextSlide := doPrevSlide := 0
         }
      }

      If (A_TickCount - startZeit>350 && InStr(mainParam, "pen-") && !swipeAct)
         doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0

      If doFrameChange
      {
         friendly := (doFrameChange=1) ? "Next" : "Previous"
         showTOOLtip(friendly " frame")
      } Else If (doNextSlide || doPrevSlide)
      {
         friendly := (doNextSlide=1) ? "Next" : "Previous"
         showTOOLtip(friendly " slide")
      } Else If doZoomChange
      {
         friendly := (doZoomChange=1) ? "in" : "out"
         showTOOLtip("Zoom " friendly ": " Round(stepFactor, 2))
      } Else 
      {
         toolTipGuiCreated := 0
         interfaceThread.ahkassign("toolTipGuiCreated", 0)
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      }
   }

   didSomething := 1
   If doFrameChange
      changeDesiredFrame(doFrameChange)
   Else If doNextSlide
      GoNextSlide()
   Else If doPrevSlide
      GoPrevSlide()
   Else If doZoomChange
      changeZoom(doZoomChange, 0, stepFactor)
   Else 
      didSomething := 0

   If !didSomething
      zeitSillyPrevent := 1

   Return didSomething
}

GetMouseCoord2wind(hwnd, ByRef nx, ByRef ny) {
    ; CoordMode, Mouse, Screen
    MouseGetPos, ox, oy
    JEE_ScreenToClient(hwnd, ox, oy, nx, ny)
}

dummyAutoClearSelectionHighlight() {
    GetMouseCoord2wind(hGDIwin, mX, mY)
    Gdip_SetPenWidth(pPen1d, SelDotsSize)
    hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
    If !hitB
    {
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
       pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
       Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
       Gdip_SetPenWidth(pPen1d, SelDotsSize//3)
       Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   }
}

doLayeredWinUpdate(funcu, hwnd, HDCu, opacity:=255) {
  Static xPox := 0, yPos := 0
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  If (A_OSVersion="WIN_7" || isWinXP=1)
  {
     ; GetPhysicalCursorPos(mainX, mainY)
     JEE_ClientToScreen(hPicOnGui1, 1, 1, xPos, yPos)
     ; WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
  }

  If (debugModa=1)
  {
     ; If (hwnd=hGDIselectWin)
     ;    opacity := 120

     If (hwnd=hGDIwin)
        nameHwnd := "hGDIwin"
     Else If (hwnd=hGDIthumbsWin)
        nameHwnd := "hGDIthumbsWin"
     Else If (hwnd=hGDIselectwin)
        nameHwnd := "hGDIselectwin"
     Else If (hwnd=hGDIinfosWin)
        nameHwnd := "hGDIinfosWin"
     Else
        nameHwnd := "unknownWin"

     If (HDCu=2NDglHDC)
        nameDCu := "2NDglHDC"
     Else If (HDCu=glHDC)
        nameDCu := "glHDC"
     Else
        nameDCu := "unknownHDC"

     fnOutputDebug(A_ThisFunc "(): " funcu " = " nameHwnd " = " nameDCu)
  }
  If !globalWinStates["a" hwnd]
     ToggleVisibilityWindow("show", hwnd)

  Return UpdateLayeredWindow(hwnd, HDCu, xPos, yPos, mainWidth, mainHeight, opacity)
}

MouseDelta(X1,Y1,X2,Y2) {
   ; from Bugz000
   return round((dllcall("msvcrt\atan2", "Double", (y2 - y1), "Double", (x2-x1), "CDECL Double") * (180/3.14159265358979323846264338327950288419716939937)),3)
}

MouseMoveResponder() {
  Static prevState := "C", prevMouseCoords := [], lastInvoked := 1
  If (A_TickCount - lastOSDtooltipInvoked<625)
  {
     SetTimer, MouseMoveResponder, -350
     Return
  }

  If (drawingShapeNow=1)
  {
     dummyRefreshImgSelectionWindow()
     SetTimer, dummyRefreshImgSelectionWindow, -150
  } Else If (liveDrawingBrushTool=1)
  {
     brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
     thisSize := (AnyWindowOpen=64) ? brushSize * zoomLevel : brushSize * viewportDynamicOBJcoords.zl
     Gdip_ResetClip(2NDglPG)
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
     If (GetKeyState("CapsLock", "T") || mustCaptureCloneBrush=1)
     {
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        Return
     }

     setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
     If (thisSize>10)
     {
        Gdip_SetClipRect(2NDglPG, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgh, 0)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight, 1)
        If (BrushToolOutsideSelection>1 && AnyWindowOpen=64 && editingSelectionNow=1)
        {
           ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
           ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, vPselRotation, rotateSelBoundsKeepRatio)
           modus := (BrushToolOutsideSelection=3) ? 4 : 1
           Gdip_SetClipPath(2NDglPG, ImgSelPath, modus)
        }

        GetMouseCoord2wind(hGDIwin, mX, mY)
        If (A_TickCount - lastInvoked > 90) && (AnyWindowOpen=64 && BrushToolAutoAngle=1)
        {
           If (prevMouseCoords[1] && prevMouseCoords[2]
           && !isDotInRect(mX, mY, prevMouseCoords[1] - 10, prevMouseCoords[1] + 10, prevMouseCoords[2] - 10, prevMouseCoords[2] + 10))
           {
              newAngle := onewAngle := MouseDelta(prevMouseCoords[1], prevMouseCoords[2], mX, mY)
              If (newAngle<0)
                 newAngle := 360 - Abs(newAngle)
              If (prevMouseCoords[3]<90 && newAngle>270)
                 prevMouseCoords[3] := 360 + prevMouseCoords[3]
              If (prevMouseCoords[3]!="")
                 newAngle := (newAngle + prevMouseCoords[3] + prevMouseCoords[3])/3
              If (newAngle>360)
                 newAngle -= 360

              prevMouseCoords[3] := newAngle
           }

           prevMouseCoords[1] := mX, prevMouseCoords[2] := mY
           lastInvoked := A_TickCount
           If (newAngle && !determineLClickstate())
              BrushToolAngle := Round(newAngle)
        }
        mX := (FlipImgH=1) ? mainWidth - mX : mX
        mY := (FlipImgV=1) ? mainHeight - mY : mY
        tmpPath := createBrushShapePath(thisSize, mX, mY, BrushToolAspectRatio, BrushToolAngle)
        Gdip_SetPenWidth(pPen1d, SelDotsSize/3 + 1)
        Gdip_SetPenWidth(pPen2, SelDotsSize/5 + 1)
        Gdip_DrawPath(2NDglPG, pPen2, tmpPath)
        Gdip_DrawPath(2NDglPG, pPen1d, tmpPath)
        Gdip_DeletePath(tmpPath)
        ; ToolTip, % BrushToolAngle " == " newAngle " == " onewAngle , , , 2

        brushSofty := (100 - BrushToolSoftness)/100
        brushSize := (brushSize*brushSofty)*zoomLevel
        If (BrushToolType!=1 && isInRange(BrushToolSoftness, 2, 98) && brushSize>9)
        {
           tmpPath2 := createBrushShapePath(brushSize, mX, mY, BrushToolAspectRatio, BrushToolAngle)
           ; Gdip_DrawPath(2NDglPG, pPen2, tmpPath2)
           Gdip_DrawPath(2NDglPG, pPen1d, tmpPath2)
           Gdip_DeletePath(tmpPath2)
        }

        Gdip_ResetClip(2NDglPG)
        If ImgSelPath
           Gdip_DeletePath(ImgSelPath)
     }
     Gdip_ResetWorldTransform(2NDglPG)
     r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
  } Else If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1 && drawingShapeNow!=1)
  {
     ; ToolTip, % SelDotsSize , , , 2
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     GetMouseCoord2wind(hGDIwin, mX, mY)
     Gdip_SetPenWidth(pPen7, SelDotsSize)
     hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
     hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen7, mX, mY)
     If (hitB=1)
        thisState := "B"
     Else If (hitA=1)
        thisState := "A"
     Else
        thisState := "C"

     If (thisState="B") ; && prevState!=thisState)
     {
        ; changeMcursor("finger")
        prevState := "B"
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
        dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight)
        Gdip_SetPenWidth(pPen1d, SelDotsSize//2)
        If (dotActiveObj.n=9)
        {
           Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
        } Else
        {
           If InStr(dotActiveObj.cx1, "|")
           {
              Gdip_DrawLines(2NDglPG, pPen1d, dotActiveObj.cx1)
              Gdip_FillEllipse(2NDglPG, pBrushC, dotActiveObj.cx2 - SelDotsSize//2, dotActiveObj.cy2 - SelDotsSize//2, SelDotsSize*2, SelDotsSize*2)
           } Else
              Gdip_DrawLine(2NDglPG, pPen1d, dotActiveObj.cx1, dotActiveObj.cy1, dotActiveObj.cx2, dotActiveObj.cy2)
        }
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
     } Else If (thisState="A" && prevState!=thisState)
     {
        ; changeMcursor("move")
        prevState := "A"
        Gdip_SetPenWidth(pPen1d, SelDotsSize//2)
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
        pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
        Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
        Gdip_FillPath(2NDglPG, pBrushF, hitTestSelectionPath)
        Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        SetTimer, dummyAutoClearSelectionHighlight, -150
     } Else If (thisState="C" && prevState!=thisState)
     {
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevState := "C"
     }
  } Else
  {
     If (prevState!="C")
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     prevState := "C"
  }
}

applyIMGeditKeepWin() {
   o := closeEditPanelOnApply
   closeEditPanelOnApply := 0
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, 0
   applyIMGeditFunction()
   Sleep, 2
   CreateGuiButton("Undo action,,ImgUndoAction||Reopen panel,,openPreviousPanel", 0, msgDisplayTime//1.5 + 500)
   closeEditPanelOnApply := o
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, % o
}

applyIMGeditFunction() {
    ; recordSelUndoLevelNow()
    If (AnyWindowOpen=24 || AnyWindowOpen=31)
       BtnPasteInSelectedArea()
    Else If (AnyWindowOpen=30)
       BtnDrawLinesSelectedArea()
    Else If (AnyWindowOpen=32)
       BtnInsertTextSelectedArea()
    Else If (AnyWindowOpen=23)
       BtnFillSelectedArea()
    Else If (AnyWindowOpen=25)
       BtnEraseSelectedArea()
    Else If (AnyWindowOpen=55)
       BtnGraySelectedArea()
    Else If (AnyWindowOpen=65)
       BtnDrawShapeSelectedArea()
    Else If (AnyWindowOpen=10 || AnyWindowOpen=64) ; colors adjustments / brush tool
       BtnCloseWindow()
    SetTimer, RemoveTooltip, -300
}

updateVPalphaMaskPaintMode() {
    Critical, on
    G2 := 2NDglPG, thisImgQuality := 5
    Gdip_ResetClip(G2)

    obju := corePasteInPlaceActNow(0, 0, 1)
    hasRotated := obju[1]
    whichBitmap := obju[2]
    zBitmap := obju[3]

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    Gdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
    PasteInPlaceCalcObjSize(1, hasRotated, oImgW, oImgH, imgSelW, imgSelH, vPselRotation, ResizedW, ResizedH)
    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    imgSelW := ResizedW, imgSelH := ResizedH
    viewportDynamicOBJcoords.x := imgSelPx, viewportDynamicOBJcoords.y := imgSelPy
    viewportDynamicOBJcoords.w := imgSelW,  viewportDynamicOBJcoords.h := imgSelH
    viewportDynamicOBJcoords.zl := (imgSelW/zImgW + imgSelH/zImgH)/2 + 0.0001

    thisOpacity := (PasteInPlaceOpacity>128) ? (PasteInPlaceOpacity - 128) : PasteInPlaceOpacity
    thisOpacity := (PasteInPlaceOpacity>128) ? thisOpacity/128 * 25 + 1 : thisOpacity/128
    alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, oimgW, oimgH, 0, thisImgQuality)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode)

    vPobju := testSelectionLargerThanViewport()
    Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)
    If (PasteInPlaceCropSel>1)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel - 1)
       If (PasteInPlaceCropSel=4 || PasteInPlaceCropSel=5)
          PersonalizedRotatePath(pPath, vPselRotation + PasteInPlaceCropAngular, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation + PasteInPlaceCropAngular, 1, 1, rotateSelBoundsKeepRatio)

       Gdip_SetClipPath(G2, pPath, 1)
    }

    ; ToolTip, % imgSelPx "," imgSelPy "," imgSelW "," imgSelH , , , 2
    r1 := trGdip_DrawImage(A_ThisFunc, G2, clipBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, oimgW, oimgH, thisOpacity)

    trGdip_DisposeImage(clipBMP, 1)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(alphaMaskGray, 1)
    Gdip_DeletePath(pPath)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
}

livePreviewsImageEditing(modus:=0, hideHUD:=0) {
   Critical, on
   If (imgEditPanelOpened!=1)
      Return

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   createGDIPcanvas(mainWidth, mainHeight)
   If (modus!="live-selection")
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

   If (modus="coords")
   {
      createDefaultSizedSelectionArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight)
      ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   }
   If (dynamicLiveObjVisible=0)
      toggleLiveEditObject()

   okayu := (A_TickCount - prevImgEditZeit>350) ? 1 : 0
   If (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1)
      updateVPalphaMaskPaintMode()
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      corePasteInPlaceActNow(0, 0)
   Else If (AnyWindowOpen=30 && okayu=1)
      coreDrawLinesSelectionArea()
   Else If (AnyWindowOpen=23 && okayu=1)
      coreFillSelectedArea()
   Else If (AnyWindowOpen=32 && okayu=1)
      livePreviewInsertTextinArea()
   Else If (AnyWindowOpen=25 && okayu=1)
      livePreviewEraseArea()
   Else If (AnyWindowOpen=55 && okayu=1)
      livePreviewDesaturateArea()
   Else If (AnyWindowOpen=65 && okayu=1)
      coreDrawShapesSelectionArea()

   If (showViewPortGrid=1 && imgEditPanelOpened=1)
      drawVPgridsNow(mainWidth, mainHeight, prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY, 2NDglPG)

   If (modus!="live-selection")
      Gdip_ResetWorldTransform(2NDglPG)

   If (scrollBarHy>0)
   {
      Gdip_SetClipRect(2NDglPG, 0, scrollBarHy, mainWidth, mainHeight - scrollBarHy)
      Gdip_GraphicsClear(2NDglPG)
   }

   If (scrollBarVx>0)
   {
      Gdip_SetClipRect(2NDglPG, scrollBarVx, 0, mainWidth - scrollBarVx, mainHeight)
      Gdip_GraphicsClear(2NDglPG)
   }

   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
   If (scrollBarHy>0 || scrollBarVx>0)
      Gdip_ResetClip(2NDglPG)
}

livePreviewsImageEditingDrawSelectionBox() {
   ; no longer used

   dotsSize := SelDotsSize
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2
 
   whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
   If (imgSelLargerViewPort!=1)
   {
      Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
      Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
      Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
      Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
   }

   If (vPselRotation!=0)
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)

   If (imgEditPanelOpened=1)
   {
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
      Gdip_FillEllipse(2NDglPG, pBrushA, SelDotDx + 5, SelDotDy + 5, dotsSize, dotsSize)
   }

   thisThick := dotsSize//5 + 1
   Gdip_SetPenWidth(pPen4, thisThick)
   Gdip_SetPenWidth(pPen1d, thisThick)
   decideLiveSelectionBasedOnWindow(angleu, isAngleu)
   ImgSelPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
   If isAngleu
      Gdip_DrawPath(2NDglPG, pPen4, ImgSelPath)

   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//3, vPimgSelY + thisThick//3, vPimgSelW, vPimgSelH)
   If (AnyWindowOpen!=23 && AnyWindowOpen!=65)
      Gdip_DrawPath(2NDglPG, pPen1d, ImgSelPath)
   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//2, vPimgSelY + thisThick//2, vPimgSelW, vPimgSelH)
   Gdip_DeletePath(ImgSelPath)
}

selectFileLongTap() {
   If (thumbsDisplaying=1 && determineLClickstate()=1 && (A_TickCount - lastOtherWinClose>350) && (A_TickCount - lastTimeToggleThumbs>350))
      markThisFileNow(currentFileIndex)
}

isDotInRect(mX, mY, x1, x2, y1, y2, modus:=0) {
   If (modus=1)
      r := (isInRange(mX, y1 - x1, y1 + x2) && isInRange(mY, y2 - x1, y2 + x2)) ? 1 : 0
   Else
      r := (isInRange(mX, x1, x2) && isInRange(mY, y1, y2)) ? 1 : 0
   Return r
}

determineSelAreaClickRect(mXoT, mYoT, dotsSize, mainWidth, mainHeight) {
   nSelDotX  := selDotX,  nSelDotAx := selDotAx
   nSelDotY  := selDotY,  nSelDotAy := selDotAy
   nSelDotBx := selDotBx, nSelDotCx := selDotCx
   nSelDotBy := selDotBy, nSelDotCy := selDotCy
   nSelDotDx := selDotDx, nSelDotDy := selDotDy

   If (FlipImgH=1)
   {
      nSelDotX := mainWidth - selDotX - dotsSize
      nSelDotAx := mainWidth - selDotAx - dotsSize
      nSelDotBx := mainWidth - selDotBx - dotsSize
      nSelDotCx := mainWidth - selDotCx - dotsSize
      nSelDotDx := mainWidth - selDotDx - dotsSize
   }

   If (FlipImgV=1)
   {
      nSelDotY := mainHeight - selDotY - dotsSize
      nSelDotAy := mainHeight - selDotAy - dotsSize
      nSelDotBy := mainHeight - selDotBy - dotsSize
      nSelDotCy := mainHeight - selDotCy - dotsSize
      nSelDotDy := mainHeight - selDotDy - dotsSize
   }

   d := dotsSize//2
   If isDotInRect(mXoT, mYoT, nselDotX, nselDotX + dotsSize, nselDotY, nselDotY + dotsSize)
   {
      ; top-left corner
      cX1 := nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d
      cX2 := nselDotX
      cY2 := nselDotY
      dotActive := 1
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotAx, nselDotAx + dotsSize, nselDotAy, nselDotAy + dotsSize)
   {
      ; bottom-right corner
      cX1 := nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d
      cX2 := nselDotAx
      cY2 := nselDotAy
      dotActive := 2
      DotPosX := imgSelX2
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotBx, nselDotBx + dotsSize, nselDotAy, nselDotBy + dotsSize)
   {
      cX1 := nselDotBx + dotsSize//2
      cX2 := nselDotBx + dotsSize//2
      cY1 := nselDotAy
      cY2 := nselDotBy
      dotActive := 8
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotCx, nselDotCx + dotsSize, nselDotCy, nselDotCy + dotsSize)
   {
      cX1 := nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d
      cX2 := nselDotCx
      cY2 := nselDotCy
      dotActive := 4
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotBx, nselDotY, nselDotY + dotsSize)
   {
      cX1 := nselDotX
      cX2 := nselDotBx
      cY1 := nselDotY + dotsSize//2
      cY2 := nselDotY + dotsSize//2
      dotActive := 5
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotCx, nselDotBx, nselDotCy, nselDotCy + dotsSize)
   {
      cX1 := nselDotCx
      cX2 := nselDotBx
      cY1 := nselDotCy + dotsSize//2
      cY2 := nselDotCy + dotsSize//2
      dotActive := 6
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotX + dotsSize, nselDotY, nselDotCy)
   {
      cX1 := nselDotX + dotsSize//2
      cX2 := nselDotX + dotsSize//2
      cY1 := nselDotY
      cY2 := nselDotCy
      dotActive := 7
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotBx, nselDotBx + dotsSize, nselDotBy, nselDotAy)
   {
      cX1 := nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d 
      cX2 := nselDotBx
      cY2 := nselDotBy
      dotActive := 3
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotDx, nselDotDx + dotsSize, nselDotDy, nselDotDy + dotsSize)
   {
      ; click the center dot of the selection area
      cX1 := nselDotDx
      cX2 := nselDotDx + dotsSize
      cY1 := nselDotDy
      cY2 := nselDotDy + dotsSize
      dotActive := 10
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotBx, nselDotBy, nselDotAy)
   {
      ; click anywhere within the selection
      cX1 := nselDotX
      cX2 := nselDotBx
      cY1 := nselDotBy
      cY2 := nselDotAy
      dotActive := 9
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   }
   ; ToolTip, % "l=" dotActive , , , 2
   obju := []
   obju.x := DotPosX
   obju.y := DotPosY
   obju.n := dotActive
   obju.cX1 := cX1
   obju.cX2 := cX2
   obju.cY1 := cY1
   obju.cY2 := cY2
   Return obju
}

addNewCustomShapePoints(mX, mY, mainWidth, mainHeight, mainParam, ctrlState) {
   Static lastInvoked := A_TickCount
   ; If (A_tickcount - lastInvoked<50)
   ;    Return

   ogmX := (FlipImgH=1) ? mainWidth - mX : mX
   ogmY := (FlipImgV=1) ? mainHeight - mY : mY
   gmX := ogmX ; + (initialDrawingStartCoords[1] - prevDestPosX)
   gmY := ogmY ; + (initialDrawingStartCoords[2] - prevDestPosY)
   dontAddPoint := dotRemoved := 0
   Loop, % customShapePoints.Count()
   {
       thisIndex := A_Index
       c := customShapePoints[A_Index]
       xu := c[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
       yu := c[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
       If isDotInRect(ogmX, ogmY, xu - SelDotsSize//2, xu + SelDotsSize, yu - SelDotsSize//2, yu + SelDotsSize)
       {
          dontAddPoint := 1
          If (mainParam="DoubleClick")
          {
             customShapePoints[thisIndex] := [gmX + SelDotsSize, gmY + SelDotsSize]
             initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
             insertThis := [gmX - SelDotsSize, gmY - SelDotsSize]
             customShapePoints.InsertAt(thisIndex, insertThis)
             insertThis := [prevDestPosX, prevDestPosY]
             initialDrawingStartCoords.InsertAt(thisIndex, insertThis) 
          } Else If (ctrlState=1 || mainParam="rClick")
          {
             dotRemoved := 1
             customShapePoints.RemoveAt(thisIndex)
             initialDrawingStartCoords.RemoveAt(thisIndex)
          } Else
          {
             initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
             While, (determineLClickstate()=1)
             {
                  GetMouseCoord2wind(PVhwnd, mX, mY)
                  gmX := (FlipImgH=1) ? mainWidth - mX : mX
                  gmY := (FlipImgV=1) ? mainHeight - mY : mY
                  If GetKeyState("Shift", "P")
                  {
                     gmX := snapToValues(gmX, c[1], c[1], SelDotsSize*2, 0)
                     gmY := snapToValues(gmY, c[2], c[2], SelDotsSize*2, 0)
                  }
                  customShapePoints[thisIndex] := [gmX, gmY]
                  dummyRefreshImgSelectionWindow()
             }
          }
          Break
       }
   }

   If (mainParam="rClick" && dotRemoved!=1)
   {
      stopDrawingShape()
      Return
   }

   ; If (FlipImgH=1 || FlipImgV=1)
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (dotRemoved!=1 && dontAddPoint!=1 && mainParam!="DoubleClick" && !InStr(mainParam, "pen-"))
   {
      If (mustSnapLiveDrawPoints=1 && thisIndex)
      {
         gmX := VPstampBMPx
         gmY := VPstampBMPy
      }

      mustSnapLiveDrawPoints := 0
      customShapePoints.Push([gmX, gmY])
      thisIndex := customShapePoints.MaxIndex()
      initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
      SetTimer, addFluidPointsCustomShape, -200
   }

   lastInvoked := A_TickCount
   SetTimer, dummyRefreshImgSelectionWindow, -5
}

thumbsListClickResponder(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<50)
      Return

   scrollXpos := mainWidth - imgHUDbaseUnit//2
   statusBarYpos := Round(mainHeight - ThumbsStatusBarH)
   If (mX>scrollXpos)
   {
      If (mainParam!="rclick")
         SetTimer, ThumbsScrollbar, -25
      Return "scrollbar"
   } Else If (mY>statusBarYpos)
   {
      If (mainParam="rclick")
         Return "statusBar"
      Else If !InStr(mainParam, "pen-")
         ToggleMultiLineStatus()
      Return
   }

   If InStr(mainParam, "pen-")
      Return

   thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   rowIndex := 0, columnIndex := -1
   Loop, % maxItemsPage*2
   {
      columnIndex++
      If (columnIndex>=maxItemsW)
      {
         rowIndex++
         columnIndex := 0
      }
      DestPosX := thumbsW*columnIndex + thumbsW
      DestPosY := thumbsH*rowIndex + thumbsH
      If (DestPosX>mX && DestPosY>mY)
      {
         newIndex := startIndex + A_Index - 1
         Break
      }
   }

   maxWidu := maxItemsW*thumbsW - 1
   maxHeitu := maxItemsH*thumbsH  - 1
   If newIndex
   {
      startClick := A_TickCount
      longTapDelay := markedSelectFile ? 350 : 750
      newIndex := clampInRange(newIndex, 1, maxFilesIndex)
      If (mainParam="rClick")
      {
         currentFileIndex := newIndex
         mainGdipWinThumbsGrid()
         Return
      }

      If (ctrlState)
         markThisFileNow(newIndex)
      Else If (altState=1)
         moveMarkedEntryNow(newIndex)
      Else If (shiftState=1)
         clickAct := "S"
      Else
      {
         While, (determineLClickstate()=1 && (A_TickCount - startClick<longTapDelay+150))
         {
            Sleep, 1
         }

         If (A_TickCount - startClick<longTapDelay) && (newIndex=currentFileIndex)
         {
            ToggleThumbsMode()
            Return
         } Else If (A_TickCount - startClick>longTapDelay)
            markThisFileNow(newIndex)
      }

      If (clickAct="S")
      {
         keyu := (newIndex>currentFileIndex) ? "Down" : "Upu"
         prevFileIndex := currentFileIndex
         currentFileIndex := newIndex
         thumbsSelector(keyu, "+Shift", prevFileIndex)
      } Else currentFileIndex := newIndex

      dummyTimerDelayiedImageDisplay(25)
   }

   lastInvoked := A_TickCount
}

WinClickAction(mainParam:=0, thisCtrlClicked:=0, OutputVarWin:=0, mX:=0, mY:=0, mXo:=0, mYo:=0) {
   Critical, on
   Static thisZeit := 1, prevTippu := 1, anotherZeit := 1, ignoreRclick := 0, ignoreNclick := 0
        , lastInvoked := 1, lastInvoked2 := 1, lastInvokedSwipe := 1

   If VisibleQuickMenuSearchWin
   {
      GoSub, QuickMenuSearchGUIAGuiClose
      Return
   }

   If (IsFunc(hudBTNfuncu) && hudBTNfuncu && hudBTNheightFuncu && mY<hudBTNheightFuncu)
   {
      If (mX<hudBTNwidthFuncu && hudBTNtypeFuncu=1)
      {
         hudBTNtypeFuncu := 0
         %hudBTNfuncu%()
         Return
      } Else If (hudBTNtypeFuncu=2)
      {
         hudBTNtypeFuncu := 0
         GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
         If (mX<mainWidth//2)
            %hudBTNfuncu%(-1)
         Else
            %hudBTNfuncu%(1)
         Return
      }
   } Else If (AnyWindowOpen=1 || AnyWindowOpen=33 || AnyWindowOpen=39 || AnyWindowOpen=59 || AnyWindowOpen=48 || AnyWindowOpen=61)
   {
      BtnCloseWindow()
      Return
   } Else If (AnyWindowOpen=64 && liveDrawingBrushTool=1`&& mustCaptureCloneBrush=1)
   {
      tinyPrevAreaCoordX := tinyPrevAreaCoordY := "C"
      createClonedBrushBitmap(mX, mY, 0, 0, 0)
      Return
   } Else If (AnyWindowOpen=23 && FillAreaColorMode=6`&& mustCaptureCloneBrush=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      While, (determineLClickstate()=1)
      {
         GetMouseCoord2wind(PVhwnd, mX, mY)
         mX := (FlipImgH=1) ? mainWidth - mX : mX
         mY := (FlipImgV=1) ? mainHeight - mY : mY
         MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
         tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
         showTOOLtip("Texture source set to`n" kX " / " kY)
         If (A_TickCount - thisZeit>90)
         {
            dummyRefreshImgSelectionWindow()
            thisZeit := A_TickCount
         }
      }

      mustCaptureCloneBrush := 0
      If (panelWinCollapsed=1)
         toggleImgEditPanelWindow()
      SoundBeep , 900, 100
      dummyRefreshImgSelectionWindow()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      ; SetTimer, updateUIfillPanel, -350
      Return
   } Else If (AnyWindowOpen=43 || AnyWindowOpen=44 || AnyWindowOpen=26)
   {
      ; respond to clicks in viewport for panels with region based previews
      While, (determineLClickstate()=1)
      {
         updateTinyPreviewArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, 1)
         dummyRefreshImgSelectionWindow()
      }
      Return
   }

   ; ToolTip, % mainParam " -- " thisCtrlClicked,,,2
   If (A_TickCount - lastLongOperationAbort < 550) || (A_TickCount - lastTimeToggleThumbs < 450) || (A_TickCount - executingCanceableOperation < 550)
      Return

   If AnyWindowOpen
   {
      ; handle clicks in the viewport when another panel is open
      If (imgEditPanelOpened!=1)
      {
         SoundPlay, *-1
         WinActivate, ahk_id %hSetWinGui%
         Return
      }
   }

   If (imageLoading=1 && thumbsDisplaying=1)
      Return

   If (toolTipGuiCreated=1)
      RemoveTooltip()

   ;  ToolTip, % HUDobjHistoBoxu[3] "==" HUDobjHistoBoxu[1] "==" mX "`n" HUDobjHistoBoxu[4] "==" HUDobjHistoBoxu[2] "==" mY , , , 2
   If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && thumbsDisplaying!=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[3], HUDobjNavBoxu[1] + HUDobjNavBoxu[3], HUDobjNavBoxu[4], HUDobjNavBoxu[2] + HUDobjNavBoxu[4]))
   {
      If (mainParam="DoubleClick")
         ToggleImgNavSizeBox()
      Else
         SetTimer, ImageNavBoxClickResponder, -25
      Return
   } Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
   {
      If (mainParam="DoubleClick")
         ToggleImgNavSizeBox()
      Else
         Sleep, 5
      Return
   }

   If (thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      If (showHistogram>1 && imgEditPanelOpened!=1 && hasDrawnHistoMap=1
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[6] + HUDobjHistoBoxu[4]))
      {
         If StrLen(hitTestSelectionPath)>2
            hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
         If !hitA
         {
            ToggleHistogramMode()
            Return
         }
      } Else If (showHistogram>1 && hasDrawnImageMap=1 && hasDrawnHistoMap=1
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
      {
         If StrLen(hitTestSelectionPath)>2
            hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
         If !hitA
         {
            If (showHistogram=6)
               showHistogram := 1
            If (mainParam="DoubleClick")
               showHistogram := 6
            ToggleImgHistogram(1)
            Return
         }
      } 

      If (mainParam="DoubleClick" && (StrLen(hitTestSelectionPath)>2 || imgSelLargerViewPort=1) && editingSelectionNow=1 && adjustNowSel=0)
      {
         hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
         If (hitA=1 || imgSelLargerViewPort=1)
         {
            If (imgEditPanelOpened=1)
               BuildImgLiveEditMenu()
            Else
               invokeSelectionAreaMenu("DoubleClick")
            Return
         }
      }
   }

   ctrlState := GetKeyState("Ctrl", "P") ? 1 : 0
   shiftState := GetKeyState("Shift", "P") ? 1 : 0
   altState := GetKeyState("Alt", "P") ? 1 : 0
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsDisplaying=1 && maxFilesIndex>0 && mainParam!="doubleclick")
   {
      ; handle clicks on thumbnails and the vertical scrollbar
      thumbsListClickResponder(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState)
      Return
   }

   displayingImageNow := (thumbsDisplaying!=1 && useGdiBitmap()) ? 1 : 0
   If (InStr(mainParam, "normal") && IMGlargerViewPort=1 && displayingImageNow=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle H/V scrollbars for images larger than the viewport
      If (scrollBarHy>1) && ((mY>scrollBarHy && FlipImgV=0)
      || (mY<(mainHeight - scrollBarHy) && FlipImgV=1))
      {
         scrollAxis := 1
         SetTimer, panIMGonScrollBar, -25
         Return
      } Else If (scrollBarVx>1) && ((mX>scrollBarVx && FlipImgH=0)
      || (mX<(mainWidth - scrollBarVx) && FlipImgH=1))
      {
         scrollAxis := 0
         SetTimer, panIMGonScrollBar, -25
         Return
      }
   }

   spaceState := GetKeyState("Space", "P") ? 1 : 0
   If ((AnyWindowOpen=31 || AnyWindowOpen=24) && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActDrawAlphaMaskBrushNow, -5
      Return
   } Else If (AnyWindowOpen=64 && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActPaintBrushNow, -5
      Return
   } Else If (drawingShapeNow=1 && spaceState!=1)
   {
      ; respond to clicks when drawing freeform polygonal shapes
      addNewCustomShapePoints(mX, mY, mainWidth, mainHeight, mainParam, ctrlState)
      Return
   }

   If ((editingSelectionNow!=1) || (imgSelOutViewPort=1 && editingSelectionNow=1) || (imgSelLargerViewPort=1 && editingSelectionNow=1))
   && (displayingImageNow=1 && getCaptionStyle(PVhwnd)!=1 && InStr(mainParam,"normal") && shiftState=1)
   {
      ; activate selection on single click + shift
      MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
      MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      defineRelativeSelCoords(rImgW, rImgH)
      ToggleEditImgSelection("show-edit")
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (InStr(mainParam, "normal") && editingSelectionNow=1 && spaceState!=1 && displayingImageNow=1)
   {
      ; handle clicks on the image selection rectangle in the viewport
      dotsSize := SelDotsSize
      zL := (zoomLevel>1) ? zoomLevel : 1/zoomLevel
      dotActiveObj := determineSelAreaClickRect(mX, mY, dotsSize, mainWidth, mainHeight)
      DotPosX := dotActiveObj.x
      DotPosY := dotActiveObj.y
      dotActive := dotActiveObj.n
      If (dotActive=10)       ; click the center dot of the selection area
         anotherZeit := A_TickCount

      If (dotActive && imgSelOutViewPort=1)
      {
         dotActive := 9 ;       ; anywhere within the selection [makes the entire selection draggable]
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }
 
      If (InStr(mainParam, "pen-") && (dotActive=9 || !dotActive))
         Return
 
      ; ToolTip, % "l=" dotActive , , , 2
      ovPselRotation := vPselRotation
      tDotPosX := DotPosX
      tDotPosY := DotPosY

      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      nImgSelX1 := tImgSelX1 := imgSelX1
      nImgSelY1 := tImgSelY1 := imgSelY1
      nImgSelX2 := tImgSelX2 := imgSelX2
      nImgSelY2 := tImgSelY2 := imgSelY2
      timgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      timgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      tavg := (timgSelW + timgSelH)//2
      timgSelX2 := tImgSelX1 + tavg
      timgSelY2 := tImgSelY1 + tavg
      otimgSelX2 := nImgSelX2
      otimgSelY2 := nImgSelY2
      timgSelRatio := timgSelW/timgSelH
      thisZeit := zX := zY := adjustNowSel := 1
      o_imageLoading := imageLoading

      If dotActive
      {
         If (lockSelectionAspectRatio>1 && desiredSelAspectRatio && adjustGradientOffset!=1 && altState!=1 && isInRange(dotActive, 1, 8) && ctrlState!=1)
            shiftState := 1

         drawImgSelectionOnWindow("init", 0, 0, 0, mainWidth, mainHeight)
         If isInRange(dotActive, 1, 8)
            adjustingSelDotNow := dotActive
      }

      newPosZeit := A_TickCount
      oldPosZeit := A_TickCount
      o_alphaMaskOffsetX := alphaMaskOffsetX
      o_alphaMaskOffsetY := alphaMaskOffsetY
      adjustGradientOffset := 0
      If (dotActive=9 && AnyWindowOpen=23 && shiftState!=1)
      {
         GuiControlGet, FillAreaColorMode, SettingsGUIA:, FillAreaColorMode
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=2 && isInRange(FillAreaColorMode, 2, 4))
            adjustGradientOffset := 1
      } Else If (dotActive=9 && (AnyWindowOpen=24 || AnyWindowOpen=31) && shiftState!=1)
      {
         GuiControlGet, PasteInPlaceAlphaMaskMode, SettingsGUIA:, PasteInPlaceAlphaMaskMode
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=3 && PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5)
            adjustGradientOffset := 1
      }

      While, (determineLClickstate()=1 && o_imageLoading!=1 && dotActive && ctrlState=0)
      {
          MouseGetPos, mX, mY, thisWind
          skipLoop := isDotInRect(mX, mY, zX - 3, zX + 3, zY - 3, zY + 3) ? 1 : 0
          If (A_TickCount - newPosZeit>950) ; || (mX=oX && mY=oY)
          {
             newPosZeit := A_TickCount
             zX := mX, zY := mY
             If (skipLoop=1)
                Continue
          } Else If (skipLoop=1)
             Continue

          zeitSillyPrevent := A_TickCount
          changePosX := (zoomLevel>1) ? Round((mX - mXo)/zL) : Round((mX - mXo)*zL)
          changePosY := (zoomLevel>1) ? Round((mY - mYo)/zL) : Round((mY - mYo)*zL)
          If (dotActive=10)
          {
             ; center dot - selection rotation
             tW := (A_TickCount - oldPosZeit)/2150 + 0.0001
             If (tW>=1)
                tW := 1

             rotAmount := (changePosX/(mainWidth*0.9))*tW
             rotAmount := rotAmount * 360
             nvPselRotation := Round(ovPselRotation + rotAmount, 2)
             If (nvPselRotation<0 || nvPselRotation>360)
                nvPselRotation := 360 - Abs(nvPselRotation)
             vPselRotation := nvPselRotation
             ; ToolTip, % TW " -- " rotAmount " -- " nvPselRotation " -- " ovPselRotation " -- " vPselRotation  , , , 2
             If (shiftState=1)
                vPselRotation := ovPselRotation + 45
             Else If (altState=1)
                vPselRotation := 0
             Else

             vPselRotation := snapToValues(vPselRotation, 90, 180, 3, 0)
             vPselRotation := snapToValues(vPselRotation, 270, 360, 3, 0)
             vPselRotation := snapToValues(vPselRotation, 0, 360, 3, 0)
             vPselRotation := clampInRange(vPselRotation, 0, 360)
          } Else If (dotActive=9 && adjustGradientOffset=1)
          {
             ; anywhere within selection click
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             alphaMaskOffsetX := clampInRange(o_alphaMaskOffsetX + movX, -0.9, 0.9)
             alphaMaskOffsetY := clampInRange(o_alphaMaskOffsetY + movY, -0.9, 0.9)
             If (altState=1)
                alphaMaskOffsetX := alphaMaskOffsetY := o_alphaMaskOffsetX := o_alphaMaskOffsetY := 0
          }

          If (shiftState=1 && dotActive=9 && adjustGradientOffset!=1)
          {
             ; drag selection
             maxPos := max(Abs(changePosX), Abs(changePosY))
             If (maxPos=Abs(changePosX))
                changePosY := 0
             Else If (maxPos=Abs(changePosY))
                changePosX := 0
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; changePosX := Round(changePosX*timgSelRatio)
             If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=3)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             } Else If (dotActive=4)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             }
          }
 
          newSelDotX := (FlipImgH=1) ? tDotPosX - changePosX : tDotPosX + changePosX
          newSelDotY := (FlipImgV=1) ? tDotPosY - changePosY : tDotPosY + changePosY
          If (showSelectionGrid=1)
          {
             newSelDotX := snapToValues(newSelDotX, 0, rImgW//2, SelDotsSize, 0)
             newSelDotY := snapToValues(newSelDotY, 0, rImgH//2, SelDotsSize, 0)
          }

          newSelDotX := snapToValues(newSelDotX, 0, rImgW, SelDotsSize, 0)
          newSelDotY := snapToValues(newSelDotY, 0, rImgH, SelDotsSize, 0)
          If (dotActive=1)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=2)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=3)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=4)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=5)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=6)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=7)
          {
             coords := 2
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=8)
          {
             coords := 2
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=9 && adjustGradientOffset!=1)
          {
             coords := 10
             imgSelX1 := (FlipImgH=1) ? nImgSelX1 - changePosX : nImgSelX1 + changePosX
             imgSelY1 := (FlipImgV=1) ? nImgSelY1 - changePosY : nImgSelY1 + changePosY
             imgSelX2 := (FlipImgH=1) ? nImgSelX2 - changePosX : nImgSelX2 + changePosX
             imgSelY2 := (FlipImgV=1) ? nImgSelY2 - changePosY : nImgSelY2 + changePosY
          }

          If (nImgSelX1>nImgSelX2 || nImgSelY1>nImgSelY2) && (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY2
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY1
          } Else If (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY1
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY2
          }

          If (imgSelX1=imgSelX2)
             imgSelX2 += 2
          If (imgSelY1=imgSelY2)
             imgSelY2 += 2

          imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
          imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          If (adjustGradientOffset!=1 && altState=1 && (dotActive=1 || dotActive=2 || dotActive=9))
          {
             ; rectangular selection mode
             avg := (imgSelW+imgSelH)//2
             If (dotActive=9)
             {
                cAvg := (changePosX+changePosY)//2
                imgSelX2 := timgSelX2 + cAvg
                imgSelY2 := timgSelY2 + cAvg
                imgSelX1 := timgSelX1 - cAvg
                imgSelY1 := timgSelY1 - cAvg
             } Else If (dotActive=2)
             {
                imgSelX2 := imgSelX1 + avg
                imgSelY2 := imgSelY1 + avg
             } Else
             {
                imgSelX1 := imgSelX2 - avg
                imgSelY1 := imgSelY2 - avg

             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; keep aspect ratio mode
             cAvg := (changePosX+changePosY)//2
             diffu := (timgSelRatio>1) ? min(timgSelW, timgSelH) : max(timgSelW, timgSelH)
             If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                imgSelX2 := clampInRange(timgSelX1 + Round((diffu + cAvg)*timgSelRatio), timgSelX1 + 5, 33000)
                imgSelY2 := clampInRange(timgSelY1 + (diffu + cAvg), timgSelY1 + 5, 33000)
             } Else If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                cAvg := -cAvg
                imgSelX1 := clampInRange(otimgSelX2 - Round((diffu + cAvg)*timgSelRatio), -33000, otimgSelX2 + 5)
                imgSelY1 := clampInRange(otimgSelY2 - (diffu + cAvg), -33000, otimgSelY2 + 5)
             } Else If (dotActive=3)
             {
                cAvg := -cAvg
                imgSelX2 := timgSelX1 + Round((diffu+cAvg)*timgSelRatio)
                imgSelY1 := otimgSelY2 - diffu - cAvg
             } Else If (dotActive=4)
             {
                ; cAvg := -cAvg
                imgSelY2 := timgSelY1 + diffu + cAvg
                imgSelX1 := otimgSelX2 - Round((diffu+cAvg)*timgSelRatio)
             }

             If (LimitSelectBoundsImg=1)
             {
                imgSelX1 := clampInRange(imgSelX1, 0, prevMaxSelX)
                imgSelY1 := clampInRange(imgSelY1, 0, prevMaxSelY)
                imgSelX2 := clampInRange(imgSelX2, 0, prevMaxSelX)
                imgSelY2 := clampInRange(imgSelY2, 0, prevMaxSelY)
             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          }

          ; ToolTip, % cAvg "=" dotActive "|" changePosX "|" changePosY "|" timgSelW "|" timgSelH , , , 2
          If (A_TickCount - thisZeit>25)
          {
             If (isInRange(dotActive, 1, 4) && minimizeMemUsage!=1)
             {
                ARGBdec := Gdip_GetPixel(gdiBitmap, newSelDotX, newSelDotY)
                Gdip_FromARGB(ARGBdec, cA, cR, cG, cB)
                pixelColor := cR ", " cG ", " cB ", " cA
                addMsg := "`n `nCorner coordinates:`nX / Y: " Round(newSelDotX) ", " Round(newSelDotY) "`nColor: " pixelColor
             }

             theRatio := (lockSelectionAspectRatio>1) ? "`nLocked aspect ratio: " Round(desiredSelAspectRatio, 2) : "`nRatio: " Round(imgSelW/imgSelH, 2)
             ; If (imgEditPanelOpened=1)
                theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "

             theMsg := "X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio addMsg
             If (adjustGradientOffset=1)
                theMsg := "Gradient center offset:`nX / Y: " Round(alphaMaskOffsetX, 2) ", " Round(alphaMaskOffsetY, 2) "`nGradient angle: " Round(FillAreaGradientAngle) "°"

             ; ToolTip, % theMsg, % mainX + 10, % mainY + 10
             drawImgSelectionOnWindow("live", theMsg, ARGBdec, dotActive, mainWidth, mainHeight)
             thisZeit := A_TickCount
          }
      }
 
      adjustingSelDotNow := adjustNowSel := 0
      If dotActive
         drawImgSelectionOnWindow("end")

      ToolTip
      If (dotActive && imgEditPanelOpened=1)
         anotherZeit := A_TickCount

      If (dotActive=9 && isInRange(Abs(changePosY), 0, 2) && isInRange(Abs(changePosX), 0, 2))
      {
         If (A_TickCount - anotherZeit<300) && (imgEditPanelOpened!=1)
            thisZeit := dotActive := ctrlState := 0
         anotherZeit := A_TickCount
      }

      If (dotActive || (A_TickCount - thisZeit<150)) && (ctrlState=0)
         Return
   }

   If (mainParam="doubleclick" && thumbsDisplaying!=1 && displayingImageNow=1 && spaceState!=1) && (A_TickCount - lastInvokedSwipe>500) && (A_TickCount - anotherZeit>600)
   {
      ; handle double clicks in the viewport when an image is being displayed
      If (editingSelectionNow=1 && imgEditPanelOpened!=1)
      {
         lastInvoked := A_TickCount
         ToggleEditImgSelection()
         Return
      }

      lastInvoked := A_TickCount
      If (slideShowRunning=1)
         ToggleSlideShowu()
      Sleep, 1
      ToggleViewModeTouch()
   } Else If ((displayingImageNow=1 || mustOpenStartFolder) && mainParam!="DoubleClick") && (A_TickCount - thisZeit>950)
   ; } Else If ((maxFilesIndex>1 || mustOpenStartFolder) && CurrentSLD && mainParam!="DoubleClick") && (A_TickCount - thisZeit>950)
   {
      ; handle single clicks in the viewport when multiple files are loaded
      didSomething := 0
      If (TouchScreenMode=0 || spaceState=1) && ((IMGlargerViewPort=1 || spaceState=1) && IMGresizingMode=4 && thumbsDisplaying!=1)
         SetTimer, simplePanIMGonClick, -15
      Else If (TouchScreenMode=1 && drawingShapeNow!=1)
         didSomething := winSwipeAction(thisCtrlClicked, mainParam)
      Else didSomething := 0

      lastInvoked := A_TickCount
      If didSomething
         lastInvokedSwipe := A_TickCount
   } Else If (!CurrentSLD || maxFilesIndex<1) && (A_TickCount - thisZeit>450)
   {
      ; when no image is loaded, on click, open files dialog
      lastInvoked := A_TickCount
      If StrLen(UserMemBMP)>2
         Return

      SetTimer, drawWelcomeImg, Off
      Sleep, 5
      If (A_TickCount - lastWinDrag>300)
         OpenDialogFiles()
   }
   lastInvoked := A_TickCount
}

JEE_ScreenToWindow(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(RECT, 16)
  DllCall("user32\GetWindowRect", "UPtr", hWnd, "UPtr", &RECT)
  vWinX := NumGet(&RECT, 0, "Int")
  vWinY := NumGet(&RECT, 4, "Int")
  vPosX2 := vPosX - vWinX
  vPosY2 := vPosY - vWinY
  RECT := ""
}

JEE_ScreenToClient(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472
  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ScreenToClient", "UPtr", hWnd, "UPtr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
  POINT := ""
}

ToggleImageSizingMode(dummy:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    If (drawingShapeNow=1)
       customShapePoints := convertCustomShape2relativeCoords(customShapePoints)

    lastInvoked := A_TickCount
    resetSlideshowTimer(0)
    If (imgEditPanelOpened!=1)
    {
       IMGdecalageX := IMGdecalageX := 1
       IMGresizingMode++
       If (IMGresizingMode>5)
          IMGresizingMode := 1

       If (IMGresizingMode=5)
       {
          editingSelectionNow := 0
          updateUIctrl()
       }
    } Else 
    {
       IMGresizingMode := (IMGresizingMode=1) ? 4 : 1
       If (IMGresizingMode=4)
          zoomLevel := 1
    }

    If (dummy="custom")
    {
       IMGresizingMode := 4
       zoomLevel := 1
    }

    If (IMGresizingMode=4)
       moreInfos := "`nImages can be panned in this mode."

    friendly := DefineImgSizing()
    showTOOLtip("Adapt to window mode:`n" friendly moreInfos, A_ThisFunc, 1, IMGresizingMode/5)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "zoomLevel", "General")
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    If (drawingShapeNow=1)
    {
       adaptCustomShapeNewZoomLevel(0)
       Return
    }

    SetTimer, coreReloadThisPicture, -50
    ; dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

DefineImgSizing() {
   friendly := (IMGresizingMode=1) ? "ADAPT ALL INTO VIEW" : "ADAPT ONLY LARGE IMAGES"
   If (IMGresizingMode=3)
      friendly := "NONE (FIXED TO ORIGINAL SIZE)"
   Else If (IMGresizingMode=4)
      friendly := "CUSTOM ZOOM " Round(zoomLevel * 100) "%"
   If (IMGresizingMode=5)
      friendly := "STRETCHED TO WINDOW"

   Return friendly
}

VPimgFXrandomizer() {
    Static lastFX, FXmodes := {1:1, 2:2, 3:3, 4:4, 5:10}
    Random, OutputVar, 1, 5
    imgFxMode := FXmodes[OutputVar]
    If (imgFxMode=lastFX && lastFX=10)
    {
       Random, OutputVar, 1, 5
       imgFxMode := FXmodes[OutputVar]
    }

    Random, OutputVar, 1, 200
    satAdjust := OutputVar/100

    Random, OutputVar, 0.1, 0.9
    bwDithering := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    usrTextureBGR := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    FlipImgH := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 1, 7
    If (OutputVar=2)
       OutputVar := 1
    usrColorDepth := OutputVar
}

dummyInfoToggleSlideShowu(actu:=0) {
  Static lastInvoked := 1
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

  GIFframesPlayied := 0
  r := ToggleSlideShowu(actu)
  If (r="lulz")
     Return

  If (slideShowRunning!=1 || actu="stop")
  {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     ; userSeenSlideImages := (userSeenSlideImages>maxFilesIndex - 1) ? maxFilesIndex : userSeenSlideImages
     showTOOLtip("Slideshow: STOPPED`nImages seen in this session: " groupDigits(userSeenSlideImages))
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else ;  If (A_TickCount - lastInvoked > 450)
  {
     delayu := DefineSlidesRate()
     friendly := DefineSlideShowType()
     etaTime := "`nEstimated time: " EstimateSlideShowLength()
     If (slidesFXrandomize=1)
        infosFX := "`nViewport colour effects are randomized for each image."

     If (skipSeenImageSlides=1)
        skippy := "`nAlready seen images will be skipped"

     showTOOLtip("Started " friendly " slideshow`nSpeed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) etaTime infosFX skippy)
     SetTimer, RemoveTooltip, % -msgDisplayTime, 900
     If (slideShowDelay < 900)
     {
        Sleep, 550
        RemoveTooltip()
     } Else SetTimer, RemoveTooltip, % -msgDisplayTime, 900
  } ; Else  SetTimer, dummyInfoToggleSlideShowu, Off
}

InfoToggleSlideShowu() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 350) && (slideShowRunning!=1) || (maxFilesIndex<3 && StrLen(mustOpenStartFolder)<4)
   {
     lastInvoked := A_TickCount
     Return
   }

   lastInvoked := A_TickCount
   If !(IMGlargerViewPort=1 && IMGresizingMode=4)
      SetTimer, dummyInfoToggleSlideShowu, -80
   Return
}

preventScreenOff() {
  ; if the user is idle ;-)
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 10500) || (slideShowRunning!=1)
     Return

  lastInvoked := A_TickCount
  If (!GetKeyState("Space", "P") && slideShowRunning=1 && WinActive("A")=PVhwnd)
  {
     MouseMove, 2, 0, 2, R
     MouseMove, -2, 0, 2, R
     ; SendEvent, {Up}
  }
  ; z := DllCall("user32\SetCursor", "Ptr", hCursBusy)
  ; ToolTip, % "L=" z , , , 2
}

ToggleSlideShowu(actu:=0, resetMode:=0) {
  If (maxFilesIndex<3 && slideShowRunning!=1)
  {
     showTOOLtip("WARNING: Insufficient indexed files to start a slideshow")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "lulz"
  }

  If askAboutFileSave(" and the slideshow will begin")
     Return "lulz"
  Else
     terminateIMGediting()

  interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
  interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
  interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
  If (slideShowRunning=1 || actu="stop") && (actu!="start")
  {
     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     {
        WinSet, Region,, ahk_id %hQPVtoolbar%
        WinSet, Transparent, % ToolbarOpacity, ahk_id %hQPVtoolbar%
     }
     If (StrLen(SlidesMusicSong)>3 && hSNDsong && resetMode!=1)
        StopMediaPlaying(1)

     slideShowRunning := 0
     ; ResetImgLoadStatus()
     ; SetTimer, theSlideShowCore, Off
     prevSlideShowStop := A_TickCount
     interfaceThread.ahkFunction("slideshowsHandler", 0, "stop", SlideHowMode)
     SetTimer, ResetImgLoadStatus, -150
  } Else If (thumbsDisplaying!=1 || actu="start")
  {
     If (A_TickCount - prevSlideShowStop<500) && (actu!="start")
        Return

     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     {
        WinSet, Region, 0-0 w5 h5, ahk_id %hQPVtoolbar%
        WinSet, Transparent, 120, ahk_id %hQPVtoolbar%
     }

     ResetImgLoadStatus()
     If (StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && resetMode!=1)
        startSlidesMusicNow()

     interfaceThread.ahkassign("allowNextSlide", 1)
     editingSelectionNow := 0
     If !resetMode
        updateUIctrl()
     slideShowRunning := 1
     If (hSNDmediaFile && hSNDmediaDuration && hSNDmedia)
        milisec := MCI_Length(hSNDmedia) 

     thisSlideSpeed := (milisec>slideShowDelay) ? milisec : slideShowDelay
     interfaceThread.ahkFunction("slideshowsHandler", thisSlideSpeed, "start", SlideHowMode)
     ; SetTimer, theSlideShowCore, % thisSlideSpeed
  }
  Return
}

theSlideShowCore() {
   If (slideShowRunning=1 && slidesFXrandomize=1)
      VPimgFXrandomizer()

   If (SlideHowMode=1)
     RandomPicture()
   Else If (SlideHowMode=2)
     PreviousPicture()
   Else If (SlideHowMode=3)
     NextPicture()
   Return
}

GoNextSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoNextSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     RandomPicture()
  Else
     NextPicture()
}

GoPrevSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoPrevSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     PrevRandyPicture()
  Else
     PreviousPicture()
}

coreSecToHHMMSS(Seco, ByRef Hrs, ByRef Min, ByRef Sec) {
  OldFormat := A_FormatFloat
  SetFormat, Float, 2.00
  Hrs := Seco//3600/1
  Min := Mod(Seco//60, 60)/1
  SetFormat, Float, %OldFormat%
  Sec := Round(Mod(Seco, 60), 2)
}

SecToHHMMSS(Seco) {
  coreSecToHHMMSS(Seco, Hrs, Min, Sec)
  If (hrs>26)
     dayz := Round(hrs/24, 2)
  If (dayz>=1.1)
  {
     If (dayz>32)
        Return "about " Round(dayz/30.5, 2) " months"
     r := dayz " days"
  } Else  r := (Hrs ? Hrs "h " : "") Min "m " Sec "s"

  If (!min && !hrs)
  {
     r := StrReplace(r, "0m ")
     r := Trimmer(r, "0")
  }
  r := StrReplace(r, ".00s", "s")
  If (min || hrs)
     r := RegExReplace(r, "\...s", "s")
  r := StrReplace(r, " 0s")
  r := StrReplace(r, "  ", A_Space)
  r := Trimmer(r)

  Return r
}

DefineSlideShowType() {
   friendly := (SlideHowMode=1) ? "RANDOM" : "BACKWARD"
   If (SlideHowMode=3)
      friendly := "FORWARD"
   Return friendly
}

ToggleSlideshowModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
      Return

   lastInvoked := A_TickCount
   SlideHowMode++
   If (SlideHowMode>3)
      SlideHowMode := 1

   resetSlideshowTimer(0, 1)
   friendly := DefineSlideShowType() "`nCurrently "
   friendly .= (slideShowRunning=1) ? "running" : "stopped"
   showTOOLtip("Slideshow direction: " friendly, A_ThisFunc, 1, SlideHowMode/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "SlideHowMode", "General")
}

DefineVPselAreaMode() {
   If (EllipseSelectMode=2)
      friendly := "FREEFORM - T" FillAreaCurveTension
   Else If (EllipseSelectMode=1)
      friendly := "ELLIPTICAL"
   Else
      friendly := "RECTANGULAR"

   Return friendly
}

DefineFXmodes() {
   Static FXmodesLabels := {1:"ORIGINAL", 2:"PERSONALIZED", 3:"AUTO-ADJUSTED", 4:"GRAYSCALE", 5:"RED CHANNEL", 6:"GREEN CHANNEL", 7:"BLUE CHANNEL", 8:"ALPHA CHANNEL", 9:"INVERTED COLORS", 10:"SEPIA"}
        , otherFXLabels := {1:"ADAPTIVE", 2:"BRIGHTNESS", 3:"CONTRAST"}

   If FXmodesLabels.HasKey(imgFxMode)
      friendly := FXmodesLabels[imgFxMode]
   Else
      friendly := "Colors FX: " imgFxMode
   If (imgFxMode=3)
      friendly .= A_Space otherFXLabels[autoAdjustMode]

   If (bwDithering=1 && imgFxMode=4)
      friendly := "BLACK/WHITE DITHERED"

   If (imgFxMode=1 && isInRange(usrColorDepth, 2, 10))
      friendly := "ALTERED COLOR DEPTH"

   Return friendly
}

ToggleImgColorDepth(dir:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbsListViewMode>1)
       Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   If (imgFxMode=4 && bwDithering=1)
   {
      imgFxMode := 1
      Return
   }

   good2go := (imgFxMode=1 || imgFxMode=2 || imgFxMode=3 || imgFxMode=8) ? 1 : 0
   If (good2go!=1)
      imgFxMode := 1

   If (dir=1)
      usrColorDepth++
   Else
      usrColorDepth--

   usrColorDepth := clampInRange(usrColorDepth, 1, 9, 1)
   ForceRefreshNowThumbsList()
   infoColorDepth := (usrColorDepth>1) ? defineColorDepth() : "NONE"
   showTOOLtip("Image color depth simulated:`n" infoColorDepth, A_ThisFunc, 2, usrColorDepth/9)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "imgFxMode", "General")
   SetTimer, RefreshImageFile, -50

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, usrColorDepth, % usrColorDepth
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineColorDepth() {
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}

   internalColorDepth := bitsOptions[usrColorDepth]
   r := internalColorDepth " bits [" 2**internalColorDepth " colors]"
   If (r<1)
      r := currIMGdetails.PixelFormat
   Else If (ColorDepthDithering=1)
      r .= " | DITHERED"

   If !r
      r := "NONE"
   Return r
}

ToggleImgFX(dir:=0) {
   Static lastInvoked := 1, moreFX := {1:"None", 2:"Brightness / Contrast", 3:"Hue / Saturation / Lightness", 4:"Levels adjust [High / Mid / Low]", 5:"Color tint [Hue / Amount]", 6:"Colors balance", 7:"Color curve per channel"}
        , curvesFX := {1:"Brightness (density)", 2:"Contrast", 3:"Highlights", 4:"Shadows", 5:"Midtones", 6:"White saturation", 7:"Black saturation"}
        , curvesChannels := {1:"Red", 2:"Green", 3:"Blue", 4:"All"}

   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbsListViewMode>1 && showHUDnavIMG!=1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=1)
      imgFxMode++
   Else
      imgFxMode--

   prevColorAdjustZeit := A_TickCount
   If (imgFxMode=3 && thumbsDisplaying=1)
   {
      If (dir=1)
         imgFxMode++
      Else
         imgFxMode--
   }

   imgFxMode := clampInRange(imgFxMode, 1, 10, 1)
   friendly := DefineFXmodes()
   If (imgFxMode=4)
      friendly .= "`nBrightness: " Round(lumosGrayAdjust, 3) "`nContrast: " Round(GammosGrayAdjust, 3)
   Else If (imgFxMode=2)
      friendly .= "`nBrightness: " Round(lumosAdjust, 3) "`nContrast: " Round(GammosAdjust, 3) "`nSaturation: " Round(satAdjust*100) "%"

   If (imgFxMode=2 || imgFxMode=4 || imgFxMode=9)
      friendly .= "`nGamma: " Round(realGammos, 3)
   
   If (imgFxMode=2 || imgFxMode=3 || (imgFxMode=4 && bwDithering=0) || imgFxMode=9 || imgFxMode=10) && (IntensityAlphaChannel!=1)
      friendly .= "`nAlpha channel: ALTERED"

   If (specialColorFXmode>1) && (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9)
   {
      friendly .= "`n" moreFX[specialColorFXmode]
      If (specialColorFXmode=7)
         friendly .= " [" curvesFX[uiColorCurveFXmode] "]: "  Round(lummyAdjust) " - " curvesChannels[uiColorCurveFXchannel]
      Else
         friendly .= ":`n" Round(hueAdjust) " / " Round(zatAdjust) " / " Round(lummyAdjust)
   }

   If (usrColorDepth>1 && imgFxMode=1)
      friendly .= "`nSimulated color depth: " defineColorDepth()

   If (imgFxMode=4 || imgFxMode=3 || imgFxMode=2)
      friendly .= "`n `nPress U to adjust colors display options."

   showTOOLtip("Image colors: " friendly, A_ThisFunc, 2, imgFxMode/10)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()

   If (imgFxMode=3 && thumbsDisplaying!=1)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
   }

   INIaction(1, "imgFxMode", "General")
   If (o_bwDithering=0)
      o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0

   If (o_bwDithering=1 && thumbsDisplaying!=1)
      RefreshImageFile()
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, imgFxMode, % imgFxMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineImgAlign() {
   modes := {1:"Top-left corner", 2:"Top-center", 3:"Top-right corner", 4:"Left-center", 5:"Center", 6:"Right-center", 7:"Bottom-left corner", 8:"Bottom-center", 9:"Bottom-right corner"}
   ; thisAlign := (IMGresizingMode=4) ? 5 : imageAligned
   r := modes[imageAligned]
   StringUpper, r, r
   Return r
}

ToggleIMGalign() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (!useGdiBitmap() && thumbsDisplaying!=1)
      Return

   resetSlideshowTimer(0, 1)
   imageAligned := (imageAligned=5) ? 1 : 5
   ; imageAligned++
   ; If (imageAligned>9)
   ;    imageAligned := 1

   showTOOLtip("Image alignment: " defineImgAlign(), A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "imageAligned", "General")
   If (drawingShapeNow=1)
   {
      customShapePoints := convertCustomShape2relativeCoords(customShapePoints)
      adaptCustomShapeNewZoomLevel(zoomLevel)
      Return
   }

   dummyTimerReloadThisPicture(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   } Else if (thumbsDisplaying=1)
   {
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }
}

toggleColorAdjustments(modus:=0) {
   Static lastInvoked := 1, prevImgAlphaChn := 1, prevFXmode := 1
   If (modus="backup")
   {
      IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
      imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
      Return
   }

   If (A_TickCount - lastInvoked < 50)
      Return

  lastInvoked := A_TickCount
  If (imgFxMode!=1 && thumbsDisplaying!=1)
  {
     prevColorAdjustZeit := A_TickCount
     resetSlideshowTimer(0)
     If (!ForceNoColorMatrix && modus!="backup")
     {
        prevFXmode := imgFxMode
        prevImgAlphaChn := IntensityAlphaChannel
     }

     ForceNoColorMatrix := !ForceNoColorMatrix
     If (modus=0)
        AnyWindowOpen := (ForceNoColorMatrix=1) ? 10 : 0
     IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
     imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
     dummyTimerDelayiedImageDisplay(50)
     If (modus=0)
     {
        AnyWindowOpen := 10
        SetTimer, resetClrMatrix, -1500
     }
  }
}

resetClrMatrix() {
   resetSlideshowTimer(0)
   AnyWindowOpen := ForceNoColorMatrix := 0
   toggleColorAdjustments("backup")
   dummyTimerDelayiedImageDisplay(50)

}

ResetImageView() {
   Critical, on
   If throwErrorNoImageLoaded()
      Return

   ChangeLumos(2)
}

HardResetImageView() {
   Critical, on
   DestroyTempBtnGui("now")
   If (!useGdiBitmap() && !CurrentSLD)
      Return

   ChangeLumos(2, "k")
}

coreResetIMGview(dummy:=0) {
  If (imgFxMode=4 && lumosGrayAdjust=1 && GammosGrayAdjust=0)
     mustResetFxMode := 1

  If (dummy="k")
  {
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0
     imgThreshold := bwDithering := hueAdjust := zatAdjust := lummyAdjust := 0
     IntensityAlphaChannel := specialColorFXmode := 1
  }

  If (imgFxMode=4)
  {
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
  } Else If (imgFxMode=2)
  {
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || dummy="k")
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0

  realGammos := 1
  If (imgFxMode=1 || dummy="k")
  {
     zoomLevel := 1
     FlipImgH := FlipImgV := 0
     If (thumbsDisplaying!=1)
       vpIMGrotation := 0
  }

  If (dummy="k")
  {
     ; bwDithering := 0
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
     vpIMGrotation := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || imgFxMode>4 || mustResetFxMode=1)
     imgFxMode := 1

  If (thumbsDisplaying=1)
  {
     thumbsZoomLevel := 1
     thumbsColumns := 7
     recalculateThumbsSizes()
     ; thumbsH := othumbsH + 1
     ; thumbsW := othumbsW + 1
     ForceRefreshNowThumbsList()
  }

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  If (dummy="k")
     usrColorDepth := internalColorDepth := 1
}

ChangeLumos(dir, dummy:=0) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode!=2 && imgFxMode!=4 && dir!=2)
      imgFxMode := 2

   showHardReset := 0
   If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
      showHardReset := 1

   prevColorAdjustZeit := A_TickCount
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=2)
   {
      coreResetIMGview(dummy)
      SetTimer, WriteSettingsColorAdjustments, -95
   } Else If (imgFxMode=4)
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosGrayAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosGrayAdjust += stepu
      Else
         lumosGrayAdjust -= stepu

      lumosGrayAdjust := clampInRange(lumosGrayAdjust, 0.001, 25)
   } Else
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosAdjust += stepu
      Else
         lumosAdjust -= stepu

      lumosAdjust := clampInRange(lumosAdjust, 0.001, 25)
   }

   value2show := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   If (dir=2)
   {
      If (imgFxMode=4)
         addMsg := DefineFXmodes()
      If (imgFxMode=1 && usrColorDepth>1)
         addMsg .= "`nImage color depth: ALTERED [ " defineColorDepth() " ]"
      If (vpIMGrotation>0)
         addMsg .= "`nImage rotated: " vpIMGrotation "° degrees."
      If (thisIMGisDownScaled=1)
         addMsg .= "`nImage dimensions DOWNSCALED to screen resolution."

      addMsg .= defineIMGmirroring()
      If (dummy!="k" && showHardReset=1)
      {
         addMore := "`nReset all adjustments to defaults with Ctrl + \"
         CreateGuiButton("Reset all adjustments,,HardResetImageView", 0, msgDisplayTime//1.5 + 100)
      }
      showTOOLtip("Image display: UNALTERED " addMsg addMore)
   } Else showTOOLtip("Image brightness: " value2show, A_ThisFunc, 2, value2show / 25)

   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues && dir!=2)
      Return

   If (dir!=2)
      SetTimer, dummySaveLumGammos, -70

   prevValues := newValues
   If (o_bwDithering=1 || otherFX=1) ; && (thumbsDisplaying!=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

WriteSettingsColorAdjustments() {
    INIaction(1, "userimgQuality", "General")
    INIaction(1, "histogramMode", "General")
    INIaction(1, "usrTextureBGR", "General")
    INIaction(1, "autoAdjustMode", "General")
    INIaction(1, "doSatAdjusts", "General")
    INIaction(1, "usrAdaptiveThreshold", "General")
    INIaction(1, "showHistogram", "General")
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "imgThreshold", "General")
    INIaction(1, "bwDithering", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "ColorDepthDithering", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "IntensityAlphaChannel", "General")
    INIaction(1, "chnBdecalage", "General")
    INIaction(1, "chnGdecalage", "General")
    INIaction(1, "chnRdecalage", "General")
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "GammosAdjust", "General")
    INIaction(1, "GammosGrayAdjust", "General")
    INIaction(1, "hueAdjust", "General")
    INIaction(1, "lumosAdjust", "General")
    INIaction(1, "lumosGrayAdjust", "General")
    INIaction(1, "realGammos", "General")
    INIaction(1, "satAdjust", "General")
    INIaction(1, "vpIMGrotation", "General")
    INIaction(1, "zatAdjust", "General")
    INIaction(1, "lummyAdjust", "General")
    INIaction(1, "zoomLevel", "General")
    INIaction(1, "specialColorFXmode", "General")
    INIaction(1, "uiColorCurveFXmode", "General")
    INIaction(1, "uiColorCurveFXchannel", "General")
}

defineIMGmirroring() {
    If (FlipImgH=1 || FlipImgV=1)
    {
       infoMirroring := "`nImage mirroring: "
       If (FlipImgV=1 && FlipImgH=0)
          infoMirroring :=  infoMirroring "VERTICAL"
       Else If (FlipImgV=0 && FlipImgH=1)
          infoMirroring := infoMirroring "HORIZONTAL"
       Else If (FlipImgV=1 && FlipImgH=1)
          infoMirroring := infoMirroring "VERTICAL, HORIZONTAL"
    }
    Return infoMirroring
}

defineFilesListType() {
    If (SLDtypeLoaded=1)
    {
       infou := !InStr(CurrentSLD, "|") ? "FOLDER RECURSIVELY" : "FOLDER"
    } Else If (SLDtypeLoaded=2)
    {
       infou := "PLAIN-TEXT | cached list"
       If (currentFilesListModified=1)
          infou .= " | unsaved changes"
    } Else If (SLDtypeLoaded=3)
       infou := "SQLITE DATABASE | cached list"
       
    Return infou
}

ChangeThumbsZoom(dir) {
   If (thumbsListViewMode>1)
   {
      changeOSDfontSize(dir)
      Return
   }

   If (dynamicThumbsColumns=1)
   {
      If (dir=1)
         thumbsZoomLevel += 0.1
      Else
         thumbsZoomLevel -= 0.1
   } Else
   {
      If (dir=1)
         thumbsColumns += 1
      Else
         thumbsColumns -= 1
   }

   thumbsZoomLevel := clampInRange(thumbsZoomLevel, 0.35, 3)
   thumbsColumns := clampInRange(thumbsColumns, 2, 100)
   ForceRefreshNowThumbsList()
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      ForceRefreshNowThumbsList()
   INIaction(1, "thumbsZoomLevel", "General")
   INIaction(1, "thumbsColumns", "General")
   ; INIaction(1, "dynamicThumbsColumns", "General")
   If (dynamicThumbsColumns=1)
      showTOOLtip("Thumbnails zoom level: " Round(thumbsZoomLevel*100) "%`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsZoomLevel/3)
   Else
      showTOOLtip("Thumbnails columns: " thumbsColumns "`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsColumns/100)

   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(95)
}

ChangeZoom(dir, key:=0, stepFactor:=1) {
   Static prevValues, lastInvoked := 1, lastInvoked2 := 1

   If InStr(key, "wheel")
   {
      MouseGetPos, , , OutputVarWin
      If (OutputVarWin!=PVhwnd)
         Return
   }

   resetSlideshowTimer(0)
   If (thumbsDisplaying=1)
   {
      ChangeThumbsZoom(dir)
      Return
   }

   If (drawingShapeNow=1)
      customShapePoints := convertCustomShape2relativeCoords(customShapePoints)

   oldZoomLevel := zoomLevel
   If (zoomLevel<=0.1 && dir!=1)
      changeFactor := 0.01
   Else If (zoomLevel<0.1 && dir=1)
      changeFactor := 0.01
   Else
      changeFactor := 0.05

   If (zoomLevel>5)
      changeFactor := 0.50
   Else If (zoomLevel>1)
      changeFactor := 0.15
   Else If (zoomLevel<0.01)
      changeFactor := 0.005

   If (dir=1)
      zoomLevel += changeFactor * stepFactor
   Else
      zoomLevel -= changeFactor * stepFactor

   If isInRange(zoomLevel, 0.1, 0.12)
      zoomLevel := 0.1
   Else If isInRange(zoomLevel, 0.99, 1.01)
      zoomLevel := 1
   Else If isInRange(zoomLevel, 1.98, 2.02)
      zoomLevel := 2
   Else If isInRange(zoomLevel, 9.90, 10.10)
      zoomLevel := 10

   o_IMGresizingMode := IMGresizingMode
   IMGresizingMode := 4
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)

   If (zoomLevel>3 && thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
   {
      imgPath := getIDimage(currentFileIndex)
      op := GetImgFileDimension(imgPath, Wi, He)
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      xu := (imgW*zoomLevel)/Wi
      hasThisChangedYo := 1
      zoomLevel := xu
      AutoDownScaleIMGs := 2
   }

   MouseGetPos, , , OutputVarWin
   If (OutputVarWin=PVhwnd && InStr(key, "wheel"))
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      prcW := mX/mainWidth
      prcH := mY/mainHeight

      prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
      prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      IMGdecalageX := IMGdecalageX + decX//35
      IMGdecalageY := IMGdecalageY + decY//35
   }

   ; tooltip, % IMGdecalageX " -- " IMGdecalageY "`n" decX " -- " decY "`n"prcW " -- " prcH
   If (A_TickCount - lastInvoked2<150)
   {
      zeitSillyPrevent := A_TickCount
      SetTimer, dummyDisplayZoomImgInfo, -80
   } Else
   {
      dummyDisplayZoomImgInfo()
      lastInvoked2 := A_TickCount
   }

   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")

   imgPath := getIDimage(currentFileIndex)
   If (drawingShapeNow=1)
   {
      newValues := "a"
      adaptCustomShapeNewZoomLevel(zoomLevel)
      Return
   }

   newValues := "a" zoomLevel thumbsZoomLevel IMGresizingMode imageAligned imgPath gdiBitmap UserMemBMP
   If (prevValues=newValues && hasThisChangedYo!=1)
      Return

   prevValues := newValues
   ; If (drawModeBzeit>150 && (A_TickCount - lastInvoked < 10) && (LastWasFastDisplay!=1)) || (hasThisChangedYo=1)
   ;    GdipCleanMain(6)

   lastInvoked := A_TickCount
   If (AutoDownScaleIMGs=2 && hasThisChangedYo=1)
   {
      SetTimer, RefreshImageFileAction, -150
   } Else 
   {
      SetTimer, dummyResizeImageGDIwin, -10
      dummyTimerDelayiedImageDisplay(600)
   }
}

adaptCustomShapeNewZoomLevel(thisZL) {
   dummyResizeImageGDIwin()
   resumeCustomShapeSelection(thisZL)
   vPselRotation := 0
   initialDrawingStartCoords := []
   ;  ToolTip, % prevDestPosX "===" prevDestPosY "===" zoomLevel , , , 2
   lastZeitFileSelect := A_TickCount
   Loop, % customShapePoints.Count()
         initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY]
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

dummyResizeImageGDIwin() {
   startZeitIMGload := A_TickCount
   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   ResizeImageGDIwin(imgPath, 0, 0)
}

dummyDisplayZoomImgInfo() {
   If (thisIMGisDownScaled=1)
      friendly := "`nThe image is downscaled.`nPress F5 or increase zoom above 300%`nto load the original file."

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }

   showTOOLtip("Zoom level: " Round(zoomLevel*100) "%" friendly, 0, 0, zoomLevel/20)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; SetTimer, ResetImgLoadStatus, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

ChangeGammos(dir) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode!=2 && imgFxMode!=4)
      imgFxMode := 2

   value2Adjust := (imgFxMode=4) ? GammosGrayAdjust : GammosAdjust
   value2AdjustB := (imgFxMode=4) ? lumosGrayAdjust : lumosAdjust
   stepu := (A_tickcount - lastInvoked<300) && (value2Adjust<-2) ? 0.06 : 0.03
   If (dir=1)
   {
      value2Adjust += stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB -= stepu
   } Else
   {
      value2Adjust -= stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB += stepu
   }

   value2Adjust := clampInRange(value2Adjust, -25, 1)
   value2AdjustB := clampInRange(value2AdjustB, 0.001, 25)
   If (imgFxMode=4)
   {
      GammosGrayAdjust := value2Adjust
      lumosGrayAdjust := value2AdjustB
   } Else
   {
      GammosAdjust := value2Adjust
      lumosAdjust := value2AdjustB
   }

   prevColorAdjustZeit := A_TickCount
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image contrast: " Round(value2Adjust, 3), A_ThisFunc, 2, Abs(value2Adjust - 1)/26)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues)
      Return

   SetTimer, dummySaveLumGammos, -70
   prevValues := newValues
   If (o_bwDithering=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

dummySaveLumGammos() {
   INIaction(1, "GammosAdjust", "General")
   INIaction(1, "GammosGrayAdjust", "General")
   INIaction(1, "lumosAdjust", "General")
   INIaction(1, "lumosGrayAdjust", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")
}

ChangeSaturation(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode=4)
      satAdjust := 0

   imgFxMode := 2
   prevColorAdjustZeit := A_TickCount
   value2Adjust := satAdjust
   If (dir=1)
      value2Adjust += 0.05
   Else
      value2Adjust -= 0.05

   value2Adjust := clampInRange(value2Adjust, 0, 3)
   satAdjust := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image saturation: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" satAdjust imgFxMode currentFileIndex
   If (prevValues=newValues)
      Return

   INIaction(1, "satAdjust", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeRealGamma(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   prevColorAdjustZeit := A_TickCount
   imgFxMode := 2
   value2Adjust := realGammos
   If (value2Adjust>2)
      stepu := 0.2
   Else If (value2Adjust<0.1)
      stepu := 0.01
   Else
      stepu := 0.05

   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0.01, 10)
   realGammos := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image gamma: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" realGammos imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "realGammos", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeVolume(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(0, 1)
   value2Adjust := mediaSNDvolume
   If (dir=1)
      value2Adjust += 5
   Else
      value2Adjust -= 5

   value2Adjust := clampInRange(value2Adjust, 1, 100)
   If (hSNDmedia && hSNDmediaFile)
   {
      zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      infoMedia := "`nAudio annotation playing:`n" OutFileName " ( " hSNDmediaDuration " )"
   }

   If (hSNDsong && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDsong)
      lenghtu := MCI_ToHHMMSS(milisec)
      infoMedia .= "`nBackground slideshow music playing:`n" OutFileName " ( " lenghtu " )"
   }

   If !infoMedia
      infoMedia := "`nNo audio is playing through QPV"

   mediaSNDvolume := value2Adjust
   INIaction(1, "mediaSNDvolume", "General")
   SetVolume(mediaSNDvolume)
   showTOOLtip("Audio volume: " value2Adjust "%" infoMedia, A_ThisFunc, 2, value2Adjust/100)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

MenuChangeImgRotationInVP() {
   changeImgRotationInVP(1, 45)
}

changeSelRotation(dir) {
   If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   value2Adjust := vPselRotation
   If (dir=1)
      value2Adjust += 2
   Else
      value2Adjust -= 2

   value2Adjust := clampInRange(value2Adjust, 0, 360 - 2, 1)
   vPselRotation := value2Adjust
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

changeImgRotationInVP(dir, stepu:=15, doReset:=0) {
   If (thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   If StrLen(whichBitmap)>3
   {
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
      Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
      If ((ResizedW*ResizedH>maxGDIbmpSize) || (ResizedW>32500) || (ResizedH>32500)) && (vpIMGrotation=0)
      {
         vpIMGrotation := 0
         SoundBeep, 300, 100
         showTOOLtip("ERROR: The document dimensions exceed the maximum limits`nThe image cannot be rotated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else Return

   resetSlideshowTimer(0)
   value2Adjust := vpIMGrotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   If (doReset=1)
      value2Adjust := 0
   Else
      value2Adjust := clampInRange(value2Adjust, 0, 360 - stepu, 1)
   vpIMGrotation := value2Adjust
   SetTimer, dummyChangeVProtation, -10
   SetTimer, RefreshImageFile, -750
}

dummyChangeVProtation() {
   showTOOLtip("Image rotation: " vpIMGrotation "° ", "changeImgRotationInVP", 2, vpIMGrotation/360)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpIMGrotation", "General")
   GdipCleanMain(4)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, vpIMGrotation, % vpIMGrotation
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

nextDesiredFrame() {
    changeDesiredFrame(1)
}

prevDesiredFrame() {
    changeDesiredFrame(-1)
}

changeDesiredFrame(dir:=1) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 || !totalFramesIndex)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the current image frame will be changed")
      Return

   DestroyGIFuWin()
   resetSlideshowTimer(0)
   value2Adjust := desiredFrameIndex
   If (dir=1)
      value2Adjust++
   Else
      value2Adjust--

   If (dir=-1 && value2Adjust<1)
      value2Adjust := 0

   value2Adjust := clampInRange(value2Adjust, 0, totalFramesIndex, 1)
   desiredFrameIndex := value2Adjust
   If (A_TickCount - lastInvoked > 350) || (dir=-1 || drawModeCzeit>450)
   {
      showCurrentFrameIndex()
      lastInvoked := A_TickCount
   } Else SetTimer, showCurrentFrameIndex, -400

   newValues := "a" value2Adjust currentFileIndex totalFramesIndex
   If (prevValues!=newValues)
   {
      ; ToolTip, % drawModeCzeit "==" drawModeAzeit "==" drawModeBzeit , , , 2
      If (drawModeAzeit>450)
         SetTimer, RefreshImageFile, -450
      Else
         SetTimer, RefreshImageFile, % (dir=-1) ? -95 : -5
      prevValues := newValues
   }
}

autoChangeDesiredFrame(act:=0, imgPath:=0) {
   Critical, on
   Static prevImgPath, lastInvoked := 1, lastFrameChange := 1
   If (thumbsDisplaying=1 || act="stop" || AnyWindowOpen || animGIFsSupport!=1 || !maxFilesIndex || !CurrentSLD)
   {
      If (animGIFplaying=1)
      {
         SetTimer, autoChangeDesiredFrame, Off
         SetTimer, ResetImgLoadStatus, -10
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         Global lastGIFdestroy := A_TickCount
         lastFrameChange := A_TickCount
         animGIFplaying := 0
         ; lastInvoked := A_TickCount
         interfaceThread.ahkassign("animGIFplaying", 0)
         ; dummyTimerDelayiedImageDisplay(50)
      }
      Return
   }
   If (alwaysOpenwithFIM=1)
      Return

   If (prevImgPath!=imgPath && StrLen(imgPath)>2)
      lastInvoked := A_TickCount

   If (act="start" && imgPath && prevImgPath!=imgPath)
   {
      SetTimer, ResetImgLoadStatus, -15
      lastFrameChange := A_TickCount
      prevImgPath := imgPath
      allowNextSlide := 0
      animGIFplaying := 1
      interfaceThread.ahkassign("animGIFplaying", 1)
      interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
      Return
   } Else
   {
      Sleep, -1
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      If !animGIFplaying
      {
         SetTimer, ResetImgLoadStatus, -10
         SetTimer, autoChangeDesiredFrame, Off
         animGIFplaying := 0
         allowNextSlide := 1
         interfaceThread.ahkassign("animGIFplaying", 0)
         interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         lastFrameChange := A_TickCount
         Global lastGIFdestroy := A_TickCount
         Return
      }
   }

   allowNextSlide := 0
   desiredFrameIndex++
   GIFframesPlayied++
   If (allowGIFsPlayEntirely=1 && GIFframesPlayied>totalFramesIndex-1) || (totalFramesIndex<3) || (allowGIFsPlayEntirely!=1)
      allowNextSlide := 1
   ; ToolTip, % allowGIFsPlayEntirely "--" allowNextSlide , , , 2
   desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex, 1)
   prevAnimGIFwas := ""
   totalZeit := A_TickCount - startZeitIMGload
   thisFrameDelay := (totalZeit>25 && totalFramesIndex>20) ? GIFspeedDelay//2 : GIFspeedDelay
   If (totalZeit>70 && totalFramesIndex>15) || (totalZeit>25 && totalFramesIndex>180)
      thisFrameDelay := 10
   If (thisFrameDelay<12 && totalZeit<40 && totalFramesIndex<14)
      thisFrameDelay := 11
   If (totalZeit>100 && totalFramesIndex>95)
      thisFrameDelay := 1

   If (slideShowRunning=1 && (A_TickCount - lastInvoked>slideShowDelay + 1) && allowNextSlide=1)
   {
      ; allowNextSlide := 0
      lastInvoked := A_TickCount
      prevImgPath := ""
      interfaceThread.ahkPostFunction("theSlideShowCore", "force")
      ; theSlideShowCore()
      invokeExternalSlideshowHandler()
   } Else If (A_TickCount - lastFrameChange > thisFrameDelay)
   {
      lastFrameChange := A_TickCount
      SetTimer, RefreshImageFile, -1
   }
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
}

showCurrentFrameIndex() {
    showTOOLtip("Image frame index: " desiredFrameIndex " / " totalFramesIndex, "changeDesiredFrame", 2, desiredFrameIndex/totalFramesIndex)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

VPflipImgV() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgV := !FlipImgV
   friendly := (FlipImgV=1) ? "ON" : "off"
   showTOOLtip("Vertical mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgV", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgV, % FlipImgV
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

setMainCanvasTransform(W, H, G:=0, forceH:=0, forceV:=0) {
    If (thumbsDisplaying=1)
       Return

    If !G
       G := glPG

    If (FlipImgH=1 && forceH=0) || (forceH=1)
    {
       Gdip_ScaleWorldTransform(G, -1, 1)
       Gdip_TranslateWorldTransform(G, -W, 0)
    }

    If (FlipImgV=1 && forceV=0) || (forceV=1)
    {
       Gdip_ScaleWorldTransform(G, 1, -1)
       Gdip_TranslateWorldTransform(G, 0, -H)
    }
}

VPflipImgH() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgH := !FlipImgH
   friendly := (FlipImgH=1) ? "ON" : "off"
   showTOOLtip("Horizontal mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgH", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgH, % FlipImgH
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

doOpenStartFolder(ByRef didSomething:=0) {
   didSomething := 0
   If StrLen(mustOpenStartFolder)>3
   {
      If askAboutFileSave(" and files found in " mustOpenStartFolder "\ will be indexed")
         Return currentFileIndex
 
      didSomething := "yes"
      SLDtypeLoaded := 1
      imgPath := getIDimage(currentFileIndex)
      coreOpenFolder("|" mustOpenStartFolder, 0)
      If FileRexists(imgPath)
         startIndex := detectFileID(imgPath)
      SetTimer, TriggerMenuBarUpdate, -90
   } Else startIndex := currentFileIndex
   Return startIndex
}

coreNextPrevImage(direction, startIndex, randomMode) {
   Static countSeen, prevStatus
   If (thumbsDisplaying!=1 && maxFilesIndex>1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return currentFileIndex
   }

   If StrLen(mustOpenStartFolder)>3
      startIndex := currentFileIndex := doOpenStartFolder()

   thisState := "a" maxFilesIndex CurrentSLD SLDtypeLoaded
   If (thisState!=prevStatus || countSeen>maxFilesIndex)
      countSeen := 0

   prevStatus := thisState
   If (startIndex>=maxFilesIndex && direction=1 && thumbsDisplaying=1 && randomMode!=1)
      Return maxFilesIndex
   Else If (startIndex<2 && direction=-1 && thumbsDisplaying=1 && randomMode!=1)
      Return 1

   startZeit := A_TickCount
   If (startIndex=1 && direction=-1)
      startIndex := maxFilesIndex + 1
   Else If (startIndex=maxFilesIndex && direction=1)
      startIndex := 0

   delayu := (slideShowDelay>3500) ? Round(slideShowDelay*0.25) : Round(slideShowDelay*0.5)
   ; canResetSeen := 0
   Loop, % maxFilesIndex + 1
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        If (thisIndex>maxFilesIndex)
           thisIndex -= maxFilesIndex
        Else If (thisIndex<1)
           thisIndex := startIndex + Abs(thisIndex)

        newIndex := thisIndex
        If (randomMode=1)
        {
           z := RandyIMGids[thisIndex]
           r := getIDimage(z)
        } Else r := getIDimage(thisIndex)
        If !r
           Continue

        If (A_TickCount - startZeit>delayu)
           Break

        r := StrReplace(r, "||")
        If (mustRecordSeenImgs=1 && skipSeenImageSlides=1 && slideShowRunning=1 && allImagesWereSeen!=1)
        {
           If retrieveSeenImageDBentry(r, thisIndex)
           {
              countSeen++
              Continue
           }
        }

        ignoreFileCheck := (InStr(AprevImgCall, r) || InStr(BprevImgCall, r)) ? 1 : 0
        If (skipDeadFiles=1 && thumbsDisplaying!=1 && ignoreFileCheck!=1)
        {
           If !FileRexists(r)
              Continue
           Else
              Break
        } Else Break
   }

   ; ToolTip, % thisIndex "==" countSeen "==" delayu , , , 2
   If newIndex
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)

   If (countSeen >= maxFilesIndex - 1) || (!newIndex) ; || (allImagesWereSeen=1)
   {
      allImagesWereSeen := 1
      newIndex := (direction=-1) ? startIndex - 1 : startIndex + 1
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)
   }

   If (randomMode=1)
   {
      RandyIMGnow := newIndex
      newIndex := RandyIMGids[RandyIMGnow]
      if (newIndex>maxFilesIndex)
      {
         Random, thisIndex, 1, % maxFilesIndex
         RandyIMGids[RandyIMGnow] := thisIndex
         newIndex := thisIndex
      }
   }
   Return newIndex
}

PreviousPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && thumbsDisplaying!=1 && slideShowRunning!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(-1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Left", "+Left", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

NextPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && slideShowRunning!=1 && thumbsDisplaying!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Right", "+Right", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

Fnt_GetMultilineStringSizeDT(hFont, p_String, NoWrap, l_Width, ByRef r_Width, ByRef r_Height) {
    Static Dummy64026703
          ,DEFAULT_GUI_FONT:=17
          ,HWND_DESKTOP    :=0
          ,OBJ_FONT        :=6
          ,SIZE

          ;-- DrawText format
          ,DT_NOCLIP:=0x100
                ;-- Draws without clipping.  DrawText is somewhat faster when
                ;   DT_NOCLIP is used.

          ,DT_CALCRECT:=0x400
                ;-- Determines the width and height of the rectangle.  The text
                ;   is not drawn.

          ,DT_NOPREFIX:=0x800
                ;-- Turns off processing of prefix characters.

          ,DT_WORDBREAK:=0x10

    If (NoWrap=1)
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX
    Else
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX|DT_WORDBREAK

    r_Width := r_Height := 0
    ;-- If needed, get the handle to the default GUI font
    if (Gdi_GetObjectType(hFont)!="FONT")
       hFont := Gdi_GetStockObject(DEFAULT_GUI_FONT)

    ;-- Select the font into the device context for the desktop
    hDC      := Gdi_GetDC(HWND_DESKTOP)
    old_hFont:= Gdi_SelectObject(hDC, hFont)
    If !l_Width
       l_Width := 0

    ;-- Calculate the size of the string
    VarSetCapacity(RECT,16,0)
    NumPut(l_Width,RECT,8,"Int")                       ;-- right
    ; Gdi_SetTextCharSpacing(hDC, TextInAreaCharSpacing)
    E := DllCall("DrawText"
        ,"Ptr",hDC                                      ;-- hdc [in]
        ,"Str",p_String                                 ;-- lpchText [in, out]
        ,"Int",StrLen(p_String)                         ;-- cchText [in]
        ,"Ptr",&RECT                                    ;-- lprc [in, out]
        ,"UInt",s_DTFormat)                             ;-- uFormat [in]

    ;-- Release the objects needed by the DrawText function
    Gdi_SelectObject(hDC, old_hFont)
        ;-- Necessary to avoid memory leak

    Gdi_ReleaseDC(hDC, HWND_DESKTOP)
    r_Width := NumGet(RECT,8,"Int")
    r_Height := NumGet(RECT,12,"Int")
    Return E
}

drawInPlaceTextInBox(Gu, theString, txtOptions) {
    ; startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    ;  TextuToGraphics(Gu, theString, nul, txtOptions.fontu, "measure", 0, mainObju)
   Return TextuToGraphics(Gu, theString, txtOptions, txtOptions.fontu, "draw2", 0, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
}

drawTextInBox(theString, fntName, theFntSize, maxW, maxH, txtColor, bgrColor, NoWrap, flippable:=0, thisTextAlign:=0, BGRopacity:="0xDD", borderu:=0) {
    startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    If (FontBolded=1)
       txtStyle .= " Bold"
    If (FontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (flippable=1 && FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    borderSize := (NoWrap=1) ? Floor(theFntSize*1.2) : Floor(theFntSize*1.5)
    borderSize := borderu ? borderu : borderSize//3
    txtOptions := []
    txtOptions.x := borderSize
    txtOptions.y := borderSize
    txtOptions.w := maxW - borderSize*2
    txtOptions.h := maxH - borderSize*2
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := "0xEE" txtColor
    txtOptions.Size := theFntSize
    mainObju := TextuToGraphics(G, "initing", txtOptions, fntName, "begin", 0, 0, NoWrap)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    dims := TextuToGraphics(2NDglPG, theString, nul, fntName, "measure", 0, mainObju)
    dimsFw := clampInRange(dims.w + borderSize*2, 5, maxW)
    dimsFh := clampInRange(dims.h + borderSize*2, 5, maxH)

    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, dimsFw, dimsFh, coreDesiredPixFmt)
    If clipBMPa
       G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 5, 1)

    If (!G || !clipBMPa)
    {
       trGdip_DisposeImage(clipBMPa, 1)
       Return
    }

    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(G, fontQuality)
    trGdip_GraphicsClear(A_ThisFunc, G, BGRopacity bgrColor)
    ; Gdip_FillRectangle(G, pBr0, -2, -2, dimsFw + 3, dimsFh + 3)
    _E := TextuToGraphics(G, theString, txtOptions, fntName, "draw", 0, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    If (flippable=1)
       flipBitmapAccordingToViewPort(clipBMPa, 1)

    Gdip_DeleteGraphics(G)
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
    Return clipBMPa
}

TextuToGraphics(pGraphics, Text, OptionsObj, Font:="Arial", initMode:=0, Unit:=0, inObj:=0, NoWrap:=0) {

   Static Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
        , Alignments := "Near|Left|Centre|Center|Far|Right"
        , prevfontFam, hFontFamily, prevFontu, hFont, prevColor, pBrushu
        , prevFmtStyle, hStringFormat

   If (initMode="begin")
   {
      xpos := OptionsObj.x,  ypos := OptionsObj.y
      Width := OptionsObj.w, Height := OptionsObj.h
      Size := OptionsObj.Size

      If (prevfontFam!=Font || !hFontFamily)
      {
         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }

         prevfontFam := Font
         hFontFamily := Gdip_FontFamilyCreate(Font)
         If !hFontFamily
            hFontFamily := Gdip_FontFamilyCreateGeneric(1)
      }

      thisFontu := "a" hFontFamily Font OptionsObj.Styles Size Unit
      If (thisFontu!=prevFontu || !hFont)
      {
         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         Styleu := 0
         For eachStyle, valStyle in StrSplit(Styles, "|")
         {
            If RegExMatch(OptionsObj.Styles, "\b" valStyle)
               Styleu |= (valStyle != "StrikeOut") ? (A_Index-1) : 8
         }

         ; ToolTip, % options "`n" size " == " colour , , , 2
         hFont := Gdip_FontCreate(hFontFamily, Size, Styleu, Unit)
         If hFont
            prevFontu := thisFontu
      }

      thisFmtStyle := "a" NoWrap OptionsObj.Align
      If (thisFmtStyle!=prevFmtStyle || !hStringFormat)
      {
         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         FormatStyle := (NoWrap=1) ? 0x4000 | 0x1000 : 0x4000
         hStringFormat := Gdip_StringFormatCreate(FormatStyle)
         If !hStringFormat
            hStringFormat := Gdip_StringFormatGetGeneric(1)

         If hStringFormat
         {
            Align := 0
            prevFmtStyle := thisFmtStyle
            For eachAlignment, valAlignment in StrSplit(Alignments, "|")
            {
               If RegExMatch(OptionsObj.Align, "\b" valAlignment)
                  Align |= A_Index//2.1   ; 0|0|1|1|2|2
            }

            Gdip_SetStringFormatAlign(hStringFormat, Align)
            If InStr(OptionsObj.Styles, "autotrim")
               Gdip_SetStringFormatTrimming(hStringFormat, 3)
         }
      }

      If (OptionsObj.Color!=prevColor || !pBrushu)
      {
         pBrushu := Gdip_BrushCreateSolid(OptionsObj.Color)
         If pBrushu
            prevColor := OptionsObj.Color
      }

      If !(hFontFamily && hFont && hStringFormat && pBrushu)
      {
         E := !pGraphics ? -2 : !hFontFamily ? -3 : !hFont ? -4 : !hStringFormat ? -5 : !pBrushu ? -6 : 0
         If pBrushu
         {
            Gdip_DeleteBrush(pBrushu)
            pBrushu := ""
         }

         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }
         return E
      }


      obju := []
      obju.x := xpos,  obju.y := ypos
      obju.w := width, obju.h := height
      ; ToolTip, % hfont "`n" hStringFormat "`n" pBrush , , , 2
      Return obju
   }

   If (initMode="measure")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ; TOOLTIP, % inObj.x "--" inObj.y "--" inObj.w "--" inObj.h , , , 2
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      val := StrSplit(ReturnRC, "|")
      measure := []
      measure.x := Floor(val[1]), measure.y := Floor(val[2])
      measure.w := Ceil(val[3]), measure.h := Ceil(val[4])
      Return measure
   }

   If (initMode="draw")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      ReturnRCtest := StrSplit(ReturnRC, "|")
      testX := Floor(ReturnRCtest[1]) - 2
      If (testX>xpos) ; error correction for different text alignments
      {
         nxpos := Floor(inObj.x - (testX - inObj.x))
         CreateRectF(RC, nxpos, inObj.y, inObj.w, inObj.h)
         ; ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
         ; MsgBox, % nxpos "--" xpos "--" ypos "`n" width "--" height "`n" ReturnRC
      }

      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   } Else if (initMode="draw2")
   {
      CreateRectF(RC, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      ; Gdip_SetClipRect(pGraphics, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   }

   return _E ? _E : ReturnRC
}

HardWrapTextFontBased(TextToWrap, hFont, maxW, maxH, lineHeight) {
   ; Critical, on
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
        , maxCharsInWidth := 2048

   if (StrLen(TextToWrap)<=2)
      return TextToWrap

   TextToWrap := Trimmer(TextToWrap)
   thisIndex := thisH := linez := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   hDC := Gdi_GetDC()
   old_hFont := Gdi_SelectObject(hDC, hFont)
   maxLinez := Round(maxH/lineHeight) - 1
   thisCharSpacing := (TextInAreaCharSpacing>0) ? TextInAreaCharSpacing : 0
   Loop, Parse, TextToWrap
   {
       If (maxLinez<linez && linez>1)
          Break

       thisIndex++
       thisLineu .= A_LoopField
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
       {
          linez++
          thisLineu := ""
          thisIndex := hasMatchedRegEx := 0
          Continue
       }

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
          whereHasMatchedinLine := thisIndex
       }

       ; thisObj := Gdi_TruncateStringToFitWidth(hFont, A_Space thisLineu A_Space, maxW - TextInAreaCharSpacing * (StrLen(thisLineu) + 1))
       E := Gdi_GetTextExtentExPoint(hDC, A_Space thisLineu A_Space, maxW - thisCharSpacing * (StrLen(thisLineu) + 1), fitLength, w, h)
       ; ToolTip, % thisObj.fitLength "==" thisObj.width "==" thisObj.height "==" thisObj.stringLength "`n" thisLineu, , , 2
       stringLength := StrLen(thisLineu) + 1
       If (hasMatchedRegEx=1 && (stringLength>fitLength || stringLength>maxCharsInWidth))
       {
          linez++
          offsetu++
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          hasMatchedRegEx := 0
          If (thisLineu=A_Space)
             thisLineu := ""
          thisLineu := SubStr(thisLineu, whereHasMatchedinLine)
          thisIndex := StrLen(thisLineu)
       } Else If (stringLength>fitLength || stringLength>maxCharsInWidth)
       {
          linez++
          thisLineu := ""
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }
   w := Gdi_SelectObject(hDC, old_hFont)
   g := Gdi_ReleaseDC(hDC, 0)
   ; ToolTip, % w "|" g "." foundPos "==" startPos, , , 2
   return newLinez
}

SimpleHardWrapText(TextToWrap, LengthLim) {
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
   LengthLim := Round(LengthLim)
   if (LengthLim<2)
      return TextToWrap
   if (StrLen(TextToWrap) <= LengthLim + 1)
      return TextToWrap

   thisIndex := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   
   Loop, Parse, TextToWrap
   {
       thisIndex++
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
          thisIndex := hasMatchedRegEx := 0

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
       }

       If (thisIndex=LengthLim && hasMatchedRegEx=1)
       {
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          offsetu++
          thisIndex := hasMatchedRegEx := 0
       } Else If (thisIndex=LengthLim)
       {
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }

   ; ToolTip, % foundPos "==" startPos, , , 2
   return newLinez
}

Gdi_DrawTextInBox(theString, hFont, maxW, maxH, txtColor, bgrColor, borderSize:=0, NoWrap:=1, scaleuPreview:=1) {
    startZeit := A_TickCount
    ; dimsu := otherGetStringSize(fntName, theFntSize, 0, theString, NoWrap, maxW)
    ; ToolTip, % dimsu.w "--" dimsu.h " == " NoWrap "`n" theString , , , 2
    thisCharSpacing := Round(TextInAreaCharSpacing / scaleuPreview)
    Gdi_MeasureString(hFont, theString, 1, oW, oH)
    ; Fnt_GetMultilineStringSizeDT(hFont, theString, 1, 0, oW, oH)
    reAdjustWtxtspacing := (Abs(thisCharSpacing)//2) * StrLen(theString)
    reAdjustWtxtspacing := clampInRange(reAdjustWtxtspacing, 1, oW - 5)
    If (thisCharSpacing<0)
       oW := oW - reAdjustWtxtspacing
    Else
       oW := oW + thisCharSpacing * StrLen(theString)
    ; ToolTip, % oW "==" oH "==" reAdjustWtxtspacing , , , 2
    Gdip_GetRotatedDimensions(oW, oH, TextInAreaLineAngle/10, rWidth, rHeight)
    scaleu := Abs(TextInAreaLineAngle/900)
    scaleu2 := Abs((TextInAreaLineAngle*scaleu)/900)
    r_Width := rWidth + borderSize*2
    r_Height := rHeight + borderSize*2
    offsetY := (TextInAreaLineAngle<0) ? r_Width//2 - rWidth//2 : r_Height//2 - rHeight//2 + clampInRange(Floor(rHeight*(scaleu*1.9)), - rHeight*5, rHeight)
    offsetX := (TextInAreaLineAngle<0) ? r_Height//2 - rHeight//2 + Floor(rWidth*scaleu2)  : r_Width//2 - rWidth//2
    If (offsetY<(rHeight - oH + borderSize) && TextInAreaLineAngle>0)
       offsetY := Abs(rHeight - oH + borderSize)

    If (offsetX<borderSize)
       offsetX := borderSize

    If (TextInAreaOnlyBorder!=1 || TextInAreaBorderOut=1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDc, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), "0x" rgb2bgr(bgrColor))
       pBitmap := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDc, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hdc)
    }

    If (TextInAreaBorderSize>0 && TextInAreaBorderOut>1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDC, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextOutline(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), Round(TextInAreaBorderSize/scaleuPreview))
       If (TextInAreaBorderOut=3)
          Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x000000")
       pBitmap2 := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDC, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hDC)
    }

    ; Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     ; ToolTip, % r_width "=" r_height "`n" hbm "==" hdc "==" obm "`n" imgW "==" imgH, , , 2
    ; fnOutputDebug("draw text in box with GDI: " A_TickCount - startZeit " ms")
    Return [pBitmap, pBitmap2, r_Width, r_Height]
}

coreInsertTextInAreaBox(theString, maxW, maxH, previewMode) {
    Static OBJ_FONT := 6, testString := "This is going to a test", klop := 0

    Gdip_FromARGB("0xFF" TextInAreaFontColor, A, R, G, B)
    txtColor := Gdip_ToARGB(TextInAreaFontOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBorderColor, A, R, G, B)
    borderColor := Gdip_ToARGB(TextInAreaBorderOpacity, R, G, B)

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    fntQuality := (previewMode=1) ? 1 : 4
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400

    thisFactor := (zoomLevel<1) ? 1 - zoomLevel*2 + 1.25 : zoomLevel/2
    thisFactor += TextInAreaFontSize/80
    thisFactor := clampInRange(thisFactor, 1.3, 13)
    ; ToolTip, % "z=" thisFactor , , , 2

    thisLineAngle := (TextInAreaLineAngle<0) ? 3600 + TextInAreaLineAngle : TextInAreaLineAngle
    If !isNumber(thisLineAngle)
       thisLineAngle := 0

    hFontPreview := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize//thisFactor, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    thisBlurAmount := max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2
    borderSize := (TextInAreaUsrMarginz>0) ? TextInAreaUsrMarginz : TextInAreaBorderSize//2 + thisBlurAmount
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    Gdi_MeasureString(hFontPreview, testString, 1, testWb, testHb)
    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, clampInRange(testHa + TextInAreaFontLineSpacing, 2, maxH + 10)))
    Else
       theString := Trimmer(theString)

    scaleuPreview := (previewMode=1) ? testWa/testWb : 1
    ; ToolTip, % thisFactor "==" scaleuPreview , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    maxW := Round(maxW / scaleuPreview) ; + Round(5*TextInAreaFontSize*scaleuPreview)
    maxH := Round(maxH / scaleuPreview) ; + TextInAreaFontSize*2
    mainBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(mainBMP, A_ThisFunc)
       Return "fail"

    thisBlur := Round(TextInAreaBlurAmount / scaleuPreview)
    If (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       pEffect := Gdip_CreateEffect(1, thisBlur, 0, 0)

    thisBorderBlur := Round(TextInAreaBlurBorderAmount / scaleuPreview)
    If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       zEffect := Gdip_CreateEffect(1, thisBorderBlur, 0, 0)

    zBrush := Gdip_BrushCreateSolid(bgrColor)
    thisQuality := (previewMode=1) ? 5 : 7
    G := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP, thisQuality)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G, 2)

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && pEffect)
    {
       o_txtColor := txtColor
       txtColor := "0xFFffFFff"
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF000000")
    }

    thisY := thisX := 0
    maxedW := maxedH := 0
    minedX := maxW, minedY := maxH
    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0
    If (previewMode=1)
       borderSize := Round(borderSize/scaleuPreview)

    thisHFont := (previewMode=1) ? hFontPreview : hFont
    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    threads := (previewMode=1) ? realSystemCores//2 : 0
    Loop, Parse, theString, `n
    {
       ; If !Trimmer(A_LoopField)
       ;    Continue

       objBMPs := Gdi_DrawTextInBox(A_Space A_LoopField A_Space, thisHFont, maxW, maxH, "FFffFF", "000000", borderSize, 1, scaleuPreview)
       imgW := objBMPs[3], imgH := objBMPs[4]
       pBitmap := (doConturDraw=1 && TextInAreaOnlyBorder=1 && objBMPs[2]) ? objBMPs[2] : objBMPs[1]
       If (doConturDraw=1 && objBMPs[1] && TextInAreaOnlyBorder=1)
          trGdip_DisposeImage(objBMPs[1])

       pBitmapContours := objBMPs[2]
       If (TextInAreaAlign=2)
          thisX := maxW//2 - imgW//2
       If (TextInAreaAlign=3)
          thisX := maxW - imgW

       If (pEffect && (TextInAreaBgrUnified!=1 || TextInAreaPaintBgr!=1))
       {
          If (previewMode!=1 || userimgQuality=1)
             ApplySpecialFixedBlur(A_ThisFunc, pBitmap, thisBlur, pEffect)
          Else
             Gdip_BitmapApplyEffect(pBitmap, pEffect)
       }

       thisBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(thisBMP)<3
       {
          fattalErr := 1
          trGdip_DisposeImage(pBitmap, 1)
          Break
       }

       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)

       If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
       {
          ; trGdip_GraphicsClear(A_ThisFunc, G2)
          Gdip_FillRectangle(G2, zBrush, 0, 0, imgW, imgH)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 1, 0, 1, threads)
          thisOpacity := TextInAreaBgrOpacity/255
       } Else
       {
          thisColor := (TextInAreaOnlyBorder=1) ? borderColor : txtColor
          trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 0, 0, 1, threads)
          thisOpacity := 1
       }

       If (TextInAreaBgrUnified!=1 && TextInAreaPaintBgr=1)
       {
          If (TextInAreaCutOutMode!=1)
             Gdip_FillRectangle(G, zBrush, thisX, thisY, imgW, imgH)

          If (TextInAreaBgrEntire=1)
          {
             Gdip_SetClipRect(G, 0, thisY, maxW, imgH)
             Gdip_SetClipRect(G, thisX, thisY, imgW, imgH, 4)
             Gdip_FillRectangle(G, zBrush, 0, thisY, maxW, imgH)
             Gdip_ResetClip(G)
          }
       }

       forceW := (imgW>=maxW) ? maxW : imgW
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (doConturDraw=1 && TextInAreaOnlyBorder!=1 && pBitmapContours)
       {
          If zEffect
          {
             If (previewMode!=1 || userimgQuality=1)
                ApplySpecialFixedBlur(A_ThisFunc, pBitmapContours, thisBorderBlur, zEffect)
             Else
                Gdip_BitmapApplyEffect(pBitmapContours, zEffect)
          }

          thizBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
          G5 := trGdip_GraphicsFromImage(A_ThisFunc, thizBMP)
          If (userimgGammaCorrect=1)
             Gdip_SetCompositingQuality(G5, 2)

          trGdip_GraphicsClear(A_ThisFunc, G5, borderColor)
          QPV_SetAlphaChannel(thizBMP, pBitmapContours, 0, 0, 1, threads)
          trGdip_DrawImage(A_ThisFunc, G, thizBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
          trGdip_DisposeImage(pBitmapContours, 1)
          trGdip_DisposeImage(thizBMP, 1)
          Gdip_DeleteGraphics(G5)
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       drawFail := trGdip_DrawImage(A_ThisFunc, G, thisBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
       If (previewMode=1)
          thisY += imgH + Round(TextInAreaFontLineSpacing / scaleuPreview)
       Else
          thisY += imgH + TextInAreaFontLineSpacing
       trGdip_DisposeImage(pBitmap, 1)
       trGdip_DisposeImage(thisBMP, 1)
       Gdip_DeleteGraphics(G2)
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }
    }

    If (fattalErr=1)
       warnUserFatalBitmapError("no-gdip", A_ThisFunc)

    Gdi_DeleteObject(hFont)
    Gdi_DeleteObject(hFontPreview)
    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    ; ToolTip, % maxedW "==" maxedH " = " minedX "==" minedY , , , 2
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       newBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
       warnUserFatalBitmapError(newBMP, A_ThisFunc)
    }

    Gdip_DeleteGraphics(G)
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && StrLen(newBMP)>2)
    {
       If pEffect
       {
          If (previewMode!=1 || userimgQuality=1)
             ApplySpecialFixedBlur(A_ThisFunc, mainBMP, thisBlur, pEffect)
          Else
             Gdip_BitmapApplyEffect(mainBMP, pEffect)

          fBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH)
          G7 := trGdip_GraphicsFromImage(A_ThisFunc, fBMP)
          trGdip_GraphicsClear(A_ThisFunc, G7, o_txtColor)
          Gdip_DeleteGraphics(G7)
          QPV_SetAlphaChannel(fBMP, mainBMP, 0, 0, 1, threads)
          trGdip_DisposeImage(mainBMP)
          mainBMP := fBMP
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBMP)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G3, 2)

       If (TextInAreaRoundBoxBgr=1)
       {
          radius := Round(((maxedW + borderSize*2 + maxedH)//2.5)*0.1) + 1
          kPath := Gdip_CreatePath()
          Gdip_AddPathRoundedRectangle(kPath, minedX, minedY, maxedW, maxedH, radius)
          Gdip_SetClipPath(G3, kPath)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          Gdip_DeletePath(kPath)
       } Else
       {
          Gdip_SetClipRect(G3, minedX, minedY, maxedW, maxedH)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
       }
       Gdip_ResetClip(G3)
       trGdip_DrawImage(A_ThisFunc, G3, mainBMP, 0, 0)
       ; QPV_SetAlphaChannel(newBMP, mainBMP, TextInAreaCutOutMode)
       trGdip_DisposeImage(mainBMP, 1)
       Gdip_DeleteGraphics(G3)
       mainBMP := newBMP
    }

    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DeleteBrush(zBrush)
    obju := [mainBMP, minedX, minedY, maxedW, maxedH, scaleuPreview]
    Return obju
}

drawHistogram(dataArray, maxYlimit, LengthX, Scale, fgrColor, bgrColor, borderSize, infoBoxBMP) {
    Static graphHeight := 300 ; graph height
         , barWidth := 2
    ; ToolTip, % maxYlimit " || " LengthX  , , , 2
    PointsList .= -1 "," graphHeight + 1 "|"
    Loop, % LengthX
    {
        skipThis := 0
        y1 := dataArray[A_Index - 1]/maxYlimit
        If !y1
        {
           y1 := 0
           skipThis := 1
        }

        y1 := graphHeight - Round(graphHeight * y1)
        If (y1<0)
           y1 := 0
        Else If (y1>graphHeight - 1) && (skipThis=0)
           y1 := graphHeight - 1
        thisIndex := A_Index * barWidth - barWidth
        PointsList .= thisIndex - 1 ","  y1 "|" thisIndex ","  y1 "|"
    }

    PointsList .= thisIndex + 1 "," graphHeight + 1
    graphPath := Gdip_CreatePath()
    Gdip_AddPathPolygon(graphPath, PointsList) ; , 0.000001)
    pMatrix := Gdip_CreateMatrix()
    Gdip_ScaleMatrix(pMatrix, Scale/2, Scale/2, 1)
    Gdip_TransformPath(graphPath, pMatrix)
    thisRect := Gdip_GetPathWorldBounds(graphPath)
    imgW := Ceil(thisRect.w), imgH := Ceil(thisRect.h) + 1
    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
    If StrLen(clipBMPa)<2
    {
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Return
    }

    G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 7, 4)
    If G
    {
       If infoBoxBMP
          Gdip_GetImageDimensions(infoBoxBMP, imgW2, imgH2)

       clipBMP := trGdip_CreateBitmap(A_ThisFunc, imgW + borderSize * 2, imgH + Round(imgH2) + Round(borderSize*1.5), coreDesiredPixFmt)
       If StrLen(clipBMP)<2
       {
          Gdip_DeletePath(graphPath)
          Gdip_DeleteMatrix(pMatrix)
          trGdip_DisposeImage(clipBMPa, 1)
          Gdip_DeleteGraphics(G)
          Return
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, clipBMP)
       If G3
       {
          pBr1 := Gdip_BrushCreateSolid(fgrColor)
          Gdip_FillPath(G, pBr1, graphPath)
          Gdip_GetImageDimensions(clipBMP, maxW, maxH)
          lineThickns := borderSize//8
          Gdip_SetPenWidth(pPen1d, lineThickns)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          ; Gdip_FillRectangle(G3, pBr0, -2, -2, maxW + borderSize*2+12, maxH + borderSize*3)
          Gdip_FillRectangle(G3, pBrushE, borderSize, borderSize, imgW, imgH)
          Gdip_DrawRectangle(G3, pPen1d, borderSize - lineThickns, borderSize - lineThickns, imgW + lineThickns*2, imgH + lineThickns*2)
          HUDobjHistoBoxu[5] := imgW + lineThickns*2 + borderSize
          HUDobjHistoBoxu[6] := imgH + lineThickns*2 + borderSize
          trGdip_DrawImage(A_ThisFunc, G3, clipBMPa, borderSize, borderSize)
          trGdip_DrawImage(A_ThisFunc, G3, infoBoxBMP, borderSize//3, imgH + borderSize*1.25)
          Gdip_DeleteGraphics(G3)
       }

       Gdip_DeleteGraphics(G)
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteBrush(pBr1)
    } Else clipBMP := ""
    trGdip_DisposeImage(clipBMPa, 1)
    ; ToolTip, % clipBMPa  "`n" clipBmp , , , 2
    ; tooltip, % maxYlimit ", " LengthX " || "  maxW "," maxH  ;  `n" PointsList
    Return clipBMP
}

PasteInPlaceNow() {
    allowOutside := 0
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && whichBitmap && imgW)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, 0, allowOutside)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       corePasteInPlaceActNow("kill")
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside=1)
    {
       nImgSelX1 := imgSelX1
       nImgSelY1 := imgSelY1
       nimgSelX2 := imgSelX2
       nimgSelY2 := imgSelY2
       If (imgSelX1>=0)
          imgSelX1 := 0
       Else
          zImgSelX1 := Abs(imgSelX1)

       If (imgSelY1>0)
          imgSelY1 := 0
       Else
          zImgSelY1 := Abs(imgSelY1)

       If (imgSelX2<imgW)
          imgSelX2 := imgW
       If (imgSelY2<imgH)
          imgSelY2 := imgH

       CropImageInViewPortToSelection("simplex")
       whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
       prevImgSelX1 += Round(zimgSelX1)
       prevImgSelY1 += Round(zimgSelY1)
       prevImgSelX2 += Round(zimgSelX1)
       prevImgSelY2 += Round(zimgSelY1)
       VPstampBMPx += Round(zimgSelX1)
       VPstampBMPy += Round(zimgSelY1)
       imgSelX1 := nimgSelX1 + Round(zimgSelX1)
       imgSelY1 := nimgSelY1 + Round(zimgSelY1)
       imgSelX2 := nimgSelX2 + Round(zimgSelX1)
       imgSelY2 := nimgSelY2 + Round(zimgSelY1)
       editingSelectionNow := 1
       hasRanExpand := 1
       ; Return
    }

    startZeit := A_TickCount
    If (UserMemBMP!=whichBitmap && whichBitmap)
    {
       fnOutputDebug(A_ThisFunc ": cloning GDI+ bitmap: " whichBitmap)
       whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
       wasClone := whichBitmap
    } Else If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
       whichBitmap := ""

    thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    If StrLen(whichBitmap)>2
    {
       fnOutputDebug(A_ThisFunc ": create graphics")
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisImgQuality, 4,, compositingQuality)
    }

    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(wasClone, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    recordUndoLevelNow("init", 0)
    ; setImageLoading()
    r1 := corePasteInPlaceActNow(G2, whichBitmap)
    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       currIMGdetails.HasAlpha := 1

    Gdip_DeleteGraphics(G2)
    corePasteInPlaceActNow("kill")
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "(): transformations ended. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    RefreshImageFile()
    If (hasRanExpand=1)
    {
       ; SoundBeep 
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       SetTimer, dummyRefreshImgSelectionWindow, -125
    }

}

realtimePasteInPlaceRotater(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState, hasRotated
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceBlurEdgesSoft
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return hasRotated
    }

    hasRotated := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return 0

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := JimgW/vpImgW

    Gdip_GetImageDimensions(clipBMP, eImgW, eImgH)
    If (PasteInPlaceOrientation=2)
       ER := Gdip_ImageRotateFlip(clipBMP, 4)
    Else If (PasteInPlaceOrientation=3)
       ER := Gdip_ImageRotateFlip(clipBMP, 6)
    Else If (PasteInPlaceOrientation=4)
       ER := Gdip_ImageRotateFlip(clipBMP, 2)

    Gdip_GetRotatedDimensions(JimgW, JimgH, vPselRotation, testW, testH)
    If (testW*testH>maxGDIbmpSize) || (testW>32500) || (testH>32500)
       notOkayRotate := 1

    If (vPselRotation>0 && notOkayRotate!=1 && !ER)
    {
       setWindowTitle("Rotating image at " vPselRotation "°")
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, clipBMP, vPselRotation,"", thisImgQuality)
       If StrLen(xBitmap)>3
       {
          hasRotated := 1
          ; If (previewMode=1)
             clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
    }

    If (prevEllipseSelectMode>0 && PasteInPlaceToolMode=1 && vPselRotation>0 && hasRotated=1)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       Gdip_GetRotatedEllipseDimensions(eImgW, eImgH, vPselRotation, pBw, pBh)
       gFx := pBw/rimgW
       gFy := pBh/rimgH
       zwImgW := Round(rImgW * gFx)
       zwImgH := Round(rImgH * gFy)
       dX := (rImgW - zwImgW)//2
       dY := (rImgH - zwImgH)//2
       xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP, dX, dY, zwImgW, zwImgH)
       If StrLen(xBitmap)>3
       {
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
       ; ToolTip, % gFx " --- " gFy "`n" zwImgW " --- " zwImgH "`n" rImgW " --- " rImgH "`n" dX " --- " dY "`n" clipBMP , , , 2
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return hasRotated
}

createSelectionBlurryMask() {
    wPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    pB := GetPathRelativeBounds(wPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    Gdip_DeletePath(wPath)
    bRa := (EllipseSelectMode>0 || VPselRotation>0) ? blurAreaAmount*2 : blurAreaAmount
    gImgselPx := imgSelPx - bRa
    gImgselPy := imgSelPy - bRa
    gImgSelW := imgSelW + bRa * 2
    gImgselH := imgSelH + bRa * 2
}

realtimePasteInPlaceBlurrator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    newBitmap := ""

    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }
    thisState := "a" userClipBMPpaste PasteInPlaceBlurEdgesSoft viewportStampBMP previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceAdaptMode
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }
 
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return "fail"

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := vpImgW/JimgW
    thisAmount := 0
    If (PasteInPlaceBlurAmount>0)
    {
       setWindowTitle("Applying blur filter on image")
       If (previewMode!=1)
          QPV_SetGivenAlphaLevel(clipBMP, 1, 1)
       thisAmount := (previewMode=1) ? Round(PasteInPlaceBlurAmount * fScale) : PasteInPlaceBlurAmount
       thisAmount := clampInRange(thisAmount, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, thisAmount, pEffect, previewMode)
       Gdip_DisposeEffect(pEffect)
    }

    If (PasteInPlaceToolMode=1) ; && (prevVPselRotation>0 || prevEllipseSelectMode>0))
    {
       ; when used with the transform tool
       eimgW := max(prevImgSelX1, prevImgSelX2) - min(prevImgSelX1, prevImgSelX2)
       eimgH := max(prevImgSelY1, prevImgSelY2) - min(prevImgSelY1, prevImgSelY2)
       decX := prevImgSelX1 - VPstampBMPx
       decY := prevImgSelY1 - VPstampBMPy
       If (previewMode=1)
       {
          Gdip_GetImageDimensions(clipBMP, wImgW, wImgH)
          Gdip_GetImageDimensions(userClipBMPpaste, gImgW, gImgH)
          scaleu := gImgW/wImgW
          eimgW := Round(eimgW/scaleu)
          eimgH := Round(eimgH/scaleu)
          decX := Round(decX/scaleu)
          decY := Round(decY/scaleu)
       }

       pPath := createImgSelPath(0, 0, eImgW, eImgH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio)
       If pPath
       {
          carvePathFromBitmap(clipBMP, pPath, -decX, -decY, 4, PasteInPlaceBlurEdgesSoft + 1, thisAmount)
          Gdip_DeletePath(pPath)
       }
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlphaBMP, rImgW, rImgH, thisImgQuality:=0) {
    Static prevBMPu, prevState
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisBMP := userAlphaBMP
    thisChan := (PasteInPlaceAlphaChannelFile=5) ? 1 : 0
    thisState := "a" previewMode PasteInPlaceAlphaFile getIDimage(currentFileIndex) currentFileIndex FillAreaGradientAngle thisChan lastPaintEventID vPselRotation
    If (thisState=prevState && prevBMPu)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       trGdip_DisposeImage(thisBMP, 1)
       Return newBitmap
    }

    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    If (PasteInPlaceAlphaChannelFile=5)
    {
       bmpGray := retrieveImgChannel(thisBMP, PasteInPlaceAlphaChannelFile)
       If StrLen(bmpGray)>1
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := bmpGray
       }
    }

    If (FillAreaGradientAngle>0 && thisBMP)
    {
       changeMcursor()
       thisMono := (FillAreaColorReversed!=1) ? "0xFF000000" : "0xFFFFFFFF"
       thisMonoBrush := Gdip_BrushCreateSolid(thisMono)
       xMask := trGdip_RotateBitmapAtCenter(A_ThisFunc, thisBMP, FillAreaGradientAngle, thisMonoBrush, thisImgQuality)
       If StrLen(xMask)>2
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := xMask
       } Else ER := "fail"
       Gdip_DeleteBrush(thisMonoBrush)
    } Else If !thisBMP
       ER := "fail"

    If ER
    {
       trGdip_DisposeImage(thisBMP, 1)
       Return
    }

    alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, thisBMP, rImgW, rImgH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(thisBMP, 1)

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : alphaMaskGray
    prevState := thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? alphaMaskGray : trGdip_CloneBitmap(A_ThisFunc, alphaMaskGray)
    Return newBitmap
}

useGdiBitmap(doConvertPARG:=0) {
   If StrLen(gdiBitmap)>3
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(gdiBitmap, 1)
      If (thisPixFmt!="0xE200B" && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
          trGdip_DisposeImage(gdiBitmap, 1)
          gdiBitmap := newBitmap
      }
      Return gdiBitmap
   } Else If StrLen(UserMemBMP)>3
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(UserMemBMP, 1)
      If (thisPixFmt!="0xE200B" && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP)
          trGdip_DisposeImage(UserMemBMP, 1)
          UserMemBMP := newBitmap
      }
      Return UserMemBMP
   }
   Else Return
}

retrieveImgChannel(pBitmap, convertGray) {
   If isInRange(convertGray, 1, 4)
   {
      bmpGray := trGdip_RetrieveBitmapChannel(pBitmap, convertGray)
   } Else If (convertGray=5)
   {
      thisValue := (isWinXP=1) ? 0 : -45
      bmpGray := trGdip_BitmapConvertGray(pBitmap, 0, thisValue, 1, 0, "0xE200B")
   }
   Return bmpGray
}

LoadCachableBitmapFromFile(imgPath) {
   Static prevBMPu, prevState
   If (imgPath="kill")
   {
      prevState := 0
      prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
      Return
   }

   thisState := "a" generateThumbName(imgPath, 1) "=-=b"
   If (thisState=prevState && prevBMPu && FileRexists(imgPath))
   {
      newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
      Return newBitmap
   }

   prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
   pBitmap := LoadBitmapFromFileu(imgPath)
   If StrLen(pBitmap)>1
   {
      zBitmap := cloneGDItoMem(A_ThisFunc, pBitmap)
      If StrLen(zBitmap)>1
      {
         trGdip_DisposeImage(pBitmap, 1)
         pBitmap := zBitmap
      }
   } Else
   {
      addJournalEntry(A_ThisFunc "() failed: unable to load image file")
      Return
   }

   prevBMPu := (minimizeMemUsage=1) ? 0 : pBitmap
   prevState := (pBitmap && minimizeMemUsage!=1) ? thisState : 0

   If pBitmap
      newBitmap := (minimizeMemUsage=1) ? pBitmap : trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   Return newBitmap
}

QPV_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask:=0, replaceSourceAlphaChannel:=0, whichChannel:=1, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask, replaceSourceAlphaChannel, whichChannel)
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (w2!=w || h2!=h || !pBitmap || !pBitmapMask)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, 0, 0, w, h, stride, mScan, mData, 1)
  func2exec := (A_PtrSize=8) ? "SetAlphaChannel" : "_SetAlphaChannel@32"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", invertAlphaMask, "Int", replaceSourceAlphaChannel, "Int", whichChannel, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_EraserBrush(pBitmap, pBitmapMask, invertAlphaMask, replaceMode, levelAlpha, offsetX, offsetY, clonescu) {
  ; thisStartZeit := A_TickCount
  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (!pBitmap || !pBitmapMask)
     Return 0

  w3 := (offsetX<0) ? w2 - Abs(offsetX) : w2
  h3 := (offsetY<0) ? h2 - Abs(offsetY) : h2
  offX := (offsetX<0) ? Abs(offsetX) : 0
  offY := (offsetY<0) ? Abs(offsetY) : 0
  offsetX := (offsetX<0) ? 0 : offsetX
  offsetY := (offsetY<0) ? 0 : offsetY
  If (offsetX + w3>=w)
     w3 -= (offsetX + w3 - w)
  If (offsetY + h2>=h)
     h3 -= (offsetY + h3 - h)

  initQPVmainDLL()
  If (w3<1 || h3<1 || !qpvMainDll)
     Return 0

  E1 := Gdip_LockBits(pBitmap, offsetX, offsetY, w3, h3, strideA, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, offX, offY, w3, h3, strideB, mScan, mData, 1)
  If clonescu
     E3 := Gdip_LockBits(clonescu, offsetX, offsetY, w3, h3, strideC, cScan, cData)

  func2exec := (A_PtrSize=8) ? "EraserBrush" : "_EraserBrush@32"
  If (!E1 && !E2)
  {
     useClone := (!E3 && clonescu) ? 1 : 0
     ; r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w3, "Int", h3, "Int", invertAlphaMask, "Int", replaceMode, "Int", levelAlpha, "Int", offX, "Int", offY, "Int", offsetX, "Int", offsetY, "int", w, "int", h, "int", w2, "int", h2, "Int", StrideA)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w3, "Int", h3, "Int", invertAlphaMask, "Int", replaceMode, "Int", levelAlpha, "UPtr", cScan, "int", useClone)

; klop := Gdip_GetImagePixelFormat(gdiBitmap, 2)
; klopa := Gdip_GetImagePixelFormat(UserMemBMP, 2)
; kloxa := Gdip_GetImagePixelFormat(pBitmapMask, 2)
; ToolTip, % r "=" ErrorLevel "=" A_LastError "`n" klop "`n" klopa "`n" kloxa "`n" "=" iScan "=" mScan "=" w2 "=" h2 "=" invertAlphaMask "=" replaceMode "=" levelAlpha "=" countClicks , , , 2
}

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  If (!E3 && clonescu)
     Gdip_UnlockBits(clonescu, cData)
  ; ToolTip, % "qpv_" r "=" e1 "=" e "`n" offsetX "=" offsetY "`n" w2 "=" h2, , , 2
  return r
}

QPV_SetGivenAlphaLevel(pBitmap, givenLevel, fillMissingOnly, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If isWinXP
     Return

  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "SetGivenAlphaLevel" : "_SetGivenAlphaLevel@24"
  If !E1
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", givenLevel, "Int", fillMissingOnly, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_BlendBitmaps(pBitmap, pBitmap2Blend, blendMode, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmap2Blend, w2, h2)
  ; ToolTip, % w "=" w2 "||" h "=" h2 , , , 2
  If (w2!=w || h2!=h || !pBitmap || !pBitmap2Blend)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmap2Blend, 0, 0, w, h, stride, mScan, mData)
  func2exec := (A_PtrSize=8) ? "BlendBitmaps" : "_BlendBitmaps@24"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", blendMode, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmap2Blend, mData)
  ; ToolTip, % "r=" r " =qpv= " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_CreateBitmapNoise(W, H, intensity, mode, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  If (!w || !h)
     Return 0

  pBitmap := trGdip_CreateBitmap(A_ThisFunc, W, H, "0x26200A")
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "RandomNoise" : "_RandomNoise@24"
  If !E1
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", intensity, "Int", mode, "Int", threads)

  ; ToolTip, % E1 "==" r " == " pBitmap "==" W "x" H, , , 2
  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return pBitmap
}

QPV_InStr(strBase, str2find) {
  return DllCall("qpvmain.dll\isInString", "WStr", strBase, "WStr", str2find)
  ; ToolTip, % r " = r" , , , 2
}

realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    If (previewMode="kill")
    {
       prevState := 0
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (coreDesiredPixFmt="0x21808")
       Return

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB PasteInPlaceAlphaMaskMode PasteInPlaceAlphaFile alphaMaskReplaceMode FillAreaGradientWrapped FillAreaColorReversed FillAreaGradientScale FillAreaGradientAngle FillAreaGradientPosA FillAreaGradientPosB alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceAlphaChannelFile lastPaintEventID vPselRotation
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    setWindowTitle("Applying alpha mask to image")
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)

    paintedImage := 0
    If (InStr(PasteInPlaceAlphaFile, "user-painted") && PasteInPlaceAlphaMaskMode=5)
       paintedImage := 1
    Else If (PasteInPlaceAlphaFile="self" || PasteInPlaceAlphaFile="this")
       PasteInPlaceAlphaFile := currentFileIndex
    Else If (PasteInPlaceAlphaFile="prev")
       PasteInPlaceAlphaFile := currentFileIndex - 1
    Else If (PasteInPlaceAlphaFile="next")
       PasteInPlaceAlphaFile := currentFileIndex + 1
    Else If (PasteInPlaceAlphaFile="last")
       PasteInPlaceAlphaFile := maxFilesIndex
    Else If (PasteInPlaceAlphaFile="first" || PasteInPlaceAlphaFile=0)
       PasteInPlaceAlphaFile := 1
    Else If (PasteInPlaceAlphaFile="obj")
       PasteInPlaceAlphaFile := -1

    thisAlphaFile := IsNumber(PasteInPlaceAlphaFile) ? getIDimage(PasteInPlaceAlphaFile) : PasteInPlaceAlphaFile
    If (isFileLocked(thisAlphaFile) && currentFileIndex!=PasteInPlaceAlphaFile)
       thisAlphaFile := ""

    ; ToolTip, % "l" PasteInPlaceAlphaMaskMode "==" thisAlphaFile "==" clipBMP "==" PasteInPlaceAlphaFile, , , 2
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return

    If (PasteInPlaceAlphaMaskMode=5 && (FileRexists(thisAlphaFile) || PasteInPlaceAlphaFile=-1))
    || (paintedImage=1 && StrLen(userAlphaMaskBmpPainted)>2)
    {
       If (paintedImage=1)
          userAlpha := trGdip_CloneBitmap(A_ThisFunc, userAlphaMaskBmpPainted)
       Else If (PasteInPlaceAlphaFile=-1)
          userAlpha := (previewMode=1) ? trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP) : trGdip_CloneBitmap(A_ThisFunc, userClipBMPpaste)
       Else
          userAlpha := (useGdiBitmap() && PasteInPlaceAlphaFile=currentFileIndex) ? trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap()) : LoadCachableBitmapFromFile(thisAlphaFile)

       ; ToolTip, % thisAlphaFile "--" PanelPasteInPlace "--" userAlpha , , , 2
       Gdip_GetImageDimensions(userAlpha, testImgW, testImgH)
       threads := (previewMode=1) ? realSystemCores//2 : 0
       If (StrLen(userAlpha)>2 && testImgW && testImgH)
       {
          Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
          brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
          contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
          thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
          alphaMaskGray := realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlpha, rImgW, rImgH, thisImgQuality)
          If !alphaMaskGray
          {
             addJournalEntry(A_ThisFunc ": failed to rotate alpha mask.")
             Return
          }

          pEffect := Gdip_CreateEffect(5, brLvl, contrLvl)
          pBlurEffect := Gdip_CreateEffect(1, thisAlphaBlur, 0)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          If (thisAlphaBlur>1)
             Gdip_BitmapApplyEffect(alphaMaskGray, pBlurEffect)
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeEffect(pBlurEffect)
          thisChannel := (PasteInPlaceAlphaChannelFile=5) ? 1 : PasteInPlaceAlphaChannelFile
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, thisChannel, threads)
          ; ToolTip, % clipBMP "--" alphaMaskGray "--" userAlpha , , , 2
          ResetImgLoadStatus()
          trGdip_DisposeImage(alphaMaskGray, 1)
       } Else addJournalEntry(A_ThisFunc ": failed to retrieve alpha mask image.")
       SetTimer, ResetImgLoadStatus, -100
    } Else If (PasteInPlaceAlphaMaskMode=6 && customShapePoints.Count()>1)
    {
       tensionLvl := Round(PasteInPlaceAlphaMaskClrB/255, 2)
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       pEffect := Gdip_CreateEffect(1, PasteInPlaceAlphaMaskClrA, 0)
       alphaPath := Gdip_CreatePath()
       fAgScal := (FillAreaGradientScale + 2)/100
       tempArray := StrSplit(initialCustomShapeCoords, "|")
       calcIMGdimensions(tempArray[3], tempArray[4], rImgW, rImgH, rW, rH)
       tRimgW := (tempArray[3]>1) ? Round(rW*fAgScal) : Round(rImgW*fAgScal)
       tRimgH := (tempArray[4]>1) ? Round(rH*fAgScal) : Round(rImgH*fAgScal)
       offX := rImgW - tRimgW + Round((rImgW*alphaMaskOffsetX)*(fAgScal+1))
       offY := rImgH - tRimgH + Round((rImgH*alphaMaskOffsetY)*(fAgScal+1))
       PointsList := convertCustomShape2givenArea(customShapePoints, 1 + offX//2, 1 + offY//2, tRimgW - 2, tRimgH - 2)
       If (PasteInPlaceAlphaMaskClrB<15 && alphaPath)
          Gdip_AddPathPolygon(alphaPath, PointsList)
       Else If alphaPath
          Gdip_AddPathClosedCurve(alphaPath, PointsList, tensionLvl)

       If (FillAreaGradientAngle>0 && alphaPath)
          Gdip_RotatePathAtCenter(alphaPath, FillAreaGradientAngle)

       G4 := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray, 7, 4)
       trGdip_GraphicsClear(A_ThisFunc, G4, "0xFF000000")
       ; BrushA := Gdip_BrushCreateSolid("0xFF000000")
       ; Gdip_FillRectangle(G4, BrushA, -2, -2, rImgW + 2, rImgH + 2)
       If G4
       {
          BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
          Gdip_FillPath(G4, BrushB, alphaPath)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }
       ResetImgLoadStatus()
       Gdip_DisposeEffect(pEffect)
       Gdip_DeletePath(alphaPath)
       ; Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteGraphics(G4)
       trGdip_DisposeImage(alphaMaskGray, 1)
       SetTimer, ResetImgLoadStatus, -100
       ; trGdip_DisposeImage(clipBmp, 1)
       ; clipBmp := alphaMaskGray
    } Else If isInRange(PasteInPlaceAlphaMaskMode, 2, 4)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       zpw := PasteInPlaceAlphaMaskClrA
       zpu := PasteInPlaceAlphaMaskClrB
       thisColorA := Gdip_ToARGB("0xFF", zpw, zpw, zpw)
       thisColorB := Gdip_ToARGB("0xFF", zpu, zpu, zpu)
       ; ToolTip, % thisColorA "`n" thisColorB, , , 2
       brImgSelW := rImgW*(FillAreaGradientScale/100)
       brImgSelH := rImgH*(FillAreaGradientScale/100)
       brimgSelPx := 0 - (brImgSelW - rImgW)//2
       brimgSelPy := 0 - (brImgSelH - rImgH)//2
       gradientWrapMode := (FillAreaGradientWrapped=1) ? 3 : 4
       If (PasteInPlaceAlphaMaskMode=2)
       {
          gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
          If gradBrush
          {
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
             Gdip_RotateLinearGrBrushAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetLinearGrBrushWrapMode(gradBrush, gradientWrapMode)
          }
       } Else If (PasteInPlaceAlphaMaskMode=3 || PasteInPlaceAlphaMaskMode=4)
       {
          grpPath := Gdip_CreatePath()
          If (PasteInPlaceAlphaMaskMode=3 && grpPath)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else If grpPath
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          If grpPath
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)

          If gradBrush
          {
             Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*alphaMaskOffsetX), 0 + rImgH//2 + Round(rImgH*alphaMaskOffsetY))
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
             Gdip_RotatePathGradientAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
          }

          Gdip_DeletePath(grpPath)
       }

       thisEllipsMod := (PasteInPlaceToolMode>0) ? prevEllipseSelectMode : EllipseSelectMode
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray)
       ; thisColorC := (FillAreaColorReversed=1) ? 
       If Ga
       {
          pPath := createImgSelPath(-Round(rImgW*0.2), -Round(rImgH*0.2), Round(rImgW*1.45), Round(rImgH*1.45), thisEllipsMod)
          trGdip_GraphicsClear(A_ThisFunc, Ga, thisColorB)
          If pPath
             Gdip_FillPath(Ga, gradBrush, pPath)

          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteBrush(gradBrush)
       Gdip_DeleteGraphics(Ga)
       ; trGdip_DisposeImage(clipBMP, 1)
       ; clipBMP := newBitmap
       trGdip_DisposeImage(alphaMaskGray, 1)
       ; clipBMP := alphaMask
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return
}

addBorder2Bitmap(ByRef pBitmap, aX, aY, bgrColor:=0) {
    ; unused function
    Gdip_GetImageDimensions(pBitmap, imgW, imgH)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW + aX*2, imgH + aY*2, coreDesiredPixFmt)
    If newBitmap
    {
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       {
          If bgrColor
             trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor, 1)

          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, 0, 0, imgW + aX*2, imgH + aY*2)
          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, aX, aY)
          If (r2!="fail")
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
             Return 1
          }
          Gdip_DeleteGraphics(G3)
       }
    }
}

applyPersonalizedColorsBMP(clipBMP, doBlur, blurStrength, applyColorFX) {
    canApplyFX := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomHue>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomHue
          gR := Randomizer(-gR, gR, 2, 10)
          H := clampInRange(PasteInPlaceHue + gR, -180, 180)
       } Else H := PasteInPlaceHue
 
       If (BrushToolRandomSat>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomSat
          gR := Randomizer(-gR, gR, 2, 11)
          S := clampInRange(PasteInPlaceSaturation + gR, -100, 100)
       } Else S := PasteInPlaceSaturation

       zEffect := Gdip_CreateEffect(6, H, S, 0)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    canApplyFX := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomLight>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomLight
          gR := Randomizer(-gR, gR, 8, 8)
          L := clampInRange(PasteInPlaceLight + gR, -255, 255)
          ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
       } Else L := PasteInPlaceLight

       If (BrushToolRandomDark>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomDark
          gR := Randomizer(-gR, gR, 8, 9)
          D := clampInRange(PasteInPlaceGamma + gR, -100, 100)
       } Else D := PasteInPlaceGamma

       zEffect := Gdip_CreateEffect(5, L, D)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (blurStrength>2 && doBlur=1)
    {
       pEffect := Gdip_CreateEffect(1, blurStrength, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, blurStrength, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
    }
}

corePasteInPlaceActNow(G2:=0, whichBitmap:=0, brushingMode:=0) {
    Critical, on
    Static prevImgCall, prevClipBMP, eImgW, eImgH, hasRotated, thisHasRan
         , lastInvoked := 1

    If (G2="kill" && thisHasRan=1)
    {
       ; fnOutputDebug("remove transform tool caches")
       thisHasRan := 0
       LoadCachableBitmapFromFile("kill")
       realtimePasteInPlaceRotater("kill", 2, lol)
       realtimePasteInPlaceBlurrator("kill", 2, lol)
       realtimePasteInPlaceAlphaMasker("kill", 2, lol)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
       viewportIDstampBMP := ""
       Return
    }

    If (PasteInPlaceLivePreview!=1 && !G2) || (G2="kill")
       Return

    If (G2)
    {
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=0)
          QPV_SetGivenAlphaLevel(userClipBMPpaste, 1, 1)
       ; Else If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=1)
       ;    rz := addBorder2Bitmap(userClipBMPpaste, PasteInPlaceBlurAmount, PasteInPlaceBlurAmount)

       clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       If StrLen(clipBMP)<3
          Return "fail"

       If (PasteInPlaceToolMode!=1)
          flipBitmapAccordingToViewPort(clipBMP, 1)

       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
       previewMode := 0
    } Else
    {
       ; If (A_TickCount - lastInvoked < 60)
       ;    Return
       lastInvoked := A_TickCount
       G2 := 2NDglPG
       thisImgQuality := 5
       previewMode := 1
       Gdip_ResetClip(G2)
       ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
       thisImgCall := getIDimage(currentFileIndex) currentFileIndex viewportStampBMP viewportIDstampBMP PasteInPlaceOrientation vPselRotation PasteInPlaceBlurAmount PasteInPlaceAlphaMaskMode PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB FillAreaColorReversed FillAreaGradientScale FillAreaGradientPosA FillAreaGradientPosB FillAreaGradientWrapped FillAreaGradientAngle PasteInPlaceAlphaFile alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceLight PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceGamma PasteInPlaceApplyColorFX PasteInPlaceBlendMode PasteInPlaceAlphaChannelFile PasteInPlaceBlurEdgesSoft lastPaintEventID liveDrawingBrushTool brushingMode
       If (prevImgCall=thisImgCall && StrLen(prevClipBMP)>2)
       {
          hasCached := 1
          clipBMP := prevClipBMP
          If (brushingMode=1)
             Return [hasRotated, clipBMP]
       } Else
       {
          prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
       }
    }
 
    thisHasRan := 1
    If (hasCached!=1)
    {
       If (PasteInPlaceBlurAmount>0) || (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode>0))
       {
          realtimePasteInPlaceBlurrator(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       If (PasteInPlaceOrientation>1 || vPselRotation>0)
       {
          hasRotated := realtimePasteInPlaceRotater(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       } Else hasRotated := 0

       If (PasteInPlaceAlphaMaskMode>1 && brushingMode!=1)
       {
          ; thisStartZeit := A_TickCount
          realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, newBitmap)
          ; ToolTip, % A_TickCount - thisStartZeit, , , 2
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       applyPersonalizedColorsBMP(clipBMP, 0, 0, PasteInPlaceApplyColorFX)
    }

    Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, vPselRotation, ResizedW, ResizedH)
    ; fnOutputDebug("hello4")

    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1 && brushingMode!=1)
       PasteInPlaceEraseArea(G2, previewMode)

    Gdip_ResetClip(G2)
    vPobju := testSelectionLargerThanViewport()
    If (previewMode=1 && brushingMode!=1)
       Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)

    If (PasteInPlaceCropSel>1 && brushingMode!=1)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel - 1)
       If (PasteInPlaceCropSel=4 || PasteInPlaceCropSel=5)
          PersonalizedRotatePath(pPath, vPselRotation + PasteInPlaceCropAngular, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation + PasteInPlaceCropAngular, 1, 1, rotateSelBoundsKeepRatio)

       ; If (PasteInPlaceBlurAmount>1 && PasteInPlaceBlurEdgesSoft=1 && previewMode!=1)
       ;    carvePathFromBitmap(clipBmp, pPath, imgSelPx, imgSelPy, 4, PasteInPlaceBlurEdgesSoft + 1, clampInRange(PasteInPlaceBlurAmount, 1, 255))
       ; Else
          Gdip_SetClipPath(G2, pPath, 1)
    }

    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    If (PasteInPlaceBlendMode>1 && isNumber(PasteInPlaceBlendMode))
    {
       ; fnOutputDebug("hello5")
       thisImgTempQuality := (userimgQuality=1 && previewMode!=1) ? 3 : 5
       If (oImgW*oImgH>ResizedW*ResizedH)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, clipBMP, ResizedW, ResizedH, 0, thisImgQuality, 0, 0)
          If StrLen(tempBMP)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := tempBMP
          }

          Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
       }

       If (PasteInPlaceGlassy=2)
          BlurAmount := 15
       Else If (PasteInPlaceGlassy=3)
          BlurAmount := 50
       Else If (PasteInPlaceGlassy=4)
          BlurAmount := 120
       Else If (PasteInPlaceGlassy=5)
          BlurAmount := 180
       Else If (PasteInPlaceGlassy=6)
          BlurAmount := 250
       Else
          BlurAmount := 0

       If (imgSelOutViewPort=1 || vPobju.isLarger=1)
          BlurAmount := 0

       bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, BlurAmount)
       If StrLen(bgrBMP)>2
       {
          setWindowTitle("Applying blending mode")
          thisStartZeit := A_TickCount
          factoru := (previewMode=1) ? 2 : 3
          delayu := (previewMode=1) ? -1 : 2
          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMP, clipBMP, PasteInPlaceBlendMode - 1, threads)
          ; Gdip_GetImageDimensions(clipBMP, gimgW, gimgH)
          ; Gdip_BlendBitmaps(bgrBMP, clipBMP, PasteInPlaceBlendMode - 1)
          ; ToolTip, % gImgW "===" gImgH "`n" ResizedW "===" ResizedH , , , 2
       }
    }

    thisBMP := (bgrBMP && PasteInPlaceBlendMode>1) ? bgrBMP : clipBMP
    If (brushingMode=1)
    {
       If (PasteInPlaceCropSel>1)
       {
          Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//11)
          Gdip_DrawPath(G2, pPen1d, pPath)
       }
       prevImgCall := ""
       prevClipBMP := clipBMP
       Return [hasRotated, thisBMP, bgrBMP]
    }

    If (userimgGammaCorrect=1 && previewMode=1)
    {
       Gdip_SetCompositingQuality(G2, 2)
       bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH)
       If bgrBMPu
       {
          trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, ResizedW, ResizedH, 0, 0, oImgW, oImgH)
          trGdip_DisposeImage(bgrBMPu)
       }
    }

    thisOpacity := (PasteInPlaceOpacity>128) ? (PasteInPlaceOpacity - 128) : PasteInPlaceOpacity
    thisOpacity := (PasteInPlaceOpacity>128) ? thisOpacity/128 * 25 + 1 : thisOpacity/128
    setWindowTitle("Scaling image to selection area")
    If (thisBMP && G2)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, ResizedW, ResizedH, 0, 0, oImgW, oImgH, thisOpacity)

    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    Gdip_ResetClip(G2)
    trGdip_DisposeImage(bgrBMP, 1)
    If (bgrBMP=thisBMP && PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       PasteInPlaceEraseArea(G2, previewMode)

    setWindowTitle(pVwinTitle, 1)
    If (previewMode=1)
    {
       If (PasteInPlaceCropSel>1)
       {
          Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//11)
          Gdip_DrawPath(G2, pPen1d, pPath)
       }
       lastInvoked := A_TickCount
       thisImgQuality := (userimgQuality=1) ? 7 : 5
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(clipBmp, 1)
       ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    } Else
    {
       trGdip_DisposeImage(clipBMP, 1)
       ; userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    }

    Gdip_DeletePath(pPath)
}

PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, ByRef imgSelPx, ByRef imgSelPy) {
    If (PasteInPlaceAlignment=2)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
    } Else If (PasteInPlaceAlignment=3)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)//2
       imgSelPy := imgSelPy + (imgSelH - ResizedH)//2
    } Else If (PasteInPlaceAlignment=4)
    {
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    } Else If (PasteInPlaceAlignment=5)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    }

    imgSelPx := Round(imgSelPx)
    imgSelPy := Round(imgSelPy)
}

PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, anglu, ByRef ResizedW, ByRef ResizedH) {
    calcIMGdimensions(oImgW, oImgH, imgSelW, imgSelH, ResizedW, ResizedH)
    If (previewMode=1)
    {
       Gdip_GetImageDimensions(userClipBMPpaste, qImgW, qImgH)
       If (anglu>0 && hasRotated=1)
       {
          If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
             Gdip_GetRotatedEllipseDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
          Else
             Gdip_GetRotatedDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
       }
    }

    If (PasteInPlaceAdaptMode=3)
    {
       ResizedW := oImgW
       ResizedH := oImgH
       If (previewMode=1)
       {
          If (PasteInPlaceAdaptMode=3)
          {
             ; fnOutputDebug("hello9")
             Gdip_GetImageDimensions(userClipBMPpaste, ResizedW, ResizedH)
             ; fnOutputDebug("hello09")
             If (anglu>0 && hasRotated=1)
             {
                If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
                   Gdip_GetRotatedEllipseDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
                Else
                   Gdip_GetRotatedDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
             }
          }
          ResizedW := ResizedW * zoomLevel
          ResizedH := ResizedH * zoomLevel
       }
    } Else If (PasteInPlaceAdaptMode=2)
    {
       ResizedW := imgSelW
       ResizedH := imgSelH
    }

    If (ResizedW*ResizedH>maxGDIbmpSize)
       calcIMGdimensions(ResizedW, ResizedH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), ResizedW, ResizedH)

    If (ResizedW>32500 || ResizedH>32500)
       calcIMGdimensions(ResizedW, ResizedH, 32500, 32500, ResizedW, ResizedH)
     
     ResizedW := Round(ResizedW), ResizedH := Round(ResizedH)
}

getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, imgSelW, imgSelH, BlurAmount:=0) {
    Static prevBMPu, prevBlurredBMP, prevState, prevFXid
    If (previewMode="kill")
    {
       prevState := prevFXid := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       Return
    }

    If (previewMode=1)
    {
       thisFXid := decideGDIPimageFX(matrix, imageAttribs, pEffect)
       thisFXid .= (BlurAmount>1) ? "." BlurAmount zoomLevel : "."
       thisFXid .= "Z" FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode

       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       thisState := "a" currentFileIndex getIDimage(currentFileIndex) imgSelPx imgSelPy oImgW oImgH imgSelW imgSelH currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode undoLevelsRecorded UserMemBMP ViewPortBMPcache
       If (thisFXid=prevFXid && thisState=prevState && StrLen(prevBMPu)>2)
       {
          Gdip_DisposeEffect(pEffect)
          newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
          Return newBitmap
       }

       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       If (thisFXid!=prevFXid || StrLen(prevBlurredBMP)<3)
       {
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
          If StrLen(ViewPortBMPcache)>2
          {
             prevBlurredBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          } Else
          {
             prevFXid := prevState := ""
             Return
          }

          If (pEffect && prevBlurredBMP)
          {
             Gdip_BitmapApplyEffect(prevBlurredBMP, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          If (imageAttribs && prevBlurredBMP)
          {
             G2 := trGdip_GraphicsFromImage(A_ThisFunc, prevBlurredBMP, 3)
             If G2
                r1 := trGdip_DrawImage(A_ThisFunc, G2, prevBlurredBMP,,,,,,,,,,, imageAttribs)
             Gdip_DeleteGraphics(G2)
          }

          If (BlurAmount>1 && prevBlurredBMP)
          {
             BlurAmount := Round(BlurAmount*zoomLevel)
             BlurAmount := clampInRange(BlurAmount, 1, 255)
             zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, prevBlurredBMP, BlurAmount, zEffect, 1)
             Gdip_DisposeEffect(zEffect)
          }
          prevFXid := thisFXid
       } Else Gdip_DisposeEffect(pEffect)

       thisBMP := prevBlurredBMP
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0,1)
       If (minimizeMemUsage=1 && StrLen(prevBlurredBMP)>2)
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       ; ToolTip, % zBitmap "==" imgSelPx "==" imgSelPy "`n" imgSelW "--" imgSelH , , , 2
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If ((oImgW!=imgSelW || oImgH!=imgSelH) && zBitmap)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, oImgW, oImgH, 0, thisImgQuality, 0, 0)
          If tempBMP
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := tempBMP
          }
       }

       prevState := (minimizeMemUsage=1) ? 0 : thisState
       newBitmap := (minimizeMemUsage=1) ? zBitmap : trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       prevBMPu := (minimizeMemUsage=1) ? 0 : zBitmap
       Return newBitmap
    }

    whichBitmap := StrLen(UserMemBMP)>3 ? UserMemBMP : useGdiBitmap()
    If (imgFxMode>1)
       whichBitmap := useGdiBitmap()

    If !whichBitmap
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): ERROR. No bitmap to process.")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
    MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX1, imgY1)
    MouseCoords2Image(imgSelPx + imgSelW, imgSelPy + imgSelH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX2, imgY2)

    ; givenCoords := imgSelPx//zoomLevel "|" imgSelPy//zoomLevel "|" Round((imgSelPx + imgSelW)/zoomLevel) "|" Round((imgSelPy + imgSelH)/zoomLevel)
    givenCoords := imgX1 "|" imgY1 "|" imgX2 "|" imgY2 
    calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
       Return

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 2, 1)

    If (pEffect && zBitmap)
       Gdip_BitmapApplyEffect(zBitmap, pEffect)

    Gdip_DisposeEffect(pEffect)
    Gdip_GetImageDimensions(zBitmap, gimgW, gimgH)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 3)
    If G2
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, oImgW, oImgH, 0, 0, gimgW, gimgH,,, imageAttribs)

    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DeleteGraphics(G2)
    If (!G2 || !zBitmap)
    {
       trGdip_DisposeImage(newBitmap, 1)
       Return
    }

    If (BlurAmount>1 && G2)
    {
       BlurAmount := Round(BlurAmount)
       BlurAmount := clampInRange(BlurAmount, 2, 254)
       zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, BlurAmount, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    prevState := 0
    Return newBitmap
}

destroyGDIfileCache(remAll:=1, makeBackup:=0) {
    If (remAll=0)
    {
       imgPath := StrReplace(getIDimage(currentFileIndex), "||")
       MD5name := generateThumbName(imgPath, 1)
       If InStr(gdiBitmapIDcall, "a1" MD5name imgPath)
       {
          If (makeBackup=1)
          {
             mainCall := SubStr(gdiBitmapIDcall, 3)
             gdiBitmapIDcall := "a0" . mainCall
             gdiBitmap := cloneGDItoMem(A_ThisFunc, gdiBitmap)
             gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := xBitmap
             gdiBitmapIDentire := gdiBitmapIDcall xBitmap
          } Else gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
       }

       If InStr(BprevImgCall, "1" MD5name imgPath)
       {
          BprevImgCall := ""
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       }

       If InStr(AprevImgCall, "1" MD5name imgPath)
       {
          AprevImgCall := ""
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       }

       If (!AprevImgCall && mainCall && makeBackup=1)
       {
          AprevImgCall := gdiBitmapIDcall
          AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       } Else If (!BprevImgCall && mainCall && makeBackup=1)
       {
          BprevImgCall := gdiBitmapIDcall
          BprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       }

       If InStr(idGDIcacheSRCfileA, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileA := ""
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       }

       If InStr(idGDIcacheSRCfileB, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileB := ""
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       }
    } Else
    {
       If (SubStr(idGDIcacheSRCfileA, 1, 1)=1)
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       If (SubStr(idGDIcacheSRCfileB, 1, 1)=1)
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       If (SubStr(BprevImgCall, 1, 1)=1)
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       If (SubStr(AprevImgCall, 1, 1)=1)
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       If (SubStr(gdiBitmapIDcall, 1, 1)=1)
          gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

       idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
       BprevImgCall := AprevImgCall := ""
       GDIcacheSRCfileA := GDIcacheSRCfileB := gdiBitmapIDcall := ""
    }
}

discardViewPortCaches() {
    ; GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    ; GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    AprevImgCall := BprevImgCall := ""
    BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
    AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
}

disposeCacheIMGs(dummy:=0) {
    gdiBitmapIDcall := ""
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    If (dummy!="soft")
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)

    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
    infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
}

MenuReturnIMGedit() {
   If (StrLen(UserMemBMP)>2 && imgIndexEditing>0)
      currentFileIndex := imgIndexEditing
   Else If prevLastImg[1, 1]
      currentFileIndex := clampInRange(prevLastImg[1, 1], 1, maxFilesIndex)

   MenuDummyToggleThumbsMode()
}

recordSelUndoLevelNow() {
   selectionCoords := Round(imgSelX1) "|" Round(imgSelY1) "|" Round(imgSelX2) "|" Round(imgSelY2) "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   ; ToolTip, % currentSelUndoLevel  " = l" , , , 2
   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (undoSelLevelsArray[totalSelUndos, 1]!=selectionCoords)
   {
      currentSelUndoLevel := totalSelUndos + 1
      undoSelLevelsArray[totalSelUndos + 1] := [selectionCoords]
   }
}

decideUndoLevelsAccepted(imgW, imgH) {
   If (A_PtrSize!=4) 
      Return

   pixelz := imgW*imgH
   memUsage := (coreDesiredPixFmt="0x21808") ? pixelz*3 : pixelz*4
   memUsage := memUsage//1000
   preventUndoLevels := (memUsage*5>maxMemUndoLevels) ? 1 : 0
   ; ToolTip, % preventUndoLevels " = mem = " memUsage , , , 2
}

recordUndoLevelNow(actionu, recordedBitmap, dX:=0, dY:=0, forceAlpha:="x") {
   Static prevAct, lastInvoked := 1
   If (preventUndoLevels=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   thisAct := actionu recordedBitmap whichBitmap minimizeMemUsage currentFileIndex getIDimage(currentFileIndex)
   if (prevAct=thisAct)
   {
      ; SoundBeep, 900, 900
      addJournalEntry(A_ThisFunc "(" actionu "): already recorded undo state")
      Return
   }

   HasAlpha := (forceAlpha!="x") ? forceAlpha : currIMGdetails.HasAlpha
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   If (StrLen(undoLevelsArray[1, 1])<3 && StrLen(whichBitmap)>2 && minimizeMemUsage!=1)
   {
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
      If thisBMP
      {
         prevAct := thisAct
         recordSelUndoLevelNow()
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
      }
   }

   If (actionu="init")
   {
      setImageLoading()
      If (minimizeMemUsage=1)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
         If thisBMP
         {
            prevAct := thisAct
            currentUndoLevel := 1
            If (undoLevelsRecorded=0)
               undoLevelsRecorded := 1
            undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         }
      }

      lastInvoked := A_TickCount
      Return
   }

   prevAct := 0
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   If (A_PtrSize=8 && undoLevelsRecorded>3)
   {
      systemMemInfo := GlobalMemoryStatusEx()
      mamUsage := GetProcessMemoryUsage(QPVpid)
      thisMemoryLoad := Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
      If isWinXP
         thisMemoryLoad := 99

      If (thisMemoryLoad<85 && systemMemInfo.MemoryLoad<85 && hasReachedMaxUndoLevels=0)
         maxUndoLevels := 100
      Else
         maxUndoLevels := hasReachedMaxUndoLevels := undoLevelsRecorded
   }

   ; currentSelUndoLevel := totalSelUndos := Round(undoSelLevelsArray.Count() + 1)
   ; undoSelLevelsArray[totalSelUndos] := [selectionCoords]
   recordSelUndoLevelNow()
   imgIndexEditing := currentFileIndex
   ; ToolTip, % currentSelUndoLevel " = p" , , , 2
   If (minimizeMemUsage=1)
   {
      currentUndoLevel := 2
      undoLevelsRecorded := 2
      trGdip_DisposeImage(undoLevelsArray[2, 1], 1)
      undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(L2)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
   } Else
   {
      If (currentUndoLevel>=maxUndoLevels)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         undoLevelsArray.RemoveAt(1)
         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lmax)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
      } Else
      {
         currentUndoLevel++
         undoLevelsRecorded++
         If (undoLevelsRecorded>currentUndoLevel)
            undoLevelsRecorded := currentUndoLevel

         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lx" currentUndoLevel ")", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
         Loop, % maxUndoLevels + 1 - currentUndoLevel
         {
             trGdip_DisposeImage(undoLevelsArray[currentUndoLevel + A_Index, 1], 1)
             undoLevelsArray[currentUndoLevel + A_Index, 1] := ""
         }
      }
   }

   currentImgModified := 1
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, TriggerMenuBarUpdate, -50
   If (A_TickCount - lastInvoked>950) && (liveDrawingBrushTool=0)
      SoundBeep , 900, 100
}

terminateIMGediting() {
   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded>0 && currentFileIndex!=imgIndexEditing && minimizeMemUsage=1)
   {
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
      viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
      viewportIDstampBMP := ""
      Loop, 3
      {
          trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
          undoLevelsArray[A_Index, 1] := ""
      }

      gdipObjectsStats(1, "recordUndoLevelNow")
      currentImgModified := 0
      undoSelLevelsArray := []
      currentSelUndoLevel := 1
      currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
      interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
      interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
      SetTimer, TriggerMenuBarUpdate, -50
      Return
   }

   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded<1) || (currentFileIndex=imgIndexEditing && undoLevelsRecorded>1 && currentImgModified=2)
      Return

   currentImgModified := 0
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
   viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
   viewportIDstampBMP := ""

   Loop, 200
   {
       trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
       undoLevelsArray[A_Index, 1] := ""
   }

   gdipObjectsStats(1, "recordUndoLevelNow")
   fnOutputDebug(A_ThisFunc "(): undo/redo levels purged")
   currentSelUndoLevel := 1
   undoSelLevelsArray := []
   currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, TriggerMenuBarUpdate, -50
   maxUndoLevels := (A_PtrSize=8) ? 100 : 2
}

ImgUndoAction(dummy:=0) {
   Critical, on
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || isAlphaPainting=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel - 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel - howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])

   SetTimer, RefreshImageFile, -325
   showTOOLtip("Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelUndoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel - 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel - howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelRedoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel + 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel + howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

restorePreviousSelections(thisLevel) {
   selectionCoords := undoSelLevelsArray[thisLevel, 1]
   ; ToolTip, % thisLevel " = k" , , , 2
   If !selectionCoords
      Return

   selectionPrefsArray := StrSplit(selectionCoords, "|")
   imgSelX1 := selectionPrefsArray[1], imgSelY1 := selectionPrefsArray[2]
   imgSelX2 := selectionPrefsArray[3], imgSelY2 := selectionPrefsArray[4]
   prcSelX1 := selectionPrefsArray[5], prcSelY1 := selectionPrefsArray[6]
   prcSelX2 := selectionPrefsArray[7], prcSelY2 := selectionPrefsArray[8]
   vPselRotation := selectionPrefsArray[9]
   rotateSelBoundsKeepRatio := selectionPrefsArray[10]
   EllipseSelectMode := selectionPrefsArray[11]
   LimitSelectBoundsImg := selectionPrefsArray[12]
   showSelectionGrid := selectionPrefsArray[13]
   currentSelUndoLevel := thisLevel
   ; currentImgModified := 1
}

ImgRedoAction(dummy:=0) {
   Critical, on
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || isAlphaPainting=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel + 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Redo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel + howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])
   SetTimer, RefreshImageFile, -325
   showTOOLtip("Redo [ "  currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ToggleCorePixFmt() {
   friendly := (A_PtrSize=4 && A_is64BitOS) ? "`n`nPlease use the 64-bits edition of this application to enjoy a better experience for image editing and image viewing." : ""
   friendly .= "`n`nUpon application restart, the 32-bits RGBA mode will no longer be activated."
   coreDesiredPixFmt := (coreDesiredPixFmt="0x21808") ? "0xE200B" : "0x21808"
   If (A_PtrSize=4 && coreDesiredPixFmt="0xE200B")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now activated. " appTitle " will now have an increased memory usage. The maximum amount of usable memory on your system is 2 GB." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=4 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. " appTitle " will use less memory, but various image editing options are disabled." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=8 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. Please note, various image editing options are disabled in 24-bits RGB mode, including proper alpha channel support.`n`nUpon application restart, the 32-bits RGBA mode will be reactivated. This option is only meant help reduce memory usage for old systems.", 0, 0, "exclamation")

   RefreshImageFileAction()
}

alertReduceColorDepth() {
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to edit is downscaled by " appTitle ". Press F5 to reload the original and then begin again to edit the image, at its original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", 0, 0, "exclamation")

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      r := msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel.", "&OK|&Activate 32-RGBA", 1, "exclamation")
   
   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit is at an unsupported color depth for editing: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost.", 0, 0, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", 0, 0, "exclamation")

   If InStr(r, "activate")
   {
      coreDesiredPixFmt := "0x26200A"
      If !undoLevelsRecorded
         RefreshImageFileAction()
   }

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will edit it now at an automatically downscaled resolution:" newRes, 0, 0, "exclamation")
   }
}

alertReduceSaveColorDepth() {
   msgResult := "continue"
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgResult := msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to save is downscaled by " appTitle ". Press F5 to reload the original and then save the modified image, at original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel before editing or saving the image.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave is originally at an unsupported color depth: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost. ", "&Continue|C&ancel", 1, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will be saving an automatically downscaled resolution:" newRes, "&Continue|C&ancel", 1, "exclamation")
   }
   If !InStr(msgResult, "continue")
      Return 1
}

mergeViewPortEffectsImgEditing(funcu:=0, recordUndoAfter:=1, applyOnArea:=0, allowOutside:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    funcuInfo := funcu ? "`n" funcu "()" : ""
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - mergeViewPortEffectsImgEditing() invoked by " funcu "() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return 1
    }

    If testSelectOutsideImgEntirely(whichBitmap)
    {
       If (allowOutside!=1)
       {
          SoundBeep, 300, 100
          showDelayedTooltip("WARNING: Invalid image selection area. It seems to be entirely outside the image boundaries." funcuInfo, 0, 450)
          Return 1
       }
       selOutsideEntirely := 1
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)
    {
       SoundBeep, 300, 100
       showDelayedTooltip("ERROR: Image editing is disabled`nThe document size is too large" funcuInfo, 0, 450)
       Return 1
    }

    alertReduceColorDepth()
    ; mustOpenStartFolder := ""
    imgIndexEditing := currentFileIndex
    currentImgModified := 1
    setImageLoading()
    showTOOLtip("Processing image, please wait" funcuInfo)
    ; If markedSelectFile
    ;    dropFilesSelection()

    discardViewPortCaches()
    ; msgbox % UserMemBMP "---" gdiBitmap
    If StrLen(gdiBitmap)>2
    {
       UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
       UserMemBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
    } 

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If (pEffect || imageAttribs)
       recordUndoLevelNow("init", 0)

    Gdip_GetImageDimensions(UserMemBMP, imgW, imgH)
    If (editingSelectionNow=1 && applyOnArea=1 && selOutsideEntirely!=1)
    {
       nImgSelX1 := min(imgSelX1, imgSelX2)
       nImgSelY1 := min(imgSelY1, imgSelY2)
       kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       isEntire := (kimgSelW=imgW && kimgSelH=imgH && nImgSelX1=0 && nImgSelY1=0) ? 1 : 0
       allowOnArea := !isEntire
    }

    If (allowOnArea=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(1, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       If pPath
       {
          pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
          dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP, pB.xa, pB.ya, pB.w, pB.h, 0, 0, 1)
       }

       If dummyBMP
       {
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4)
          carvePathFromBitmap(UserMemBMP, pPath, pB.x, pB.y, 0)
          G4 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
          r1 := trGdip_DrawImage(A_ThisFunc, G4, dummyBMP, pB.xa, pB.ya)
          Gdip_DeleteGraphics(G4)
          trGdip_DisposeImage(dummyBMP, 1)
       } Else r1 := "fail"

       Gdip_DeletePath(pPath)
    } Else UserMemBMP := applyVPeffectsOnBMP(UserMemBMP)
   
    Gdip_DisposeEffect(pEffect)
    If ((pEffect || imageAttribs) && StrLen(UserMemBMP)>2 && recordUndoAfter!=0 && r1!="fail")
    {
       recordUndoLevelNow(0, UserMemBMP)
       disposeCacheIMGs("soft")
       ; gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime//2
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := 0 ; FlipImgH := FlipImgV := 0
}

CutSelectedArea() {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   r := CopyImage2clip()
   If r
      Return

   EraseAreaFader := 0
   Sleep, 350
   EraseSelectedArea()
   ; EraseSelectedArea(1)
}

ApplyColorAdjustsSelectedArea(modus:=0) {
    Static prevFXmode := "n"
    If InStr(modus, "outside")
       modus := "outside"

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through modes`nor press U to open color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisMode := (modus="outside") ? 0 : 1
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 0, thisMode)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If !pPath
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    thisMode := (modus="outside") ? 0 : 4
    Gdip_SetClipPath(G2, pPath, thisMode)
    zBitmap := (preventUndoLevels=1) ? gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r0!="fail" && r1!="fail" && G2)
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    Return r1
}

InsertTextSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    startOperation := A_TickCount
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 0)
    If obju[1]
    {
       textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
       trGdip_DisposeImage(obju[1], 1)
    }

    coreDesiredPixFmt := o_coreFmt
    Gdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    Gdip_GetRotatedDimensions(nImgW, nImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, ".")
       If StrLen(xBitmap)>3
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
          Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, nimgW, nimgH, 0, 0, nimgW, nimgH)
    livePreviewInsertTextinArea("kill")
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_DeleteGraphics(G2)
    zeitOperation := A_TickCount - startOperation
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
    addJournalEntry("Text drawn on image in: " etaTime)
    SetTimer, RefreshImageFile, -25
}

livePreviewInsertTextinArea(actionu:=0) {
    Static lastInvoked := 1, prevBMPu, prevState, scaleuPreview := 1
    If (actionu="kill")
    {
       prevState := 0
       If StrLen(prevBMPu)>2
          prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (TextInAreaLivePreview!=1 || !AnyWindowOpen)
       Return

    ; setImageLoading()
    G2 := 2NDglPG
    Gdip_ResetClip(G2)
    ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)

    thisState := "a" UserTextArea TextInAreaAlign TextInAreaValign TextInAreaDoBlurs TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr imgSelW imgSelH mainWidth mainHeight TextInAreaLineAngle TextInAreaCharSpacing TextInAreaAutoWrap
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    If (A_TickCount - lastInvoked < 50) || (thisState=prevState)
    {
       textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If (thisState!=prevState)
          mustGoTimer := 1
    } Else
    {
       obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1)
       If obju[1]
       {
          prevState := thisState
          trGdip_DisposeImage(prevBMPu, 1)
          textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
          trGdip_DisposeImage(obju[1], 1)
          scaleuPreview := obju[6]
          prevBMPu := textBoxu
          textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       }
    }

    startZeit := A_TickCount
    coreDesiredPixFmt := o_coreFmt
    Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight)
    imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
    imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
    imgSelW := max(X1, X2) - min(X1, X2)
    imgSelH := max(Y1, Y2) - min(Y1, Y2)

    If (userimgGammaCorrect=1)
    {
       Gdip_SetCompositingQuality(G2, 2)
       bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0)
       If bgrBMPu
       {
          trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, imgSelW, imgSelH)
          trGdip_DisposeImage(bgrBMPu)
       }
    }

    Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
    zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
    zImgH := Round((nImgH*zoomLevel)*scaleuPreview)

    Gdip_GetRotatedDimensions(zImgW, zImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, "-", 5)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
       }
       Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
       zImgH := Round((nImgH*zoomLevel)*scaleuPreview)
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH, 0, 0, nimgW, nimgH)
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_ResetClip(G2)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    ; livePreviewsImageEditingDrawSelectionBox()
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    If (A_TickCount - startZeit<65) && (mustGoTimer=1)
       livePreviewsImageEditing()
    Else If (mustGoTimer=1)
       SetTimer, livePreviewInsertTextinArea, -100
    ; Else
       ; SetTimer, ResetImgLoadStatus, -200
    lastInvoked := A_TickCount
}

FillSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && FillAreaShape=1 && FillAreaInverted=1 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelFillSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    recordUndoLevelNow("init", 0)
    mustRemBackground := FillAreaRemBGR
    If (UserMemBMP!=whichBitmap && mustRemBackground!=1)
       disposableBMP := whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)

    kBitmap := whichBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (mustRemBackground=1)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
    Else
       pBitmap := whichBitmap

    If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
    {
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4,, compositingQuality)
    pPath := coreFillSelectedArea(G2, whichBitmap, kBitmap)
    If (pPath="fail")
    {
       Gdip_DeleteGraphics(G2)
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    Gdip_ResetClip(G2)
    modus := (FillAreaInverted=1) ? 0 : 4
    If (mustRemBackground=1 && pPath)
       Gdip_SetClipPath(G2, pPath, modus)

    If (mustRemBackground=1)
    {
       currIMGdetails.HasAlpha := 1
       r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap)
       If (UserMemBMP=whichBitmap)
          UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    }

    Gdip_ResetClip(G2)
    If (FillAreaDoContour=1)
       coreDrawShapesSelectionArea(G2, pBitmap)

    Gdip_DeleteGraphics(G2)
    coreFillSelectedArea("kill")
    UserMemBMP := pBitmap
    recordUndoLevelNow(0, UserMemBMP)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Fill selected area operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    SetTimer, RefreshImageFile, -25
}

coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape) {
    pPath := Gdip_CreatePath()
    If (shape=1) ; rect
    {
       Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=2) ; rounded rect
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       Gdip_AddPathRoundedRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, radius)
    } Else If (shape=3) ; ellipse
    {
       Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=4) ; triangle
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (shape=5) ; right triangle
    {
       cX1 := imgSelPx
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (shape=6) ; rhombus
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH//2
       cX3 := imgSelPx + imgSelW//2
       cY3 := imgSelPy + imgSelH
       cX4 := imgSelPx + imgSelW
       cY4 := imgSelPy + imgSelH//2
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3 "|" cX4 "," cY4)
    } Else If (shape=7 && FillAreaCurveTension=1)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       ; ToolTip, % customShapePoints "`nLOL" PointsList , , , 2
       If (FillAreaClosedPath=1)
          Gdip_AddPathPolygon(pPath, PointsList)
       Else
          Gdip_AddPathLines(pPath, PointsList)
    } Else If (shape=7)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       If (FillAreaClosedPath=1)
          Gdip_AddPathClosedCurve(pPath, PointsList, tensionCurveCustomShape)
       Else
          Gdip_AddPathCurve(pPath, PointsList, tensionCurveCustomShape)
    }
    Return pPath
}

DrawRoundedRectangle2(pGraphics, pPen, x, y, w, h, r, Angle:=0) {
; extracted from: https://github.com/tariqporter/Gdip2/blob/master/lib/Object.ahk
; and adapted by Marius Șucan

   penWidth := Gdip_GetPenWidth(pPen)
   pw := penWidth / 2
   if (w <= h && (r + pw > w / 2))
   {
      r := (w / 2 > pw) ? w / 2 - pw : 0
   } else if (h < w && r + pw > h / 2)
   {
      r := (h / 2 > pw) ? h / 2 - pw : 0
   } else if (r < pw / 2)
   {
      r := pw / 2
   }

   r2 := r * 2
   path1 := Gdip_CreatePath(0)
   Gdip_AddPathArc(path1, x + pw, y + pw, r2, r2, 180, 90)
   Gdip_AddPathLine(path1, x + pw + r, y + pw, x + w - r - pw, y + pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + pw, r2, r2, 270, 90)
   Gdip_AddPathLine(path1, x + w - pw, y + r + pw, x + w - pw, y + h - r - pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + h - r2 - pw, r2, r2, 0, 90)
   Gdip_AddPathLine(path1, x + w - r - pw, y + h - pw, x + r + pw, y + h - pw)
   Gdip_AddPathArc(path1, x + pw, y + h - r2 - pw, r2, r2, 90, 90)
   Gdip_AddPathLine(path1, x + pw, y + h - r - pw, x + pw, y + r + pw)
   Gdip_ClosePathFigure(path1)
   If (Angle>0)
      Gdip_RotatePathAtCenter(path1, Angle, 1, 1, rotateSelBoundsKeepRatio)
   _E := Gdip_DrawPath(pGraphics, pPen, path1)
   Gdip_DeletePath(path1)
   return _E
}

PersonalizedRotatePath(pPath, angle, x, y, w, h, withinBounds:=0, withinBkeepRatio:=1, EllipseMode:=1) {
  dummyPath := Gdip_CreatePath()
  If (EllipseMode=1)
     Gdip_AddPathEllipse(dummyPath, x, y, w, h)
  Else
     Gdip_AddPathRectangle(dummyPath, x, y, w, h)

  MatrixOrder := 1
  Rect := Gdip_GetPathWorldBounds(dummyPath)
  cX := Rect.x + (Rect.w / 2)
  cY := Rect.y + (Rect.h / 2)
  pMatrix := Gdip_CreateMatrix()
  Gdip_TranslateMatrix(pMatrix, -cX , -cY)
  Gdip_RotateMatrix(pMatrix, Angle, MatrixOrder)
  Gdip_TranslateMatrix(pMatrix, cX, cY, MatrixOrder)
  E := Gdip_TransformPath(dummyPath, pMatrix)
  E := Gdip_TransformPath(pPath, pMatrix)
  Gdip_DeleteMatrix(pMatrix)
  If (withinBounds=1 && !E && Angle!=0)
  {
     nRect := Gdip_GetPathWorldBounds(dummyPath)
     ncX := nRect.x + (nRect.w / 2)
     ncY := nRect.y + (nRect.h / 2)
     pMatrix := Gdip_CreateMatrix()
     Gdip_TranslateMatrix(pMatrix, -ncX , -ncY)
     sX := Rect.w / nRect.w
     sY := Rect.h / nRect.h
     If (withinBkeepRatio=1)
     {
        sX := min(sX, sY)
        sY := min(sX, sY)
     }
     Gdip_ScaleMatrix(pMatrix, sX, sY, MatrixOrder)
     Gdip_TranslateMatrix(pMatrix, ncX, ncY, MatrixOrder)
     If (sX!=0 && sY!=0)
     {
        E := Gdip_TransformPath(pPath, pMatrix)
        E := Gdip_TransformPath(dummyPath, pMatrix)
     }
     Gdip_DeleteMatrix(pMatrix)
  }
  Gdip_DeletePath(dummyPath)
}

coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode:=0) {
    Static prevState, prevBMPu
    If (whichBitmap="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" whichBitmap dimgSelPx dimgSelPy dimgSelW dimgSelH thisQuality G2 imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight BlurAmount
    If (thisState!=prevState || G2!=2NDglPG || !prevBMPu)
    {
       ; ToolTip, % thisState , , , 2
       doFakeBgr := (2NDglPG=G2) ? 0 : 1
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, 0, 0, 1)
       If (doFakeBgr=1)
          QPV_SetGivenAlphaLevel(zBitmap, 2, 1)

       thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, dimgSelW//2+2, dimgSelH//2 + 2, 0, thisQuality, -1)
       If !warnUserFatalBitmapError(thisBMP, A_ThisFunc)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := thisBMP
          setWindowTitle("Blurring image, please wait")
          afterVPresize := (AnyWindowOpen && G2=2NDglPG) ? Round(dimgSelW*zoomLevel) * Round(dimgSelH*zoomLevel) : 1
          preVPresize := dimgSelW//2 * dimgSelH//2
          applyBlurAfter := (afterVPresize<preVPresize && afterVPresize!=1) ? 1 : 0
          If (applyBlurAfter=0 || G2!=2NDglPG)
          {
             BlurAmountA := BlurAmount + 1
             BlurAmountA := clampInRange(BlurAmountA, 2, 255)
             pzEffect := Gdip_CreateEffect(1, BlurAmountA, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, zBitmap, BlurAmountA, pzEffect, previewMode)
          }
       }

       If (AnyWindowOpen && G2=2NDglPG)
       {
          thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, Round(dimgSelW*zoomLevel), Round(dimgSelH*zoomLevel), 0, thisQuality, -1)
          If (applyBlurAfter=1)
          {
             BlurAmountB := Round(BlurAmount*zoomLevel)*2
             BlurAmountB := clampInRange(BlurAmountB, 2, 254)
             zEffect := Gdip_CreateEffect(1, BlurAmountB, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, thisBMP, BlurAmountB, zEffect, previewMode)
          }

          trGdip_DisposeImage(zBitmap, 1)
       } Else thisBMP := zBitmap
       prevBMPu := thisBMP
       prevState := thisState
       thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, thisBMP)
    } Else thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)

    Gdip_SetClipPath(G2, pPath, 0)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
       Gdip_BitmapApplyEffect(thisPBitmap, pEffect)

    If (AnyWindowOpen && G2=2NDglPG)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisPBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,,,, imageAttribs)
    trGdip_DisposeImage(thisPBitmap, 1)
    Gdip_ResetClip(G2)
    setWindowTitle(pVwinTitle, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DisposeEffect(pzEffect)
}

testSelectionLargerThanViewport() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    obju := []
    obju.mainWidth := mainWidth
    obju.mainHeight := mainHeight
    vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    obju.isLarger := (MAINmpx<VPmpx) ? 1 : 0
    Return obju
}

testSelectionLargerThanGiven(imgW, imgH) {
    nImgSelX1 := min(imgSelX1, imgSelX2)
    nImgSelY1 := min(imgSelY1, imgSelY2)
    nimgSelX2 := max(imgSelX1, imgSelX2)
    nimgSelY2 := max(imgSelY1, imgSelY2)
    If (nImgSelX1<0 || nImgSelY1<0 || nImgSelX2>imgW || nImgSelY2>imgH)
       Return 1
    Return 0
}

trGdip_DrawImage(funcu, pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using pG=" pGraphics ", pBMP=" pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to draw the processed image in the internal graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics " and pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsFromImage(funcu, pBitmap, InterpolationMode:="", SmoothingMode:="", PageUnit:="", CompositingQuality:="") {
  If !pBitmap
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() for pBitmap = " pBitmap)
     Return
  }

  r := Gdip_GraphicsFromImage(pBitmap, InterpolationMode, SmoothingMode, PageUnit, CompositingQuality)
  If (!r || gdipLastError)
  {
     baseMsg := "Unable to create virtual graphics object required for processing the image... Error occured in " A_ThisFunc "() invoked by " funcu "() for pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(gdipLastError, baseMsg)
     Return
  } Else Return r
}

trGdip_DrawImageFX(funcu, pGraphics, pBitmap, dX:="", dY:="", sX:="", sY:="", sW:="", sH:="", matrix:="", pEffect:="", ImageAttr:=0, hMatrix:=0, Unit:=2) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using " pGraphics ", " pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImageFX(pGraphics, pBitmap, dX, dY, sX, sY, sW, sH, matrix, pEffect, ImageAttr, hMatrix, Unit)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to modify the image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "(). "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsClear(funcu, pGraphics, coloru:=0x00ffFFff, silentMode:=0) {
  If !pGraphics
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() on graphics = " pGraphics ". ")
     Return "fail"
  }

  r := Gdip_GraphicsClear(pGraphics, coloru)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to apply operations on image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics ". "
     generalInternalErrorMsgBox(r, baseMsg, silentMode)
     Return "fail"
  }
}

QPV_SaveImageFile(funcu, pBitmap, file2save, jpegQuality) {
   r := Gdip_SaveBitmapToFile(pBitmap, file2save, jpegQuality)
   If (r=-5)
      r := Gdip_ErrorHandler(gdipLastError, 0)
   Else If r
      r .= " / " A_LastError

   If r
   {
      addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with GDI+: " file2save "`nError code: " r)
      zr := SaveFIMfile(file2save, pBitmap)
      If (!zr && wasInitFIMlib=1)
         r := zr
      Else If (wasInitFIMlib=1)
         addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with FreeImage: " file2save "`nError code: " zr)
   }

   Return r
}

warnUserFatalBitmapError(pBitmap, funcu) {
    If (StrLen(pBitmap)<3 || pBitmap="err" || pBitmap="fail")
    {
       r := (pBitmap="no-gdip") ? 0 : gdipLastError
       baseMsg := "Unable to create internal bitmap to apply operations on image... Error occured in Gdip_CreateBitmap() invoked by " funcu  "(). "
       generalInternalErrorMsgBox(r, baseMsg)
       Return "fail"
    }
}

coreFillSelectedArea(G2:=0, whichBitmap:=0, ywbmp:=0) {
    Critical, on
    Static prevPath, noRepeat := 0
    If (G2="kill")
    {
       Gdip_DeletePath(prevPath)
       Gdip_ResetClip(2NDglPG)
       prevPath := ""
       coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       coredrawWelcomeImg("kill", 0, 0, 0, 0, 0, 5, 5, 0, 0, 0)
       Return
    }

    decXu := decYu := decWu := decHu := 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    vPimgSelW := (!G2 && FillAreaInverted=1) ? mainWidth : max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := (!G2 && FillAreaInverted=1) ? mainHeight : max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    dropSpecialFX := (MAINmpx<VPmpx && !G2) ? 1 : 0
    If (FillAreaBlendMode>1 && FillAreaRemBGR!=1)
    {
       If whichBitmap
          Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

       If (vPimgSelW>mainWidth)
          decWu := mainWidth - vPimgSelW
       If (vPimgSelH>mainHeight)
          decHu := mainHeight - vPimgSelH

       ; vPimgSelW := clampInRange(vPimgSelW, 2, mainWidth)
       ; vPimgSelH := clampInRange(vPimgSelH, 2, mainHeight)
       o_whichBitmap := whichBitmap
       If !G2
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, vPimgSelW, vPimgSelH, coreDesiredPixFmt)
       Else
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)

       If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
          Return "fail"

       o_G2 := G2 ? G2 : 2NDglPG
       If !G2
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 5, 3)
       Else
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)

       mustDoBlendMode := 1
    } Else
    {
       If !whichBitmap
          whichBitmap := useGdiBitmap()
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    oimgSelW := imgSelW, oimgSelH := imgSelH
    maxLength := min(imgSelW, imgSelH)//2
    thisThick := (FillAreaContourThickness>maxLength//1.05) ? maxLength//1.05 : FillAreaContourThickness
    If (!G2 || 2NDglPG=o_G2)
    {
       previewMode := 1
       thisThick := thisThick*zoomLevel
       If (mustDoBlendMode=1)
       {
          imgSelPx := x1 := SelDotsSize//2, x2 := vPimgSelW
          imgSelPy := y1 := SelDotsSize//2, y2 := vPimgSelH
          imgSelW := imgW := vPimgSelW ; + decWu
          imgSelH := imgH := vPimgSelH ; + decHu
          If (imgSelPx>selDotX + SelDotsSize)
             decXu := imgSelPx - selDotX - SelDotsSize

          If (imgSelPy>selDotY + SelDotsSize)
             decYu := imgSelPy - selDotY - SelDotsSize
       } Else
       {
          o_G2 := G2 := 2NDglPG
          imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
          imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
          imgSelW := max(X1, X2) - min(X1, X2)
          imgSelH := max(Y1, Y2) - min(Y1, Y2)
          imgW := mainWidth
          imgH := mainHeight
       }

       Gdip_ResetClip(o_G2)
       ; trGdip_GraphicsClear(A_ThisFunc, o_G2, "0x00" WindowBGRcolor)
       Gdip_SetClipRect(o_G2, 0, 0, mainWidth, mainHeight)
       If (decXu>1 || decYu>1 || decWu>1 || decHu>1) && (mustDoBlendMode=1)
       {
          diffu := SelDotsSize
          thisW := min(vPimgSelW, mainWidth) + diffu
          thisH := min(vPimgSelH, mainHeight) + diffu
          thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
          thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
          If (FillAreaInverted!=1)
             Gdip_SetClipRect(G2, decXu, decYu, thisW, thisH)
       }
    } Else previewMode := 0

    If StrLen(G2)<2
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): fatal error. No GDI+ graphics object.")
       Return
    }

    dR := (FillAreaContourAlign=3) ? thisThick//2 : 0
    If (FillAreaContourAlign=1)
       dR := -thisThick//2

    If (FillAreaDoContour!=1)
    {
       dR := thisThick := 0
    } Else
    {
       imgSelPx -= dR
       imgSelPy -= dR
       imgSelW += dR*2
       imgSelH += dR*2
    }

    If (FillAreaGlassy=2)
       BlurAmount := 15
    Else If (FillAreaGlassy=3)
       BlurAmount := 50
    Else If (FillAreaGlassy=4)
       BlurAmount := 120
    Else If (FillAreaGlassy=5)
       BlurAmount := 180
    Else If (FillAreaGlassy=6)
       BlurAmount := 250
    Else
       BlurAmount := 0

    ; prepare the brush
    Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
    this1stOpacity := (FillAreaColorMode=5) ? clampInRange(FillAreaOpacity, 1, 215) : FillAreaOpacity
    thisColorA := Gdip_ToARGB(this1stOpacity, R, G, B)

    Gdip_FromARGB("0xFF" FillArea2ndColor, A, R, G, B)
    this2ndOpacity := (FillAreaColorMode=5) ? clampInRange(FillArea2ndOpacity, 1, 215) : FillArea2ndOpacity
    thisColorB := Gdip_ToARGB(this2ndOpacity, R, G, B)
    If (FillAreaColorReversed=1 && isInRange(FillAreaColorMode, 2, 4))
    {
       tempu := thisColorA
       thisColorA := thisColorB
       thisColorB := tempu
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
    {
       rimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) ; + SelDotsSize//2
       rimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) ; + SelDotsSize//2
       rimgSelX := selDotX + SelDotsSize//2
       rimgSelY := selDotY + SelDotsSize//2
       brImgSelW := Round(rImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(rImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := rimgSelX - (brImgSelW - rimgSelW)//2
       brimgSelPy := rimgSelY - (brImgSelH - rimgSelH)//2
    } Else
    {
       brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := imgSelPx - (brImgSelW - imgSelW)//2
       brimgSelPy := imgSelPy - (brImgSelH - imgSelH)//2
    }

    If (previewMode=1)
    {
       dpX := (FillAreaInverted=1) ? prevDestPosX : imgSelPx
       dpY := (FillAreaInverted=1) ? prevDestPosY : imgSelPy
       kW := (FillAreaInverted=1) ? prevResizedVPimgW : imgSelW
       kH := (FillAreaInverted=1) ? prevResizedVPimgH : imgSelH
    } Else
    {
       dpX := (FillAreaInverted=1) ? 0 : imgSelPx
       dpY := (FillAreaInverted=1) ? 0 : imgSelPy
       kW := (FillAreaInverted=1) ? imgW : imgSelW
       kH := (FillAreaInverted=1) ? imgH : imgSelH
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
       pPath := coreCreateFillAreaShape(rimgSelX, rimgSelY, rimgSelW, rimgSelH, FillAreaShape)
    Else
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape)

    If (vPselRotation>0 && pPath)
    {
       If (FillAreaShape=4 || FillAreaShape=5)
       {
          If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
             PersonalizedRotatePath(pPath, vPselRotation, rimgSelX, rimgSelY, rimgSelW, rimgSelH, 1, rotateSelBoundsKeepRatio, 0)
          Else
             PersonalizedRotatePath(pPath, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       } Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    }

    If (FillAreaColorMode=1)
    {
       ; solid color
       Brush := Gdip_BrushCreateSolid(thisColorA)
    } Else If (FillAreaColorMode=2)
    {
       ; linear gradient
       Brush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
       Gdip_RotateLinearGrBrushAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       Gdip_SetLinearGrBrushGammaCorrection(Brush, userimgGammaCorrect)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
    } Else If (FillAreaColorMode=3 || FillAreaColorMode=4)
    {
       ; radial or box gradient
       grpPath := Gdip_CreatePath()
       If (FillAreaColorMode=3)
          Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
       Else
          Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

       Brush := Gdip_PathGradientCreateFromPath(grpPath)
       If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
          Gdip_PathGradientSetCenterPoint(Brush, rimgSelX + rimgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), rimgSelY + rimgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))
       Else
          Gdip_PathGradientSetCenterPoint(Brush, imgSelPx + imgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), imgSelPy + imgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))

       Gdip_SetLinearGrBrushGammaCorrection(Brush, userimgGammaCorrect)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
       Gdip_RotatePathGradientAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       Gdip_PathGradientSetWrapMode(Brush, FillAreaGradientWrapped - 1)
       Gdip_DeletePath(grpPath)
    } Else If (FillAreaColorMode=5)
    {
       ; welcome screens patterns
       iterations := Round(100*(FillAreaGradientScale/300)) + 1
       modelu := Round(7*(FillAreaGradientPosB/100))
       moduz := Round(9*(FillAreaGradientPosA/100))
       sweepRand := Round(9*(FillAreaGradientAngle/360))
       Brush := Gdip_BrushCreateSolid(thisColorB)
       thisBMPwelcome := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, Ceil(imgSelW), Ceil(imgSelH), 5, 5, 0, previewMode, !previewMode)
       If (BrushToolApplyColorFX=1)
          applyPersonalizedColorsBMP(thisBMPwelcome, 0, 0, BrushToolApplyColorFX)

       clrMatrix := FillAreaOpacity/255
       ; Gdip_DeleteBrush(bruA)
    } Else If (FillAreaColorMode=6)
    {
       ; texture mode
       If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
          tinyPrevAreaCoordX := tinyPrevAreaCoordY := 2

       Gdip_GetImageDimensions(useGdiBitmap(), kklimgW, kklimgH)
       maxSizeX := kklimgW - tinyPrevAreaCoordX - 2
       maxSizeY := kklimgH - tinyPrevAreaCoordY - 2
       texSize := clampInRange(3 * FillAreaGradientScale, 2, maxSizeX)
       texSize2 := texSize + Round(texSize * (FillAreaGradientPosB/100))
       texSize2 := clampInRange(texSize2, 2, maxSizeY)
       texScaleX := imgSelW/oimgSelW
       texScaleX := texScaleX * (FillAreaGradientPosA / 100)
       texScaleY := texScaleX
       If (FillAreaColorReversed=1 && FillAreaGradientWrapped=1)
          tilingMode := 3
       Else If (FillAreaColorReversed=1 && FillAreaGradientWrapped=0)
          tilingMode := 2
       Else If (FillAreaColorReversed=0 && FillAreaGradientWrapped=1)
          tilingMode := 1
       Else
          tilingMode := 0

       TexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), tilingMode, tinyPrevAreaCoordX, tinyPrevAreaCoordY, texSize, texSize2,, texScaleX, texScaleY, FillAreaGradientAngle, 0)
       If TexBrush
       {
          thisBMPwelcome := trGdip_CreateBitmap(A_ThisFunc, Ceil(imgSelW), Ceil(imgSelH))
          If thisBMPwelcome
          {
             Gup := Gdip_GraphicsFromImage(thisBMPwelcome)
             Gdip_FillRectangle(Gup, TexBrush, 0, 0, Ceil(imgSelW), Ceil(imgSelH))
             Gdip_DeleteGraphics(Gup)
             clrMatrix := FillAreaOpacity / 255
             If (FillAreaApplyColorFX=1)
                applyPersonalizedColorsBMP(thisBMPwelcome, 0, 0, FillAreaApplyColorFX)
          }
          Gdip_DeleteBrush(TexBrush)
       }
    }

    If (userimgGammaCorrect=1 && previewMode=1)
    {
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       Gdip_SetCompositingQuality(G2, 2)
       If (FillAreaInverted!=1 && mustDoBlendMode!=1)
       {
          ; diffu := SelDotsSize
          ; thisW := vPimgSelW
          ; thisH := vPimgSelH
          ; thisX := max(- diffu//2, selDotX) + diffu//2
          ; thisY := max(- diffu//2, selDotY) + diffu//2
          ; If (mustDoBlendMode=1)
          ;    bgrBMPu := getImgSelectedAreaEditMode(1, thisX, thisY, thisW, thisH, thisW, thisH, 0)
          ; Else
             bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0)
   
          If bgrBMPu
             trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, imgSelW, imgSelH)
          trGdip_DisposeImage(bgrBMPu)
       } Else If (mustDoBlendMode!=1)
          trGdip_DrawImage(A_ThisFunc, G2, ViewPortBMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight)
    }

    ; draw the shape
    mustRemBackground := FillAreaRemBGR
    If (FillAreaInverted=1)
    {
       Gdip_SetClipPath(G2, pPath, 4)
       If (FillAreaGlassy>1 && FillAreaRemBGR!=1 && BlurAmount>1) || (mustDoBlendMode=1)
       {
          If (previewMode=1)
          {
             bgrBMPu := getImgSelectedAreaEditMode(1, 0, 0, mainWidth, mainHeight, mainWidth, mainHeight, BlurAmount)
          } Else
          {
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, ywbmp)
             If (BlurAmount>1)
             {
                zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
                ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
                Gdip_DisposeEffect(zrEffect)
             }
          }

          If StrLen(bgrBMPu)>3
          {
             If (previewMode!=1)
                trGdip_GraphicsClear(A_ThisFunc, G2)

             If (mustDoBlendMode=1)
             {
                threads := (previewMode=1) ? realSystemCores//2 : 0
                If (thisBMPwelcome && FillAreaColorMode>=5)
                {
                   If (previewMode=1)
                      Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

                   Gdip_FillRectangle(G2, Brush, dpX, dpY, kW, kH)
                   trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, dpX, dpY, kW, kH,,,,, clrMatrix)
                   thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
                } Else Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)

                QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
                thisG2 := (previewMode=1) ? 2NDglPG : o_G2
                trGdip_DrawImage(A_ThisFunc, thisG2, bgrBMPu)
                trGdip_DisposeImage(whichBitmap, 1)
                Gdip_DeleteGraphics(G2)
             } Else trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu)
             trGdip_DisposeImage(bgrBMPu, 1)
          }
       }

       If (mustRemBackground=1 && AnyWindowOpen && (o_G2=2NDglPG || G2=2NDglPG))
          Gdip_FillRectangle(G2, useHatchedBrush(), -2, -2, imgW + 2, imgH + 2)

       If (thisBMPwelcome && FillAreaColorMode>=5 && mustDoBlendMode!=1)
       {
          If (previewMode=1)
             Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)
          Gdip_FillRectangle(G2, Brush, dpX, dpY, kW, kH)
          trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, dpX, dpY, kW, kH,,,,, clrMatrix)
          thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
       } Else If (mustDoBlendMode!=1)
          Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)
    } Else
    {
       If (mustRemBackground=1 && previewMode=1)
          Gdip_FillPath(G2, useHatchedBrush(), pPath)
       
       thisQuality := (previewMode=1) ? 5 : 3
       canBlur := (previewMode=1 && FillAreaLivePreview=1 || G2!=2NDglPG) ? 1 : 0
       opacityLevels := (FillAreaColorMode=1 && FillAreaOpacity<253) || (FillAreaColorMode>1 && (FillAreaOpacity<253 || FillArea2ndOpacity<253)) ? 1 : 0
       ; MsgBox, % "a" canBlur "=" mustRemBackground "=" FillAreaGlassy "=" opacityLevels

       If (BlurAmount>1 && canBlur=1 && dropSpecialFX!=1 && FillAreaBlendMode=1 && FillAreaRemBGR!=1 && !testSelectOutsideImgEntirely(whichBitmap) && FillAreaGlassy>1 && opacityLevels=1)
       {
          Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
          calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
          If (previewMode!=1)
          {
             pB := GetPathRelativeBounds(pPath, dimgSelPx, dimgSelPy)
             dimgSelPx := pB.x,  dimgSelPy := pB.y
             dimgSelW  := pB.w,  dimgSelH  := pB.h
             imgSelPx := pB.x,   imgSelPy := pB.y
             imgSelW  := pB.w,   imgSelH  := pB.h
          }

          coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode)
          If (previewMode!=1)
             coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       }

       If (previewMode=1 && mustDoBlendMode!=1)
          Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

       ; thisStartZeit := A_TickCount
       If (thisBMPwelcome && FillAreaColorMode>=5)
       {
          Gdip_FillPath(G2, Brush, pPath)
          Gdip_SetClipPath(G2, pPath)
          trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, clrMatrix)
          thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
       } Else Gdip_FillPath(G2, Brush, pPath)
       ; ToolTip, % brImgSelW "--" brImgSelH "==" thisW "--" thisH "==" A_TickCount - thisStartZeit , , , 2

       If ((FillAreaColorMode=4 || FillAreaColorMode=3) && (FillAreaGradientScale>=99 || FillAreaGradientWrapped!=1))
       {
          sBrush := Gdip_BrushCreateSolid(thisColorB)
          grpPath := Gdip_CreatePath()
          If (sBrush && grpPath)
          {
             If (FillAreaColorMode=3)
                Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             Else
                Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

             Gdip_RotatePathAtCenter(grpPath, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgSelW, imgSelH)
             Gdip_SetClipPath(G2, grpPath, 4)
             Gdip_FillPath(G2, sBrush, pPath)
             Gdip_DeleteBrush(sBrush)
             Gdip_DeletePath(grpPath)
          }
       }

       If (mustDoBlendMode=1)
       {
          thisBlurAmount := 0
          If (BlurAmount>1 && FillAreaGlassy>1 && previewMode=1 && FillAreaLivePreview=1 && dropSpecialFX!=1)
             thisBlurAmount := clampInRange(BlurAmount, 1, 255)

          If (previewMode=1)
          {
             Gdip_ResetClip(o_G2)
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)

             diffu := SelDotsSize
             thisW := min(vPimgSelW, mainWidth) + diffu
             thisH := min(vPimgSelH, mainHeight) + diffu
             thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
             thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
             kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, decXu, decYu, thisW, thisH, 0, 0, 1)
             trGdip_DisposeImage(whichBitmap)
             whichBitmap := kBitmap
             bgrBMPu := getImgSelectedAreaEditMode(1, thisX, thisY, thisW, thisH, thisW, thisH, thisBlurAmount)
          } Else
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, o_whichBitmap)

          If (BlurAmount>1 && FillAreaGlassy>1 && FillAreaRemBGR!=1 && previewMode!=1)
          {
             BlurAmount := clampInRange(BlurAmount, 2, 254)
             zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
             Gdip_DisposeEffect(zrEffect)
          }

          If (previewMode!=1)
          {
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, bgrBMPu)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)
          }

          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
          If (FillAreaApplyColorFX=1 && FillAreaColorMode<5)
             applyPersonalizedColorsBMP(bgrBMPu, 0, 0, FillAreaApplyColorFX)

          If (previewMode=1)
             r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, bgrBMPu, thisX, thisY)
          Else
             r1 := trGdip_DrawImage(A_ThisFunc, o_G2, bgrBMPu)

          trGdip_DisposeImage(bgrBMPu, 1)
          trGdip_DisposeImage(whichBitmap, 1)
          Gdip_DeleteGraphics(G2)
       }
    }

    Gdip_DeleteBrush(Brush)

    If (previewMode=1)
    {
       Gdip_SetCompositingQuality(G2, 1)
       Gdip_DeletePath(pPath)
       ; fnOutputDebug("about to reset clip for " G2)
       Gdip_ResetClip(2NDglPG)
       ; fnOutputDebug("done - reset clip for " G2)
       ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
       pPath := ""
       If (FillAreaDoContour=1)
          coreDrawShapesSelectionArea()
    }

    prevPath := pPath
    Return pPath
}

carvePathFromBitmap(ByRef pBitmap, pPath, cX, cY, modus, safeWay:=0, blurLevel:=0, doBorder:=1) {
    If (safeWay=2 && blurLevel>1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFFFFFFFF")

       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       ; Gdip_TranslateMatrix(pMatrix, blurLevel , blurLevel)
       E := Gdip_TransformPath(zPath, pMatrix)
       Gdip_SetClipPath(G3, zPath, modus)

       BrushB := Gdip_BrushCreateSolid("0xFF000000")
       r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)
       Gdip_ResetClip(G3)
       Gdip_SetClipRect(G3, blurLevel, blurLevel, imgW - blurLevel*2, imgH - blurLevel*2, 4)
       If (doBorder=1)
          r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)

       Gdip_DeleteGraphics(G3)
       thisAmount := clampInRange(blurLevel, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
       If (blurLevel>257)
       {
          thisAmount := clampInRange(blurLevel - 255, 1, 255)
          pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
          ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
          Gdip_DisposeEffect(pEffect)
       }
       r0 := QPV_SetAlphaChannel(pBitmap, newBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeletePath(wPath)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteMatrix(pMatrix)
       trGdip_DisposeImage(newBitmap, 1)
       ; ToolTip, % newBitmap "==" G3 "==" BrushB "`n" r2 "==" r3 "==" r0 , , , 2
       Return
    } Else safeWay := 0

    If (safeWay=1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0x26200A")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
    } Else
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)

    If (G3 && (newBitmap || safeWay!=1))
    {
       ; Gdip_GetImageDimensions(pBitmap, qImgW, qImgH)
       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       E := Gdip_TransformPath(zPath, pMatrix)
       If (safeWay=1)
       {
          Gdip_SetCompositingQuality(G3, 4)
          Gdip_SetCompositingMode(G3, 1)
          Gdip_SetPixelOffsetMode(G3, 4)
          thinBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap,,,,, "0x26200A")
          pEffect := Gdip_CreateEffect(5, -25, 0, 0)
          Gdip_BitmapApplyEffect(thinBMP, pEffect)

          QPV_SetGivenAlphaLevel(thinBMP, 1, 0)
          trGdip_DrawImage(A_ThisFunc, G3, thinBMP) ; ,,,,,,,,,10)
          modus := (modus=4) ? 0 : 4
       }

       Gdip_SetClipPath(G3, zPath, modus)
       If (safeWay!=1)
          r1 := trGdip_GraphicsClear(A_ThisFunc, G3)

       r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteGraphics(G3)
       If (safeWay=1)
       {
          trGdip_DisposeImage(thinBMP, 1)
          If !r2
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
          } Else Return "Fail"
       }
    }

    If (!G3 || r1="fail")
       Return "fail"
}

GraySelectedArea() {
   EraseOrInvertOrGraySelectedArea("desaturate", A_ThisFunc)
}

InvertSelectedArea() {
   EraseOrInvertOrGraySelectedArea("invert", A_ThisFunc)
}

EraseSelectedArea() {
   EraseOrInvertOrGraySelectedArea("erase", A_ThisFunc)
}

FlipSelectedAreaH() {
    EraseOrInvertOrGraySelectedArea("flip-h", A_ThisFunc)
}

FlipSelectedAreaV() {
    EraseOrInvertOrGraySelectedArea("flip-v", A_ThisFunc)
}

EraseOrInvertOrGraySelectedArea(actionu, funcu) {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1 && actionu!="erase")
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(funcu)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && EraseAreaInvert=1 && actionu="erase" && EllipseSelectMode=0 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelEraseSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(funcu, whichBitmap, 7, 4)
    infoFriendly := (actionu="flip" || actionu="flip" ) ? actionu : actionu " the colours in"
    If !G2
    {
       showTOOLtip("Failed to " infoFriendly " the selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    recordUndoLevelNow("init", 0)
    If (!gdiBitmap && preventUndoLevels=1)
    {
       hasCloned := 1
       o_gdiBitmap := Gdip_CloneBmpPargbArea(funcu, UserMemBMP)
    } Else o_gdiBitmap := gdiBitmap

    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If !pPath
    {
       showTOOLtip("Failed to " infoFriendly " the selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    modus := (EraseAreaInvert=1 && actionu="erase") ? 4 : 0
    Gdip_SetClipPath(G2, pPath, modus)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    If !r0
       currIMGdetails.HasAlpha := 1

    If (actionu="erase")
    {
       matrix := (EraseAreaFader=1) ? EraseAreaOpacity / 256 : 0
    } Else If (actionu="invert")
    {
       matrix := GenerateColorMatrix(6, 1, 0, 1)
    } Else If (actionu="desaturate")
    {
       coreDesatureAreaFX(matrix, pEffect)
    } Else If InStr(actionu, "flip")
    {
       matrix := 1
       thisW := imgSelW + imgSelPx*2
       thisH := imgSelH + imgSelPy*2
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If (actionu="flip-h")
       {
          Gdip_ScaleWorldTransform(G2, -1, 1)
          Gdip_TranslateWorldTransform(G2, -thisW, 0)
       } Else If (actionu="flip-v")
       {
          Gdip_ScaleWorldTransform(G2, 1, -1)
          Gdip_TranslateWorldTransform(G2, 0, -thisH)
       }
    }

    zBitmap := (preventUndoLevels=1) ? o_gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    If (!pEffect && matrix)
       r1 := trGdip_DrawImage(funcu, G2, zBitmap, 0, 0,,,,,,, matrix)
    Else If pEffect
       r1 := trGdip_DrawImageFX(funcu, G2, zBitmap,,,,,,, matrix, pEffect)

    Gdip_DeletePath(pPath)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeleteGraphics(G2)
    If hasCloned
       trGdip_DisposeImage(o_gdiBitmap, 1)

    If (r0!="fail" && r1!="fail" && G2)
    {
       currIMGdetails.HasAlpha := 0
       isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
       If (actionu="erase") || (InStr(actionu, "flip") && isInside=0)
          currIMGdetails.HasAlpha := 1

       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
}

ResizeIMGviewportSelection() {
    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisQuality := (userimgQuality=1) ? 7 : 5
    pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
    newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgSelW, imgSelH, 0, thisQuality, pargbPixFmt)
    If StrLen(newBitmap)<2
    {
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    UserMemBMP := newBitmap

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    recordUndoLevelNow(0, newBitmap)
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgResizeVP, -125
}

dummyInfoImgResizeVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image resized to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

getTransformToolSelectedArea(applyVPfx, doCarving, fakeBGR) {
    Return getselectedImageArea(useGdiBitmap(), doCarving, 0, applyVPfx, fakeBGR)
/*
    If (applyVPfx=1)
    {
       stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
       whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
       If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
          Return
    } Else whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    Return zBitmap
*/

}

DrawLinesInSelectedArea(modus) {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    If !G2
       Return

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (modus=1)
       coreDrawLinesSelectionArea(G2, whichBitmap)
    Else
       coreDrawShapesSelectionArea(G2, whichBitmap)

    Gdip_DeleteGraphics(G2)
    UserMemBMP := whichBitmap
    recordUndoLevelNow(0, UserMemBMP)
    SetTimer, RefreshImageFile, -25
}

coreDrawLinesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := (imgSelW + imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
    } Else
    {
       G2 := 2NDglPG
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)

       Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := (qimgSelW + qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
       If (userimgGammaCorrect=1)
       {
          Gdip_SetCompositingQuality(G2, 2)
          GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
          bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0)
       }
    }
    If (userimgGammaCorrect=1 && bgrBMPu)
    {
       trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(bgrBMPu)
    }

    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    pPathArcs := Gdip_CreatePath()
    If (DrawLineAreaBorderArcA=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 180, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcB=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 270, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcC=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 90, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcD=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 0, 90)

    pPathBrders := Gdip_CreatePath()
    If (DrawLineAreaBorderTop=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderBottom=1)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderLeft=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x1, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderRight=1)
       Gdip_AddPathLine(pPathBrders, x2, y1, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1 + imgSelW//2, y1, x1 + imgSelW//2, y2)
    
    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=3 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1, y1 + imgSelH//2, x2, y1 + imgSelH//2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=5 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    If (DrawLineAreaKeepBounds!=1)
    {
       applyLimits :=  Gdip_GetPathPointsCount(pPathBrders)>2 ? 1 : 0
       Gdip_RotatePathAtCenter(pPathBrders, vPselRotation, 1, applyLimits, rotateSelBoundsKeepRatio)
       Gdip_RotatePathAtCenter(pPathArcs, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    } Else
    {
       PersonalizedRotatePath(pPathBrders, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       PersonalizedRotatePath(pPathArcs, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
    }

    Gdip_DrawPath(G2, thisPen, pPathBrders)
    Gdip_DrawPath(G2, thisPen, pPathArcs)
    Gdip_DeletePath(pPathBrders)
    Gdip_DeletePath(pPathArcs)
    Gdip_DeletePen(thisPen)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)
}

coreDrawShapesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := (imgSelW + imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
    } Else
    {
       G2 := 2NDglPG
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
       Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := min(qimgSelW, qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.05) ? maxLength//1.05 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
       If (userimgGammaCorrect=1)
       {
          Gdip_SetCompositingQuality(G2, 2)
          GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
          If (AnyWindowOpen!=23)
             bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0)
       }
    }

    If (userimgGammaCorrect=1 && bgrBMPu)
    {
       trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(bgrBMPu)
    }

    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape)
    If (vPselRotation>0 && pPath)
    {
       If (FillAreaShape=4 || FillAreaShape=5)
          PersonalizedRotatePath(pPath, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    }

    radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
    If (FillAreaShape=2)
       DrawRoundedRectangle2(G2, thisPen, imgSelPx - thisThick//2, imgSelPy - thisThick//2, imgSelW + thisThick, imgSelH + thisThick, radius, vPselRotation)
    Else
       Gdip_DrawPath(G2, thisPen, pPath)

    Gdip_DeletePath(pPath)
    Gdip_DeletePen(thisPen)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)
}

ChangeImageCanvasSize(userW, userH, userAddT, userAddB, userAddL, userAddR, userAddC, vpMode) {
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (vpMode=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       newW := imgSelW, newH := imgSelH
       If (newW*newH>maxGDIbmpSize)
       {
          calcIMGdimensions(imgSelW, imgSelH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       } Else If (newW>32500 || newH>32500)
       {
          calcIMGdimensions(imgSelW, imgSelH, 32500, 32500, newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       }

       If (isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
          Return

       imgSelPx := - imgSelPx
       imgSelPy := - imgSelPy
       editingSelectionNow := 0
       updateUIctrl()
       MouseMoveResponder()
    } Else If (adjustCanvasMode=1)
    {
       newW := userAddL + userAddR + userAddC + imgW
       newH := userAddT + userAddB + userAddC + imgH
       imgSelPx := userAddL + (userAddC + 1)//2
       imgSelPy := userAddT + (userAddC + 1)//2
    } Else
    {
       newW := userW
       newH := userH
       imgSelPx := (adjustCanvasCentered=1) ? newW//2 - imgW//2 : 0
       imgSelPy := (adjustCanvasCentered=1) ? newH//2 - imgH//2 : 0
    }

    xBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(xBitmap, A_ThisFunc)
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap, 7, 4)
    If !G2
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    currIMGdetails.HasAlpha := 1
    If (adjustCanvasNoBgr!=1)
    {
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       Gdip_SetClipRect(G2, 0, 0, newW, newH, 0)
       Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgW, imgH, 4)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       If r0
          addJournalEntry(A_ThisFunc "(): failed to set background color through trGdip_GraphicsClear()")
       Gdip_ResetClip(G2)
    }
    ; MsgBox, % newW "--" newH "--" imgSelPx "--" imgSelPy
    ; r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy, imgW, imgH, 0, 0, imgW, imgH)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy)
    If (vpMode=1)
       pPath := createImgSelPath(0, 0, newW, newH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)

    If pPath
    {
       Gdip_SetClipPath(G2, pPath, 4)
       Gdip_DeletePath(pPath)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(whichBitmap, 1)
    If (r1!="fail")
    {
       UserMemBMP := xBitmap
       recordUndoLevelNow(0, UserMemBMP)
    } Else trGdip_DisposeImage(xBitmap, 1)
    SetTimer, RefreshImageFile, -25
}

ApplySpecialFixedBlur(funcu, zBitmap, radius, pEffect, previewMode:=0) {
    If (!pEffect || !zBitmap)
    {
       addJournalEntry("Internal error: " A_ThisFunc "() has failed: " pEffect " | " zBitmap ". Caller: " funcu "()")
       Return
    }

    If (radius>19 || previewMode=1)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Return
    }

    If (radius=19)
       radius += 18
    Else If (radius=18)
       radius += 15
    Else If (radius=17)
       radius += 12
    Else If (radius=16)
       radius += 10
    Else If (radius=15)
       radius += 8
    Else If (radius=14)
       radius += 6
    Else If (radius=13)
       radius += 4
    Else If (radius=12)
       radius += 2
    Else If (radius=11)
       radius += 1

    If (radius<=1)
       radius := 2

    zA := Gdip_CreateEffect(1, radius//2, 0, 0)
    zB := Gdip_CreateEffect(1, radius//2, 0, 0)
    Gdip_ImageRotateFlip(zBitmap, 1)
    Gdip_BitmapApplyEffect(zBitmap, zA)
    Gdip_ImageRotateFlip(zBitmap, 3)
    Gdip_BitmapApplyEffect(zBitmap, zB)
    Gdip_DisposeEffect(zA)
    Gdip_DisposeEffect(zB)
}

BlurSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := 1 ; testSelectionLargerThanGiven(imgW, imgH)
    decXbr := (X1<0) ? Abs(X1) : 0
    decYbr := (Y1<0) ? Abs(Y1) : 0
    If (X1<5)
       X1MarginSnap := 1
    If (X2>imgW - 5)
       X2MarginSnap := 1
    If (Y1<5)
       Y1MarginSnap := 1
    If (Y2>imgH - 5)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && blurAreaInverted=1 && EllipseSelectMode=0 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    } Else If (blurAreaAmount<2 && blurAreaPixelizeAmount<2)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You have set both pixelize amount and blur amount to zero. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h

    If (blurAreaSoftEdges!=1 && pPath)
    {
       modus := (blurAreaInverted=1) ? 4 : 0
       If (blurAreaInverted=1 && pPath)
          Gdip_SetClipPath(G2, pPath, 4)
       Else If pPath
          Gdip_SetClipPath(G2, pPath, modus)
    }

    If (blurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    thisOpacity := blurAreaOpacity/255
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 1, 1)

    If (blurAreaPixelizeAmount>1 && blurAreaPixelizeMethod>1)
    {
       thisAmount := blurAreaPixelizeAmount
       thisImgW := (blurAreaPixelizeAmount>1) ? Ceil(imgSelW/blurAreaPixelizeAmount) : imgSelW
       thisImgH := (blurAreaPixelizeAmount>1) ? Ceil(imgSelH/blurAreaPixelizeAmount) : imgSelH
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       thisPixiQuality := (blurAreaPixelizeMethod=2) ? 5 : 7
       pixiBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, thisImgW, thisImgH, 0, thisPixiQuality)
       If pixiBMP
          newBitmap := trGdip_ResizeBitmap(A_ThisFunc, pixiBMP, imgSelW, imgSelH, 0, 5)

       If (newBitmap && pixiBMP)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
       trGdip_DisposeImage(pixiBMP, 1)
    } Else If (blurAreaPixelizeAmount>1)
    {
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, coreDesiredPixFmt)
       If warnUserFatalBitmapError(pixiBMP, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(zBitmap, 1)
          Gdip_DeletePath(pPath)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       thisStartZeit := A_TickCount
       QPV_PixelateBitmap(zBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(imgSelW, imgSelH)))
       ; ToolTip, % A_TickCount - thisStartZeit , , , 2
       trGdip_DisposeImage(zBitmap, 1)
       zBitmap := pixiBMP
    }

    thisBlurMode := blurAreaMode
    pEffect := Gdip_CreateEffect(1, blurAreaAmount, 0, 0)
    If (blurAreaTwice=1)
    {
       setWindowTitle("EXTRA-BLURRING IMAGE, please wait", 1)
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//2, imgSelH//2, 1, 3, -1)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          dhMatrix := Gdip_CreateMatrix()
          Gdip_ScaleMatrix(dhMatrix, 2, 2, 1)
          Gdip_TranslateMatrix(dhMatrix, imgSelPx, imgSelPy, 1)
          If (thisBlurMode=3)
          {
             QPV_BoxBlurBitmap(xBitmap, Round(blurAreaAmount/2))
          } Else If (thisBlurMode=2)
          {
             gBitmap := trGdip_BlurBitmap(xBitmap, blurAreaAmount/2.5, 1, 6)
             If !isWinXP
                ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

             Gu := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
             If (Gu && gBitmap)
             {
                trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
                Gdip_DeleteGraphics(Gu)
             }
             trGdip_DisposeImage(gBitmap, 1)
          } Else If (thisBlurMode=1)
             ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

          ; trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, imgSelW, imgSelH, 1, 3, -1)
          trGdip_DisposeImage(xBitmap, 1)
       }
    }

    If (blurAreaAmount<2)
       thisBlurMode := 0
    Else
       setWindowTitle("BLURRING IMAGE, please wait", 1)

    If (thisBlurMode=3) ; box blur
    {
       QPV_BoxBlurBitmap(zBitmap, Round(blurAreaAmount/2))
       gEffect := Gdip_CreateEffect(5, Round(blurAreaAmount/2.5), blurAreaAmount//6)
       If gEffect  ; light readjustments
          Gdip_BitmapApplyEffect(zBitmap, gEffect)

       Gdip_DisposeEffect(gEffect)
    } Else If (thisBlurMode=2)  ; alternate mode
    {
       ; gBitmap := Gdip_BlurNewBitmap(zBitmap, blurAreaAmount, 1, 0)
       gBitmap := trGdip_BlurBitmap(zBitmap, blurAreaAmount/2.5, 1, 6)
       If (!isWinXP && pEffect)
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

       Gu := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
       If (Gu && gBitmap)
       {
          trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
          Gdip_DeleteGraphics(Gu)
       }
       trGdip_DisposeImage(gBitmap, 1)
    } Else If (thisBlurMode=1) ; high quality
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

    If (BlurAreaBlendMode>1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252 && blurAreaSoftEdges!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    If (blurAreaSoftEdges=1)
    {
       setWindowTitle("APPLYING SOFT EDGES MASK, please wait", 1)
       thisAmount := (blurAreaTwice=1) ? blurAreaAmount*2 : blurAreaAmount
       thisAmount := (blurAreaSoftLevel>3) ? Round(thisAmount*(blurAreaSoftLevel - 1)) : Round(thisAmount*(blurAreaSoftLevel/3))
       modus := (blurAreaInverted!=1) ? 4 : 0
       carvePathFromBitmap(zBitmap, pPath, imgSelPx , imgSelPy, modus, 2, thisAmount, !blurAreaInverted)
    }

    If (BlurAreaBlendMode>1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       rz := QPV_BlendBitmaps(bgrBMPu, zBitmap, BlurAreaBlendMode - 1, 0)
       ou := zBitmap
       zBitmap := bgrBMPu
       bgrBMPu := ou
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DeleteMatrix(dhMatrix)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r1!="fail" && r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

detectEdgesSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       setWindowTitle("DETECTING EDGES - iteration " A_Index "/" thisCount ", please wait", 1)
       r0 := coreDetectEdgesSelectedArea(whichBitmap, 0, G2)
       If r0
          Break
    }

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreDetectEdgesSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    If (IDedgesBlendMode>1)
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)

    If (IDedgesCenterAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesCenterAmount, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, IDedgesCenterAmount, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
    r0 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, IDedgesXuAmount, IDedgesYuAmount)
    QPV_BlendBitmaps(fBitmap, zBitmap, 16, 0) ; difference mode

    zEffect := Gdip_CreateEffect(6, 0, -100, 0)  ; desaturate image
    If zEffect
       Gdip_BitmapApplyEffect(fBitmap, zEffect)
    Gdip_DisposeEffect(zEffect)

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(fBitmap, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(fBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesAfterBlur>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesAfterBlur*2, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, fBitmap, IDedgesAfterBlur*2, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesBlendMode>1)
    {
       QPV_BlendBitmaps(gBitmap, fBitmap, IDedgesBlendMode - 1, 0)
       If (previewMode!=1)
          r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && gBitmap) ? gBitmap : fBitmap
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G3)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)
    er := r1 ? r1 : r0
    Return er
}

addNoiseSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    setWindowTitle("ADDING NOISE, please wait", 1)
    r0 := coreAddNoiseSelectedArea(whichBitmap, 0, G2)

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreAddNoiseSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    thisPixelize := (doubleBlurPreviewArea=1 && previewMode=1) ? blurAreaPixelizeAmount/2 : blurAreaPixelizeAmount
    thisImgW := (thisPixelize>1) ? Ceil(imgSelW/thisPixelize) : imgSelW
    thisImgH := (thisPixelize>1) ? Ceil(imgSelH/thisPixelize) : imgSelH
    noiseBMP := QPV_CreateBitmapNoise(thisImgW, thisImgH, UserAddNoiseIntensity, UserAddNoiseMode, 1)
    If (thisPixelize>1)
    {
       newBitmap := trGdip_ResizeBitmap(A_ThisFunc, noiseBMP, imgSelW, imgSelH, 0, 5)
       If newBitmap
       {
          trGdip_DisposeImage(noiseBMP, 1)
          noiseBMP := newBitmap
       }
    }

    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    thisBlurAmount := (doubleBlurPreviewArea=1 && previewMode=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, noiseBMP, thisBlurAmount, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(noiseBMP, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(noiseBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesBlendMode>1)
    {
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
       If gBitmap
          QPV_BlendBitmaps(gBitmap, noiseBMP, IDedgesBlendMode - 1, 0)
    }

    ; r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && gBitmap) ? gBitmap : noiseBMP
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeletePath(pPath)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)

    er := r1 ? r1 : r0
    Return er
}

livePreviewsPanelNoEffects() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
 }

livePreviewIDedges() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       r0 := coreDetectEdgesSelectedArea(cornersBMP, 1)
       If r0
          Break
    }

    flipBitmapAccordingToViewPort(cornersBMP, 1)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

livePreviewAddNoiser() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)

    Gdip_DeleteGraphics(G)
    r0 := coreAddNoiseSelectedArea(cornersBMP, 1)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

QPV_BoxBlurBitmap(pBitmap, passes) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BoxBlurBitmap(pBitmap, passes)
  }

  If !pBitmap
     Return 0

  Gdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  If E1
     Return 0

  func2exec := (A_PtrSize=8) ? "BoxBlurBitmap" : "_BoxBlurBitmap@20"
  r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", stride, "Int", passes)
  Gdip_UnlockBits(pBitmap, iData)
  ; DllCall("GlobalFree", "ptr", mCodeFunc)
  return r
}

QPV_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize) {
   initQPVmainDLL()
   If !qpvMainDll
   {
      addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
      Return Gdip_PixelateBitmap(pBitmap, pBitmapOut, BlockSize)
   }

   if (!pBitmap || !pBitmapOut)
      return -3

   Gdip_GetImageDimensions(pBitmap, Width, Height)
   If (width<1 || height<1)
      Return 0

   if (Width!=Gdip_GetImageWidth(pBitmapOut) || Height!=Gdip_GetImageHeight(pBitmapOut))
      return -1

   if (BlockSize>Width || BlockSize>Height)
      return -2

   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)

   func2exec := (A_PtrSize=8) ? "PixelateBitmap" : "_PixelateBitmap@24"
   if (!E1 && !E2)
      r := DllCall("qpvmain.dll\" func2exec, "UPtr", Scan01, "UPtr", Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)
   
   If !E1
      Gdip_UnlockBits(pBitmap, BitmapData1)

   If !E2
      Gdip_UnlockBits(pBitmapOut, BitmapData2)
   return r
}

applyVPeffectsOnBMP(zBitmap) {
    Gdip_GetImageDimensions(zBitmap, imgW, imgH)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If imageAttribs
    {
       bluba := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
       If StrLen(bluba)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := bluba
          }
       }
    }
    Return zBitmap
}

GetPathRelativeBounds(pPath, imgSelPx, imgSelPy) {
    pB := Gdip_GetPathWorldBounds(pPath)
    pB.xa := Round(imgSelPx + pB.x)
    pB.ya := Round(imgSelPy + pB.y)
    pB.w := Round(pB.w)
    pB.h := Round(pB.h)
    Return pB
}

getselectedImageArea(whichBitmap, doCarving, limitBounds, applyVPfx, fakeBGR) {
    If StrLen(whichBitmap)<3
    {
       addJournalEntry(A_ThisFunc "(): failed; no bitmap given")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!limitBounds, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    pPath := createImgSelPath(0, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If pPath
    {
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       pBxa := (limitBounds=1) ? clampInRange(pB.xa, 0, imgW - 1) : pB.xa
       pBya := (limitBounds=1) ? clampInRange(pB.ya, 0, imgH - 1) : pB.ya
       pBw := (limitBounds=1) ? clampInRange(pB.w, pB.xa + 1, imgW) : pB.w
       pBh := (limitBounds=1) ? clampInRange(pB.h, pB.ya + 1, imgH) : pB.h

       ; ToolTip, % imgSelPx "===" imgSelPy "`n" pBw "===" pBh , , , 2
       ; extendedClone := !limitBounds ; (A_PtrSize=8) ? 1 : 0
       dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, pBxa, pBya, pBw, pBh, 0, 0, 1, 0)
       If (applyVPfx>0)
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)

       If (doCarving=1 && dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4, fakeBGR)

       If (applyVPfx=2)
          flipBitmapAccordingToViewPort(dummyBMP)

       ; QPV_SetGivenAlphaLevel(dummyBMP, 1, 1)
       Gdip_DeletePath(pPath)
       Return dummyBMP
    } Else addJournalEntry(A_ThisFunc "(): failed to create GDI+ object path")
}

CropImageInViewPortToSelection(modus:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If throwErrorSelectionOutsideBounds(whichBitmap)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (UserMemBMP=whichBitmap)
       xBitmap := UserMemBMP

    If (modus!="simplex" && EllipseSelectMode=0 && isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
    {
       MouseMoveResponder()
       SetTimer, RefreshImageFile, -25
       Return
    }

    recordUndoLevelNow("init", 0)
    dummyBMP := getselectedImageArea(whichBitmap, 1, 0, 0, 0)
    If StrLen(dummyBMP)>1
    {
       If (EllipseSelectMode>0 || VPselRotation>0 || X1<0 || Y1<0 || X2>imgW || Y2>ImgH)
          currIMGdetails.HasAlpha := 1
       UserMemBMP := dummyBMP
    } Else
    {
       showTOOLtip("Failed to crop image to selected area.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    recordUndoLevelNow(0, UserMemBMP)
    trGdip_DisposeImage(xBitmap, 1)
    If (modus="simplex")
       Return

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgCropVP, -125
}

dummyInfoImgCropVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image canvas size set to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

MenuPasteHDropFiles() {
   r := PasteHDropFiles(1)
   If !r
   {
      showTOOLtip("No image files identified in the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PasteHDropFiles(allowFilesPaste) {
   Try testClipTypeImgA := IsClipboardFormatAvailable(8)
   Try testClipTypeImgB := IsClipboardFormatAvailable(2)
   If (testClipTypeImgA=1 || testClipTypeImgB=1)
      Return

   Try testClipType := IsClipboardFormatAvailable(15)
   Try imgsListu := Clipboard
   If (testClipType!=1)
   {
      filesFound := 0
      Loop, Parse, imgsListu, `n,`r
      {
           If FileExist(Trimmer(A_LoopField))
              filesFound := 1
      } Until (A_Index>5)

      If (filesFound!=1)
      {
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (testClipType=1 || filesFound=1) && (allowFilesPaste=0)
   {
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   countFiles := ST_Count(Trimmer(imgsListu), "`n")
   If (countFiles>0 && StrLen(imgsListu)>4)
   {
      showTOOLtip("Files identified in the clipboard")
      msgResult := msgBoxWrapper(appTitle ": Paste files", "You have " countFiles " file entries stored in the clipboard by your file explorer or manager.`n`nWould you like to import the image files (if any) into the files list of " appTitle "?", 4, 0, "question", "Select newly inserted index entries")
   }

   If InStr(msgResult.btn, "yes")
   {
      initialIndex := maxFilesIndex
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir, msgResult.check)
      If (initialIndex!=maxFilesIndex)
      {
         currentFileIndex := maxFilesIndex - 1
         GenerateRandyList()
         dummyTimerDelayiedImageDisplay(50)
         ForceRefreshNowThumbsList()
         newFiles := max(initialIndex, maxFilesIndex) - min(initialIndex, maxFilesIndex)
         showTOOLtip("Finished adding " groupDigits(newFiles) " files to the current list from the clipboard")
      } Else showTOOLtip("No image files identified in the clipboard`nFiles list unchanged.")
   } Else RemoveTooltip()

   ResetImgLoadStatus()
   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return 1
}

ClipboardGetDropEffect() {
/*
    Retrieves the preferred method of data transfer (preferred drop effect set by source).
    Return value:
        If the function succeeds, the return value is one of the following.
        1  DROPEFFECT_COPY      The source should copy the data. The original data is untouched.
        2  DROPEFFECT_MOVE      The source should remove the data.
        5                       This value also indicates copy (DROPEFFECT_COPY).
        ---------------------------------------------------
        Any other value is considered an error.
        -1        No data transfer operation found.
        -2        The clipboard could not be opened.
    Windows Clipboard Formats:
        https://www.codeproject.com/Reference/1091137/Windows-Clipboard-Formats
*/
; to-do ; fix this

   If !IsClipboardFormatAvailable(15)
      Return -1

   If !DllCall("OpenClipboard", "UPtr", A_ScriptHwnd)
      Return -2

   h := DllCall("User32.dll\GetClipboardData", "UInt", 15, "UPtr") ; CF_HDROP = 15
   z := DllCall("Kernel32.dll\GlobalLock", "Ptr", h, "Ptr")
   If z
      r := NumGet(z, 0, "Int")
   g := DllCall("Kernel32.dll\GlobalUnlock", "Ptr", h, "Ptr")
   DllCall("CloseClipboard")
   Return r
}

IsClipboardFormatAvailable(typeu) {
/*
    Values for typeu     Description
    CF_TEXT = 1          Text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the data. Use this format for ANSI text.
    CF_BITMAP = 2        A handle to a bitmap (HBITMAP).
    CF_METAFILEPICT = 3  Handle to a metafile picture format as defined by the METAFILEPICT structure. When passing a CF_METAFILEPICT handle by means of DDE, the application responsible for deleting hMem should also free the metafile referred to by the CF_METAFILEPICT handle.
    CF_SYLK =  4         Microsoft Symbolic Link (SYLK) format.
    CF_DIF = 5           Software Arts' Data Interchange Format.
    CF_TIFF = 6          Tagged-image file format.
    CF_OEMTEXT = 7       Text format containing characters in the OEM character set. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the data.
    CF_DIB = 8           A memory object containing a BITMAPINFO structure followed by the bitmap bits.
    CF_PENDATA = 10      Data for the pen extensions to the Microsoft Windows for Pen Computing.
    CF_RIFF = 11         Represents audio data more complex than can be represented in a CF_WAVE standard wave format.
    CF_WAVE = 12         Represents audio data in one of the standard wave formats, such as 11 kHz or 22 kHz PCM.
    CF_UNICODETEXT = 13  Unicode text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the data.
    CF_ENHMETAFILE = 14  A handle to an enhanced metafile (HENHMETAFILE).
    CF_HDROP = 15        A handle to type HDROP that identifies a list of files. An application can retrieve information about the files by passing the handle to the DragQueryFile function.
    CF_DIBV5 = 17        A memory object containing a BITMAPV5HEADER structure followed by the bitmap color space information and the bitmap bits.
    CF_DSPBITMAP = 0x0082
        Bitmap display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in bitmap format in lieu of the privately formatted data.
    CF_DSPENHMETAFILE = 0x008E
        Enhanced metafile display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in enhanced metafile format in lieu of the privately formatted data.
    CF_DSPMETAFILEPICT = 0x0083
        Metafile-picture display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in metafile-picture format in lieu of the privately formatted data.
    CF_DSPTEXT = 0x0081
        Text display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in text format in lieu of the privately formatted data.
    CF_GDIOBJFIRST = 0x0300
        Start of a range of integer values for application-defined GDI object clipboard formats. The end of the range is CF_GDIOBJLAST.
    Handles associated with clipboard formats in this range are not automatically deleted using the GlobalFree function when the clipboard is emptied. Also, when using values in this range, the hMem parameter is not a handle to a GDI object, but is a handle allocated by the GlobalAlloc function with the GMEM_MOVEABLE flag.
    CF_GDIOBJLAST = 0x03FF
        See CF_GDIOBJFIRST.
    CF_LOCALE =  16
        The data is a handle (HGLOBAL) to the locale identifier (LCID) associated with text in the clipboard. When you close the clipboard, if it contains CF_TEXT data but no CF_LOCALE data, the system automatically sets the CF_LOCALE format to the current input language. You can use the CF_LOCALE format to associate a different locale with the clipboard text.
        An application that pastes text from the clipboard can retrieve this format to determine which character set was used to generate the text.
        Note that the clipboard does not support plain text in multiple character sets. To achieve this, use a formatted text data type such as RTF instead.
        The system uses the code page associated with CF_LOCALE to implicitly convert from CF_TEXT to CF_UNICODETEXT. Therefore, the correct code page table is used for the conversion.
    CF_OWNERDISPLAY =  0x0080
        Owner-display format. The clipboard owner must display and update the clipboard viewer window, and receive the WM_ASKCBFORMATNAME, WM_HSCROLLCLIPBOARD, WM_PAINTCLIPBOARD, WM_SIZECLIPBOARD, and WM_VSCROLLCLIPBOARD messages. The hMem parameter must be NULL.
    CF_PALETTE = 9
        Handle to a color palette. Whenever an application places data in the clipboard that depends on or assumes a color palette, it should place the palette on the clipboard as well.
        If the clipboard contains data in the CF_PALETTE (logical color palette) format, the application should use the SelectPalette and RealizePalette functions to realize (compare) any other data in the clipboard against that logical palette.
        When displaying clipboard data, the clipboard always uses as its current palette any object on the clipboard that is in the CF_PALETTE format.
    CF_PRIVATEFIRST = 0x0200
        Start of a range of integer values for private clipboard formats. The range ends with CF_PRIVATELAST. Handles associated with private clipboard formats are not freed automatically; the clipboard owner must free such handles, typically in response to the WM_DESTROYCLIPBOARD message.
    CF_PRIVATELAST = 0x02FF
        See CF_PRIVATEFIRST.
*/ 

   Return DllCall("IsClipboardFormatAvailable", "uint", typeu)
}

corePasteClipboardImg(modus, imgW, imgH, allowFilesPaste) {
    clipBMP := Gdip_CreateBitmapFromClipboard()
    If StrLen(clipBMP)>2
       createdGDIobjsArray["x" clipBMP] := [clipBMP, "bmp", 1, A_ThisFunc]

    If (isInRange(Abs(clipBMP), 1, 5) || !clipBMP)
    {
       If PasteHDropFiles(allowFilesPaste)
          Return

       Try toPaste := Trimmer(Clipboard)
       If StrLen(toPaste)>2
       {
          textMode := 1
          toPaste := SubStr(toPaste, 1, 9500)
          clipBMP := drawTextInBox(toPaste, OSDFontName, PasteFntSize, imgW, imgH, OSDtextColor, OSDbgrColor, 0, 0, usrTextAlign, "0xFF")
          If (modus=1)
             showTOOLtip("Text clipboard content rendered as image`nOSD font and colors used")
          SetTimer, RemoveTooltip, % -msgDisplayTime
       } Else
       {
          Tooltip
          showTOOLtip("ERROR: Unable to retrieve image from clipboard")
          SetTimer, ResetImgLoadStatus, -25
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ; disposeCacheIMGs()
    If StrLen(clipBMP)<3
       Return

    If (!InStr(Gdip_GetImagePixelFormat(clipBMP, 1), "0xE200") && coreDesiredPixFmt="0xE200B")
    {
       krpBmp := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
       If krpBmp
       {
          trGdip_DisposeImage(clipBMP, 1)
          clipBMP := krpBmp
       }
    }
    ; MsgBox, % Gdip_GetImagePixelFormat(clipBMP, 1)
    Return clipBMP
}

tlbrPasteClipboardIMG() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelPasteInPlace()
   Else
      PasteClipboardIMG()
}

PasteClipboardIMG(modus:=0, clipBMP:=0) {
    Critical, on
    Static clippyCount := 0

    If (AnyWindowOpen>0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    ; If askAboutFileSave(" and the clipboard image or files entries are going to be pasted")
    ;    Return

    setImageLoading()
    changeMcursor()
    calcScreenLimits()
    imgPath := getIDimage(currentFileIndex)
    If (modus!="scanner")
    {
       showTOOLtip("Retrieving clipboard, please wait")
       If PasteHDropFiles(1)
          Return

       clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    }

    If !clipBMP
    {
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, -500
       Return
    }

    isImgOpen := 1
    If ((StrLen(gdiBitmap)>2 || StrLen(UserMemBMP)>2) && imgPath && A_PtrSize=8)
       isImgOpen := 2
    Else If (!currentFileIndex || !CurrentSLD || !maxFilesIndex || !imgPath)
       isImgOpen := 0

    ; terminateIMGediting()
    If (isImgOpen=2)
       recordUndoLevelNow("init", 0)

    clippyCount++
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    If (editingSelectionNow=1)
       ToggleEditImgSelection()

    discardViewPortCaches()
    UserMemBMP := clipBMP
    If (isImgOpen=0)
    {
       maxFilesIndex := currentFileIndex := 0
       labelu := (modus="scanner") ? "WIA-Acquired-" : "Clipboard-"
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\" labelu "-" clippyCount ".img"
    }
    
    If (modus!="scanner")
    {
       currIMGdetails.HasAlpha := 1
       isUniform := Gdip_TestBitmapUniformity(clipBMP, 7, maxLevelIndex)
       If (isUniform=1 && isInRange(maxLevelIndex, 252, 255))
          currIMGdetails.HasAlpha := 0
    } Else currIMGdetails.HasAlpha := 0
    ; ToolTip, % currIMGdetails.HasAlpha " = lol" , , , 2
    currentImgModified := usrColorDepth := imgFxMode := 1
    imgIndexEditing := currentFileIndex
    vpIMGrotation := FlipImgH := FlipImgV := 0
    defineColorDepth()
    dropFilesSelection(1)
    RemoveTooltip()
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "imgFxMode", "General")
    If (isImgOpen=2)
       recordUndoLevelNow(0, UserMemBMP)
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, RefreshImageFile, -50
}

thumbsSelector(keyu, aKey, prevFileIndex) {
  Static lastInvoked := 1

  ; ToolTip, % prevFileIndex "--" markedSelectFile "`n" lola
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Upu" || keyu="Home") && prevFileIndex<=1)
  || (InStr(aKey, "+") && (keyu="Right" || keyu="Down" || keyu="End") && prevFileIndex>=maxFilesIndex)
     Return

  selA := resultedFilesList[currentFileIndex, 2]
  selB := resultedFilesList[prevFileIndex, 2]
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Right"))
  {
     testIndex := (keyu="Left") ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (keyu="Left") ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        markedSelectFile++
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 1
     } Else If (selA=1 && selB=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 0
        markedSelectFile -= 2
     }

     markedSelectFile++
     lastZeitFileSelect := A_TickCount
  } Else If InStr(aKey, "+") ; && (keyu="Upu" || keyu="Down"))
  {
     direction := (keyu="Down" || keyu="PgDn" || keyu="End") ? 1 : 0
     testIndex := (direction!=1) ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (direction!=1) ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        lastZeitFileSelect := A_TickCount
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 1)
        lastZeitFileSelect := A_TickCount
     } Else If (selA=1 && selB=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 0)
        resultedFilesList[currentFileIndex, 2] := 1
        lastZeitFileSelect := A_TickCount
        markedSelectFile++
     }
  }

  If (markedSelectFile=1 && InStr(aKey, "+"))
  {
     markedSelectFile := 0
     lastZeitFileSelect := A_TickCount
     resultedFilesList[currentFileIndex, 2] := 0
  }
}

generateNumberRangeString(pA, pB) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
        stringRange .= "," mA + A_Index - 1 "|"

    Return stringRange
}

selectFilesRange(pA, pB, sel) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
    {
        oSel := resultedFilesList[mA + A_Index - 1, 2]
        resultedFilesList[mA + A_Index - 1, 2] := sel
        If (sel=1 && oSel!=1)
           markedSelectFile++
        Else If (sel!=1 && oSel=1)
           markedSelectFile--
    }
    lastZeitFileSelect := A_TickCount
    Return rangeC
}

jumpSelectRangeGiven(pA, pB) {
   mB := max(pA, pB)
   mA := min(pA, pB)
   rangeC := mB - mA + 1
   changeMcursor()
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection. The given range is: " mA " - " mB, "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel")
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   If (msgResult="replace" || !msgResult)
   {
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % rangeC
      resultedFilesList[mA + A_Index - 1, 2] := (msgResult="add" || !msgResult) ? 1 : 0

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ResetImgLoadStatus()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   Return rangeC
}

ThumbsNavigator(keyu, aKey) {
  resetSlideshowTimer(0)
  If (thumbsDisplaying!=1 && maxFilesIndex>1)
  {
     If askAboutFileSave(" and another image will be loaded")
        Return
  }

  prevFileIndex := currentFileIndex
  thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
  If (keyu="Down")
  {
     currentFileIndex := currentFileIndex + maxItemsW - 1
     NextPicture(0, 0, 1)
  } Else If (keyu="Upu")
  {
     currentFileIndex := currentFileIndex - maxItemsW + 1
     PreviousPicture(0, 0, 1)
  } Else If (keyu="PgUp")
  {
     currentFileIndex := currentFileIndex - maxItemsPage + 1
     PreviousPicture()
  } Else If (keyu="PgDn")
  {
     Loop, % maxItemsH
     {
        currentFileIndex := currentFileIndex + maxItemsW - 1
        NextPicture(0, 0, 1)
        thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
     }
     ; currentFileIndex := currentFileIndex + maxItemsPage - 1
     ; NextPicture()
  } Else If (keyu="Left")
     PreviousPicture()
  Else If (keyu="Right")
     NextPicture()
  Else If (keyu="End")
     LastPicture()
  Else If (keyu="Home")
     FirstPicture()

  thumbsSelector(keyu, aKey, prevFileIndex)
  If (thumbsDisplaying!=1 && InStr(aKey, "+"))
     dummyTimerDelayiedImageDisplay(50)
}

PanIMGonScreen(direction, thisKey) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (GetKeyState("Left", "P")!=1 && GetKeyState("Right", "P")!=1)
   && (GetKeyState("Down", "P")!=1 && GetKeyState("Up", "P")!=1)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If InStr(thisKey, "+")
      zL := clampInRange(zoomLevel, 0.8, 3.2)
   Else
      zL := clampInRange(zoomLevel, 0.7, 2.1)

   stepu := InStr(thisKey, "+") ? 0.35 * zL : 0.1 * zL
   stepu := (Round(mainHeight*stepu) + Round(mainWidth*stepu))//2 + 1
   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY + stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX + stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX - stepu

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      diffIMGdecY := stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      diffIMGdecY := - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      diffIMGdecX := stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      diffIMGdecX := - stepu

   dummyTimerDelayiedImageDisplay(5)
}

dummyTimerDelayiedImageDisplay(timeru:=0) {
  If (timeru>1)
     SetTimer, extraDummyDelayiedImageDisplay, % -timeru ; , 950
}

extraDummyDelayiedImageDisplay() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -15
     Return
  }
  DelayiedImageDisplay()
}

filterDelayiedImageDisplay() {
  Static lastInvoked := 1
  If (A_tickcount - lastInvoked < 60)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -50
     Return
  }
  lastInvoked := A_TickCount
  DelayiedImageDisplay()
  lastInvoked := A_TickCount
}

DelayiedImageDisplay() {
   If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
   {
      r := IDshowImage(currentFileIndex)
      If !r
         informUserFileMissing()
   }
}

DonateNow() {
   Try Run, https://www.paypal.me/MariusSucan/10
}

openSettingsDir() {
   Try Run, % mainCompiledPath
}

DeleteAllSettings() {
    SoundBeep, 300, 300
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete ALL personalized settings?`n`n" appTitle " will automatically restart if you choose to do so. This action is irreversible.", "&Restore defaults|&Cancel", 2, "exclamation")
    If (msgResult="restore defaults")
    {
       FileSetAttrib, -R, % mainSettingsFile
       FileDelete, % mainSettingsFile
       terminateIMGediting()
       restartAppu()
    }
}

externalinvokedSettingsContextMenu() {
    
    hwndA := WinActive("ahk_id " hSetWinGui)
    hwndB := WinActive("ahk_id " MsgBox2hwnd)
    hwnd := ((hwndA=hSetWinGui || hwndB=MsgBox2hwnd) && AnyWindowOpen) ? 1 : 0
    If (hwnd!=1)
       Return

    If (AnyWindowOpen && MsgBox2hwnd=hwndB && hwndB && MsgBox2InputHook)
       GuiControlGet, OutputVar, WinMsgBox: Focus
    Else If AnyWindowOpen
       GuiControlGet, OutputVar, SettingsGUIA: Focus
    ; ToolTip, % OutputVar , , , 2
    If InStr(OutputVar, "edit")
       Return

    If (AnyWindowOpen=3 && InStr(OutputVar, "listview"))
       invokePanelDynaFoldersContextMenu()
    Else If (AnyWindowOpen=2 && InStr(OutputVar, "listview"))
       invokePanelStaticFoldersContextMenu()
    Else If AnyWindowOpen
       invokePrefsPanelsContextMenu()
}

SettingsGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (mouseToolTipWinCreated=1)
    {
       mouseTurnOFFtooltip()
       Return
    }

    If (GuiHwnd!=hSetWinGui)
       Return

    If (AnyWindowOpen=3 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=2 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelStaticFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview") && IsRightClick=1) ; || (MsgBox2hwnd && A_IsSuspended)
    {
       If SettingsToolTips()
          Return
    }

    If (CtrlHwnd && IsRightClick=1) || ((A_TickCount - lastInvoked>250) && IsRightClick=0) || (mouseToolTipWinCreated=1)
    {
       lastInvoked := A_TickCount
       Return
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu()
    Return
}

invokePrefsPanelsContextMenu() {
    Menu, ContextMenu, UseErrorLevel
    Menu, ContextMenu, Delete
    Sleep, 5
    Menu, ContextMenu, Add, &Large UI fonts, ToggleLargeUIfonts
    Menu, ContextMenu, Add, &Close panel`tEscape, CloseWindow
    If (imgEditPanelOpened=1)
       Menu, ContextMenu, Add, C&ollapse panel`tF8, toggleImgEditPanelWindow
    Menu, ContextMenu, Add, 
    If (PrefsLargeFonts=1)
       Menu, ContextMenu, Check, &Large UI fonts

    Menu, ContextMenu, Add, O&pen settings folder, openSettingsDir
    Menu, ContextMenu, Add, Restore ALL defaults, DeleteAllSettings
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &Visit official site, OpenGitHub
    Menu, ContextMenu, Add, &Make a donation, DonateNow
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &New instance, OpenNewQPVinstance
    Menu, ContextMenu, Add, &Restart %appTitle%, restartAppu
    showThisMenu("ContextMenu")
}

WinMsgBoxGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1
    If (mouseToolTipWinCreated=1) ; || (A_TickCount - lastInvoked<90)
    {
       mouseTurnOFFtooltip()
       Return
    }

    ; isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
    If (!MsgBox2hwnd || !isNowFakeWinOpen)
       Return

    If (isRightClick=1)
    {
       If SettingsToolTips()
          Return
       Else If AnyWindowOpen
          invokePrefsPanelsContextMenu()
    }

    lastInvoked := A_TickCount
    Return
}

WM_RBUTTONUP() {
    ; unused function - see GuiContextMenu() functions 
    ; Tooltip, %A_GuiControl%
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()
    Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview")) || (MsgBox2hwnd && A_IsSuspended)
       SettingsToolTips()
}

SettingsToolTips() {
   ActiveWin := WinActive("A")
   ; bActiveWin := WinExist("A")
   thisHwndGood := (ActiveWin=hSetWinGui) || (ActiveWin=MsgBox2hwnd && A_IsSuspended) ? 1 : 0
   ;  ToolTip, % isNowFakeWinOpen "==" ActiveWin "==" thisHwndGood "==" PVhwnd "==" hSetWinGui "==" MsgBox2hwnd , , , 2
   If (thisHwndGood!=1 && ActiveWin!=PVhwnd)
      Return

   If (mouseToolTipWinCreated=1)
      mouseTurnOFFtooltip()
 
   If (ActiveWin=MsgBox2hwnd && A_IsSuspended)
   {
      Gui, WinMsgBox: Default
   } Else
   {
      If (panelWinCollapsed=1)
      {
         toggleImgEditPanelWindow()
         Return
      }

      Gui, SettingsGUIA: Default
   }

   GuiControlGet, value, , %A_GuiControl%
   ; MouseGetPos, , , , hwnd, 1 ; |2|3]
   GuiControlGet, hwnd, hwnd, %A_GuiControl%
   ControlGetText, info,, ahk_id %hwnd%
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
   If (info=value)
      info := ""

   If StrLen(info)>0
      info .= "`n"

   If (posuk := InStr(value, "&"))
      hotkeyu := "`nAlt+" SubStr(value, posuk + 1, 1)
   Else If (posuk := InStr(A_GuiControl, "&"))
      hotkeyu := "`nAlt+" SubStr(A_GuiControl, posuk + 1, 1)
   
   StringUpper, hotkeyu, hotkeyu
   value := StrReplace(value, "&")
   ctrlu := StrReplace(A_GuiControl, "&")
   If (ctrlu=value)
      value := ""

   ; btnType := GetButtonType(hwnd)
   If StrLen(value)>0
   {
      thisValueNumber := isNumber(Trimmer(value))
      value .= " = "
   }

   MouseGetPos, , , id, controla, 2
   If !hwnd
      ControlGetText, info, , ahk_id %controla%

   If !hotkeyu
   {
      If (posuk := InStr(info, "&"))
         hotkeyu := "`nAlt+" SubStr(info, posuk + 1, 1)
   }

   info := StrReplace(info, "&")
   WinGetClass, OutputVar, ahk_id %hwnd%
   If OutputVar
   {
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " minu "; " maxu
      } Else If (InStr(OutputVar, "Button") && thisValueNumber=1 && InStr(value, "="))
         OutputVar := "Checkbox"
      Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value)
      {
         OutputVar := "Clickable" ; value  " - " ctrlu
         controlType := "`n[" OutputVar "]"
      }
      If !InStr(OutputVar, "static")
         controlType := "`n[" OutputVar "]"
   }

   msg2show := info value ctrlu controlType hotkeyu
   ; ToolTip, % A_DefaultGUI "===" msg2show , , , 2
   ; If (ctrlActiveState!=1 && StrLen(msg2show)>2 && btnType)
   ;    msg2show .= "`n[CONTROL DISABLED]"
   If StrLen(listBoxOptions)>3
   {
      countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
      If (countListBoxOptions>10)
         listBoxOptions := "[too many to list]"
      msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
   }

   ; If (!value && btnType)
   ;    msg2show .= "`n`nCONTROL TYPE:`n" btnType
   If InStr(msg2show, "lib\") || InStr(msg2show, "a href=")
      Return

   mouseCreateOSDinfoLine(msg2show, PrefsLargeFonts)
   Return msg2show
}

ST_Count(Haystack, searchFor) {
    StrReplace(Haystack, searchFor,, OutputVarCount)
    Return OutputVarCount
}

SetParentID(Window_ID, theOther) {
  r := DllCall("SetParent", "uint", theOther, "uint", Window_ID) ; success = handle to previous parent, failure =null 
  Return r
}

CreateGuiButton(btnList, killWin:=0, delayu:=950) {
    Critical, On
    Static lastCreated := 1, bgrColor := 112288, txtColor := "ddeeFF", thisOpacity := 200
         , prevBtnList := "z"
    Global BtnTemp1, BtnTemp2
    
    If (killWin=1)
    {
       prevBtnList := ""
       Gui, TempBtnGui: Destroy
       tempBtnVisible := "null"
       interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
       Return
    }

    If (prevBtnList=btnList && tempBtnVisible!="null" && killWin!=1)
       Return

    If (TouchScreenMode!=1 && killWin!="force") ; || MsgBox2hwnd
       Return
 
    thisFntSize := OSDfntSize
    thisFntSize := Round(thisFntSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9
    Gui, TempBtnGui: Destroy
    Sleep, 25

    roundedCsize := Round(thisFntSize/1.7) + 15
    Gui, TempBtnGui: -DPIScale -Caption +ToolWindow +E0x8000000 +hwndhGuiBtn +Owner%PVhwnd%
    Gui, TempBtnGui: Margin, % thisFntSize + 10, % thisFntSize
    Gui, TempBtnGui: Color, c%bgrColor%
    Gui, TempBtnGui: Font, s%thisFntSize% Bold Q5, Arial
    btnArray := StrSplit(btnList, "||")
    tempBtnGuiBtnArray := []
    Loop, % btnArray.Count()
    {
        thisBtnArr := StrSplit(btnArray[A_Index], ",,")
        ; ToolTip, % thisBtnArr[1] "==" thisBtnArr[2] , , , 2
        If (A_Index=1)
           Gui, TempBtnGui: Add, Text, c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
        Else If thisBtnArr[1]
           Gui, TempBtnGui: Add, Text, x+%OSDfntSize% c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
 
        tempBtnGuiBtnArray[A_Index] := thisBtnArr[2]
    }

    WinGetPos, winPosX, winPosY, Wid, Heig, ahk_id %PVhwnd%
    Gui, TempBtnGui: Show, NoActivate AutoSize Hide x%winPosX% y%winPosY%, QPVGuiActionBtn
    WinGetPos,,, gWid, gHeig, ahk_id %hGuiBtn%
    If (gWid>Wid - thisFntSize*2.2)
       gWid := Wid - Round(thisFntSize * 2.25) - 5
    If (gWid<5)
       gWid := 5

    ; compatMode := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_7") ? 1 : 0
    compatMode := 1
    If (compatMode=0)
       winPosX := winPosY := 1

    offsetuY := scrollBarHy ? Heig - scrollBarHy : 0
    Final_x := winPosX + thisFntSize * 2
    Final_y := winPosY + Heig - thisFntSize * 2 - gHeig - offsetuY//2
    If (compatMode=1)
    {
       WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBtn%
       WinSet, AlwaysOnTop, On, ahk_id %hGuiBtn%
    }

    WinSet, Region, 0-0 R%roundedCsize%-%roundedCsize% w%gWid% h%gHeig%, QPVGuiActionBtn
    If (compatMode=0)
       SetParentID(PVhwnd, hGuiBtn)

    GroupAdd, QPVwindows, ahk_id %hGuiBtn%
    Gui, TempBtnGui: Show, NoActivate AutoSize x%Final_x% y%Final_y%, GuiActionBtn
    tempBtnVisible := hGuiBtn
    If InStr(btnList, ",,")
       prevBtnList := btnList
    interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
    SetTimer, DestroyTempBtnGui, % - delayu
    lastCreated := A_TickCount
}

tempGuiBtnCall1() {
    coretempGuiBtnCalls(1)
}

tempGuiBtnCall2() {
    coretempGuiBtnCalls(2)
}

tempGuiBtnCall3() {
    coretempGuiBtnCalls(3)
}

tempGuiBtnCall4() {
    coretempGuiBtnCalls(4)
}

tempGuiBtnCall5() {
    coretempGuiBtnCalls(5)
}

coretempGuiBtnCalls(indexu) {
    Static listu := ",reduceCustomShapelength,togglePathCurveTension,toggleOpenClosedLineCustomShape,ToggleCardinalCurveMode,"
    thisFunc := tempBtnGuiBtnArray[indexu]
    z := InStr(listu, "," thisFunc ",")
    If !z
       SetTimer, DestroyTempBtnGui, -950

    If (WinActive("A")!=PVhwnd)
       WinActivate, ahk_id %PVhwnd%
    ; ToolTip, % thisfunc "===" indexu , , , 2
    %thisFunc%()
    If (drawingShapeNow!=1 && !z)
       SetTimer, DestroyTempBtnGui, -950
}

DestroyTempBtnGui(dummy:=0) {
    Critical, On
    MouseGetPos, , , OutputVarWin
    thisWin := WinActive("A")
    okay := (thisWin=PVhwnd || thisWin=hSetWinGui) ? 1 : 0
    ; ToolTip, % OutputVarWin , , , 2
    If (OutputVarWin!=tempBtnVisible) || (okay!=1) || (dummy="now")
       CreateGuiButton("Die dummy", 1)  ;   ;-)
    Else
       SetTimer, DestroyTempBtnGui, -950
}

openPreviousPanel(mode:="") {
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (IsFunc(thisfunc) && thisFunc && allowReopen=1) || (thisFunc && mode="forced")
   {
      %thisFunc%()
   } Else
   {
      showTOOLtip("No previously opened panel")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

mouseTurnOFFtooltip() {
   Gui, mouseToolTipGuia: Destroy
   mouseToolTipWinCreated := 0
}

mouseCreateOSDinfoLine(msg:=0, largus:=0) {
    Critical, On
    Static prevMsg, lastInvoked := 1
    Global TippyMsg

    thisHwnd := (AnyWindowOpen>0 && isNowFakeWinOpen!=1) ? hSetWinGui : MsgBox2hwnd
    If (StrLen(msg)<3) || (prevMsg=msg && mouseToolTipWinCreated=1) || (A_TickCount - lastInvoked<100) || !thisHwnd
       Return

    lastInvoked := A_TickCount
    Gui, mouseToolTipGuia: Destroy
    thisFntSize := (largus=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
    If (thisFntSize<12)
       thisFntSize := 12
    bgrColor := OSDbgrColor
    txtColor := OSDtextColor
    isBold := (FontBolded=1) ? " Bold" : ""
    Sleep, 25

    Gui, mouseToolTipGuia: -DPIScale -Caption +Owner%thisHwnd% +ToolWindow +hwndhGuiTip
    Gui, mouseToolTipGuia: Margin, % thisFntSize, % thisFntSize
    Gui, mouseToolTipGuia: Color, c%bgrColor%
    Gui, mouseToolTipGuia: Font, s%thisFntSize% %isBold% Q5, %OSDFontName%
    Gui, mouseToolTipGuia: Add, Text, 0x80 c%txtColor% gmouseTurnOFFtooltip vTippyMsg, %msg%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVOguiTipsWin

    GetPhysicalCursorPos(mX, mY)
    tipX := mX + 15
    tipY := mY + 15
    ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    MaxWidth := Floor(ResWidth*0.85)
    If (MaxWidth<Wid && MaxWidth>10)
    {
       GuiControl, mouseToolTipGuia: Move, TippyMsg, w1 h1
       GuiControl, mouseToolTipGuia:, TippyMsg,
       Gui, mouseToolTipGuia: Add, Text, 0x80 xp yp c%txtColor% gmouseTurnOFFtooltip w%MaxWidth%, %msg%
       Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVguiTipsWin
       ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    }

    prevMsg := msg
    mouseToolTipWinCreated := 1
    WinSet, AlwaysOnTop, On, ahk_id %hGuiTip%
    WinSet, Transparent, 225, ahk_id %hGuiTip%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize x%Final_x% y%Final_y%, QPVguiTipsWin
    delayu := StrLen(msg) * 70 + 900
    If (delayu<msgDisplayTime/2)
       delayu := msgDisplayTime//2 + 1
    SetTimer, mouseTurnOFFtooltip, % -delayu
}

adjustWin2MonLimits(winHwnd, winX, winY, ByRef rX, ByRef rY, ByRef Wid, ByRef Heig) {
   GetWinClientSize(Wid, Heig, winHwnd, 1)
   ActiveMon := MWAGetMonitorMouseIsIn(winX, winY)
   If ActiveMon
   {
      SysGet, bCoord, Monitor, %ActiveMon%
      rX := max(bCoordLeft, min(winX, bCoordRight - Wid))
      rY := max(bCoordTop, min(winY, bCoordBottom - Heig*1.2))
      ResWidth := Abs(max(bCoordRight, bCoordLeft) - min(bCoordRight, bCoordLeft))
      ; ResHeight := Abs(max(bCoordTop, bCoordBottom) - min(bCoordTop, bCoordBottom))
   } Else
   {
      rX := winX
      rY := winY
   }

   Return ResWidth
}

createSettingsGUI(IDwin, thisCaller:=0, allowReopen:=1) {
    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    ; If (editingSelectionNow=1 && imgEditPanelOpened!=1)
    ;    ToggleEditImgSelection()

    panelWinCollapsed := 0
    o_ImgQuality := userimgQuality
    interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
    interfaceThread.ahkassign("imgEditPanelOpened", imgEditPanelOpened)
    If (imgEditPanelOpened=1)
    {
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
       ; ToggleVisibilityWindow("show", hGDIthumbsWin)
       ForceRefreshNowThumbsList()
       ; dummyTimerDelayiedImageDisplay(150) ; probably needed in some cases ; I do not know 

       If (folderTreeWinOpen=1)
          fdTreeClose()

       initQPVmainDLL()
       recordSelUndoLevelNow()
       If (closeEditPanelOnApply=-1)
          INIaction(0, "closeEditPanelOnApply", "General", 1)
       interfaceThread.ahkassign("AnyWindowOpen", IDwin)
       TriggerMenuBarUpdate()
       If AnyWindowOpen
          Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%
       ; coreDesiredPixFmt := "0x26200A" ; 32-ARGB
       DestroyGIFuWin()
       Gui, SettingsGUIA: Destroy
       Sleep, 5
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
    } Else CloseWindow()
    Sleep, 15
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: -MaximizeBox +Border +Owner%PVhwnd% +hwndhSetWinGui 
    Gui, SettingsGUIA: Margin, 15, 15
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    AnyWindowOpen := IDwin
    interfaceThread.ahkassign("AnyWindowOpen", IDwin)
    interfaceThread.ahkassign("hSetWinGui", hSetWinGui)
    If (allowReopen=1)
    {
       prevOpenedWindow := []
       prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 0, o_ImgQuality]
    }

    createGUItoolbar()
    If (ShowAdvToolbar=1)
       decideIconBTNmainTooler()
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    Return thisBtnHeight
}

PanelSeenStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaH, infoLine
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(39, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 199
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Daily|Monthly|Hourly|Options
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Hourly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaH, #|Hour|Images|`%
    Gui, Tab, 4 ; Options
    Gui, Add, Button, x+15 y+15 h%thisBtnHeight% gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
    Gui, Add, Button, y+5 hp geraseSeenIMGsDB, &Erase the entire list
    Gui, Add, Button, y+5 hp gBtnCopySeenStats, &Copy statistics to clipboard
    Gui, Add, Button, y+5 hp gBtnALLviewedImages2List, &Retrieve list of recorded seen images
    Gui, Add, Text, y+10 w%lstWid%, TIP: To retrieve the images seen on a given day or month, double click on the date in the list.
    Gui, Add, Text, y+10 h%thisBtnHeight% +0x200 w%lstWid% vinfoLine, Please wait...

    Gui, Tab
    Gui, Add, Button, xp y+5 h%thisBtnHeight% w1 h1 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Images seen statistics: " appTitle)
    PopulateSeenStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelIndexedImagesStats() {
    Global LViewMetaD, LViewMetaG, LViewMetaU, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT, LViewMetaA, LViewMetaI
         , LViewMetaR, StatsUIhistoThingy := 1

    showTOOLtip("Generating image files statistics, please wait")
    thisBtnHeight := createSettingsGUI(48, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Megapixels|Aspect ratios|DPI|Frames|Pixel formats|Histogram
    Gui, Tab, 1
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gIndexStatsLVaction, #|MPx|Images|`%
    Gui, Tab, 2
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaY AltSubmit gIndexStatsLVaction, #|W/H ratios|Images|`%
    Gui, Tab, 3
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaU AltSubmit gIndexStatsLVaction, #|DPI|Images|`%
    Gui, Tab, 4
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gIndexStatsLVaction, #|Frames|Images|`%
    Gui, Tab, 5
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaS AltSubmit gIndexStatsLVaction, #|Formats|Images|`%
    Gui, Tab, 6
    Gui, Add, DropDownList, y+15 w%lstWid% AltSubmit Choose1 gSwitchUIdlHistoStats vStatsUIhistoThingy, Averages|Medians|Peak (range)|Minimum (range)|Total range
    Gui, Add, ListView, y+10 w%lstWid% r6 Grid vLViewMetaG AltSubmit gIndexStatsLVaction, #|Medians|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaA AltSubmit gIndexStatsLVaction, #|Max|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaI AltSubmit gIndexStatsLVaction, #|Min|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaT AltSubmit gIndexStatsLVaction, #|Avg|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaR AltSubmit gIndexStatsLVaction, #|Range|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, C&lose
    Gui, Add, Button, x+5 hp gPanelWrapperFilesStats, Bac&k
    Gui, Add, Text, x+5 hp w%lstWid% vinfoLine +0x200 -wrap, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed images statistics: " appTitle)
    ; If (SLDtypeLoaded=3)
    ;    PopulateIndexSQLFilesStatsInfos()
    ; Else
       PopulateImagesIndexStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
    SetTimer, SwitchUIdlHistoStats, -300
}

SwitchUIdlHistoStats() {
   If (AnyWindowOpen=48)
   {
      GuiControlGet, StatsUIhistoThingy
      If (StatsUIhistoThingy=1)
      {
         GuiControl, SettingsGUIA: Show, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=2)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Show, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=3)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Show, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=4)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Show, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=5)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Show, LViewMetaR
      }
   }
}

PanelIndexedFilesStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(59, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Days|Months|Years|Sizes|Types
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Yearly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaY AltSubmit gIndexStatsLVaction, #|Year|Images|`%
    Gui, Tab, 4 ; Sizes
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaS AltSubmit gIndexStatsLVaction, #|File size ranges|Total size [MB]|Images|`%
    Gui, Tab, 5 ; Types
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaT AltSubmit gIndexStatsLVaction, #|File types|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, C&lose
    Gui, Add, Button, x+2 h%thisBtnHeight% gPanelWrapperFilesStats, Bac&k
    Gui, Add, Text, x+5 yp hp +0x200 -wrap, Modified file date used for statistics
    Gui, Add, Text, xs w%lstWid% vinfoLine +0x200, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed files statistics: " appTitle)
    If (SLDtypeLoaded=3)
       PopulateIndexSQLFilesStatsInfos()
    Else
       PopulateIndexFilesStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelWrapperFilesStats() {
    thisBtnHeight := createSettingsGUI(58, A_ThisFunc)
    btnWid := 105
    txtWid := 370
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 165
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, The statistics panel allows users to filter the indexed files to various criteria by double-clicking on list view entries. It is meant to facilitate the identification of small files, low resolution images, low key or high key, or washed out images in your collection.
    Gui, Add, Text, y+15 Section, File details: size, date modified, type.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedFilesStats, Open &file statistics panel
    Gui, Add, Button, x+5 hp gBtnCollectFileInfos, &Collect data
    Gui, Add, Text, xs y+35 Section, Image properties: resolution, frames, histogram and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedImagesStats, Open &images statistics panel
    Gui, Add, Button, xp+15 y+5 hp gBtnCollectImageInfos, Collect image &properties
    Gui, Add, Text, y+5, File details are collected as well.
    Gui, Add, Button, y+15 h%thisBtnHeight% gBtnCollectHistoInfos, Collect image &histograms properties
    Gui, Add, Text, y+5, Image fingerprints and properties are collected as well.

    Gui, Tab
    Gui, Add, Button, xs y+35 h%thisBtnHeight% gPanelEnableFilesFilter, C&reate custom filter
    If (SLDtypeLoaded=3)
       Gui, Add, Button, x+5 hp gBtnPurgeCachedSQLdata, Pur&ge cached data
    Gui, Add, Button, x+5 w90 hp gBtnCloseWindow, C&lose

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Statistics: " appTitle)
}

BtnPurgeCachedSQLdata() {
   BtnCloseWindow()
   AnyWindowOpen := 49
   PanelPurgeCachedSQLdata()
}

SeenStatsLVaction(CtrlHwnd:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (A_GuiEvent="k" && A_EventInfo=32) || (A_GuiEvent="DoubleClick") ? 1 : 0
    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_EX_GetNextItem(CtrlHwnd, -1)
    folderu := LV_EX_GetSubItemText(CtrlHwnd, RowNumber + 1, 2)
    If (StrLen(folderu)<3 || folderu="date")
       Return

    BtnALLviewedImages2List(folderu "|filteru|")
}

IndexStatsLVaction(CtrlHwnd:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (A_GuiEvent="k" && A_EventInfo=32) || (A_GuiEvent="DoubleClick") ? 1 : 0
    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_EX_GetNextItem(CtrlHwnd, -1)
    dateu := LV_EX_GetSubItemText(CtrlHwnd, RowNumber + 1, 2)
    If (StrLen(dateu)<1 || dateu="date" || InStr(dateu, "file"))
       Return

    r := BtnIndexStatsToList(RowNumber + 1, dateu, varu, 0)
    If (SLDtypeLoaded!=3 && r)
    {
       coreEnableFiltru(r)
       SetTimer, RandomPicture, -100
    }
}

BtnIndexStatsToList(RowNumber, dateu, LVvaru, givenQuery) {
      Static minz := {1:0, 2:4999, 3:10002, 4:25002, 5:50002, 6:100002, 7:250002, 8:500002, 9:1000002, 10:2500002, 11:5000002, 12:10000002, 13:25000002, 14:50000002, 15:100000002, 16:250000002}
           , maxz := {1:4998, 2:10001, 3:25001, 4:50001, 5:100001, 6:250001, 7:500001, 8:1000001, 9:2500001, 10:5000001, 11:10000001, 12:25000001, 13:50000001, 14:100000001, 15:250000001, 16:500000001}

      ; ToolTip, % RowNumber "==" dateu "==" LVvaru , , , 2
      winOpen := AnyWindowOpen
      If (AnyWindowOpen && LVvaru!="none")
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be filtered to given criteria")
         Return -1

      setImageLoading()
      If (LVvaru="none" && SLDtypeLoaded=3)
      {
         showTOOLtip("Retrieving entire files list SQL index, please wait")
      } Else
      {
         showTOOLtip("Gathering entries matching " dateu ", please wait")
         setWindowTitle("Gathering entries matching " dateu ", please wait...", 1)
         If (InStr(LVvaru, "metaT") && winOpen!=48)
         {
            If (SLDtypeLoaded=3)
            {
               givenQuery := "WHERE imgfile LIKE '%." dateu "'"
               LVvaru := "custom"
            } Else
            {
               UsrEditFilter := "(\." dateu ")$"
               userFilterInvertThis := 0
               userFilterStringPos := 4
               userFilterProperty := userFilterWhat := userFilterDoString := 1
               coreEnableFiltru("\>" UsrEditFilter)
               Return
            }
         }
      }

      oDateu := dateu
      arDateu := StrSplit(oDateu, "-")
      RecordSet := ""
      If (winOpen!=48)
         dateu := StrReplace(dateu, "-")

      minRange := (winOpen=48) ? arDateu[1] : minz[RowNumber]
      maxRange := (winOpen=48) ? arDateu[2] : maxz[RowNumber]
      If !dataColumn
         dataColumn := InStr(LVvaru, "metaS") ? "fsize" : "fmodified"

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
      k := 14 - StrLen(dateu)
      If (LVvaru="custom")
      {
         theQuery := givenQuery
         theQueryNonDB := givenQuery
      } Else If (LVvaru="none")
      {
         theQuery := ""
         theQueryNonDB := ""
      } Else If (winOpen=48)
      {
         If InStr(LVvaru, "metaM")
         {
            userFilterProperty := 9
            userFilterInvertThis := userFilterDoString := 0
            FilteruMinRange := FilteruMaxRange := Round(dateu)
            theQuery := "WHERE imgframes='" dateu "'"
            theQueryNonDB := "QPV::query::imgframes::" dateu ":: " dateu
         } Else If InStr(LVvaru, "metaS")
         {
            userFilterDoString := 0
            theQuery := "WHERE imgpixfmt LIKE '" dateu "'"
            theQueryNonDB := "QPV::query::imgpixfmt::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaD")
         {
            userFilterProperty := 5
            userFilterInvertThis := userFilterDoString := 0
            FilteruMinRange := Floor(dateu)
            FilteruMAxRange := Ceil(dateu)
            theQuery := "WHERE Round(imgmegapix, 1) BETWEEN " dateu " AND " dateu
            theQueryNonDB := "QPV::query::imgmegapix::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaU")
         {
            userFilterProperty := 10
            userFilterInvertThis := userFilterDoString := 0
            FilteruMinRange := FilteruMAxRange := Round(dateu)
            theQuery := "WHERE imgdpi='" dateu "'"
            theQueryNonDB := "QPV::query::imgdpi::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaY")
         {
            userFilterInvertThis := userFilterProperty := 8
            FilteruMinRange := Round(dateu*10)
            FilteruMAxRange := Round(dateu*10)
            theQuery := "WHERE Round(imgwhratio, 1) BETWEEN " dateu " AND " dateu
            theQueryNonDB := "QPV::query::imgwhratio::" dateu ":: " dateu
         } Else If (InStr(LVvaru, "metaA") || InStr(LVvaru, "metaR") || InStr(LVvaru, "metaI") || InStr(LVvaru, "metaT") || InStr(LVvaru, "metaG"))
         {
            If InStr(LVvaru, "metaA")
            {
               userFilterProperty := 13
               dataColumn := "imghpeak"
            } Else If InStr(LVvaru, "metaI")
            {
               userFilterProperty := 14
               dataColumn := "imghlow"
            } Else If InStr(LVvaru, "metaR")
            {
               userFilterProperty := 15
               dataColumn := "imghrange"
            } Else If InStr(LVvaru, "metaT")
            {
               userFilterProperty := 11
               dataColumn := "imgavg"
            } Else If InStr(LVvaru, "metaG")
            {
               userFilterProperty := 12
               dataColumn := "imgmedian"
            }

            userFilterInvertThis := userFilterDoString := 0
            FilteruMinRange := Round(minRange)
            FilteruMaxRange := Round(maxRange)
            minRange := Round((minRange + 1)/256, 3)
            maxRange := Round((maxRange + 1)/256, 3)
            theQuery := "WHERE Round(" dataColumn ", 2) BETWEEN " minRange " AND " maxRange
            theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
         }
      } Else
      {
         If (InStr(LVvaru, "metaD") || InStr(LVvaru, "metaM") || InStr(LVvaru, "metaY") || InStr(LVvaru, "LIKE"))
         {
            userFilterProperty := 3
            userFilterInvertThis := userFilterDoString := 0
            FilteruDateMaxRange := FilteruDateMinRange := Format("{1}{2:" k "}", dateu, 0)
            theQuery := "WHERE " dataColumn " LIKE '" dateu "%'"
            theQueryNonDB := "QPV::query::" dataColumn "::" FilteruDateMinRange "::" FilteruDateMaxRange
            theQueryNonDB := StrReplace(theQueryNonDB, A_Space, 0)
         } Else If (InStr(LVvaru, "metaS") || InStr(LVvaru, "BETWEEN"))
         {
            userFilterProperty := 2
            userFilterSizeProperty := 1
            userFilterInvertThis := userFilterDoString := 0
            FilteruMinRange := Round(minRange/1024)
            FilteruMaxRange := Round(maxRange/1024)
            theQuery := "WHERE " dataColumn " BETWEEN " minRange " AND " maxRange
            theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
         }
      }

      If (SLDtypeLoaded=3)
      {
         If !getMaxRowIDsqlDB()
            Return -1

         SQLstr := "SELECT imgidu, fullPath FROM images " theQuery reorder
         ; ToolTip, % SQLstr , , , 2
         If !activeSQLdb.GetTable(SQLstr, RecordSet)
         {
            throwSQLqueryDBerror(A_ThisFunc)
            Return -1
         }
      } Else Return theQueryNonDB

      If (RecordSet.RowCount<1)
      {
         showTOOLtip("WARNING: No records found in the database matching the query:`n" SQLstr)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0
      startOperation := A_TickCount
      ; ToolTip, % filesFilter , , , 2
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:") && LVvaru!="none")
         remFilesListFilter("simple")

      If (StrLen(filesFilter)<2 && LVvaru!="none")
      {
         bckpResultedFilesList := []
         bckpResultedFilesList := resultedFilesList.Clone()
         bckpMaxFilesIndex := maxFilesIndex
      }

      If (LVvaru!="none")
         showTOOLtip("Generating files list index for " oDateu)

      renewCurrentFilesList()
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[2]
         {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex, 1] := Rowu[2]
             resultedFilesList[maxFilesIndex, 12] := Rowu[1]
          }
      }

      RecordSet.Free()
      If (LVvaru!="none")
         filesFilter := "SQL:query:" theQuery
      ;  MsgBox, % maxFilesIndex " --- " RecordSet.RowCount
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      CurrentSLD := backCurrentSLD
      If (LVvaru!="none")
      {
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -500
         SetTimer, ResetImgLoadStatus, -50
         RandomPicture()
      }
}

BtnCopySeenStats() {
   textu .= "`nMONTHLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaM
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nDAILY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nHOURLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaH
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Images seen statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateSeenStatsInfos() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  entriesCount := 0
  RecordSet := ""
  SQL := "SELECT imgViewDate, COUNT(*) FROM images GROUP BY imgViewDate;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entriesD := []
  entriesM := []
  entriesH := []
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
      {
         dateuD := "z" StrReplace(SubStr(Rowu[1], 1, 10), "-")
         dateuM := "z" StrReplace(SubStr(Rowu[1], 1, 7), "-")
         dateuH := "z" StrReplace(SubStr(Rowu[1], 12, 2), "-")
         entriez%dateuD% += Rowu[2]
         entriez%dateuM% += Rowu[2]
         entriez%dateuH% += Rowu[2]
         entriesCount += Rowu[2]
         entriesD[dateuD] := [entriez%dateuD%, SubStr(Rowu[1], 1, 10)]
         entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 7)]
         entriesH[dateuH] := [entriez%dateuH%, SubStr(Rowu[1], 12, 2)]
      }
  }

  RecordSet.Free()
  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesH
      LV_Add(A_Index, A_Index, Value[2] ":00", Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  GuiControl, SettingsGUIA:, infoLine, Total seen images: %entriesCount%
}

QPV_FileGetSizeTime(imgPath, type, imgIndex, b:=0) {
    Switch type
    {
       Case "S":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
       Case "M":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
       Case "C":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       Case "R":
          r := 0
    }

    If !r
    {
       ; If !runningLongOperation
       ; SoundBeep 
       obju := GetFileAttributesEx(imgPath)
       If (b=1)
       {
          bckpResultedFilesList[imgIndex, 6] := obju.size
          bckpResultedFilesList[imgIndex, 7] := obju.wTime
          bckpResultedFilesList[imgIndex, 8] := obju.cTime
       } Else
       {
          resultedFilesList[imgIndex, 6] := obju.size
          resultedFilesList[imgIndex, 7] := obju.wTime
          resultedFilesList[imgIndex, 8] := obju.cTime
       }

       Switch type
       {
          Case "S":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
          Case "M":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
          Case "C":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       }
    }
    Return r
}

GetFileAttributesEx(inFile) {
; https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesexw
; coded by TheArkive and modified by Marius Șucan
; https://www.autohotkey.com/boards/viewtopic.php?t=83269
; https://github.com/TheArkive
; THANK YOU VERY MUCH @ TheArkive

    If (StrLen(inFile)>32766 || StrLen(inFile)<4)
       return

    Static GetFileExInfoStandard := 0, GetFileExMaxInfoLevel := 1 ; https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ne-minwinbase-get_fileex_info_levels
    Static attr := { Archive:0x20 ; https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants
            , Compressed:0x800, Device:0x40, Directory:0x10, Encrypted:0x4000, Hidden:0x2, integ_stream:0x8000, Normal:0x80, NotContentIndexed:0x2000
            , NoScrubData:0x20000, Offline:0x1000, ReadOnly:0x1, RecallOnDataAccess:0x400000, RecallOnOpen:0x40000, ReparsePoint:0x400, SparseFile:0x200
            , System:0x4, Temporary:0x100, Virtual:0x10000}
    
    VarSetCapacity(bFileAttribs,((A_PtrSize=8)?40:36),0) ; AHK v1
    p2 := &bFileAttribs
    r := DllCall("GetFileAttributesExW", "Str", "\\?\" inFile,"Int", 0, "Ptr", p2)
/*
    iAttribs := NumGet(bFileAttribs,"UInt")
    AttrList := []
    For attrib, value in attr
    {
        If (value & iAttribs)
           AttrList[A_Index] := attrib
    }
*/

    cTime := FileTimeToSystemTime(p2+4)  ;   CreationTimePtr
    wTime := FileTimeToSystemTime(p2+20) ;   LastWriteTime
    ; aTime := FileTimeToSystemTime(p2+12)
    
    ; sizeHigh << 32 | sizeLow 
    fileSize := (NumGet(bFileAttribs,28,"UInt") << 32) | NumGet(bFileAttribs,32,"UInt")
    return {attr:AttrList, cTime:cTime, aTime:aTime, wTime:wTime, size:fileSize}
}

FileTimeToSystemTime(ptr) {         
    VarSetCapacity(SYSTEMTIME,16,0)
    r := DllCall("FileTimeToSystemTime","Ptr",ptr,"Ptr",&SYSTEMTIME)

    VarSetCapacity(SYSTIME2,16,0)
    r := DllCall("SystemTimeToTzSpecificLocalTime","Ptr",0,"Ptr",&SYSTEMTIME,"Ptr",&SYSTIME2) ; https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime

    ; dayOfWeek := NumGet(SYSTIME2,4,"UShort")
    ; mil := NumGet(SYSTIME2,14,"UShort")
    
    year := NumGet(SYSTIME2,0,"UShort")
    month := Format("{:02d}", NumGet(SYSTIME2,2,"UShort"))
    day := Format("{:02d}", NumGet(SYSTIME2,6,"UShort"))
    hour := Format("{:02d}", NumGet(SYSTIME2,8,"UShort"))
    minute := Format("{:02d}", NumGet(SYSTIME2,10,"UShort"))
    second := Format("{:02d}", NumGet(SYSTIME2,12,"UShort"))

    return year month day hour minute second
    ; return {year:year, month:month, day:day, dayOfWeek:dayOfWeek, hour:hour, minute:minute, second:second, mil:mil}
}

ETAinfos(countTFilez, filesElected, startOperation) {
   Static prevTick := 0, prevStartu, prevTimes := [], prevCountTFilez := 0, prevAvg := 0, prevZeit := 0, prevTotal
   If (prevStartu!=startOperation || countTFilez<prevCountTFilez || prevTotal!=filesElected)
   {
      prevTimes := []
      prevZeit := prevCountTFilez := prevTick := prevAvg := 0
   }

   prevTick++
   thisAmount := countTFilez - prevCountTFilez
   prevTimes.Push([thisAmount, A_TickCount])
   If (prevTick=5)
      prevTimes.RemoveAt(1)

   prevCountTFilez := countTFilez
   theSum := 0
   loops := prevTimes.Count()
   Loop, % loops
       theSum += Round(prevTimes[A_Index, 1])

   theAvg := Round(theSum/loops, 6)
   If prevAvg
      theAvg := Round((prevAvg+theAvg)/2, 6)

   prevAvg := theAvg
   prevTotal := filesElected
   intervalA := Round(prevTimes[2, 2] - prevTimes[1, 2])
   intervalB := Round(prevTimes[3, 2] - prevTimes[2, 2])
   intervalC := Round(prevTimes[4, 2] - prevTimes[3, 2])
   interval := Round((1 + intervalA + intervalB + intervalC)/3, 6)
   zeitLeftA := Round(((filesElected - countTFilez)/theAvg)*interval)
   ; ToolTip, % loops " == " prevTick " == " theSum " == " theAvg , , , 2

   prevTick := clampInRange(prevTick, 1, 4)
   prevStartu := startOperation

   zeitOperation := A_TickCount - startOperation
   percDone := " ( " Round((countTFilez / filesElected) * 100, 1) "% )"
   percLeft := (1 - countTFilez / filesElected) * 100
   zeitLeftB := (zeitOperation/countTFilez) * filesElected - zeitOperation
   etaTime := "`n" groupDigits(countTFilez) " / " groupDigits(filesElected) percDone
   If (A_TickCount - startOperation<2500)
      zeitC := (zeitLeftA+zeitLeftB)/2
   If (A_TickCount - startOperation<5000)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftB)/3
   Else If (A_TickCount - startOperation<9500)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftA+zeitLeftB)/4
   Else
      zeitC := zeitLeftA

   zeitF := prevZeit ? (Round(zeitC) + Round(prevZeit))/2 : zeitC
   If !zeitF
      zeitF := zeitLeftB
   prevZeit := zeitC
   etaTime .= "`nEstimated time left: " SecToHHMMSS(Round(zeitF/1000, 3))
   ; etaTime .= "`nEstimated B time left: " SecToHHMMSS(Round(zeitLeft2/1000, 3))
   etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   Return etaTime
}

collectImageInfosNow(queryString:=0, modus:=0, simple:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    If (simple=1)
    {
       backCurrentSLD := CurrentSLD
       CurrentSLD := ""
    }

    showTOOLtip("Collecting image details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    failedFiles := abandonAll := 0
    zEffect := (modus=11) ? Gdip_CreateEffect(6, 0, -99, 0) : 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          If failedFiles
             etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

          showTOOLtip("Collecting image details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       If (modus=9)
          testThis := !isFilter ? resultedFilesList[A_Index, 9] : bckpResultedFilesList[A_Index, 9]
       Else
          testThis := !isFilter ? resultedFilesList[A_Index, 11] : bckpResultedFilesList[A_Index, 11]

       If testThis
          Continue

       imgPath := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
       If queryString
       {
          If !coreSearchIndex(imgPath, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       thisIndex := A_Index
       If (modus=9)
          r := GetCachableImgFileDetails(imgPath, A_Index, 0, 0, isFilter)
       Else
          r := GetCachableHistogramFile(imgPath, A_Index, 0, 0, 1, isFilter, zEffect)

       If !r
          failedFiles++
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2

    Gdip_DisposeEffect(zEffect)
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    If (simple=1)
    {
       CurrentSLD := backCurrentSLD
       percDone := " ( " Round((thisIndex / thisMaxCount) * 100, 1) "% )"
       If failedFiles
          percDone .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

       If (abandonAll=1)
       {
          showTOOLtip("Operation abandoned. " groupDigits(thisIndex) " / " groupDigits(thisMaxCount)) percDone
          SoundBeep, 300, 100
       } Else If (abandonAll=1)
          showTOOLtip("Finished collecting data for " groupDigits(thisMaxCount)) " files"

       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -150
       Return
    }
    Return abandonAll
}

collectFileInfosNow(queryString:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    showTOOLtip("Collecting file details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    abandonAll := 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          showTOOLtip("Collecting file details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       testThis := !isFilter ? resultedFilesList[A_Index, 6] : bckpResultedFilesList[A_Index, 6]
       If testThis
          Continue

       If queryString
       {
          r := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
          If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       If !isFilter
       {
          obju := GetFileAttributesEx(resultedFilesList[A_Index, 1])
          resultedFilesList[A_Index, 6] := obju.size ? obju.size : 1
          resultedFilesList[A_Index, 7] := obju.wTime
          resultedFilesList[A_Index, 8] := obju.cTime
       } Else
       {
          obju := GetFileAttributesEx(bckpResultedFilesList[A_Index, 1])
          bckpResultedFilesList[A_Index, 6] := obju.size ? obju.size : 1
          bckpResultedFilesList[A_Index, 7] := obju.wTime
          bckpResultedFilesList[A_Index, 8] := obju.cTime
       }
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    Return abandonAll
}

PopulateIndexFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount, totalSizeu
      , sizer1, sizeTr1, sizer2, sizeTr2, sizer3, sizeTr3, sizer4, sizeTr4
      , sizer5, sizeTr5, sizer6, sizeTr6, sizer7, sizeTr7, sizer8, sizeTr8
      , sizer9, sizeTr9, sizer10, sizeTr10, sizer11, sizeTr11, sizer12, sizer16
      , sizeTr12, sizer13, sizeTr13, sizer14, sizeTr14, sizer15, sizeTr15, sizeTr16

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0

  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait`n0/" groupDigits(thisMaxCount))
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := 0, sizer1:=0, sizeTr1:=0, sizer2:=0, sizeTr2:=0, sizer3:=0, sizeTr3:=0, sizer4:=0, sizeTr4:=0
     sizer5:=0, sizeTr5:=0, sizer6:=0, sizeTr6:=0, sizer7:=0, sizeTr7:=0, sizer8:=0, sizeTr8:=0, sizer9:=0, sizeTr9:=0
     sizer10:=0, sizeTr10:=0, sizer11:=0, sizeTr11:=0, sizer12:=0, sizeTr12:=0, sizer13:=0, sizeTr13:=0, sizer14:=0
     sizeTr14:=0, sizer15:=0, sizeTr15:=0, sizer16:=0, sizeTr16:=0, totalSizeu := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     If (dummy="kill")
     {
        ; bckpResultedFilesList := []
        ; filteredMap2mainList := []
        ; filesFilter := ""
        ; bckpMaxFilesIndex := 0
        PopulateIndexSQLFilesStatsInfos(dummy)
        PopulateImagesIndexStatsInfos(dummy)
        Return
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         If (isFilter=1)
         {
            imgPath := bckpResultedFilesList[A_Index, 1]
            dateu := bckpResultedFilesList[A_Index, 7]
            sizeu := bckpResultedFilesList[A_Index, 6]
         } Else
         {
            imgPath := resultedFilesList[A_Index, 1]
            dateu := resultedFilesList[A_Index, 7]
            sizeu := resultedFilesList[A_Index, 6]
         }

         ; ToolTip, % imgPath "`n" dateu "`n" sizeu , , , 2
         foundPos := InStr(imgPath, ".", 0, -1)
         If foundPos
         {
            fileEXT := SubStr(imgPath, foundPos + 1)
            entriez%fileEXT%++
            entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
         }

         If dateu
         {
            dateuD := "z" SubStr(dateu, 1, 8)
            dateuM := "z" SubStr(dateu, 1, 6)
            dateuY := "z" SubStr(dateu, 1, 4)
            entriez%dateuD%++
            entriez%dateuM%++
            entriez%dateuY%++
            entriesD[dateuD] := [entriez%dateuD%, dateuD]
            entriesM[dateuM] := [entriez%dateuM%, dateuM]
            entriesY[dateuY] := [entriez%dateuY%, dateuY]
         }

         If sizeu
         {
            entriesCount++
            totalSizeu += Round(sizeu/(1024**2), 4)
            If (sizeu<=5000001)
            {
               If isInRange(sizeu, 0, 4998)
               {
                  sizeTr1 += sizeu
                  sizer1++
               } Else If isInRange(sizeu, 4999, 10001)
               {
                  sizeTr2 += sizeu
                  sizer2++
               } Else If isInRange(sizeu, 10002, 25001)
               {
                  sizeTr3 += sizeu
                  sizer3++
               } Else If isInRange(sizeu, 25002, 50001)
               {
                  sizeTr4 += sizeu
                  sizer4++
               } Else If isInRange(sizeu, 50002, 100001)
               {
                  sizeTr5 += sizeu
                  sizer5++
               } Else If isInRange(sizeu, 100002, 250001)
               {
                  sizeTr6 += sizeu
                  sizer6++
               } Else If isInRange(sizeu, 250002, 500001)
               {
                  sizeTr7 += sizeu
                  sizer7++
               } Else If isInRange(sizeu, 500002, 1000001)
               {
                  sizeTr8 += sizeu
                  sizer8++
               } Else If isInRange(sizeu, 1000002, 2500001)
               {
                  sizeTr9 += sizeu
                  sizer9++
               } Else If isInRange(sizeu, 2500002, 5000001)
               {
                  sizeTr10 += sizeu
                  sizer10++
               }
            } Else
            {
               If isInRange(sizeu, 5000002, 10000001)
               {
                  sizeTr11 += sizeu
                  sizer11++
               } Else If isInRange(sizeu, 10000002, 25000001)
               {
                  sizeTr12 += sizeu
                  sizer12++
               } Else If isInRange(sizeu, 25000002, 50000001)
               {
                  sizeTr13 += sizeu
                  sizer13++
               } Else If isInRange(sizeu, 50000002, 100000001)
               {
                  sizeTr14 += sizeu
                  sizer14++
               } Else If isInRange(sizeu, 100000002, 250000001)
               {
                  sizeTr15 += sizeu
                  sizer15++
               } Else If isInRange(sizeu, 250000002, 500000001)
               {
                  sizeTr16 += sizeu
                  sizer16++
               }
            }
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
     If (abandonAll!=1)
        prevState := thisState
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  ; msgBox, % entriesCount "=" thisMaxCount
  If (entriesCount<Round(thisMaxCount - 1)) && (abandonAll!=1)
  {
     msgResult := msgBoxWrapper(appTitle ": Statistics", appTitle " has not yet indexed the files' details. These are required to populate this panel with statistics. Would you like to collect the data now? This may take awhile...", 4, 0, "question")
     If (msgResult="Yes")
     {
        prevState := ""
        RemoveTooltip()
        BtnCloseWindow()
        r := collectFileInfosNow()
        If !r
           SetTimer, PanelIndexedFilesStats, -250
        Return
     }
  }

  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, SubStr(Value[2], 2), Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  LV_Add(1, 1, "<5 KB", Round(sizeTr1/(1024**2), 1), sizer1, Round((sizer1/thisMaxCount)*100, 1))
  LV_Add(2, 2, "5-10 KB", Round(sizeTr2/(1024**2), 1), sizer2, Round((sizer2/thisMaxCount)*100, 1))
  LV_Add(3, 3, "10-25 KB", Round(sizeTr3/(1024**2), 1), sizer3, Round((sizer3/thisMaxCount)*100, 1))
  LV_Add(4, 4, "25-50 KB", Round(sizeTr4/(1024**2), 1), sizer4, Round((sizer4/thisMaxCount)*100, 1))
  LV_Add(5, 5, "50-100 KB", Round(sizeTr5/(1024**2), 1), sizer5, Round((sizer5/thisMaxCount)*100, 1))
  LV_Add(6, 6, "100-250 KB", Round(sizeTr6/(1024**2), 1), sizer6, Round((sizer6/thisMaxCount)*100, 1))
  LV_Add(7, 7, "250-500 KB", Round(sizeTr7/(1024**2), 1), sizer7, Round((sizer7/thisMaxCount)*100, 1))
  LV_Add(8, 8, "0.5-1.0 MB", Round(sizeTr8/(1024**2), 1), sizer8, Round((sizer8/thisMaxCount)*100, 1))
  LV_Add(9, 9, "1.0-2.5 MB", Round(sizeTr9/(1024**2), 1), sizer9, Round((sizer9/thisMaxCount)*100, 1))
  LV_Add(10, 10, "2.5-5.0 MB", Round(sizeTr10/(1024**2), 1), sizer10, Round((sizer10/thisMaxCount)*100, 1))
  LV_Add(11, 11, "5-10 MB", Round(sizeTr11/(1024**2), 1), sizer11, Round((sizer11/thisMaxCount)*100, 1))
  LV_Add(12, 12, "10-25 MB", Round(sizeTr12/(1024**2), 1), sizer12, Round((sizer12/thisMaxCount)*100, 1))
  LV_Add(13, 13, "25-50 MB", Round(sizeTr13/(1024**2), 1), sizer13, Round((sizer13/thisMaxCount)*100, 1))
  LV_Add(14, 14, "50-100 MB", Round(sizeTr14/(1024**2), 1), sizer14, Round((sizer14/thisMaxCount)*100, 1))
  LV_Add(15, 15, "100-250 MB", Round(sizeTr15/(1024**2), 1), sizer15, Round((sizer15/thisMaxCount)*100, 1))
  LV_Add(16, 16, "250-500 MB", Round(sizeTr16/(1024**2), 1), sizer16, Round((sizer16/thisMaxCount)*100, 1))

  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(totalSizeu/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

retrieveGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgwidth") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT " which ", Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      newArrayu := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
            newArrayu[A_Index] := [Rowu[2], Rowu[1]]
      }

      RecordSet.Free()
      Return newArrayu
   }
}

retrieveHistoGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgavg") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT Round(" which "*256), Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := 0
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      entriesG := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
         {
            hmed := Rowu[1]
            If isInRange(hmed, 0, 50)
            {
               entriezHM1 := entriezHM1 + Rowu[2]
               entriesG[1] := [entriezHM1, "0-50"]
            } Else If isInRange(hmed, 50, 100)
            {
               entriezHM2 := entriezHM2 + Rowu[2]
               entriesG[2] := [entriezHM2, "50-100"]
            } Else If isInRange(hmed, 100, 150)
            {
               entriezHM3 := entriezHM3 + Rowu[2]
               entriesG[3] := [entriezHM3, "100-150"]
            } Else If isInRange(hmed, 150, 200)
            {
               entriezHM4 := entriezHM4 + Rowu[2]
               entriesG[4] := [entriezHM4, "150-200"]
            } Else If isInRange(hmed, 200, 256)
            {
               entriezHM5 := entriezHM5 + Rowu[2]
               entriesG[5] := [entriezHM5, "200-255"]
            }
         }
      }

      RecordSet.Free()
      Return entriesG
   }
}

PopulateImagesIndexStatsInfos(dummy:=0) {
  Static entriesR, entriesD, entriesS, entriesU, entriesM, entriesY, entriesT, entriesA, entriesI, entriesG, prevState, entriesCount, prevMaxu

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics on images details, please wait`n0/" groupDigits(thisMaxCount))
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := totalSizeu := entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := prevMaxu := 0
     entriezHL1 := entriezHP1 := entriezHA1 := entriezHL2 := entriezHP2 := entriezHA2 := entriezHL3 := entriezHP3 := entriezHA3 := entriezHL4 := entriezHP4 := entriezHA4 := entriezHL5 := entriezHP5 := entriezHA5 := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     entriesA := []
     entriesG := []
     entriesU := []
     entriesI := []
     entriesR := []
     If (dummy="kill")
        Return

     If (SLDtypeLoaded=3)
     {
        prevMaxu := getTotalIMGsSQLdb()
        ; prevMaxu := getTotalIMGsSQLdb("WHERE imgwidth IS NOT NULL")
        thisMaxCount := prevMaxu
        If !prevMaxu
           Return 0

        entriesS := retrieveGroupSQLimgInfos("imgpixfmt", 2, 12)
        entriesM := retrieveGroupSQLimgInfos("imgframes", 3, 12)
        entriesU := retrieveGroupSQLimgInfos("imgdpi", 4, 12)
        entriesD := retrieveGroupSQLimgInfos("Round(imgmegapix, 1)", 5, 12)
        entriesY := retrieveGroupSQLimgInfos("Round(imgwhratio, 1)", 6, 12)
        entriesT := retrieveHistoGroupSQLimgInfos("imgavg", 7, 12)
        entriesG := retrieveHistoGroupSQLimgInfos("imgmedian", 8, 12)
        entriesA := retrieveHistoGroupSQLimgInfos("imghpeak", 9, 12)
        entriesI := retrieveHistoGroupSQLimgInfos("imghlow", 10, 12)
        entriesR := retrieveHistoGroupSQLimgInfos("imghrange", 11, 12)
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (SLDtypeLoaded=3)
            Break

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         entriesCount++
         If (isFilter=1)
         {
            mgpx := bckpResultedFilesList[A_Index, 17]
            frames := bckpResultedFilesList[A_Index, 9]
            ratio := bckpResultedFilesList[A_Index, 16]
            pixfmt := bckpResultedFilesList[A_Index, 15]
            havg := bckpResultedFilesList[A_Index, 18]
            hmed := bckpResultedFilesList[A_Index, 19]
            hpeak := bckpResultedFilesList[A_Index, 20]
            hlow := bckpResultedFilesList[A_Index, 21]
            dpiu := bckpResultedFilesList[A_Index, 22]
            hrange := bckpResultedFilesList[A_Index, 25]
         } Else
         {
            mgpx := resultedFilesList[A_Index, 17]
            frames := resultedFilesList[A_Index, 9]
            ratio := resultedFilesList[A_Index, 16]
            pixfmt := resultedFilesList[A_Index, 15]
            havg := resultedFilesList[A_Index, 18]
            hmed := resultedFilesList[A_Index, 19]
            hpeak := resultedFilesList[A_Index, 20]
            hlow := resultedFilesList[A_Index, 21]
            dpiu := resultedFilesList[A_Index, 22]
            hrange := resultedFilesList[A_Index, 25]
         }

         havg := Round(256*havg)
         hmed := Round(256*hmed)
         hpeak := Round(256*hpeak)
         hlow := Round(256*hlow)
         hrange := Round(256*hrange)
         If isInRange(havg, 0, 50)
         {
            entriezHA1++
            entriesT[1] := [entriezHA1, "0-50"]
         } Else If isInRange(havg, 50, 100)
         {
            entriezHA2++
            entriesT[2] := [entriezHA2, "50-100"]
         } Else If isInRange(havg, 100, 150)
         {
            entriezHA3++
            entriesT[3] := [entriezHA3, "100-150"]
         } Else If isInRange(havg, 150, 200)
         {
            entriezHA4++
            entriesT[4] := [entriezHA4, "150-200"]
         } Else If isInRange(havg, 200, 256)
         {
            entriezHA5++
            entriesT[5] := [entriezHA5, "200-255"]
         }

         If isInRange(hmed, 0, 50)
         {
            entriezHM1++
            entriesG[1] := [entriezHM1, "0-50"]
         } Else If isInRange(hmed, 50, 100)
         {
            entriezHM2++
            entriesG[2] := [entriezHM2, "50-100"]
         } Else If isInRange(hmed, 100, 150)
         {
            entriezHM3++
            entriesG[3] := [entriezHM3, "100-150"]
         } Else If isInRange(hmed, 150, 200)
         {
            entriezHM4++
            entriesG[4] := [entriezHM4, "150-200"]
         } Else If isInRange(hmed, 200, 256)
         {
            entriezHM5++
            entriesG[5] := [entriezHM5, "200-255"]
         }

         If isInRange(hpeak, 0, 50)
         {
            entriezHP1++
            entriesA[1] := [entriezHP1, "0-50"]
         } Else If isInRange(hpeak, 50, 100)
         {
            entriezHP2++
            entriesA[2] := [entriezHP2, "50-100"]
         } Else If isInRange(hpeak, 100, 150)
         {
            entriezHP3++
            entriesA[3] := [entriezHP3, "100-150"]
         } Else If isInRange(hpeak, 150, 200)
         {
            entriezHP4++
            entriesA[4] := [entriezHP4, "150-200"]
         } Else If isInRange(hpeak, 200, 256)
         {
            entriezHP5++
            entriesA[5] := [entriezHP5, "200-255"]
         }

         If isInRange(hlow, 0, 50)
         {
            entriezHL1++
            entriesI[1] := [entriezHL1, "0-50"]
         } Else If isInRange(hlow, 50, 100)
         {
            entriezHL2++
            entriesI[2] := [entriezHL2, "50-100"]
         } Else If isInRange(hlow, 100, 150)
         {
            entriezHL3++
            entriesI[3] := [entriezHL3, "100-150"]
         } Else If isInRange(hlow, 150, 200)
         {
            entriezHL4++
            entriesI[4] := [entriezHL4, "150-200"]
         } Else If isInRange(hlow, 200, 256)
         {
            entriezHL5++
            entriesI[5] := [entriezHL5, "200-255"]
         }

         If isInRange(hRange, 0, 50)
         {
            entriezHR1++
            entriesR[1] := [entriezHR1, "0-50"]
         } Else If isInRange(hRange, 50, 100)
         {
            entriezHR2++
            entriesR[2] := [entriezHR2, "50-100"]
         } Else If isInRange(hRange, 100, 150)
         {
            entriezHR3++
            entriesR[3] := [entriezHR3, "100-150"]
         } Else If isInRange(hRange, 150, 200)
         {
            entriezHR4++
            entriesR[4] := [entriezHR4, "150-200"]
         } Else If isInRange(hRange, 200, 256)
         {
            entriezHR5++
            entriesR[5] := [entriezHR5, "200-255"]
         }

         mgpx := Round(mgpx, 1)
         ratio := Round(ratio, 1)
         pixu := "z" StringToASC(pixfmt)
         ratiou := StrReplace(ratio, ".", "q")
         mgpxu := StrReplace(mgpx, ".", "q")
         entriez%ratiou%++
         entriez%pixu%++
         entriezMP%mgpxu%++
         entriezFram%frames%++
         entriezU%dpiu%++
         entriesD[mgpxu] := [entriezMP%mgpxu%, mgpx]
         entriesS[pixu] := [entriez%pixu%, pixFmt]
         entriesY[ratiou] := [entriez%ratiou%, ratio]
         entriesM["z" frames] := [entriezFram%frames%, frames]
         entriesU["z" dpiu] := [entriezU%dpiu%, dpiu]

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
     If (SLDtypeLoaded=3)
        RecordSet.Free()

     If (abandonAll!=1)
        prevState := thisState
  }

  If (SLDtypeLoaded=3 && prevMaxu)
     thisMaxCount := prevMaxu

  If (SLDtypeLoaded=3)
  {
     entriesCount := 0
     Loop, % entriesD.Count()
        entriesCount += entriesD[A_Index, 1]
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaU
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesU
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaA
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesA
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaG
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesG
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaR
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesR
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaI
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesI
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesS
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 5
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  percDone := " (" Round((entriesCount / thisMaxCount) * 100, 1) "%)"
  entriesCount := groupDigits(entriesCount)
  thisMaxCount := groupDigits(thisMaxCount)
  GuiControl, SettingsGUIA:, infoLine, Indexed images: %entriesCount% / %thisMaxCount%%percDone%
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PopulateIndexSQLFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  startZeit := A_TickCount

  If (thisState!=prevState || dummy="kill")
  {
     cachedMode := entriesCount := 0
     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     zr := uiFileIndexStatsRetrieveSizeRangeDB(1, q, 1, ":-)", 0, 1)
     If (dummy="kill")
        Return

     If (sqlFailedInit=1)
        Return 0

     RecordSet := ""
     SQL := "SELECT substr(fmodified, 1, 8), COUNT(*) FROM images GROUP BY substr(fmodified, 1, 8);"
     If !activeSQLdb.GetTable(SQL, RecordSet)
     {
        throwSQLqueryDBerror(A_ThisFunc)
        Return 0
     }

     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait", 0, 0, 0.4/10)
     setImageLoading()

     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            dateuD := "z" Rowu[1] ; SubStr(Row[1], 1, 8)
            dateuM := "z" SubStr(Rowu[1], 1, 6)
            dateuY := "z" SubStr(Rowu[1], 1, 4)
            entriez%dateuD% += Rowu[2]
            entriez%dateuM% += Rowu[2]
            entriez%dateuY% += Rowu[2]
            entriesCount += Rowu[2]
            entriesD[dateuD] := [entriez%dateuD%, Rowu[1]] ; SubStr(Row[1], 1, 8)]
            entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 6)]
            entriesY[dateuY] := [entriez%dateuY%, SubStr(Rowu[1], 1, 4)]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     If (abandonAll!=1)
        prevState := thisState

     RecordSet.Free()
  } Else cachedMode := 1

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  showTOOLtip("Generating statistics, please wait", 0, 0, 1.5/10)
  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", Value[2], 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", Value[2], 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  Loop, % thisMaxCount
  {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (isFilter=1)
         imgPath := bckpResultedFilesList[A_Index, 1]
      Else
         imgPath := resultedFilesList[A_Index, 1]

      foundPos := InStr(imgPath, ".", 0, -1)
      If foundPos
      {
         fileEXT := SubStr(imgPath, foundPos + 1)
         entriez%fileEXT%++
         entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
      }
  }

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  If (abandonAll=1 || determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastOtherWinClose := A_TickCount
     interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  zr := (cachedMode=1) ? "c" : 0
  j := 0
  showTOOLtip("Generating statistics, please wait", 0, 0, 4/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 1, "<5 KB", 0, 4998)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 2, "5-10 KB", 4999, 10001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 3, "10-25 KB", 10002, 25001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 4, "25-50 KB", 25002, 50001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 6/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 5, "50-100 KB", 50002, 100001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 6, "100-250 KB", 100002, 250001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 7, "250-500 KB", 250002, 500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 8, "0.5-1.0 MB", 500002, 1000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 8/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 9, "1.0-2.5 MB", 1000002, 2500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 10, "2.5-5.0 MB", 2500002, 5000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 11, "5-10 MB", 5000002, 10000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 12, "10-25 MB", 10000002, 25000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 9/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 13, "25-50 MB", 25000002, 50000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 14, "50-100 MB", 50000002, 100000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 15, "100-250 MB", 100000002, 250000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 16, "250-500 MB", 250000002, 500000001)
  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(j/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

uiFileIndexStatsRetrieveSizeRangeDB(zr, ByRef totalSizeu, indexu, labelu, minu, maxu) {
  Static cacheInfos := []

  thisCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  If (zr=1)
  {
     cacheInfos := []
     Return
  } Else If (zr="c")
  {
     LV_Add(indexu, indexu, labelu, cacheInfos[indexu, 1], cacheInfos[indexu, 2], Round((cacheInfos[indexu, 2]/thisCount)*100, 1))
     totalSizeu += cacheInfos[indexu, 1]
     Return "c"
  }

  SQL := "SELECT sum(fsize), COUNT(*) FROM images WHERE fsize BETWEEN " minu " AND " maxu ";"
  If activeSQLdb.GetTable(SQL, RecordSet)
  {
     abandonAll := thisSizeFiles := thisTotalSizeRange := 0
     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            thisSizeFiles := Rowu[2]
            thisTotalSizeRange := Rowu[1]
            ; thisSizeFiles++
            ; thisTotalSizeRange += Row[1]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     RecordSet.Free()
     totalSizeu += Round(thisTotalSizeRange/(1024**2), 4)
     cacheInfos[indexu] := [Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles]
     LV_Add(indexu, indexu, labelu, Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles, Round((thisSizeFiles/thisCount)*100, 1))
  }

  Return abandonAll
}

PanelImageInfos() {
    Global LViewMetaD, LViewMetaOthers
    If (thumbsDisplaying=1)
       MenuDummyToggleThumbsMode()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, fileNamu, folderu)
    If !FileRexists(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(5, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Tab3,, General|Others
    Gui, Tab, 1 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD, Property|Data
    Gui, Tab, 2 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaOthers, Property|Data
    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w40 gInfoBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gInfoBtnNextImg, >>
    Gui, Add, Button, x+15 hp w%btnWid% gcopyIMGinfos2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gOpenThisFileFolder, &Explore folder
    Gui, Add, Button, x+5 hp w%btnWid% gOpenFileProperties, &File properties
    Gui, Add, Button, x+5 hp w90 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file details: " appTitle)
    PopulateImgInfos()
}

MenuPanelFoldersTree() {
   if (folderTreeWinOpen=1)
      GoSub, fdTreeGuiaGuiClose
   Else
      PanelFoldersTree()
}

PanelFoldersTree() {
    Static hasRan, prevSize := 0
    Global fdTreeInfoLine
    If MsgBox2hwnd
       Return

    If (hasRan=1 && prevSize!=PrefsLargeFonts)
    {
       hasRan := 0
       Gui, fdTreeGuia: Destroy
    }

    If (hasRan=1)
    {
       Gui, fdTreeGuia: Show
       folderTreeWinOpen := 1
       interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
       Return
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: +Resize -DPIScale -MaximizeBox -MinimizeBox +Owner%PVhwnd% +hwndhfdTreeWinGui +ToolWindow
    Gui, fdTreeGuia: Margin, 1, 1
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    prevSize := PrefsLargeFonts
    thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, TreeView, r10 vTVlistFolders AltSubmit +hwndhTVlistFolders gFolderTreeResponder
    Gui, Add, Button, xp y+1 w%thisBtnHeight% h%thisBtnHeight% gfolderTreeMiniBtn vbtnFldr, \\
    Gui, Add, Text, x+2 vfdTreeInfoLine +0x200 h%thisBtnHeight% gfolderTreeCopyPath -wrap, Folder tree status bar...
    Gui, Add, Button, x+1 y+1 w1 h1 -wantTab -TabStop Default gfolderTreeDefaultAction, &Default

    winPos := (prevSetWinPosY && prevSetWinPosX) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("fdTreeGuia", hfdTreeWinGui, 0, "Folders tree view: " appTitle, winPos)
    folderTreeWinOpen := 1
    interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
    hasRan := 1
    SetTimer, FolderTreeRepopulate, -100
}

folderTreeMiniBtn() {
   r := invokeFoldersListerMenu()
   If (r="err")
      folderTreeExpandCollapseAll()
}

folderTreeCopyPath(dummy:=0) {
   Static lastInvoked := 0
   If (A_TickCount - lastInvoked<356) || (dummy="forced")
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
         Return

      Try Clipboard := folderPath
      Catch wasError
          Sleep, 1

      If !wasError
         showTOOLtip("Folder tree path copied to the clipboard:`n" folderPath)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else lastInvoked := A_TickCount
}

folderTreeSetFolderProtected() {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
         Return
      setContaintFolderAsProtected(folderPath)
}

folderTreeDefaultAction() {
   If askAboutFileSave(" and another folder will be operned")
      Return

   If askAboutSlidesListSave()
      Return

   z := 0
   If GetKeyState("Shift", "P")
      z := 2
   Else If GetKeyState("Ctrl", "P")
      z := 1

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   folderPath := folderTreeGetSelectedPath(c)
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
   {
      OpenNewQPVinstance(folderPath)
   } Else If folderPath
   {
      tryOpenGivenFolder(folderPath, CurrentSLD)
      FileExploreSiblingsNav("reset")
   }

   Sleep, 1
   WinActivate, ahk_id %hfdTreeWinGui%
}

fdTreeGuiaGuiSize() {     
   ; (GuiHwnd, EventInfo, Width, Height) {
   GetWinClientSize(Width, Height, hfdTreeWinGui, 0)
   If (!width || !height || folderTreeWinOpen!=1)
      Return

   thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
   height -= thisBtnHeight
   GuiControl, fdTreeGuia: Move, TVlistFolders, w%width% h%height%
   width -= thisBtnHeight
   yPos := height + 1
   GuiControl, fdTreeGuia: Move, fdTreeInfoLine, y%yPos% w%width% 
   GuiControl, fdTreeGuia: Move, btnFldr, y%yPos% 
   ; SoundBeep , 900, 100
   SetTimer, fdTreeGuiaGuiSize, -100
}

fdTreeClose() {
   Gosub, fdTreeGuiaGuiClose
}

fdTreeGuiaGuiClose:
fdTreeGuiaGuiEscape:
   lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   Gui, fdTreeGuia: Hide
   folderTreeWinOpen := 0
   interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
Return

FolderTreeResponder(a, b, c) {
   Static lastInvoked, prevCu
   ; ToolTip, % A_DefaultTreeView "==" c , , , 2
   If (b="Normal" && StrLen(c)>3)
   {
      TV_Modify(c)
      zeit := A_TickCount - lastInvoked
      ; ToolTip, % zeit "==" prevCu "==" c , , , 2
      If (zeit<1234 && prevCu=c)
      {
         If TV_Get(c, "Expand")
            TV_Modify(c, "-Expand")
         Else
            TV_Modify(c, "+Expand")
      }
      lastInvoked := A_TickCount
      prevCu := c
   } Else If (b="K" && c=115) ; F4
   {
      WinActivate, ahk_id %PVhwnd%
   } Else If (b="K" && c=116) ; F5
   {
      FolderTreeRepopulate()
   } Else If (b="K" && c=112) ; F1
   {
      HelpWindow()
   } Else If (b="K" && c=113) ; F2
   {
      folderTreeRenameFolder()
   } Else If (b="K" && c=114) ; F3
   {
      folderTreeAppendFiles()
   } Else If (b="K" && c=118) ; F7
   {
      folderTreeCreateFolder()
   } Else If (b="K" && (c=119 || c=46)) ; F8
   {
      folderTreeDeleteFolder()
   } Else If (b="K" && c=120) ; F9
   {
      FolderTreeFindActiveFile()
      folderTreeInfoLineUpdater()
   } Else If (b="DoubleClick")
   {
      TV_Modify(c)
      folderTreeDefaultAction()
   } Else If (b="RightClick") || (b="K" && c=93) ; Apps/Menu key
   {
      If (b!="K")
         TV_Modify(c)

      folderTreeContextMenu()
   } Else If (b="d") || (b="K" && c=32) ; Space
   {
      If (b="K")
         c := TV_GetSelection()
      TV_Modify(c)
      folderTreeScanSubbies()
   }
   SetTimer, folderTreeInfoLineUpdater, -125
   ; ToolTip, % a "==" b "==" c "`n" folderPath , , , 2
}

folderTreeInfoLineUpdater() {
    If (folderTreeWinOpen!=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    c := TV_GetSelection()

    If c
       thisFolder := folderTreeGetSelectedPath(c)

    thisfolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
    If (!thisFolder && c)
       TV_GetText(OutputVar, c)
    Else If !thisFolder
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"

    If InStr(OutputVar, ":\")
    {
       Try DriveGet, info, Label, %OutputVar%
       Try DriveGet, size, Capacity, %OutputVar%
       Try DriveSpaceFree, FreeSpace, %OutputVar%
       perc := Round((FreeSpace/size)*100, 1) "%"
       driveInfo .= info " - " perc " free | "
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"
    }

    GuiControl, fdTreeGuia:, fdTreeInfoLine, % thisFolder
    SetTimer, fdTreeGuiaGuiSize, -50
}

folderTreeGetSelectedPath(c) {
   If StrLen(c)<2
      Return

   TV_GetText(folderPath, c)
   r := c
   Loop
   {
      r := TV_GetParent(r)
      If !r
         Break
      TV_GetText(thisu, r)
      folderPath := thisu folderPath
   }

   folderPath := StrReplace(folderPath, "\\", "\")
   If StrLen(folderPath)<5
      folderPath := ""

   Return folderPath
}

FolderTreeFindActiveFile(givenPath:=0) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    showTOOLtip("Scanning folders, please wait")
    z := 0 ; TV_GetNext()
    oimgPath := StrReplace(getIDimage(currentFileIndex), "||")
    imgPath := SubStr(oimgPath, 1, InStr(oimgPath, "\", 0, -1) - 1)
    If FolderExist(givenPath)
    {
       imgPath := givenPath
       wasGiven := 1
    }

    sliced := StrSplit(imgPath, "\")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    g := iterateFDtreeView(1, 0, sliced)
    lvl := g[1]
    z := g[2] ? g[2] : 0
    hasAdded := 0
    ; ToolTip, % lvl "=" gu , , , 2
    Loop, % sliced.Count()
    {
          thisIndex := A_Index - 1 + lvl
          If !sliced[thisIndex]
             Continue

          hasAdded := 1
          If (thisIndex=1)
             z := TV_Add(sliced[thisIndex] "\", z, "Expand Select VisFirst")
          Else
             z := TV_Add("\" sliced[thisIndex], z, "Expand Select VisFirst")
    }

    If (hasAdded!=1 && z)
       TV_Modify(z, "Expand Select VisFirst")

    initialSibling := SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
    If z
       w := TV_GetParent(z)
    ; ToolTip, % initialSibling , , , 2
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    If (w && !wasGiven)
    {
       r := w
       r := TV_GetChild(w)
       Loop
       {
          If (A_Index>1)
             r := TV_GetNext(r)

          If r
             x := TV_GetChild(r)
          Else
             x := ""

          If !r
             Break

          If x
          {
             labelu := ""
             TV_GetText(labelu, r)
             If (Trimmer(labelu, "\")!=initialSibling)
             {
                h := Trimmer(labelu, "\")
                mustSkip[h] := 1
                Continue
             }
          }
 
          mustDelete[r] := 1
       }
    }

    If !wasGiven
    {
       For Key, Value in mustDelete
          TV_Delete(Key)
    }

    mustDelete := ""
    subPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
    If (FolderExist(subPath) && w && !wasGiven)
    {
       Loop, Files, % subPath "\*", D
       {
          If (A_LoopFileName!="")
          {
             If mustSkip.hasKey(A_LoopFileName)
                Continue

             P%A_Index% := TV_Add("\" A_LoopFileName, w)
             If (A_LoopFileName=initialSibling)
                subsParent := P%A_Index%
          }
       }
    }

    mustSkip := ""
    If (subsParent && !wasGiven)
    {
       TV_Modify(subsParent, "Select VisFirst")
       folderTreeScanSubbies()
    }

    TV_Modify(w, "Sort")
    If !wasGiven
    {
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoLineUpdater, -100
       SetTimer, RemoveTooltip, -100
    }
}

iterateFDtreeView(lvl, z, sliced) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders

    Loop
    {
       labelu := ""
       If z
          TV_GetText(labelu, z)

       If (Trimmer(labelu, "\")=sliced[lvl] && labelu)
       {
          lvl++
          gu := z
          r := TV_GetChild(z)
          If (r!=0)
          {
             g := iterateFDtreeView(lvl, r, sliced)
             lvl := g[1]
             If g[2]
                gu := g[2]
          }
       }

       r := TV_GetNext(z)
       If (r=0)
          Break

       z := r
    }
    Return [lvl, gu]
}

FolderTreeRepopulate(dummy:=0, listuGiven:=0) {
    If (dummy="given" && listuGiven)
    {
       PanelFoldersTree()
       Try SetTimer, FolderTreeRepopulate, Off
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    If (!HKifs("imgsLoaded") || (dummy="given" && listuGiven))
    {
       If (dummy="given" && listuGiven)
       {
          aListu := listuGiven
          TV_Delete()
       } Else
       {
          aListu := readRecentEntries(0, 0)
          aListu .= readRecentFileDesties()
          If FolderExist(prevFileSavePath)
             aListu .= "`n" prevFileSavePath "`n"
          If FolderExist(prevFileMovePath)
             aListu .= "`n" prevFileMovePath "`n"
          If FolderExist(prevOpenFolderPath)
             aListu .= "`n" prevOpenFolderPath "`n"
    
          Sort, aListu, UD`n
       }

       Loop, Parse, aListu, `n
       {
          countItemz++
          testThis := StrReplace(A_LoopField, "|")
          If (StrLen(A_LoopField)<4 || !FileExist(testThis))
             Continue
 
          If RegExMatch(testThis, sldsPattern)
             testThis := SubStr(testThis, 1, InStr(testThis, "\", 0, -1) - 1)
 
          bListu .= testThis "`n"
       }
 
       Loop, Parse, bListu, `n
       {
          If A_LoopField
             FolderTreeFindActiveFile(A_LoopField)
       }
       TV_Modify(0, "Select VisFirst")
       folderTreeExpandCollapseAll("collapse")
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoLineUpdater, -100
       SetTimer, RemoveTooltip, -100
       Return
    }

    z := TV_GetNext()
    If z
       TV_Delete(z)

    showTOOLtip("Scanning folders, please wait")
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    parentsLevels := parentsObj.Count()
    ; ToolTip, % parentsLevels " == " currentParent , , , 2
    Loop, % parentsLevels
    {
       If (A_Index>currentParent)
          Continue
   
       If (A_Index=1 && !InStr(parentsObj[1], ":"))
          Break

       pu := A_Index - 1
       If (A_Index=1)
          P1 := TV_Add(parentsObj[A_Index] "\",, "Expand")
       Else If (A_Index!=currentParent)
          P%A_Index% := TV_Add("\" parentsObj[A_Index], P%pu%, "Expand")

       If (A_Index=currentParent)
          siblingsParent := P%pu%
    }

    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    Loop, % sibsObj.Count()
    {
       If !siblingsParent
          Continue

       pu := A_Index - 1
       If (A_Index=currentSib)
          subsParent := TV_Add("\" sibsObj[A_Index], siblingsParent, "Expand Bold")
       Else
          P%A_Index% := TV_Add("\" sibsObj[A_Index], siblingsParent)
    }

    If siblingsParent
       TV_Modify(siblingsParent, "Expand Sort")

    thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_LoopFileName!="")
          {
             P%A_Index% := TV_Add("\" A_LoopFileName, subsParent)
             hasAddedSubs := 1
          }
       }
    }

    If subsParent
       TV_Modify(subsParent, "Expand Sort")

    countu := TV_GetCount()
    If !countu
       FolderTreeFindActiveFile()

    GuiControl, fdTreeGuia: +Redraw, TVlistFolders
    SetTimer, folderTreeInfoLineUpdater, -100
    SetTimer, RemoveTooltip, -100
}

folderTreeContextMenu() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If c
      TV_GetText(labelu, c)

   Try Menu, PVfdTree, Delete
   Menu, PVfdTree, Add, Re&generate tree view`tF5, FolderTreeRepopulate
   Menu, PVfdTree, Add, &Highlight the focused file location`tF9, FolderTreeFindActiveFile
   If c
      Menu, PVfdTree, Add, &Scan for sub-folders`tSpace, folderTreeScanSubbies

   If (c && !InStr(labelu, ":"))
   {
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, Open`tEnter, folderTreeDefaultAction
      Menu, PVfdTree, Add, &Append images to the list`tF3, folderTreeAppendFiles
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, &Create new folder`tF7, folderTreeCreateFolder
      Menu, PVfdTree, Add, C&ut folder (Explorer mode), folderTreeCutCopyFolder
      Menu, PVfdTree, Add, C&opy folder (Explorer mode), folderTreeCutCopyFolder
      Menu, PVfdTree, Add, &Paste folder(s) into..., folderTreePasteFoldersInto
      Menu, PVfdTree, Add, &Rename folder`tF2, folderTreeRenameFolder
      Menu, PVfdTree, Add, &Delete folder`tDelete, folderTreeDeleteFolder
      Menu, PVfdTree, Add, Se&t as the protected folder, folderTreeSetFolderProtected
      Menu, PVfdTree, Add, Folder properties (E&xplorer), folderTreePropertiesFolder
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, Paste clip&board file(s) into..., folderTreePasteClippy
      Menu, PVfdTree, Add, Cop&y selected file(s) into...`t7, FolderTreeMenuCopyFiles
      Menu, PVfdTree, Add, &Move selected file(s) into...`tShift+7, FolderTreeMenuMoveFiles
      Menu, PVfdTree, Add
   }

   Menu, PVfdTree, Add, Large UI fonts, folderTreeToggleLargeUIfonts
   Menu, PVfdTree, Add, Close panel`tEscape, fdTreeGuiaGuiClose
   If (PrefsLargeFonts=1)
      Menu, PVfdTree, Check, Large UI fonts

   showThisMenu("PVfdTree")
}

folderTreeToggleLargeUIfonts() {
    ToggleLargeUIfonts()
    PanelFoldersTree()
}

FolderTreeMenuCopyFiles() {
   triggerQuickFileAction("vk37")
}

FolderTreeMenuMoveFiles() {
   triggerQuickFileAction("+vk37")
}

folderTreeCreateFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If !FolderExist(thisFolder)
   {
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected folder seems to no longer exist:`n`n" thisFolder "\`n`nWould you like to recreate it? By choosing yes, you will be able to create a new folder inside it.", 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   fakeWinCreator(53, A_ThisFunc, 0)
   msgResult := msgBoxWrapper("panelu|Create folder: " appTitle, "Create new folder in:`n" thisFolder "\`n`nPlease type the new folder name.", "&Create folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", "")
   If InStr(msgResult.btn, "Create")
   {
      newFileName := Trimmer(msgResult.edit)
      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      FileCreateDir, %thisFolder%\%newFileName%
      If !ErrorLevel
      {
         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         TV_Add("\" newFileName, c)
         TV_Add(c, "Expand Sort")
         GuiControl, fdTreeGuia: +Redraw, TVlistFolders
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured creating the new folder in:`n" thisFolder "\")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeDeleteFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If FolderExist(thisFolder)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected:`n`n" thisFolder "\`n`nPlease confirm you want to DELETE entirely this folder.", "&Delete|&Cancel", 2, "question")
      If (msgResult="delete")
      {
         destroyGDIfileCache()
         showTOOLtip("Deleting folder, please wait`n" thisFolder "\*")
         changeMcursor()
         ; FileRemoveDir, % thisFolder, 1
         r := ShellFileOperation("FO_DELETE", thisFolder "\", nona, "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
         If (!r["error"] && !r["aborted"])
         {
            Gui, fdTreeGuia: Default
            Gui, fdTreeGuia: TreeView, TVlistFolders
            SoundBeep , 900, 100
            RemoveTooltip()
            TV_Delete(c)
            GuiControl, fdTreeGuia: +Redraw, TVlistFolders
         } Else If (r["error"] || r["aborted"])
         {
            If r["error"]
               showTOOLtip("Failed to delete selected folder:`n" thisFolder "\")
            Else
               showTOOLtip("Operation aborted: delete folder:`n" thisFolder "\")
            SoundBeep , 300, 100
         }
      }
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      TV_Delete(c)
      SoundBeep 300, 100
   }
   SetTimer, ResetImgLoadStatus, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreePasteFoldersInto() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If !FolderExist(thisFolder)
   {
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected folder seems to no longer exist:`n`n" thisFolder "\`n`nWould you like to recreate it? By choosing yes, QPV will paste the folders inside it.", 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   showTOOLtip("Importing clipboard content...")
   Try listu := Clipboard
   SetTimer, RemoveTooltip, -200
   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no folders in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   isExplorerModeA := IsClipboardFormatAvailable(15)
   msgResult := msgBoxWrapper(appTitle ": Paste folders", "The folders from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" thisFolder "\", "&Copy|&Move|C&ancel", 1, "question")
   SetTimer, RemoveTooltip, -200
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "COPYING"
      filesActu := "FO_COPY"
   } Else If InStr(msgResult, "Move")
   {
      friendly := "MOVING"
      filesActu := "FO_MOVE"
   } Else
   {
      WinActivate, ahk_id %hfdTreeWinGui%
      Return
   }

   destroyGDIfileCache()
   changeMcursor()
   line := ""
   zr := loopsCount := 0
   Loop, Parse, listu, `n,`r
   {
        line := Trimmer(Trimmer(A_LoopField), "\")
        If FolderExist(line)
        {
           loopsCount++
           r := ShellFileOperation(filesActu, line "\", thisFolder "\", "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
           If (r["aborted"] || r["error"])
           {
              zr := r["error"] ? 1 : 2
              Break
           }
        }
   }

   folderTreeScanSubbies()
   If zr
   {
      friendly2 := InStr(msgResult, "Copy") ? "COPY" : "MOVE"
      If (zr=1)
         showTOOLtip("Failed to " friendly2 " folder:`n" line "\")
      Else
         showTOOLtip("Operation aborted while " friendly " the folder:`n" line "\")
      SoundBeep , 300, 100
   } Else
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (filesActu="FO_MOVE" && isExplorerModeA=1 && isExplorerModeB=1)
         Try Clipboard := ""

      showTOOLtip("Finished " friendly " folder(s) from the clipboard into:`n" thisFolder "\")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   ResetImgLoadStatus()
}

folderTreeCutCopyFolder(a) {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   userOption := InStr(StrReplace(a, "&"), "cut") ? "CUT" : "COPY"
   If FolderExist(thisFolder)
   {
      destroyGDIfileCache()
      dataHandle := ClipboardSetFiles([thisFolder], userOption, 1)
      Sleep, 5
      testClipType := IsClipboardFormatAvailable(15)
      infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set the clipboard" : userOption " action: the folder can now be pasted in any file manager`n" thisFolder "\"
      showTOOLtip(infoText)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

folderTreePropertiesFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If FolderExist(thisFolder)
   {
      Try Run, Properties "%thisFolder%"
      Catch wasError
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

folderTreeRenameFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If !FolderExist(thisFolder)
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   fakeWinCreator(51, A_ThisFunc, 0)
   thisParent := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   msgResult := msgBoxWrapper("panelu|Rename folder: " appTitle, "Folder location:`n" thisFolder "\`n`nPlease type the new folder name for:`n" thisParent, "&Rename folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", thisParent)
   If InStr(msgResult.btn, "Rename")
   {
      newFileName := Trimmer(msgResult.edit)
      If !newFileName
         Return

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      oldPath := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
      FileMoveDir, % thisFolder, % oldPath "\" newFileName, R
      If !ErrorLevel
      {
         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         TV_Modify(c, "Select Vis Sort", "\" newFileName)
         GuiControl, fdTreeGuia: +Redraw, TVlistFolders
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured renaming the folder:`n" thisFolder "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeAppendFiles() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   changeMcursor()
   linea := folderTreeGetSelectedPath(c)
   If (!linea || !FolderExist(linea) || InStr(DynamicFoldersList, linea "`n"))
      Return

   If !CurrentSLD
      CurrentSLD := linea

   GetFilesList(linea "\*")
   DynamicFoldersList .= linea "`n"
   If (SLDtypeLoaded=3)
      addDynamicFolderSQLdb(linea, 0, "dynamicfolders")

   SoundBeep 900, 100
   ResetImgLoadStatus()
   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
}

folderTreeExpandCollapseAll(forceMode:=0) {
   Static prevState := 1
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetNext()
   If !c
      Return

   If (forceMode="collapse")
      prevState := 1
   Else If (forceMode="expand")
      prevState := 0

   act := (prevState=1) ? "-Expand" : "Expand"
   friendly := (prevState=1) ? "COLLAPSED" : "EXPANDED"
   c := TV_Modify(c, act)
   Loop
   {
       c := TV_GetNext(c, "F")
       TV_Modify(c, act)
       If !c
          Break
   }

   c := TV_GetNext()
   c := TV_Modify(c, "VisFirst Select")
   prevState := !prevState
   showTOOLtip("Folder tree: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreeScanSubbies() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   ; c := prevTVelement

   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
   {
      TV_GetText(thisFolder, c)
      thisFolder := Trimmer(thisFolder, "\")
   }

   If !thisFolder
      Return

    showTOOLtip("Scanning folders, please wait")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...
    ; ToolTip, % A_DefaultTreeView "==" A_DefaultGUI "==" c , , , 2
    changeMcursor()
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    r := c
    r := TV_GetChild(c)
    Loop
    {
       If (A_Index>1)
          r := TV_GetNext(r)

       If r
          x := TV_GetChild(r)
       Else
          x := ""

       If !r
          Break

       If x
       {
          labelu := ""
          TV_GetText(labelu, r)
          If (Trimmer(labelu, "\") && FolderExist(thisFolder labelu))
          {
             h := Trimmer(labelu, "\")
             mustSkip[h] := 1
             Continue
          }
       }

       mustDelete[r] := 1
    }

    For Key, Value in mustDelete
       TV_Delete(Key)

   mustDelete := ""
   If FolderExist(thisFolder)
   || (StrLen(thisFolder)=2 && InStr(thisFolder, ":"))
   {
      Loop, Files, % thisFolder "\*", D
      {
         If mustSkip.hasKey(A_LoopFileName)
            Continue

         If (A_LoopFileName!="")
         {
            P%A_Index% := TV_Add("\" A_LoopFileName, c)
            hasAddedSubs := 1
         }
      }
   }

   mustSkip := ""
   RemoveTooltip()
   TV_Modify(c, "Expand Vis Select Sort")
   GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   SetTimer, folderTreeInfoLineUpdater, -100
   SetTimer, ResetImgLoadStatus, -125
}

folderTreePasteClippy() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If FolderExist(thisFolder)
   {
      PasteFilesIntoGivenFolder(thisFolder)
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PasteFilesIntoGivenFolder(folderPath) {
   showTOOLtip("Importing clipboard content...")
   Try listu := Clipboard
   SetTimer, RemoveTooltip, -200
   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no files in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   msgResult := msgBoxWrapper(appTitle ": Paste files", "The files from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" folderPath "\", "&Copy|&Move|C&ancel", 1, "question")
   SetTimer, RemoveTooltip, -200
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "Copying"
      filesActu := 1
   } Else If InStr(msgResult, "Move")
   {
      friendly := "Moving"
      filesActu := 2
   } Else
   {
      WinActivate, ahk_id %hfdTreeWinGui%
      Return
   }

   isExplorerModeA := IsClipboardFormatAvailable(15)
   foundFiles := ST_Count(listu, "`n")
   finalDest := folderPath
   filezMoved := countTFilez := 0
   doStartLongOpDance()
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   Loop, Parse, listu, `n,`r
   {
      If !A_LoopField
         Continue

      file2rem := A_LoopField
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, foundFiles, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/foundFiles)
         prevMSGdisplay := A_TickCount
      }

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (filesActu=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
         }

         filezMoved++
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   If (filesActu=2)
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (abandonAll!=1 && isExplorerModeA=1 && isExplorerModeB=1)
         Try Clipboard := ""

      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BtnCloseWindow() {
   Critical, on
   CloseWindow("yes")
   If AnyWindowOpen
      BtnCloseWindow()
}

InfoBtnNextImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  NextPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

InfoBtnPrevImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  PreviousPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

copyIMGinfos2clip() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>95)
          Break
   }

   textu := Trimmer(textu) "`NOTHER DETAILS:`n"
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>99)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Unable to copy to clipboard file details")
         SoundBeep , 300, 100
      } Else showTOOLtip("File details copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateImgInfos() {
   If (AnyWindowOpen!=5)
      Return

   resultu := getIDimage(currentFileIndex)
   If !FileExist(resultu)
   {
      informUserFileMissing()
      Return
   }

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   LV_Delete()
   Try PropList := FGP_List(resultu)            ; Gets all of a file's non-blank properties.
   Loop, Parse, % PropList.CSV,`n
   {
       If !A_LoopField
          Continue
       lineArru := StrSplit(A_LoopField, ",")
       LV_Add(A_Index, lineArru[2], lineArru[3])
   }

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_Delete()
   FileGetSize, FileSizu, % resultu, K
   FileGetTime, FileDateM, % resultu, M
   FileGetTime, FileDateC, % resultu, C
   FormatTime, FileDateM, % FileDateM, dddd, d MMMM yyyy, HH:mm:ss
   FormatTime, FileDateC, % FileDateC, dddd, d MMMM yyyy, HH:mm:ss

   zPlitPath(resultu, 0, fileNamu, folderu)
   zoomu := Round(zoomLevel*100)
   If (thisIMGisDownScaled=1)
      infoDownScale := " [DOWNSCALED] "

   Gdip_GetImageDimensions(useGdiBitmap(), Width, Height)
   If (currIMGdetails.TooLargeGDI=1)
      infoRes := "`nOriginal resolution (W x H)||" groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " (in pixels)"

   generalInfos := "File name||" fileNamu "`nLocation||" folderu "\`nFile size||" groupDigits(fileSizu) " kilobytes`nDate created||" FileDateC "`nDate modified||" FileDateM infoRes "`nResolution (W x H)||" groupDigits(Width) " x " groupDigits(Height) " (in pixels)`nCurrent zoom level||" zoomu " % (" DefineImgSizing() infoDownScale ")"
   Loop, Parse, generalInfos, `n
   {
       lineArru := StrSplit(A_LoopField, "||")
       LV_Add(A_Index, lineArru[1], lineArru[2])
   }

   LV_Add(A_Index, "Colors display mode", DefineFXmodes())
   Gdip_GetHistogram(useGdiBitmap(), 2, ArrChR, ArrChG, ArrChB)
   Loop, 256
   {
       sumTotalR += ArrChR[A_Index] * A_Index
       sumTotalG += ArrChG[A_Index] * A_Index
       sumTotalB += ArrChB[A_Index] * A_Index
   }

   diffRGBtotal := max(sumTotalR, sumTotalG, sumTotalB) - min(sumTotalR, sumTotalG, sumTotalB)
   diffRGBtotal := diffRGBtotal/max(sumTotalR, sumTotalG, sumTotalB)
   If (diffRGBtotal<0.0001 || diffRGBtotal="")
      LV_Add(A_Index, "Grayscale image", 1)
   Else
      LV_Add(A_Index, "Grayscale image", 0)

   LV_Add(A_Index, "Image file format", currIMGdetails.RawFormat)
   LV_Add(A_Index, "Image pixel format", currIMGdetails.PixelFormat)

   CountFrames := currIMGdetails.Frames
   If (CountFrames>1)
      LV_Add(A_Index, "Embedded frames", CountFrames)

   If (currIMGdetails.OpenedWith="GDI+")
   {
      thumbBMP := trGdip_CreateBitmapFromFile(getIDimage(currentFileIndex))
      If StrLen(thumbBMP)>2
         MoreProperties := Gdip_GetAllPropertyItems(thumbBMP)
      For ID, Val In MoreProperties
      {
         If ID Is Integer
         {
            PropName := Gdip_GetPropertyTagName(ID)
            PropType := Gdip_GetPropertyTagType(Val.Type)
            If (val.value && StrLen(PropName)>1 && PropName!="unknown" && PropType!="undefined" && PropType!="byte")
            {
               If (InStr(PropName, "nancetable") || InStr(PropName, "jpeg") || InStr(PropName, "thumbnail")
               || InStr(PropName, "printflag") || InStr(PropName, "strip") || InStr(PropName, "chromatic"))
                  Continue
 
               If (PropName="frame delay") || (PropName="bits per sample")
               {
                  valu := SubStr(Val.Value, 1, InStr(Val.Value, A_Space))
                  LV_Add(A_Index, PropName, valu)
               } Else LV_Add(A_Index, PropName, Val.Value)
            }
         }
      }
      trGdip_DisposeImage(thumbBMP, 1)
   }
   LV_Add(A_Index, "Image loaded with ", currIMGdetails.OpenedWith)

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")
}

Trimmer(string, whatTrim:="") {
   If (whatTrim!="")
      string := Trim(string, whatTrim)
   Else
      string := Trim(string, "`r`n `t`f`v`b")
   Return string
}

FileRexists(filePath) {
   obju := GetFileAttributesEx(filePath)
   ; MsgBox, % fileAttribs "`n" fileSizu "`nA" filePath "A"
   If (obju.size<120 || !obju.size)
      Return 0
   Else
      Return 1
}

hFindIsFolder(ByRef fileInfos) {
   Static FILE_ATTRIBUTE_DIRECTORY := 0x10
   Return NumGet(&fileInfos,0,"UInt") & FILE_ATTRIBUTE_DIRECTORY
}

hFindGetName(ByRef fileInfos) {
   cFileName := StrGet(&fileInfos + 44, 260, "UTF-16")
   If (cFileName="." || cFileName="..")
      cFileName := ""
   Return cFileName
}

testGetFile(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 1512, 0)

    hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")
    cFileName := hFindGetName(Win32FindData)
    If (hFindIsFolder(Win32FindData) && cFileName)
    {
    ;  MsgBox, folderrr
       testGetFile(filePath "\" cFileName)
    } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
    {
       maxFilesIndex++
       resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
    }

   ; MsgBox, % filePath "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError


 ;   instance.nFileSizeHigh := NumGet(&Win32FindData, 28,  "UInt")
;    instance.nFileSizeLow := NumGet(&Win32FindData, 32,  "UInt")

    While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
          cFileName := hFindGetName(Win32FindData)
          If hFindIsFolder(Win32FindData) && cFileName
          {
             testGetFile(filePath "\" cFileName)
          } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
          }
    ; MsgBox, % filePath "`n" r "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
    }

   ; maxFilesIndex := resultedFilesList.Length()
    ; SoundBeep 
    Return
}

testGetFile2(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 318+1024, 0)
    if (hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")) {
        cFileName := StrGet(&Win32FindData + 44, 260, "UTF-16")
        cAlternateFileName := StrGet(&Win32FindData + 564, 14, "UTF-16")
        
        MsgBox, %  hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
        While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
            cFileNamea := StrGet(&Win32FindData + 44, 260, "UTF-16")
            cAlternateFileNamea := StrGet(&Win32FindData + 564, 14, "UTF-16")
            MsgBox, %  r "`n" cFileNameA "`n" cAlternateFileNameA "`n" ErrorLevel "`n" A_LastError
        }
    }
    Return
}

testFileExistence(imgPath) {
  ; https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfilesize
  ; H := DllCall("kernel32\GetFileAttributesW", "Str", imgPath)
  ; H := DllCall("shlwapi.dll\PathFileExistsW", "Str", imgPath)
  ; If (h>0)
  ;    Return 256
  VarSetCapacity(dummy, 1024, 0)
  H := DllCall("kernel32\FindFirstFileW", "Str", imgPath, "Ptr", &dummy, "Ptr")
  Return H
}

informUserFileMissing() {
   Critical, on
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
   winTitle := "[*] " currentFileIndex "/" maxFilesIndex " | " fileNamu " | " folderu
   setWindowTitle(winTitle, 1)
   SoundBeep, 300, 100
   If (autoRemDeadEntry=1)
      remCurrentEntry(1)
   If (thumbsDisplaying=1 && maxFilesIndex>0)
      mainGdipWinThumbsGrid()

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

JEE_StrRegExLiteral(vText) {
  Loop, Parse, vText
  {
    If InStr("\.+[{()^$", A_LoopField)
      vOutput .= "\" A_LoopField
    Else If InStr("?*", A_LoopField)
      vOutput .= "." A_LoopField
    Else
      vOutput .= A_LoopField
  }

  Return vOutput
}

FiltersComboAction() {
  If (A_GuiControlEvent="DoubleClick")
     BtnApplyFilesFilter()
}


readRecentFiltersEntries() {
   Loop, 20
   {
       IniRead, newEntry, % mainRecentsFile, RecentFilters, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (InStr(entriesList, newEntry "`n") || !newEntry)
          Continue

       addSel := (newEntry=testFilteru) ? "`n" : ""
       If StrLen(newEntry)>1
          entriesList .= newEntry "`n" addSel
   }

   Return entriesList
}

EraseFilterzHisto() {
  IniDelete, % mainRecentsFile, RecentFilters
  CloseWindow()
  Sleep, 50
  PanelEnableFilesFilter()
}

PanelEnableFilesFilter() {
    Global FilterTypeu := 0
    If (maxFilesIndex<3 && !filesFilter)
       Return

    If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
    {
       showTOOLtip("WARNING: The files list is already filtered.`nIt is comprised of duplicate image pairs filtered by Hamming distance.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, PanelChangeHamDistThreshold, -350
       Return
    }

    thisBtnHeight := createSettingsGUI(6, A_ThisFunc)
    btnWid := 80
    txtWid := 360
    EditWid := 390
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 200
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If !filesFilter
    {
       userFilterProperty := 1 
       userFilterDoString := 0
    }

    listu := readRecentFiltersEntries()
    If (!InStr(listu, "`n`n") && StrLen(UsrEditFilter)>0 && userFilterDoString=1 && StrLen(filesFilter)>1)
       listu := UsrEditFilter "`n`n" listu

    Gui, +Delimiter`n
    Gui, Add, Tab3,, Text`nFile and image
    Gui, Tab, 1
    Gui, Add, Checkbox, x+15 y+15 Section w%txtWid% gupdateUIFiltersPanel Checked%userFilterDoString% vuserFilterDoString, Filter files list with given string
    Gui, Add, ComboBox, y+7 w%EditWid% gupdateUIFiltersPanel vUsrEditFilter, % listu
    Gui, Add, DropDownList, y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterStringPos% vuserFilterStringPos, Anywhere`nBegins with`nEnds with`nRegEx
    Gui, Add, DropDownList, x+2 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterWhat% vuserFilterWhat, Full path`nFolder path`nFile name`nParent folder
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain given string
    Gui, Add, Button, xs y+7 vbtnFldr h%thisBtnHeight% w%btnWid% gEraseFilterzHisto, Erase &history
    Gui, Add, Text, xs y+15 vbtnFldr2 w%txtWid%, TIP: You can use | for OR and the *, ? wildcards in the filter to match more files.
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section w%txtWid%, Please choose the type of criteria and set minimum and maximum range.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterProperty% vuserFilterProperty, None`nFile size`nModified date`nCreated date`nMegapixels`nWidth`nHeight`nAspect ratio`nFrames`nDPI`nAverage`nMedian`nPeak range`nMinimum range`nTotal range`nMode`nMinimum`nRoot-mean suqare`nSelected files`nAlready seen
    Gui, Add, Text, x+5 wp vFilterTypeu, 
    Gui, Add, Edit, xs y+7 wp number limit5 +hwndhEditA gupdateUIFiltersPanel vFilteruMinRange, % FilteruMinRange
    Gui, Add, Edit, x+5 wp number limit5 +hwndhEditB gupdateUIFiltersPanel vFilteruMaxRange, % FilteruMaxRange
    Gui, Add, DropDownList, x+5 wp gupdateUIFiltersPanel AltSubmit Choose%userFilterSizeProperty% vuserFilterSizeProperty, Kilobytes`nMegabytes
    Gui, Add, DateTime, xs y+7 wp gupdateUIFiltersPanel vFilteruDateMinRange, yyyy/MM/dd
    Gui, Add, DateTime, x+5 wp gupdateUIFiltersPanel vFilteruDateMaxRange, yyyy/MM/dd
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterInvertThis% vuserFilterInvertThis, &Invert filter
    Gui, Tab
    Gui, Add, Edit, xs y+10 w%EditWid% r2 +0x0800 vInternalFilterString, % filesFilter
    ; Gui, Add, Text, y+7 w%txtWid%, Tip: you can begin the string with \> to use RegEx.

    btnWid := (PrefsLargeFonts=1) ? btnWid - 15 : btnWid - 5
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% w%btnWid% Default gBtnApplyFilesFilter, &Apply filter
    If StrLen(filesFilter)>1
       Gui, Add, Button, x+5 hp wp+20 gBTNuiremFilesListFilter, &Remove filters
    btnWid := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, x+5 hp w%btnWid% gPanelWrapperFilesStats, S&tats
    Gui, Add, Button, x+5 hp wp gPanelSearchIndex, &Search
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files list filtering: " appTitle)
    EM_SETCUEBANNER(hEditA, "Minimum")
    EM_SETCUEBANNER(hEditB, "Maximum")
    ; EM_SETCUEBANNER(hEditC, "String to match")
    SetTimer, updateUIFiltersPanel, -300
}

BTNuiremFilesListFilter() {
   BtnCloseWindow()
   remFilesListFilter()
   SetTimer, RandomPicture, -90
}

SQLescapeStr(str, likeu:=0) {
   str := StrReplace(str, "'", "''")
   If (likeu=1)
   {
      str := StrReplace(str, "_", ">_")
      str := StrReplace(str, "%", ">%")
      str := StrReplace(str, "[", ">[")
   }
   Return str
}

updateUIFiltersPanel(dummy:=0) {
   Static columnsList := {2:"fsize", 3:"fmodified", 4:"fcreated", 5:"imgmegapix", 6:"imgwidth", 7:"imgheight", 8:"imgwhratio", 9:"imgframes", 10:"imgdpi", 11:"imgavg", 12:"imgmedian", 13:"imghpeak", 14:"imghlow", 15:"imghrange", 16:"imghmode", 17:"imghminu", 18:"imghrms"}

   If (dummy!="external")
   {
      If (AnyWindowOpen=6)
         Gui, SettingsGUIA: Default
      Else
         Return

      GuiControlGet, UsrEditFilter
      GuiControlGet, userFilterDoString
      GuiControlGet, userFilterStringIsNot
      GuiControlGet, userFilterStringPos
      GuiControlGet, userFilterWhat
      GuiControlGet, userFilterProperty
      GuiControlGet, userFilterSizeProperty
      GuiControlGet, userFilterInvertThis
      GuiControlGet, FilteruMinRange
      GuiControlGet, FilteruMaxRange
      GuiControlGet, FilteruDateMaxRange
      GuiControlGet, FilteruDateMinRange

      If (userFilterStringPos!=4)
      {
         Loop, Parse, % "<>/"
            UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)

         If (userFilterWhat=3)
         {
            Loop, Parse, % ":\"
               UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)
         }
         UsrEditFilter := StrReplace(UsrEditFilter, "||")
      }

      actu := (userFilterDoString=1) ?  "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterWhat
      GuiControl, % actu, userFilterStringPos
      GuiControl, % actu, userFilterStringIsNot
      GuiControl, % actu, UsrEditFilter
      GuiControl, % actu, btnFldr
      GuiControl, % actu, btnFldr2

      If (userFilterProperty=1 || userFilterProperty=19)
         GuiControl, SettingsGUIA: Disable,  userFilterInvertThis
      Else
         GuiControl, SettingsGUIA: Enable,  userFilterInvertThis

      If (userFilterProperty=2)
         GuiControl, SettingsGUIA: Enable,  userFilterSizeProperty
      Else
         GuiControl, SettingsGUIA: Disable,  userFilterSizeProperty

      If (userFilterProperty=3 || userFilterProperty=4)
      {
         GuiControl, SettingsGUIA: Enable, FilteruDateMaxRange
         GuiControl, SettingsGUIA: Enable, FilteruDateMinRange
      } Else
      {
         GuiControl, SettingsGUIA: Disable, FilteruDateMaxRange
         GuiControl, SettingsGUIA: Disable, FilteruDateMinRange
      }

      If (userFilterProperty=2 || isInRange(userFilterProperty, 5, 18))
      {
         GuiControl, SettingsGUIA: Enable, FilteruMinRange
         GuiControl, SettingsGUIA: Enable, FilteruMaxRange
      } Else
      {
         GuiControl, SettingsGUIA: Disable, FilteruMinRange
         GuiControl, SettingsGUIA: Disable, FilteruMaxRange
      }

      If isInRange(userFilterProperty, 2, 4)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, File property
      } Else If isInRange(userFilterProperty, 5, 10)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, Image property
      } Else If isInRange(userFilterProperty, 11, 18)
      {
         ; FilteruMaxRange := Round(FilteruMaxRange*1.05)
         ; FilteruMinRange := Round(FilteruMinRange*1.05)
         GuiControl, SettingsGUIA:, FilterTypeu, Histogram details
      } Else
      {
         GuiControl, SettingsGUIA:, FilterTypeu, -
      }
   }

   ; testRegEx := SubStr(UsrEditFilter, 1, 2)
   thisStringFilter := ""
   If (userFilterDoString=1 && SLDtypeLoaded=3)
   {
      thisStringFilter := SQLescapeStr(UsrEditFilter, 1)
      If (userFilterStringPos=4 && thisStringFilter)
         thisStringFilter := thisStringFilter
      Else If (userFilterStringPos=3 && thisStringFilter) 
         thisStringFilter := "%" thisStringFilter
      Else If (userFilterStringPos=2 && thisStringFilter)
         thisStringFilter := thisStringFilter "%"
      Else If UsrEditFilter
         thisStringFilter := "%" thisStringFilter "%"

      thisStringFilter := StrReplace(thisStringFilter, "?", "_")
      thisStringFilter := StrReplace(thisStringFilter, "*", "_")
      thisStringFilter := StrReplace(thisStringFilter, "|")
   } Else If (userFilterDoString=1 && SLDtypeLoaded!=3)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If UsrEditFilter
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   columnu := columnsList[userFilterProperty]
   minRange := min(FilteruMinRange, FilteruMaxRange)
   maxRange := max(FilteruMinRange, FilteruMaxRange)
   minDrange := min(FilteruDateMinRange, FilteruDateMaxRange)
   maxDrange := max(FilteruDateMinRange, FilteruDateMaxRange)
   If (userFilterProperty>1 && minRange!="")
   {
      If (userFilterProperty=2)
      {
         minRange := (userFilterSizeProperty=2) ? minRange*(1024**2) : minRange*1024
         maxRange := (userFilterSizeProperty=2) ? maxRange*(1024**2) : maxRange*1024
      } Else If (userFilterProperty=3 || userFilterProperty=4)
      {
         minRange := SubStr(minDrange, 1, 8) "010101"
         maxRange := SubStr(maxDrange, 1, 8) "010101"
      } Else If (userFilterProperty=8)
      {
         minRange := Round(minRange/10, 1)
         maxRange := Round(maxRange/10, 1)
      } Else If (userFilterProperty>10)
      {
         minRange := Round(clampInRange(minRange, 1, 256)/256, 5)
         maxRange := Round(clampInRange(maxRange, 1, 256)/256, 5)
      }

      If (SLDtypeLoaded=3)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterProperty=8)
            columnu := "Round(imgwhratio, 1)"
         If (userFilterProperty=5)
            columnu := "Round(imgmegapix)"

         If (userFilterWhat=3)
            2ndColumn := "imgfile"

         If (userFilterInvertThis=1)
            invertor := " NOT "

         finalFilteru := "SQL:query:WHERE " columnu invertor " BETWEEN " minRange " AND " maxRange
         If thisStringFilter
            finalFilteru .= " AND " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else
      {
         finalFilteru := "QPV::query::" columnu "::" minRange "::" maxRange
         If thisStringFilter
            finalFilteru .= "::" thisStringFilter
      }
   } Else
   {
      If (SLDtypeLoaded=3 && thisStringFilter)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterWhat=3)
            2ndColumn := "imgfile"
         finalFilteru := "SQL:query:WHERE " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else If thisStringFilter
         finalFilteru := "\>" thisStringFilter
   }

   newFilter := Trimmer(finalFilteru)
   newFilter := StrReplace(newFilter, "||", "|")
   newFilter := Trimmer(newFilter, "|")
   If (userFilterProperty=19)
      newFilter := (SLDtypeLoaded=3) ? "SQL:query:||Prev-Files-Selection||" : "||Prev-Files-Selection||"
   Else If (userFilterProperty=20)
      newFilter := "||Already-Seen-Images||"

   If (dummy!="external")
      GuiControl, SettingsGUIA:, InternalFilterString, % newFilter

   Return newFilter
}

BtnApplyFilesFilter() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UsrEditFilter
   GuiControlGet, userFilterInvertThis
   newFilter := updateUIFiltersPanel()
   Gui, SettingsGUIA: Submit, NoHide
   If !newFilter
   {
      SoundBeep , 300, 100
      showTOOLtip("WARNING: No filter has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (userFilterProperty=19)
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         msgBoxWrapper(appTitle ": WARNING", "You currently have no selected image in the files list. The filter is therefore inapplicable.", 0, 0, "warning")
         Return
      } Else userFilterDoString := 0
   } Else If (userFilterProperty=20)
   {
      BtnCloseWindow()
      userFilterDoString := 0
      retrieveAlreadySeenImageFromCurrentList()
      Return
   }

   BtnCloseWindow()
   If askAboutFileSave(" and the files list will be renewed based on the provided filter criteria")
   {
      UsrEditFilter := ""
      Return
   }

   If (userFilterDoString=1 && UsrEditFilter)
      RecentFiltersManager(UsrEditFilter)

   coreEnableFiltru(newFilter)
   dummyTimerDelayiedImageDisplay(50)
}

RecentFiltersManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFiltersEntries()
  If (StrLen(entry2add)<3 || InStr(entry2add, "{ no filter }"))
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>20)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentFilters, E%countItemz%
  }
}

msgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, checkBoxuCaption:="", checkState:=0, dropListu:="",edithu:="", edithuDef:="", listEditMode:=0, setWidth:=0, 2ndDropListu:=0, 2ndlistEditMode:=0) {
    Static msgBoxed := 0
    If (msgBoxed=1 && MsgBox2hwnd)
       Return

    msgBoxed := 1
    SetTimer, dummyUnSuspendu, Delete
    doSuspendu(1)
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", iconz)

    panelMode := 0
    fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 0
    hwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
    If (InStr(winTitle, "panelu|") && AnyWindowOpen>0 && isNowFakeWinOpen=1)
    {
       winTitle := StrReplace(winTitle, "panelu|")
       panelMode := 1
       hwnd := PVhwnd
    } Else DestroyTempBtnGui("now")

    zr := MsgBox2(msg, winTitle, buttonz, defaultBTN, iconz, nullFnt, PrefsLargeFonts, fontSize, hwnd, hwnd, checkBoxuCaption, checkState, dropListu, edithu, edithuDef, listEditMode, setWidth, 2nddropListu, 2ndlistEditMode)
    r := zr.btn

    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    If (buttonz!=-1)
       addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
    Else
       addJournalEntry("HELP BOX CLOSED: " winTitle)

    If (panelMode=1) ; fake window panel
    {
       AnyWindowOpen := isNowFakeWinOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    }

    lastLongOperationAbort := A_TickCount
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", "normal")

    SetTimer, dummyUnSuspendu, -200, 900
    msgBoxed := 0
    Return (checkBoxuCaption || dropListu || edithu) ? zr : r
}

simpleMsgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, modality:=0, optionz:=0) {
   ; Buttonz options:
   ; 0 = OK (that is, only an OK button is displayed)
   ; 1 = OK/Cancel
   ; 2 = Abort/Retry/Ignore
   ; 3 - Yes/No/Cancel
   ; 4 = Yes/No
   ; 5 = Retry/Cancel
   ; 6 = Cancel/Try Again/Continue

   ; Iconz options:
   ; 16 = Icon Hand (stop/error)
   ; 32 = Icon Question
   ; 48 = Icon Exclamation
   ; 64 = Icon Asterisk (info)

   ; Modality options:
   ; 4096 = System Modal (always on top)
   ; 8192 = Task Modal
   ; 262144 = Always-on-top (style WS_EX_TOPMOST - like System Modal but omits title bar icon)

   If AnyWindowOpen
   {
      If (defaultBTN=2)
         defaultBTN := 255
      Else If (defaultBTN=3)
         defaultBTN := 512
      Else
         defaultBTN := 0
 
      If (iconz=1 || iconz="hand" || iconz="error" || iconz="stop")
         iconz := 16
      Else If (iconz=2 || iconz="question")
         iconz := 32
      Else If (iconz=3 || iconz="exclamation")
         iconz := 48
      Else If (iconz=4 || iconz="info")
         iconz := 64
      Else
         iconz := 0
 
      theseOptionz := buttonz + iconz + defaultBTN + modality
      If optionz
         theseOptionz := optionz
 
      Gui, SettingsGUIA: +OwnDialogs
      MsgBox, % theseOptionz, % winTitle, % msg
      IfMsgBox, Yes
           r := "Yes"
      IfMsgBox, No
           r := "No"
      IfMsgBox, OK
           r := "OK"
      IfMsgBox, Cancel
           r := "Cancel"
      IfMsgBox, Abort
           r := "Abort"
      IfMsgBox, Ignore
           r := "Ignore"
      IfMsgBox, Retry
           r := "Retry"
      IfMsgBox, Continue
           r := "Continue"
      IfMsgBox, TryAgain
           r := "TryAgain"
   } Else r := interfaceThread.ahkFunction("msgBoxWrapper", winTitle, msg, buttonz, defaultBTN, iconz, modality, optionz)

   ; addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
   ; lastLongOperationAbort := A_TickCount
   Return r
}

coreEnableFiltru(stringu, noStringProcessing:=0) {
  If (stringu="\>")
     stringu := filesFilter := ""

  prevFilter := filesFilter
  backCurrentSLD := CurrentSLD
  userSearchString := CurrentSLD := ""
  friendly := (StrLen(stringu)>1) ? "Applying filter on the list of files, please wait`n" stringu : "Deactivating the files list filter, please wait..."
  showTOOLtip(friendly)
  setImageLoading()

  If StrLen(filesFilter)<2
  {
     thereWasFilter := 0
     bckpResultedFilesList := []
     bckpResultedFilesList := resultedFilesList.Clone()
     bckpCurrentFileIndex := currentFileIndex
     bckpMaxFilesIndex := maxFilesIndex
  } Else thereWasFilter := 1

  If (stringu="||Already-Seen-Images||")
  {
     CurrentSLD := backCurrentSLD
     retrieveAlreadySeenImageFromCurrentList()
     Return
  }

  If (noStringProcessing=0)
  {
     testRegEx := SubStr(stringu, 1, 2)
     If (InStr(stringu, "QPV::query") || InStr(stringu, "SQL:query"))
        filesFilter := stringu
     Else If (testRegEx!="\>")
        filesFilter := JEE_StrRegExLiteral(stringu)
     Else
        filesFilter := SubStr(stringu, 3)
  } Else filesFilter := stringu

  FilterFilesIndex(thereWasFilter, doExactFolderMatch, prevFilter)
  If (maxFilesIndex<1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "No files matched your filtering criteria:`n" stringu "`n`nQPV will now restore the complete list of files.", 0, 1, "exclamation")
     filesFilter := ""
     FilterFilesIndex(0, 0, 0)
  } Else SoundBeep, 900, 100

  CurrentSLD := backCurrentSLD
  If !filesFilter
  {
     ; ToolTip, haha , , , 2
     currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
     If (maxFilesIndex>0 && doRandom=1)
        dummyTimerDelayiedImageDisplay(50)
  } Else If (maxFilesIndex>0 && doRandom=1)
  {
     ; SoundBeep 1200, 100
     currentFileIndex := 1
     dummyTimerDelayiedImageDisplay(50)
     ; RandomPicture()
  }

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

FilterFilesIndex(thereWasFilter:=0, doExactFolderMatch:=0, prevFilter:="") {
   If (InStr(prevFilter, "SQL:query:") && !InStr(filesFilter, "SQL:query:"))
   {
      BtnIndexStatsToList(0, 0, "none", 0) 
      If StrLen(filesFilter)<2
         Return
   }

   startZeit := A_TickCount
   selectedFiles := newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   mustDoQuery := 0
   If InStr(filesFilter, "QPV::query::")
   {
      queryObj := StrSplit(filesFilter, "::")
      queryType := queryObj[3]
      If (queryObj[5]="")
         queryObj[5] := queryObj[4]

      If (queryType="imgpixfmt" && queryObj[4])
      {
         queryMin := queryMax := queryObj[4]
         mustDoQuery := 1
      } Else If (queryType && !isNumber(queryType) && isNumber(queryObj[4]) && isNumber(queryObj[5]))
      {
         queryMin := min(Abs(queryObj[4]), Abs(queryObj[5]))
         queryMax := max(Abs(queryObj[4]), Abs(queryObj[5]))
         mustDoQuery := 1
      }

      queryString := Trimmer(queryObj[6])
      userFilterDoString := StrLen(queryString)>0 ? 1 : 0
      If (userFilterDoString!=1)
         queryString := 0

      If (mustDoQuery=1)
      {
         If RegExMatch(queryType, "i)(fsize|fmodified|fcreated)")
            r := collectFileInfosNow(queryString)
         Else If RegExMatch(queryType, "i)(imgpixfmt|imgwidth|imgheight|imgwhratio|imgmegapix|imgframes|imgdpi)")
            r := collectImageInfosNow(queryString, 9, 0)
         Else If RegExMatch(queryType, "i)(imgavg|imgmedian|imghpeak|imghlow|imghminu|imghmode|imghrms|imghrange)")
            r := collectImageInfosNow(queryString, 11, 0)

         If (r=1)
         {
            resultedFilesList := []
            resultedFilesList := bckpResultedFilesList.Clone()
            bckpResultedFilesList := []
            filesFilter := ""
            SoundBeep, 300, 100
            showTOOLtip("Operation abandoned. The files list was not filtered, because data collection did not complete.")
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }
      ; ToolTip, % queryType "=" queryMin "=" queryMax , , , 2
   }

   ; ToolTip, % filesFilter " = " userFilterWhat " = " userFilterStringIsNot , , , 2
   If (InStr(filesFilter, "SQL:query:WHERE") && SLDtypeLoaded=3)
   {
      If isInRange(userFilterProperty, 2, 4)
         collectSQLFileInfosNow("fsize", 0, 1, 0)
      Else If isInRange(userFilterProperty, 5, 10)
         collectSQLFileInfosNow("imgmegapix", 0, 1, 0)
      Else If isInRange(userFilterProperty, 11, 18)
         collectSQLFileInfosNow("imgmedian", 0, 1, 0)

      markedSelectFile := 0
      filteredMap2mainList := []
      extraFilter := extractSQLqueryFromFilter()
      r := BtnIndexStatsToList(0, extraFilter, "custom", extraFilter)
      If (r=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": WARNING", "No files matched the provided filter options:`n" filesFilter "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
         remFilesListFilter("simple")
      } Else bckpResultedFilesList := []
      Return
   } Else If InStr(filesFilter, "||Prev-Files-Selection||")
   {
      Loop, % maxFilesIndex + 1
      {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If (resultedFilesList[A_Index, 2]!=1) ; is selected ?
               Continue

            newFilesIndex++
            newFilesList[newFilesIndex] := resultedFilesList[A_Index]
            If resultedFilesList[A_Index, 2]
               selectedFiles++

            If (thereWasFilter=1)
            {
               oldIndex := filteredMap2mainList[A_Index]
               newMappingList[newFilesIndex] := oldIndex
            } Else newMappingList[newFilesIndex] := A_Index
      }
   } Else
   {
      isStrFilter := StrLen(filesFilter)>1 ? 1 : 0
      Loop, % bckpMaxFilesIndex + 1
      {
            r := bckpResultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            thisIndex++
            If (mustDoQuery=1)
            {
               If (userFilterDoString=1)
               {
                  If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
                     Continue
               }

               Switch queryType
               {
                  Case "fmodified":
                     valu := bckpResultedFilesList[A_Index, 7]
                  Case "fcreated":
                     valu := bckpResultedFilesList[A_Index, 8]
                  Case "fsize":
                     valu := bckpResultedFilesList[A_Index, 6]
                  Case "imgmegapix":
                     valu := Round(bckpResultedFilesList[A_Index, 17], 1)
                  Case "imgwidth":
                     valu := bckpResultedFilesList[A_Index, 13]
                  Case "imgheight":
                     valu := bckpResultedFilesList[A_Index, 14]
                  Case "imgpixfmt":
                     valu := bckpResultedFilesList[A_Index, 15]
                  Case "imgdpi":
                     valu := bckpResultedFilesList[A_Index, 22]
                  Case "imgframes":
                     valu := bckpResultedFilesList[A_Index, 9]
                  Case "imgwhratio":
                     valu := Round(bckpResultedFilesList[A_Index, 16], 1)
                  Case "imgmedian":
                     valu := bckpResultedFilesList[A_Index, 19]
                  Case "imgavg":
                     valu := bckpResultedFilesList[A_Index, 18]
                  Case "imghpeak":
                     valu := bckpResultedFilesList[A_Index, 20]
                  Case "imghlow":
                     valu := bckpResultedFilesList[A_Index, 21]
                  Case "imghrms":
                     valu := bckpResultedFilesList[A_Index, 24]
                  Case "imghrange":
                     valu := bckpResultedFilesList[A_Index, 25]
                  Case "imghmode":
                     valu := bckpResultedFilesList[A_Index, 26]
                  Case "imghminu":
                     valu := bckpResultedFilesList[A_Index, 27]
               }

               zuza := isInRange(valu, queryMin, queryMax)
               If (userFilterInvertThis=1)
                  zuza := !zuza

               If !zuza
                  Continue
            } Else If (isStrFilter=1)
            {
               If !coreSearchIndex(r, filesFilter, userFilterWhat, userFilterStringIsNot)
                  Continue
            }

            newFilesIndex++
            newFilesList[newFilesIndex] := bckpResultedFilesList[A_Index]
            If bckpResultedFilesList[A_Index, 2]
               selectedFiles++

            If (isStrFilter=1)
               newMappingList[newFilesIndex] := A_Index
      }
   }

   filteredMap2mainList := []
   renewCurrentFilesList()
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   resultedFilesList := newFilesList.Clone()
   markedSelectFile := selectedFiles
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
   GenerateRandyList()
}

throwMSGwriteError() {
  Static lastInvoked := 1
  If (ErrorLevel=1) && (A_TickCount - lastInvoked>45100)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the settings files: permission denied.", 0, 0, "error")
     lastInvoked := A_TickCount
  }
}

updateMainUnfilteredList(indexu, indexProperty, value) {
   If (SLDtypeLoaded=3 && hasHamDistCached!=1)
   {
      If InStr(filesFilter, "SQL:query:")
         Return
   }

   If StrLen(filesFilter)>1
      bckpResultedFilesList[filteredMap2mainList[indexu], indexProperty] := value
}

singleInListEntriesRemover() {
   InListMultiEntriesRemover("single")
}

InListMultiEntriesRemover(dummy:=0, dontAsk:=0) {
   filesElected := getSelectedFiles(0, 1)
   If (markedSelectFile>1)
      itMultiFiles := 1

   If (itMultiFiles!=1 || dummy="single")
   {
      remCurrentEntry(0)
      Return
   }

   If (filesElected>500 && dontAsk!="y")
   {
      msgResult := msgBoxWrapper(appTitle, "Are you sure you want to remove " groupDigits(filesElected) " entries from the slideshow files list?", 4, 0, "question")
      If (msgResult!="yes")
         Return
   }

   startOperation := A_TickCount
   showTOOLtip("Removing " groupDigits(filesElected) " index entries, please wait")
   prevMSGdisplay := A_TickCount
   ForceRefreshNowThumbsList()
   countTFilez := 0
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   updateMainu := (StrLen(filesFilter)>1 && (!InStr(filesFilter, "SQL:query:") || hasHamDistCached=1)) ? 1 : 0
   Loop, % maxFilesIndex + 1
   {
      thisFileIndex := A_Index ; - countTFilez
      isSelected := resultedFilesList[thisFileIndex, 2]
      imgPath := resultedFilesList[thisFileIndex, 1]
      If (preventDeleteMatchingSearch=1 && imgPath && userSearchString)
      {
         If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
            isSelected := 0
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(imgPath, protectedFolderPath "\") ? protectedFolderPath : 0
         Else
            zPlitPath(imgPath, 0, OutFileName, OutDir)

         If (protectedFolderPath=OutDir)
            isSelected := 0
      }

      If (isSelected!=1 && imgPath)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := resultedFilesList[thisFileIndex]
         If (updateMainu=1)
            newMappingList[newFilesIndex] := filteredMap2mainList[thisFileIndex]

         Continue
      } Else If !imgPath
         Continue

      If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
         deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[thisFileIndex, 12])

      countTFilez++
      If (updateMainu=1)
         updateMainUnfilteredList(thisFileIndex, 1, "")

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If !startPoint
         startPoint := thisFileIndex
   }

   resultedFilesList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   filteredMap2mainList := []
   If (updateMainu=1)
      filteredMap2mainList := newMappingList.Clone()

   newMappingList := []
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   } Else currentFilesListModified := 1

   GenerateRandyList()
   getSelectedFiles(0, 1)
   zeitOperation := A_TickCount - startOperation
   etaTime := "Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countTFilez " index entries were removed until now`n" etaTime)
   Else
      showTOOLtip(countTFilez " index entries removed`n" etaTime)

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         changeMcursor()
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
      } Else handleEmptyFilesList(CurrentSLD)
   } Else
   {
      startPoint--
      If (startPoint<2)
         startPoint := 1
      currentFileIndex := startPoint
      dummyTimerDelayiedImageDisplay(50)
   }

   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

remCurrentEntry(silentus:=0, whichIndex:=0) {
   Critical, on
   thisFileIndex := !whichIndex ? currentFileIndex : whichIndex
   If (!thisFileIndex || thisFileIndex<0)
      Return

   imgPath := resultedFilesList[thisFileIndex, 1]
   dbIndex := resultedFilesList[thisFileIndex, 12]
   file2remZ := resultedFilesList.RemoveAt(thisFileIndex)
   ; file2remA := file2remZ[1]
   If StrLen(filesFilter)>1
   {
      ; oldIndex :=  filteredMap2mainList[thisFileIndex]
      updateMainUnfilteredList(thisFileIndex, 1, "")
      file2remC := filteredMap2mainList.RemoveAt(thisFileIndex)
      ; file2remB := bckpResultedFilesList[oldIndex, 1]
      ; Sleep, 200
      ; ToolTip, % file2remC " b " oldIndex " a " file2remB "`n" file2remA, , , 2
   }

   If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
      deleteSQLdbEntry(StrReplace(imgPath, "||"), dbIndex)

   maxFilesIndex--
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (silentus!=1)
   {
      If (thumbsDisplaying!=1)
         Sleep, 50

      zPlitPath(StrReplace(imgPath, "||"), 1, OutFileName, OutDir)
      showDelayedTooltip("Index entry removed: " groupDigits(thisFileIndex) "`n" OutFileName "`n" OutDir "\", 0, 250)
   }

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
         ; RandomPicture()
      } Else handleEmptyFilesList(CurrentSLD)
   } Else 
   {
      currentFileIndex--
      NextPicture()
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

addSQLdbEntry(fileNamu, imgPath, fileSizu, fileMdate, fileCdate, simple:=0, factCheck:=1) {
   Static prevIDu := 0
   fileMdate := SubStr(fileMdate, 1, 12)
   fileCdate := SubStr(fileCdate, 1, 12)
   If (simple=1)
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
   Else
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "', '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"

      ; ToolTip, % activeSQLdb.ErrorMsg " === " sqlDBrowID , , , 2
   If !activeSQLdb.Exec(SQLStr)
   {
      If InStr(activeSQLdb.ErrorMsg, "constraint failed")
         Return "err"

      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      If (simple=1)
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ") ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
      Else
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ", '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
 
      If !activeSQLdb.Exec(SQLStr)
         Return "err"
   }

   If (factCheck=1)
   {
      activeSQLdb.LastInsertRowID(alolu)
      thisIDu := alolu CurrentSLD
      ; ToolTip, % prevIDu "==" thisIDu "==" sqlDBrowID , , , 2
      If (thisIDu!=prevIDu && alolu)
      {
         prevIDu := thisIDu
         sqlDBrowID++
      } Else Return "err"
   } Else sqlDBrowID++
}

updateSQLdbEntryImgRes(fullPath, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (imgResu=1)
      thisPart := " imgpixfmt='" resultedFilesList[indexu, 15] "', imgframes='" resultedFilesList[indexu, 9] "', imgdpi='" resultedFilesList[indexu, 22] "', imgwidth='" resultedFilesList[indexu, 13] "', imgheight='" resultedFilesList[indexu, 14] "'"
   Else If (imgResu=2)
      thisPart := " imgpixfmt='" bckpResultedFilesList[indexu, 15] "', imgframes='" bckpResultedFilesList[indexu, 9] "', imgdpi='" bckpResultedFilesList[indexu, 22] "', imgwidth='" bckpResultedFilesList[indexu, 13] "', imgheight='" bckpResultedFilesList[indexu, 14] "'"
   Else
      thisPart := " imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.w "', imgheight='" imgResu.h "'"

   If (fileInfos=1)
      thisPart .= ", fsize='" resultedFilesList[indexu, 6] "', fmodified='" SubStr(resultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(resultedFilesList[indexu, 8], 1, 12) "'"
   Else If (fileInfos=2)
      thisPart .= ", fsize='" bckpResultedFilesList[indexu, 6] "', fmodified='" SubStr(bckpResultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(bckpResultedFilesList[indexu, 8], 1, 12) "'"
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryFileInfos(fullPath, fileInfos, dbIndex) {
   thisPart := " fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"
   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)
   Return 1
}

updateSQLdbEntryImgHisto(fullPath, obju, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (obju=1)
      thisPart := " imgmedian='" resultedFilesList[indexu, 19] "', imgavg='" resultedFilesList[indexu, 18] "', imghpeak='" resultedFilesList[indexu, 20] "', imghlow='" resultedFilesList[indexu, 21] "', imghrms='" resultedFilesList[indexu, 24] "', imghrange='" resultedFilesList[indexu, 25] "',  imghmode='" resultedFilesList[indexu, 26] "', imghminu='" resultedFilesList[indexu, 27] "', outerpixelz='" resultedFilesList[indexu, 29] "', entireHush='" resultedFilesList[indexu, 30] "', innerpixelz='" resultedFilesList[indexu, 28] "'"
   Else If (obju=2)
      thisPart := " imgmedian='" bckpResultedFilesList[indexu, 19] "', imgavg='" bckpResultedFilesList[indexu, 18] "', imghpeak='" bckpResultedFilesList[indexu, 20] "', imghlow='" bckpResultedFilesList[indexu, 21] "', imghrms='" bckpResultedFilesList[indexu, 24] "', imghrange='" bckpResultedFilesList[indexu, 25] "',  imghmode='" bckpResultedFilesList[indexu, 26] "', imghminu='" bckpResultedFilesList[indexu, 27] "', outerpixelz='" bckpResultedFilesList[indexu, 29] "', entireHush='" bckpResultedFilesList[indexu, 30] "', innerpixelz='" bckpResultedFilesList[indexu, 28] "'"
   Else
      thisPart := " imgmedian='" obju.median "', imgavg='" obju.avg "', imghpeak='" obju.peak "', imghlow='" obju.low "', imghrms='" obju.rms "', imghrange='" obju.range "',  imghmode='" obju.mode "', imghminu='" obju.minu "', outerpixelz='" obju.outerpixelz "', entireHush='" obju.entireH "', innerpixelz='" obju.innerpixelz "'"

   If (imgResu=1)
      thisPart .= ", imgpixfmt='" resultedFilesList[indexu, 15] "', imgframes='" resultedFilesList[indexu, 9] "', imgdpi='" resultedFilesList[indexu, 22] "', imgwidth='" resultedFilesList[indexu, 13] "', imgheight='" resultedFilesList[indexu, 14] "'"
   Else If (imgResu=2)
      thisPart .= ", imgpixfmt='" bckpResultedFilesList[indexu, 15] "', imgframes='" bckpResultedFilesList[indexu, 9] "', imgdpi='" bckpResultedFilesList[indexu, 22] "', imgwidth='" bckpResultedFilesList[indexu, 13] "', imgheight='" bckpResultedFilesList[indexu, 14] "'"
   Else If IsObject(imgResu)
      thisPart .= ", imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.W "', imgheight='" imgResu.H "'"

   If (fileInfos=1)
      thisPart .= ", fsize='" resultedFilesList[indexu, 6] "', fmodified='" SubStr(resultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(resultedFilesList[indexu, 8], 1, 12) "'"
   Else If (fileInfos=2)
      thisPart .= ", fsize='" bckpResultedFilesList[indexu, 6] "', fmodified='" SubStr(bckpResultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(bckpResultedFilesList[indexu, 8], 1, 12) "'"
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryCaption(imgPath, txtData, whatSet) {
   activeSQLdb.EscapeStr(imgPath)
   activeSQLdb.EscapeStr(txtData)
   SQLstr := "INSERT INTO imagesData (imgfile) VALUES (" imgPath ");"
   activeSQLdb.Exec(SQLStr)
   SQLstr := "UPDATE imagesData SET " whatSet "=" txtData " WHERE imgfile=" imgPath ";"
   If !activeSQLdb.Exec(SQLStr)
      Return -1
}

retrieveSQLdbEntryCaption(imgPath, whatRetrieve) {
  If (SLDtypeLoaded!=3)
     Return

  RecordSet := ""
  activeSQLdb.EscapeStr(imgPath)
  SQL := "SELECT " whatRetrieve " FROM imagesData WHERE imgfile=" imgPath ";"
  If !activeSQLdb.GetTable(SQL, RecordSet)
     Return

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      entries .= Rowu[1] A_Space
  }

  RecordSet.Free()
  Return Trimmer(entries)
}

retrieveSQLdbEntryImgInfos(fullPath, imgIndex, dbIndex, modus) {
   Critical, on
   If (SLDtypeLoaded!=3)
      Return 0

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQL := "SELECT imgwidth, imgheight, imgframes, imgpixfmt, imgmedian, imgavg, imghpeak, imghlow, imgdpi FROM images" wherePart
   yay := RecordSet := ""

   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      fnOutputDebug(A_ThisFunc "() - failed query in database: " fullPath)
      Return 0
   }
   ; ToolTip, % "l= " RecordSet.RowCount , , , 2
   If !RecordSet.RowCount
      Return 0

   Loop, % RecordSet.RowCount
   {
     Rowu := RecordSet.Rows[A_Index]
     If (Rowu[5] || Rowu[6] || Rowu[7])
     {
        countLoops++
        resultedFilesList[imgIndex, 19] := Rowu[5]
        resultedFilesList[imgIndex, 18] := Rowu[6]
        resultedFilesList[imgIndex, 20] := Rowu[7]
        resultedFilesList[imgIndex, 21] := Rowu[8]
     }

     ; ToolTip, % Row[1] " = " Row[5] , , , 2
     If (Rowu[1] && Rowu[2])
     {
        countLoops++
        resultedFilesList[imgIndex, 13] := Rowu[1]
        resultedFilesList[imgIndex, 14] := Rowu[2]
        resultedFilesList[imgIndex, 15] := Rowu[4]
        resultedFilesList[imgIndex, 9] := Rowu[3]
        resultedFilesList[imgIndex, 22] := Rowu[9]
     }
   }

  RecordSet.Free()
  If !countLoops
     fnOutputDebug(A_ThisFunc "() - no cache in database: " fullPath)

  Return yay
}

updateSQLdbEntry(oldEntry, newEntry, updateDates, dbIndex) {
   If (updateDates=1)
      obju := GetFileAttributesEx(newEntry)

   If !dbIndex
      activeSQLdb.EscapeStr(oldEntry)

   zPlitPath(newEntry, 1, newFileName, newFilePath)
   extra := (updateDates=1) ? ", fmodified=" SubStr(obju.wTime, 1, 12) ", fcreated=" SubStr(obju.cTime, 1, 12) ", fsize=" obju.size : ""
   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" oldEntry ";"
   SQLstr := "UPDATE images SET isDeleted=0, imgfile='" SQLescapeStr(newFileName) "', imgfolder='" SQLescapeStr(newFilePath) "'" extra wherePart
   If !activeSQLdb.Exec(SQLstr)
   {
      zPlitPath(oldEntry, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      activeSQLdb.EscapeStr(newFileName)
      activeSQLdb.EscapeStr(newFilePath)
      SQLstr := "UPDATE images SET isDeleted=0, imgfile=" newFileName ", imgfolder=" newFilePath extra " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
         Return 0
   }
   Return 1
}

SQLdeleteEntriesMarked() {
    If (SLDtypeLoaded!=3)
       Return

    SQLstr := "DELETE FROM images WHERE isDeleted=1;"
    If !activeSQLdb.Exec(SQLStr)
       throwSQLqueryDBerror(A_ThisFunc)
    Else
       getMaxRowIDsqlDB()
}

deleteSQLdbEntry(fullPath, dbIndex) {
  If !dbIndex
     activeSQLdb.EscapeStr(fullPath)

  wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
  SQLstr := "DELETE FROM images" wherePart
  If !activeSQLdb.Exec(SQLStr)
  {
     zPlitPath(fullPath, 1, fileNamu, imgPath)
     activeSQLdb.EscapeStr(fileNamu)
     activeSQLdb.EscapeStr(imgPath)
     SQLstr := "DELETE FROM images WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
     activeSQLdb.Exec(SQLStr)
  }
}

openFileDialogWrapper(p_Type, optionz, startPath, msg, pattern, ByRef n_FilterIndex:="", chooseFilterIndex:=1, defaultEditField:="") {
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen) ? hSetWinGui : PVhwnd
   ; If (p_type="o")
   ;    pattern .= "|All files (*.*)"

   If FolderExist(startPath)
      pathSymbol := "\"

   If !chooseFilterIndex
      chooseFilterIndex := 1

   optionz .= " NoChangeDir HideReadOnly"
   If InStr(p_type, "o")
   {
      entriesList := defaultu "`n" recentOpenedFolders()
      If (p_type="o1")
      {
         thisCombo := "Open selected file only"
         thisCombo .= "`nOpen in a new QPV instance"
         thisCombo .= "`nIndex all images in current folder as well"
         thisCombo .= "`nPerform recursive folder(s) scan to index images"
         thisGroup := "Open mode"
      }

      FileMustExist := InStr(optionz, "FileMustExist") ? 1 : 0
      zr := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, thisCombo, 1, thisGroup, entriesList, 0, pattern, chooseFilterIndex, FileMustExist, defaultEditField)
      r := zr.SelectedDir
      n_FilterIndex := zr.SelectedCombo
   } Else
   {
      If InStr(p_type, "m")
         p_Type := "o"

      r := Dlg_OpenSaveFile(p_Type, thisHwnd, msg, pattern, chooseFilterIndex, startPath pathSymbol, "", optionz)
      n_FilterIndex := NumGet(optionz, (A_PtrSize=8) ? 44:24,"UInt")
   }
   r := Trimmer(r)
   If StrLen(r)<4
      r := ""

   SetWorkingDir, % mainCompiledPath
   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return r
}

WritePrefsIntoSLD() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   startPath := !CurrentSLD ? prevOpenFolderPath : CurrentSLD
   file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save slideshow settings into file...", "Slideshow plain-text (*.sld)")
   If file2save
   {
      If !RegExMatch(file2save, sldsPattern)
         file2save .= ".sld"

      FileReadLine, firstLine, % file2save, 1
      If InStr(firstLine, "[General]")
      {
         Sleep, 10
         writeSlideSettings(file2save)
      } Else 
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgBoxWrapper(appTitle ": ERROR", "The selected file appears not to have the correct file format.`nPlease select a .SLD file already saved by this application.`n`n" OutFileName, 0, 0, "error")
      }
   }
}

recreateDynaFoldersSQLdbList(saveDynaFolders) {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM dynamicfolders;")
   Loop, Parse, saveDynaFolders, `n
   {
       If StrLen(A_LoopField)>2
          addDynamicFolderSQLdb(Trimmer(A_LoopField), 0, "dynamicfolders")
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

saveSlideSettingsInDB() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM settings;")
   IniSLDBWrite("SLDcacheFilesList", 1)
   IniSLDBWrite("IMGresizingMode", IMGresizingMode)
   IniSLDBWrite("imgFxMode", imgFxMode)
   IniSLDBWrite("SlideHowMode", SlideHowMode)
   IniSLDBWrite("slideShowDelay", slideShowDelay)
   IniSLDBWrite("slidesFXrandomize", slidesFXrandomize)
   IniSLDBWrite("zoomLevel", zoomLevel)
   IniSLDBWrite("vpIMGrotation", vpIMGrotation)
   IniSLDBWrite("doSlidesTransitions", doSlidesTransitions)
   IniSLDBWrite("WindowBgrColor", WindowBgrColor)
   IniSLDBWrite("FlipImgH", FlipImgH)
   IniSLDBWrite("FlipImgV", FlipImgV)
   IniSLDBWrite("usrColorDepth", usrColorDepth)
   IniSLDBWrite("ColorDepthDithering", ColorDepthDithering)
   IniSLDBWrite("lumosAdjust", lumosAdjust)
   IniSLDBWrite("GammosAdjust", GammosAdjust)
   IniSLDBWrite("lumosGrayAdjust", lumosGrayAdjust)
   IniSLDBWrite("GammosGrayAdjust", GammosGrayAdjust)
   IniSLDBWrite("satAdjust", satAdjust)
   IniSLDBWrite("imageAligned", imageAligned)
   IniSLDBWrite("doSatAdjusts", doSatAdjusts)
   IniSLDBWrite("autoAdjustMode", autoAdjustMode)
   IniSLDBWrite("chnRdecalage", chnRdecalage)
   IniSLDBWrite("chnGdecalage", chnGdecalage)
   IniSLDBWrite("chnBdecalage", chnBdecalage)
   IniSLDBWrite("IntensityAlphaChannel", IntensityAlphaChannel)
   IniSLDBWrite("usrAdaptiveThreshold", usrAdaptiveThreshold)
   IniSLDBWrite("TouchScreenMode", TouchScreenMode)
   IniSLDBWrite("skipDeadFiles", skipDeadFiles)
   IniSLDBWrite("isAlwaysOnTop", isAlwaysOnTop)
   IniSLDBWrite("bwDithering", bwDithering)
   IniSLDBWrite("zatAdjust", zatAdjust)
   IniSLDBWrite("hueAdjust", hueAdjust)
   IniSLDBWrite("realGammos", realGammos)
   IniSLDBWrite("imgThreshold", imgThreshold)
   IniSLDBWrite("isTitleBarHidden", isTitleBarHidden)
   IniSLDBWrite("animGIFsSupport", animGIFsSupport)
   IniSLDBWrite("thumbsAratio", thumbsAratio)
   IniSLDBWrite("thumbsZoomLevel", thumbsZoomLevel)
   IniSLDBWrite("easySlideStoppage", easySlideStoppage)
   IniSLDBWrite("appVersion", appVersion)
   IniSLDBWrite("usrTextureBGR", usrTextureBGR)
   IniSLDBWrite("syncSlideShow2Audios", syncSlideShow2Audios)
   IniSLDBWrite("autoPlaySNDs", autoPlaySNDs)
   IniSLDBWrite("mediaSNDvolume", mediaSNDvolume)
   IniSLDBWrite("reverseOrderOnSort", reverseOrderOnSort)
   IniSLDBWrite("borderAroundImage", borderAroundImage)
   IniSLDBWrite("resetImageViewOnChange", resetImageViewOnChange)
   IniSLDBWrite("showImgAnnotations", showImgAnnotations)
   IniSLDBWrite("allowGIFsPlayEntirely", allowGIFsPlayEntirely)
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
   IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

IniSLDBwrite(what, value, whichTable:="settings") {
    SQLstr := "INSERT INTO " whichTable " (paramz, valuez) VALUES ('" what "', '" value "');"
    Return activeSQLdb.Exec(SQLStr)
}

IniSLDBreadAll(givenFilter:="", whichTable:="settings") {
  startOperation := A_TickCount
  SQL := "SELECT paramz, valuez FROM " whichTable ";"
  RecordSet := ""

  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "(): failed to read settings from SQL database")
     Return -1
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If StrLen(Rowu[1])>2
      {
         paramu := Rowu[1]
         valu := Rowu[2]
         If (StrLen(valu)>0 && (MustLoadSLDprefs=1 || paramu=givenFilter))
            %paramu% := valu
      }
  }

  If (isWinXP=1 || minimizeMemUsage=1)
     doSlidesTransitions := 0

  RecordSet.Free()
}

SQLdbGenerateStaticFolders() {
   If (SLDtypeLoaded=2)
   {
      BTNignoreSelFolder("update-all")
      Return
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 5
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   SQL := "SELECT DISTINCT imgfolder FROM images;"
   RecordSet := ""
   FoldersArray := []
   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      SoundBeep, 300, 100
      addJournalEntry("Failed to execute SQL command in order to generate the static folders list from the indexed files.")
      Return
   }

   activeSQLdb.Exec("BEGIN TRANSACTION;")
   Loop, % RecordSet.RowCount
   {
       Rowu := RecordSet.Rows[A_Index]
       thisFolder := Trimmer(Rowu[1])
       If StrLen(thisFolder)>2
          addDynamicFolderSQLdb(thisFolder, 0, "staticfolders")
   }

   RecordSet.Free()
   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

getDynamicFoldersList(fileu:=0) {
   If !fileu
      fileu := RegExMatch(CurrentSLD, sldsPattern) ? CurrentSLD : ""

   listu := (fileu && FileExist(fileu) && InStr(DynamicFoldersList, "|hexists|")) ? coreLoadDynaFolders(fileu) : DynamicFoldersList
   listu := StrReplace(listu, "|hexists|")
   Sort, listu, UD`n
   listu := cleanDynamicFoldersList(listu "`n")
   Return listu
}

SaveDBfilesList(enforceFile:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - database", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 50
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as SQL slideshow database...", "Slideshow database (*.sldb)")
         If (!RegExMatch(file2save, "i)(.\.sldb)$") && file2save)
            file2save .= ".sldb"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else Return

   If !file2save
      Return

   o_SLDtypeLoaded := SLDtypeLoaded
   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 10
   startOperation := A_TickCount
   If ((SLDtypeLoaded=1 || SLDtypeLoaded=2) && file2save)
   {
      activeSQLdb.CloseDB()
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1
         } Else
         {
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }

         If wasErrorB
         {
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied.", 0, 0, "error")
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }
      }

      err := SLDbInitSQLdb(file2save)
      If err
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to create SQL database file. Fatal error. Please choose the plain-text format to save the files list (slideshow).`n`nError details: " err, 0, 0, "error")
         SetTimer, PanelSaveSlideShowu, -200
         Return
      }

      setImageLoading()
      setWindowTitle("Saving SQL files list database, please wait", 1)
      showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into SQL database`n" file2save "`nPlease wait")
      saveDynaFolders := getDynamicFoldersList()
      recreateDynaFoldersSQLdbList(saveDynaFolders)
      saveSlideSettingsInDB()
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      staticFoldersListu := ""
      currentFilesListModified := 0
      If (SLDcacheFilesList=1 && SLDtypeLoaded=2 && ForceRegenStaticFolders!=1)
      {
         populatedStaticFolders := 1
         rawstaticFoldersListu := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
         Loop, % countStaticFolders
         {
             staticFoldersListu .= rawstaticFoldersListu[A_Index, 1] "`n"
             addStaticFolderSQLdb(rawstaticFoldersListu[A_Index, 1], rawstaticFoldersListu[A_Index, 2], 0)
         }
      }

      showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries in the SQL database`n" file2save "`nPlease wait", 0, 0, 3/100)
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      doStartLongOpDance()
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      prevMSGdisplay := A_TickCount
      sqlDBrowID := 1
      failedFiles := 0
      Loop, % maxFilesIndex
      {
         imgPath := resultedFilesList[A_Index, 1]
         zPlitPath(imgPath, 1, OutFileName, OutDir)
         
         ; fileInfos := GetFileAttributesEx(imgPath)
         If (resultedFilesList[A_Index, 6] && resultedFilesList[A_Index, 7])
            z := addSQLdbEntry(OutFileName, OutDir, resultedFilesList[A_Index, 6], resultedFilesList[A_Index, 7], resultedFilesList[A_Index, 8], 0)
         Else
            z := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1, 0)

         If z
            failedFiles++

         resultedFilesList[A_Index, 12] := sqlDBrowID
         If (resultedFilesList[A_Index, 11] && resultedFilesList[A_Index, 13])
         {
            updateSQLdbEntryImgHisto(imgPath, 1, 1, 0, sqlDBrowID, A_Index)
         } Else
         {
            If resultedFilesList[A_Index, 11]
               updateSQLdbEntryImgHisto(imgPath, 1, 0, 0, sqlDBrowID, A_Index)
            If resultedFilesList[A_Index, 13]
               updateSQLdbEntryImgRes(imgPath, 1, 0, sqlDBrowID, A_Index)
         }

         If (A_TickCount - prevMSGdisplay>1500)
         {
            etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
            If failedFiles
               someErrors := "`nFailed to insert " groupDigits(failedFiles) " entries"

            showTOOLtip("Inserting entries into the SQL database`n" file2save someErrors etaTime, 0, 0, A_Index/maxFilesIndex)
            prevMSGdisplay := A_TickCount
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
      If (populatedStaticFolders!=1)
         SQLdbGenerateStaticFolders()

      If (abandonAll!=1)
      {
         getMaxRowIDsqlDB()
         CurrentSLD := file2save
         SLDtypeLoaded := 3
      } Else activeSQLdb.CloseDB()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      dummyTimerDelayiedImageDisplay(50)
      RemoveTooltip()
   } Else If (CurrentSLD=file2save && SLDtypeLoaded=3)
   {
      showTOOLtip("Saving SQL files list database, please wait")
      If (ForceRegenStaticFolders=1 && fileWasGiven=0)
      {
         showTOOLtip("Regenerating static folders index")
         SQLdbGenerateStaticFolders()
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If (CurrentSLD!=file2save && SLDtypeLoaded=3)
   {
      activeSQLdb.CloseDB()
      Sleep, 5
      FileCopy, % CurrentSLD, % file2save, 1
      Sleep, 5
      activeSQLdb := new SQLiteDB
      If !activeSQLdb.OpenDB(file2save)
      {
         showTOOLtip("ERROR: Failed to save the slideshow database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }

      If (ForceRegenStaticFolders=1)
      {
         showTOOLtip("Regenerating static folders index")
         SQLdbGenerateStaticFolders()
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      CurrentSLD := file2save
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   etaTime := "Elapsed time to save the SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

SaveFilesList(enforceFile:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (!CurrentSLD || maxFilesIndex<2)
   {
      showTOOLtip("WARNING: No files presently indexed")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (maxFilesIndex>0)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - plain text", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 50
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as plain-text slideshow...", "Slideshow plain-text (*.sld)")
         If (!RegExMatch(file2save, "i)(.\.sld)$") && file2save)
            file2save .= ".sld"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else
   {
      showTOOLtip("WARNING: Insufficient files added to index")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir)
      If FileExist(file2save)
      {
         If !fileWasGiven
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")

         If (msgResult="Yes" || fileWasGiven=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            If (file2save=CurrentSLD)
            {
               newTmpFile := file2save "-bkcp"
               Try FileMove, %file2save%, %newTmpFile%, 1
               Catch wasErrorA
                     Sleep, 1
            } Else
            {
               Try FileDelete, %file2save%
               Catch wasErrorB
                     Sleep, 1
            }

            If (wasErrorA || wasErrorB)
            {
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
               Return
            }
         } Else Return
      }

      Sleep, 2
      BtnCloseWindow()
      writeSlideSettings(file2save)
      mainFile := FileOpen(file2save, "a", "UTF-16")
      If !IsObject(mainFile)
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to write file in the given location. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         Return
      }

      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      Sleep, 10
      setWindowTitle("Saving files list index, please wait", 1)
      If (SLDcacheFilesList=1)
         showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into`n" file2save "`nPlease wait")
      Else
         showTOOLtip("Saving folders index in`n" file2save "`nPlease wait")

      thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
      ; ToolTip, % thisTmpFile "=" , , , 2

      saveDynaFolders := getDynamicFoldersList(thisTmpFile)
      mainFile.Write("`n[DynamicFolderz]`n")
      Loop, Parse, saveDynaFolders, `n
      {
          fileTest := StrReplace(A_LoopField, "|")
          If !FolderExist(fileTest)
             Continue

          countDynas++
          mainFile.Write("DF" countDynas "=" A_LoopField "`n")
          changeMcursor()
      }

      If (SLDcacheFilesList=0)
         ForceRegenStaticFolders := mustGenerateStaticFolders := 0

      foldersListArray := new hashtable()
      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1) && (SLDcacheFilesList=1)
      {
         ; filesListu .= printLargeStrArray(resultedFilesList, maxFilesIndex + 1, "`n")
         Loop, % maxFilesIndex + 1
         {
              r := getIDimage(A_Index)
              If (InStr(r, "||") || !r)
                 Continue

              changeMcursor()
              zPlitPath(r, 1, irrelevantVar, OutDir)
              foldersListArray[Format("{:L}", OutDir)] := 1
         }
      }

      changeMcursor()
      mainFile.Write("`n[Folders]`n")
      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1) && (SLDcacheFilesList=1)
      {
         ForceRegenStaticFolders := 0
         ; Loop, Parse, foldersList, `n
         For Key, Value in foldersListArray
         {
             If !Key
                Continue

             FileGetTime, dirDate, % Key, M
             mainFile.Write("Fi" A_Index "=" dirDate "*&*" Key "`n")
             changeMcursor()
         }
      } Else If (SLDcacheFilesList=1)
      {
         thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
         arrayList := LoadStaticFoldersCached(thisTmpFile, countStaticFolders, 1)
         Loop, % countStaticFolders
               mainFile.Write("Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n")
      }

      foldersListArray := ""
      mainFile.Write("`n[FilesList]`n")
      If (SLDcacheFilesList=1)
      {
         Loop, % maxFilesIndex
         {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue
            mainFile.Write(r "`n")
         }
      }

      mainFile.Close()
      currentFilesListModified := 0
      SLDtypeLoaded := 2
      FileDelete, % newTmpFile
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      CurrentSLD := file2save
      DynamicFoldersList := "|hexists|"
      mustGenerateStaticFolders := 0
      etaTime := "Elapsed time to save plain-text files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
      addJournalEntry(etaTime)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % wasErrorC ? 300 : 900, 100
      If wasErrorC
         msgBoxWrapper(appTitle ": ERROR", "Errors occured when writing the files list to disk. Permission denied or not enough disk space.", 0, 0, "error")
      dummyTimerDelayiedImageDisplay(50)
   }
}

LoadStaticFoldersCached(fileNamu, ByRef countStaticFolders, asArray:=0) {
    countStaticFolders := 0
    arrayList := []
    If (SLDtypeLoaded=3)
    {
       SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
       If !activeSQLdb.GetTable(SQL, RecordSet)
       {
          throwSQLqueryDBerror(A_ThisFunc)
          Return 0
       }

       newStaticFoldersListCache := []
       hash := new hashtable()
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           z := Format("{:L}", Rowu[1])
           If (StrLen(Rowu[1])>3 && hash[z]!=1)
           {
              hash[z] := 1
              countStaticFolders++
              newStaticFoldersListCache[countStaticFolders] := [Rowu[1], Rowu[2]]
           }
       }

       RecordSet.Free()
       hash := ""
       Return newStaticFoldersListCache.Clone()
    }

    If StrLen(newStaticFoldersListCache[1, 1])>4
    {
       countStaticFolders := newStaticFoldersListCache.Count()
       Return newStaticFoldersListCache.Clone()
    }

    FileRead, tehFileVar, %fileNamu%
    newStaticFoldersListCache := []
    hash := new hashtable()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(Fi[0-9].*\=.{14}\*\&\*[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
       {
          lineArru := StrSplit(line, "*&*")
          folderu := lineArru[2]
          oldDateu := lineArru[1]
          oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
          z := Format("{:L}", folderu)
          If (StrLen(folderu)>3 && StrLen(oldDateu)>3 && hash[z]!=1)
          {
             hash[z] := 1
             countStaticFolders++
             newStaticFoldersListCache[countStaticFolders] := [folderu, oldDateu]
             changeMcursor()
          }
       }
    }
    hash := ""
    changeMcursor("normal")
    Return newStaticFoldersListCache.Clone()
}

determineTerminateOperation() {
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 200)
     Return 0

  lastInvoked := A_TickCount
  theEnd := interfaceThread.ahkgetvar.mustAbandonCurrentOperations
  If theEnd
     lastLongOperationAbort := A_TickCount
  Return theEnd
}

doStartLongOpDance() {
     startLongOperation := A_TickCount
     imageLoading := runningLongOperation := 1
     interfaceThread.ahkassign("mustAbandonCurrentOperations", 0)
     interfaceThread.ahkassign("lastCloseInvoked", 0)
     interfaceThread.ahkassign("imageLoading", 1)
     interfaceThread.ahkassign("runningLongOperation", 1)
     interfaceThread.ahkassign("executingCanceableOperation", A_TickCount)
     interfaceThread.ahkPostFunction("setTaskbarIconState", "anim")
}

cleanDeadFilesList(dummy:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      startOperation := A_TickCount
      friendlyLabel := (dummy="noFilesCheck") ? "Removing duplicate entries" : "Scanning for missing files"
      setWindowTitle(friendlyLabel ", please wait", 1)
      showTOOLtip(friendlyLabel ", please wait")
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      If (InStr(backCurrentSLD, mainCompiledPath "\viewed-images-history-") && !InStr(backCurrentSLD, "-viewed-images-history-current-session"))
         CleanDeadFilesSeenImagesDB("yesu", StrReplace(backCurrentSLD, mainCompiledPath))
      Else If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      countTFilez := deadFiles := newFilesIndex := 0
      newFilesList := []
      newMappingList := []
      hash := new hashtable(maxFilesIndex)
      updateMainu := (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:")) ? 1 : 0
      skipDuplicatesCheck := (SLDtypeLoaded=3) ? 1 : 0
      Loop, % maxFilesIndex
      {
            imgPath := resultedFilesList[A_Index, 1]
            If !imgPath
               Continue

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }

            If (A_TickCount - prevMSGdisplay>1500)
            {
               etaTime := ETAinfos(countTFilez + deadFiles, maxFilesIndex, startOperation)
               thisPath := PathCompact(SubStr(imgPath, 1, InStr(imgPath, "\", 0, 0) - 1), 45)
               showTOOLtip(friendlyLabel ", please wait`n" thisPath etaTime "`nFound " groupDigits(deadFiles) " dead files", 0, 0, (countTFilez+deadFiles)/maxFilesIndex)
               prevMSGdisplay := A_TickCount
            }

            If (skipDuplicatesCheck!=1)
            {
               z := Format("{:L}", imgPath)
               w := hash[z]
            }

            If ((w!=1 || skipDuplicatesCheck=1) && !InStr(imgPath, "||"))
            {
               If (skipDuplicatesCheck!=1 && w!=1)
                  hash[z] := 1

               If (dummy="noFilesCheck")
                  okayu := 1
               Else
                  okayu := (abandonAll=1) ? -2 : FileRexists(imgPath)

               If (okayu=-2 || okayu=1)
               {
                  countTFilez++
                  newFilesList[countTFilez] := resultedFilesList[A_Index]
                  If (updateMainu=1)
                     newMappingList[countTFilez] := filteredMap2mainList[A_Index]
                  Continue
               } Else deadFiles++
            } Else deadFiles++

            If (SLDtypeLoaded=3)
               deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[A_Index, 12])

            If (updateMainu=1)
               updateMainUnfilteredList(A_Index, 1, "")

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }
      }

      hash := ""
      If (abandonAll!=1)
      {
         resultedFilesList := []
         resultedFilesList := newFilesList.Clone()
         maxFilesIndex := countTFilez
         newFilesList := []
         filteredMap2mainList := []
         If (updateMainu=1)
            filteredMap2mainList := newMappingList.Clone()

         newMappingList := []
         GenerateRandyList()
      }

      If (SLDtypeLoaded=3)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            throwSQLqueryDBerror(A_ThisFunc)
      }

      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(deadFiles) " index entries were removed until now" etaTime)
      Else
         showTOOLtip(groupDigits(deadFiles) " index entries removed" etaTime)

      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
      {
         remFilesListFilter("simple")
      } Else If (maxFilesIndex<1 && StrLen(filesFilter)<2)
      {
         handleEmptyFilesList(backCurrentSLD)
         Return
      }

      ForceRefreshNowThumbsList()
      getSelectedFiles(0, 1)
      If deadFiles
         currentFilesListModified := 1
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      CurrentSLD := backCurrentSLD
      currentFileIndex := clampInRange(currentFileIndex, 1, maxFilesIndex)
      dummyTimerDelayiedImageDisplay(50)
      ; RandomPicture()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

handleEmptyFilesList(thisSLD, extraInfo:=""){
   FadeMainWindow()
   SoundBeep, 300, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   showButtons := ((RegExMatch(thisSLD, sldsPattern) && FileExist(thisSLD)) || FolderExist(thisSLD) || InStr(thisSLD, "\QPV\favourite-images-list.SLD")) ? "&Reload current list|&Continue" : 0

   If showButtons
      info := "`n`nCurrent files list:`n" thisSLD

   msgResult := msgBoxWrapper(appTitle ": WARNING", "No files left in the index of " appTitle ", please load a files list or folder." info extraInfo, showButtons, 0, "info")
   If InStr(msgResult, "reload")
   {
      CurrentSLD := thisSLD
      currentFilesListModified := 0
      RefreshFilesList()
   } Else ; If (thumbsDisplaying=1)
   {
      currentFilesListModified := 0
      ; ToggleThumbsMode()
      ; FadeMainWindow()
      closeDocuments()
      ; resetMainWin2Welcome()
   }
}

removeFilesListFavouritedImages() {
   removeFilesListSeenImages("faves")
}

removeFilesListSeenImages(modus:=0) {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   friendlyLabel := (modus="faves") ? "favourite" : "already seen"
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and " friendlyLabel " images will be removed from the files list")
         Return

      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Remove " friendlyLabel " images from index", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be scanned.`n`nTo scan all the image files from the index, deactivcate the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
         Else hasAskedFilter := 1
      }

      remFromDb := 1
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setWindowTitle("Removing " friendlyLabel " images, please wait", 1)
      showTOOLtip("Removing " friendlyLabel " images`nGathering data, please wait")
      setImageLoading()
      If (modus="faves")
         seenEntries := retrieveFavesAsArray(totalSeenIMGs)
      Else
         seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)

      If (totalSeenIMGs<3)
      {
         seenEntries := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         If (SLDtypeLoaded=3)
         {
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
               throwSQLqueryDBerror(A_ThisFunc)
         }
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("Finished removing " friendlyLabel " images`nNo image was removed from the files list" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      showTOOLtip("Removing " friendlyLabel " images, please wait" etaTime)
      doStartLongOpDance()
      newArrayu := []
      newFilesIndex := 0
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for " friendlyLabel " images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If (SLDtypeLoaded=3 && remFromDb=1)
                deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, 1, "")

             countSeen++
             Continue
          }

          newFilesIndex++
          newArrayu[newFilesIndex] := resultedFilesList[A_Index]
          If resultedFilesList[A_Index, 2]
             selectedFiles++

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (!activeSQLdb.Exec("COMMIT TRANSACTION;") && SLDtypeLoaded=3)
         throwSQLqueryDBerror(A_ThisFunc)

      If (abandonAll=1)
      {
         If (SLDtypeLoaded=3)
            showTOOLtip("Operation aborted. " groupDigits(countSeen) " already removed until now from the database.")
         Else
            showTOOLtip("Operation aborted. Files list left unchanged, no index entries removed.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newArrayu := ""
         ; dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (newFilesIndex<1)
      {
         friendly := (modus="faves") ? "All images seem to have been added to favourites." : "It seems all the images were viewed."
         showTOOLtip("WARNING: " friendly "`nTherefore, the files list is left unchanged.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         ; dummyTimerDelayiedImageDisplay(50)
         SetTimer, ResetImgLoadStatus, -150
         Return
      }

      ; renewCurrentFilesList()
      currentFilesListModified := 1
      maxFilesIndex := newFilesIndex
      resultedFilesList := newArrayu.Clone()
      markedSelectFile := selectedFiles
      ForceRefreshNowThumbsList()
      newArrayu := ""
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished removing " friendlyLabel " images`n" groupDigits(countSeen) " images were removed from the files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

retrieveAlreadySeenImageFromCurrentList() {
   ; Critical, on

   If (slideShowRunning=1)
      ToggleSlideShowu()

   initSeenImagesListDB()
   If (sqlFailedInit=1)
   {
      showTOOLtip("ERROR: Failed to initialize the SQL database engine.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   }

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and already seen images will be removed from the files list")
         Return

      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Retrieving already seen images matching entire files list`nPlease wait")
      setImageLoading()
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      If (totalSeenIMGs<2)
      {
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("No records found matching the criteria" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If (StrLen(filesFilter)>1) ; && filesFilter!="||Already-Seen-Images||") I do not know why i had this extra condition...
         remFilesListFilter("simple")

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      newFilesList := []
      countSeen := selectedFiles := newFilesIndex := 0
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for already seen images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          zuza := seenEntries[Format("{:L}", r)]
          If (userFilterInvertThis=1)
             zuza := !zuza

          If (zuza=1)
          {
             newFilesIndex++
             newFilesList[newFilesIndex] := resultedFilesList[A_Index]
             If resultedFilesList[A_Index, 2]
                selectedFiles++
 
             newMappingList[newFilesIndex] := A_Index
             countSeen++
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1 || countSeen<2)
      {

         If (abandonAll=1)
            showTOOLtip("Operation aborted. Files list left unchanged, no filter applied.")
         Else
            showTOOLtip("No seen images identified. Files list left unchanged, no filter applied.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newFilesList := []
         newMappingList := []
         dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      ; renewCurrentFilesList()
      filteredMap2mainList := newMappingList.Clone()
      bckpResultedFilesList := resultedFilesList.Clone()
      resultedFilesList := newFilesList.Clone()
      If !filesFilter
         bckpMaxFilesIndex := maxFilesIndex
      maxFilesIndex := newFilesIndex
      markedSelectFile := selectedFiles
      filesFilter := "||Already-Seen-Images||"
      userFilterProperty := 20
      userFilterDoString := 0
      ForceRefreshNowThumbsList()
      newFilesList := []
      newMappingList := []
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished the identification process of already seen images`n" groupDigits(countSeen) " images were found in the initial files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

extractSQLqueryFromFilter() {
    If InStr(filesFilter, "SQL:query:WHERE")
    {
       extraFilter := StrReplace(filesFilter, "`n", A_Space)
       extraFilter := SubStr(extraFilter, InStr(extraFilter, ":WHERE ") + 1)
       If InStr(extraFilter, " ORDER BY ")
          extraFilter := SubStr(extraFilter, 1, InStr(extraFilter, " ORDER BY "))
       Return extraFilter
    }
}

collectSQLFileInfosNow(scu, modus, asku, doFilterExtra:=1, showInfos:=1) {
   Static noQuestion := 0
   If (asku=1 && noQuestion=1)
   {
      addJournalEntry(A_ThisFunc "(): user chose to never be asked to collect data in this session.")
      Return 0
   }

   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (doFilterExtra=1)
      extraFilter := extractSQLqueryFromFilter()

   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   If showInfos
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait" friendly)

   If RegExMatch(scu, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms|innerpixelz|outerpixelz|pixelzHash)")
      adaptedSortCriteria := 3
   Else If RegExMatch(scu, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      adaptedSortCriteria := 2
   Else If RegExMatch(scu, "i)(fcreated|fmodified|fsize|kbfsize)")
      adaptedSortCriteria := 1
   Else
      adaptedSortCriteria := 0

   failedFiles := failedSQLfiles := 0
   If adaptedSortCriteria
   {
      If !getMaxRowIDsqlDB()
      {
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      thisWhere := extraFilter ? extraFilter " AND " scu " IS NULL;" : "WHERE " scu " IS NULL;"
      SQLstr := "SELECT imgidu, fullPath FROM images " thisWhere
      ; addJournalEntry(SQLstr)
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      failedFiles := countTFilez := 0
      filesToBeSorted := RecordSet.RowCount
      thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
      alreadySorted := thisMaxCount - filesToBeSorted
      If (alreadySorted<5)
         noQuestion := 1

      zEffect := (adaptedSortCriteria=3 && filesToBeSorted>0) ? Gdip_CreateEffect(6, 0, -99, 0) : 0
      If (asku=1 && noQuestion=0 && filesToBeSorted>10)
      {
         thisFriendly := (SLDtypeLoaded=3) ? "`n`nThe data will be automatically cached in the database and you can stop and resume this process at anytime." : ""
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to perform an operation that relies on collected file and image details. " appTitle " needs to scan " groupDigits(filesToBeSorted) " out of " groupDigits(thisMaxCount) " files. By refusing to the collect data, the operation you chose (sort, filter, generate statistics or find duplicates) will likely give incomplete or erroneous results." thisFriendly, "Collect &data now|&Continue with incomplete data", 0, "question", "&Do not collect file data and never ask again in this session", 0)

         If (InStr(msgResult.btn, "incomplete") || msgResult.Check=1)
         {
            noQuestion := msgResult.Check
            CurrentSLD := backCurrentSLD
            SetTimer, RemoveTooltip, % -msgDisplayTime
            SetTimer, ResetImgLoadStatus, -200
            Return 0
         }
      }

      If (filesToBeSorted>0)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      prevMSGdisplay := A_TickCount
      Loop, % RecordSet.RowCount
      {
          Row := RecordSet.Rows[A_Index]
          If Row[2]
          {
             rs := 1
             countTFilez++
             If (adaptedSortCriteria=1)
             {
                If FileExist(Row[2])
                   rs := updateSQLdbEntryFileInfos(Row[2], GetFileAttributesEx(Row[2]), Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=2)
             {
                objul := GetCachableImgFileDetails(Row[2], Row[1], 0, 1)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgRes(Row[2], objul[1], objul[2], Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=3)
             {
                objul := GetCachableHistogramFile(Row[2], Row[1], 0, 1, 1, 0, zEffect)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgHisto(Row[2], objul[1], objul[2], 0, Row[1])
                Else
                   failedFiles++
             }
             If !rs
                failedSQLfiles++
          }

          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             thisPath := PathCompact(SubStr(Row[2], 1, InStr(Row[2], "\", 0, 0) - 1), 45)
             If (failedFiles>0)
                etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
             If (failedSQLfiles>0)
                etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

             showTOOLtip("Gathering files information, please wait`n" thisPath etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      Gdip_DisposeEffect(zEffect)
      RecordSet.Free()
      If (filesToBeSorted>0)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            ErrorMsg := "ERROR: failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
      }
   }

   PopulateIndexFilesStatsInfos("kill")
   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedFiles>0)
      someErrors .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      If (modus=1)
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone "`nFiles list not sorted, because data collection did not complete.")
      Else
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   If (modus!=1 && filesToBeSorted>1)
   {
      showTOOLtip(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)
      SoundBeep 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
   }
   Return 0
}

generateSQLimagesExtraHash() {
   Static noQuestion := 0
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   showTOOLtip("Generating image hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   SQLstr := "SELECT imgidu, innerpixelz||outerpixelz AS hashu FROM images WHERE innerpixelz IS NOT NULL AND pixelzHash IS NULL;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   prevMSGdisplay := A_TickCount
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          rs := 1
          countTFilez++
          arr := StrSplit(Row[2])
          g := ST_Count(Row[2], "0")
          newHash := (g//2)*2
          newHash .= ((64 - g)//2)*2
          If (StrLen(newHash)!=4)
             newHash .= 9

          thisIndex := 0
          Loop, 32
          {
             thisIndex++
             x := arr[thisIndex] + arr[thisIndex+1]
             thisIndex++
             newHash .= x
          }

          SQLstr := "UPDATE images SET pixelzHash='" newHash "' WHERE imgidu=" Row[1] ";"
          If !activeSQLdb.Exec(SQLstr)
             failedSQLfiles++
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip("Generating image hashes, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
   }

   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

TEMPgenerateHush() {
   Static noQuestion := 0
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   showTOOLtip("Generating image hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   SQLstr := "SELECT imgidu, innerpixelz, outerpixelz FROM images WHERE innerpixelz IS NOT NULL;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   prevMSGdisplay := A_TickCount
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          newHash := reorderStoredHashes(Row[2], Row[3])
          ; newHash := ConvertBase(2, 16, newHash)

          countTFilez++
          SQLstr := "UPDATE images SET entireHush='" newHash "' WHERE imgidu=" Row[1] ";"
          If !activeSQLdb.Exec(SQLstr)
             failedSQLfiles++
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip("Generating image hashes, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
   }

   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

BtnCollectFileInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("fsize", 0, 0)
   Else
      collectFileInfosNow()
   PanelWrapperFilesStats()
}

BtnCollectImageInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgmegapix", 0, 0)
   Else
      collectImageInfosNow(0, 9, 1)
   PanelWrapperFilesStats()
}

BtnCollectHistoInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgavg", 0, 0)
   Else
      collectImageInfosNow(0, 11, 1)

   openPreviousPanel()
}

dbSortingCached(SortCriterion) {
   If (maxFilesIndex>0)
   {
      If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
      {
         showTOOLtip("WARNING: Files list sorting not allowed.`nThe files list is comprised of duplicate image pairs filtered by Hamming distance.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If AnyWindowOpen
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be sorted")
         Return

      abandonAll := collectSQLFileInfosNow(SortCriterion, 1, 1)
      If (!getMaxRowIDsqlDB() || abandonAll=1)
      {
         SetTimer, ResetImgLoadStatus, -200
         Return
      }

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      prevFilesSortMode := SortCriterion
      IniSLDBWrite("prevFilesSortMode", SortCriterion)
      setWindowTitle("Sorting files list by " SortCriterion ", please wait", 1)
      If testIsDupesList()
      {
         retrieveDupesByProperties(0, 0, SortCriterion)
         Return
      }

      setImageLoading()
      doStartLongOpDance()
      startOperation := A_TickCount
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      extraFilter := extractSQLqueryFromFilter()
      SQLstr := "SELECT imgidu, fullPath FROM images " extraFilter " ORDER BY " SortCriterion sortMode ";"
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      countTFilez := RecordSet.RowCount
      If !countTFilez
      {
         showTOOLtip("No image records found in the database matching:`n" SQLstr)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      addJournalEntry("Sorting database using query: " SQLstr)
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0
      previmgPath := getIDimage(currentFileIndex)
      If StrLen(filesFilter)>1
         backFilesFilter := filesFilter

      showTOOLtip("Generating sorted files list index")
      renewCurrentFilesList()
      prevMSGdisplay := A_TickCount - 900
      Loop, % RecordSet.RowCount
      {
          Rowu := RecordSet.Rows[A_Index]
          If Rowu[2]
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex, 1] := Rowu[2]
             resultedFilesList[maxFilesIndex, 12] := Rowu[1]
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }
  
      RecordSet.Free()
      ForceRefreshNowThumbsList()
      If extraFilter
         filesFilter := "SQL:query:" extraFilter

      CurrentSLD := backCurrentSLD
      If (StrLen(backfilesFilter)>1 && !extraFilter && !InStr(backFilesFilter, "SQL:query:JOIN"))
         coreEnableFiltru(backFilesFilter, 1)
      Else
         GenerateRandyList()

      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 25
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      IDshowImage(currentFileIndex)
      ; MsgBox, % maxFilesIndex "=" CurrentSLD
  }
  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

ActSortName() {
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder, imgfile")
   Else
      SortFilesList("name-entire")
}

ActSortSize() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fsize")
   Else
      SortFilesList("size")
   etaTime := "Elapsed time to sort files list by file size: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortPath() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder")
   Else
      SortFilesList("name-folder")
   etaTime := "Elapsed time to sort files list by folder name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortDupeGroups() {
   startOperation := A_TickCount
   If testIsDupesList()
      retrieveDupesByProperties(0, 0, 1)

   etaTime := "Elapsed time to sort files list by duplicates image group IDs: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortFileName() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfile")
   Else
      SortFilesList("name-file")
   etaTime := "Elapsed time to sort files list by file name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortModified() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fmodified")
   Else
      SortFilesList("modified")
   etaTime := "Elapsed time to sort files list by file modified date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortCreated() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fcreated")
   Else
      SortFilesList("created")
   etaTime := "Elapsed time to sort files list by file created date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortHistogram(modus) {
   Static listuA := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghrange", 6:"imghmode", 7:"imghminu", 8:"imghrms"}
        , listuB := {1:"avg", 2:"median", 3:"peak", 4:"low", 5:"range", 6:"mode", 7:"minu", 8:"hrms"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("histogram-" listuB[modus])

   etaTime := "Elapsed time to sort files list by histogram mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortImageProperties(modus) {
   Static listuA := {1:"imgmegapix", 2:"imgwidth", 3:"imgheight", 4:"imgwhratio", 5:"imgdpi", 6:"imgframes"}
        , listuB := {1:"resolution", 2:"width", 3:"height", 4:"wh-ratio", 5:"dpi", 6:"frames"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("image-" listuB[modus])

   etaTime := "Elapsed time to sort files list by image properties mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

warnXPhistoSort() {
   If isWinXP
   {
      msgBoxWrapper(appTitle ": ERROR", "There is no support in GDI+ for extracting histogram data from images on your system... Therefore, you cannot sort the images by histogram.", 0, 0, "error")
      Return 1
   }
}

SortFilesList(SortCriterion) {
   ; Critical, on
   Static hasAskedFilter := 0

   If AnyWindowOpen
      BtnCloseWindow()

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and the files list will be sorted")
         Return

      filesToBeSorted := maxFilesIndex
      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Sort operation", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be sorted, not all the files.`n`nTo sort all files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
         Else hasAskedFilter := 1
      }

      startOperation := A_TickCount
      setImageLoading()
      previmgPath := getIDimage(currentFileIndex)
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      setWindowTitle("Sorting files list, please wait", 1)
      backCurrentSLD := CurrentSLD
      CurrentSLD := filterBehaviour := ""
      newIndex :=  := 0
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
      {
         filterBehaviour := 1
         showTOOLtip("Preparing the files list, please wait")
         Loop, %maxFilesIndex%   ; marking index entries to be sorted
             updateMainUnfilteredList(A_Index, 10, 1)

         backfilesFilter := filesFilter
         remFilesListFilter("simple")
         Sleep, 25
         RemoveTooltip()
      }

      newFilesList := []
      prevMSGdisplay := A_TickCount
      adaptedSortCriteria := StrReplace(SortCriterion, "image-")
      adaptedSortCriteria := StrReplace(adaptedSortCriteria, "histogram-")

      sortPages := sortedFiles := 0
      unSortPages := unSortedFiles := 0
      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         activeSQLdb.Exec("BEGIN TRANSACTION;")
         If InStr(SortCriterion, "histogram")
            zEffect := Gdip_CreateEffect(6, 0, -99, 0)
      }

      countTFilez := 0
      ; doFilesCheck := InStr(SortCriterion, "name-") ? 0 : OnSortdoFilesCheck
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          If (filterBehaviour=1 || filterBehaviour=2)
          {
             If !resultedFilesList[A_Index, 10]
             {
                ; building the sorted new files list array; this is the unsorted section
                newIndex++
                newFilesList[newIndex] := resultedFilesList[A_Index]
                Continue
             }
          }

          changeMcursor()
          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             If (failedFiles>0)
                etaTime .= "`nFailed to sort " groupDigits(failedFiles) " files"

             showTOOLtip("Gathering files information, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          If (OnSortdoFilesCheck=1)
          {
             If !FileRexists(r)
             {
                resultedFilesList[A_Index, 10] := 0
                If (SLDtypeLoaded=3)
                   deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

                failedFiles++
                Continue
             }
          }

          If (SortCriterion="size")
          {
             SortBy := QPV_FileGetSizeTime(r, "S", A_Index)
          } Else If (SortCriterion="modified")
          {
             SortBy := QPV_FileGetSizeTime(r, "M", A_Index)
          } Else If (SortCriterion="created")
          {
             SortBy := QPV_FileGetSizeTime(r, "C", A_Index)
          } Else If (SortCriterion="name-folder")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutDir
          } Else If (SortCriterion="name-file")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutFileName
          } Else If (SortCriterion="name-entire")
          {
             SortBy := r
          } Else If InStr(SortCriterion, "image-")
          {
             If !resultedFilesList[A_Index, 9]
                GetCachableImgFileDetails(r, A_Index)

             If resultedFilesList[A_Index, 13]
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgRes(r, 1, 1, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "resolution":
                      SortBy := resultedFilesList[A_Index, 17]
                   Case "width":
                      SortBy := resultedFilesList[A_Index, 13]
                   Case "height":
                      SortBy := resultedFilesList[A_Index, 14]
                   Case "wh-ratio":
                      SortBy := resultedFilesList[A_Index, 16]
                   Case "dpi":
                      SortBy := resultedFilesList[A_Index, 22]
                   Case "frames":
                      SortBy := resultedFilesList[A_Index, 9]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          } Else If InStr(SortCriterion, "histogram")
          {
             If !resultedFilesList[A_Index, 11]
                GetCachableHistogramFile(r, A_Index, 0, 0, 1, 0, zEffect)

             If (resultedFilesList[A_Index, 11])
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgHisto(r, 1, 1, 0, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "median":
                      SortBy := resultedFilesList[A_Index, 19]
                   Case "avg":
                      SortBy := resultedFilesList[A_Index, 18]
                   Case "peak":
                      SortBy := resultedFilesList[A_Index, 20]
                   Case "low":
                      SortBy := resultedFilesList[A_Index, 21]
                   Case "hrms":
                      SortBy := resultedFilesList[A_Index, 24]
                   Case "range":
                      SortBy := resultedFilesList[A_Index, 25]
                   Case "mode":
                      SortBy := resultedFilesList[A_Index, 26]
                   Case "minu":
                      SortBy := resultedFilesList[A_Index, 27]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          sortedFiles++
          filesListu%sortPages% .= SortBy "|!\!|" A_Index "`n"
          If (sortedFiles>3102)
          {
             sortedFiles := 0
             sortPages++
          }
      }

      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         Gdip_DisposeEffect(zEffect)
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            addJournalEntry(A_ThisFunc "() failed to commit transactions to SQL database")
      }

      If (abandonAll=1)
      {
         If errorOccured
            msgInfos := "`nErrors occured. Multi-threading error."
         If (failedFiles && SLDtypeLoaded=3 && OnSortdoFilesCheck=1)
            msgInfos .= "`n" failedFiles " inexistent files were removed from the SQL database index"

         If StrLen(backfilesFilter)>1
         {
            ; rebuilding the filtered files list index, as it was
            thisIndex := 0
            newFilesList := []
            newMappingList := []
            filesFilter := backfilesFilter
            Loop, % maxFilesIndex + 1
            {
               r := resultedFilesList[A_Index, 1]
               If (InStr(r, "||") || !r)
                  Continue

               If resultedFilesList[A_Index, 10]
               {
                  thisIndex++
                  newFilesList[thisIndex] := resultedFilesList[A_Index]
                  newMappingList[thisIndex] := A_Index
                  If resultedFilesList[A_Index, 2]
                     selectedFiles++
               }
            }

            filteredMap2mainList := []
            filteredMap2mainList := newMappingList.Clone()
            newMappingList := []
            bckpResultedFilesList := resultedFilesList.Clone()
            resultedFilesList := newFilesList.Clone()
            newFilesList := []
            bckpMaxFilesIndex := maxFilesIndex
            maxFilesIndex := thisIndex
            markedSelectFile := selectedFiles
         }

         showTOOLtip("Operation aborted. Files list unchanged. " msgInfos)
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         lastLongOperationAbort := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         Return
      }

      showTOOLtip("Preparing gathered data`n" unSortPages " / " sortPages)
      prevMSGdisplay := A_TickCount
      changeMcursor()
      Loop, % sortPages + 1
      {
         thisIndex := A_Index - 1
         entireString .= filesListu%thisIndex%
      }

      showTOOLtip("Sorting gathered data")
      sortMode := (reverseOrderOnSort=1) ? "R" : ""
      If InStr(SortCriterion, "name-")
         Sort, entireString, %sortMode% D`n
      Else
         Sort, entireString, %sortMode% N D`n

      If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Generating sorted files list index")

      2ndnewIndex := 0
      2ndnewFilesList := []
      newMappingList := []
      histoObj := []
      prevMSGdisplay := A_TickCount
      Loop, Parse, entireString,`n,`r
      {
          If !A_LoopField
             Continue

          2ndnewIndex++
          line := StrSplit(A_LoopField, "|!\!|")
          2ndnewFilesList[2ndnewIndex] := resultedFilesList[line[2]]
          If filterBehaviour
          {
             2ndnewFilesList[2ndnewIndex, 10] := 0
             newMappingList[2ndnewIndex] := A_Index
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }

      ; and now build the final files list array with sorted and unsorted sections of the initial array
      finalNewList := []
      Loop, % 2ndnewIndex   ; the sorted section
         finalNewList[A_Index] := 2ndnewFilesList[A_Index]

      If filterBehaviour
      {
         Loop, % newIndex    ; the unsorted section
            finalNewList[A_Index + 2ndnewIndex] := newFilesList[A_Index]

         filteredMap2mainList := newMappingList.Clone()
         bckpResultedFilesList := finalNewList.Clone()
         bckpMaxFilesIndex := newIndex + 2ndnewIndex
      }

      maxFilesIndex := 2ndnewIndex
      resultedFilesList := 2ndnewFilesList.Clone()
      newFilesList := []
      2ndnewFilesList := []
      finalNewList := []
      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
         filesFilter := backfilesFilter

      GenerateRandyList()
      entireString := entireNotSortedString := ""
      currentFilesListModified := 1
      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 5
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
         remFilesListFilter("simple")
      Else If (maxFilesIndex<1)
         handleEmptyFilesList(CurrentSLD)
      Else
         IDshowImage(currentFileIndex)
   }
}

getSelectedFilesListString(maxList, ByRef countTFilez, ByRef filesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  filesListu := []
  selectedFilesArray := []
  showTOOLtip("Preparing workload for multi-threaded processing")

  Loop, % maxFilesIndex
  {
      isSelected := resultedFilesList[A_Index, 2]
      If !isSelected
         Continue

      r := resultedFilesList[A_Index, 1]
      If (InStr(r, "||") || !r)
         Continue

      countTFilez++
      selectedFilesArray[countTFilez] := A_Index "?" r "`n"
  }

  maxList := selectedFilesArray.Count()
  trenchSize := maxList//systemCores
  r := 0
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          realIndex := trenchSize*(thisIndex-1) + A_Index
          line := selectedFilesArray[realIndex]
          If !line
             Continue

          filesListu[thisIndex] .= line
      }
  }

  Loop, % maxList - trenchSize*(systemCores-1)
  {
      realIndex := trenchSize*(systemCores-1) + A_Index
      line := selectedFilesArray[realIndex]
      If !line
         Continue

      filesListu[systemCores] .= line
  }
}

WorkLoadMultiCoresJpegLL(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-jpegll||" jpegDesiredOperation "=" jpegDoCrop "=" relativeImgSelCoords "=" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setForceRefreshThumbsFilesIndex(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }
            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

   Loop, % systemCores
       FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt

   processedFiles := skippedFiles := failedFiles := 0
   Loop, % systemCores
   {
      RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
      filesStatusArr := StrSplit(filesStatus, "/")
      If (filesStatusArr[1]>0)
         processedFiles += filesStatusArr[1]
      If (filesStatusArr[2]>0)
         failedFiles += filesStatusArr[2]
      If (filesStatusArr[3]>0)
         skippedFiles += filesStatusArr[3]
   }

   zeitOperation := A_TickCount - startOperation
   someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
   If (failedFiles>0)
      someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
    
  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. JPEG lossless processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  CurrentSLD := backCurrentSLD
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  Return r
}

testProcessExists(pid) {
   If StrLen(pid)<2
      Return 0

   Process, Exist, % pid
   R := (ErrorLevel=pid) ? 1 : 0
   Return R
}

WorkLoadMultiCoresConvertFormat(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-fmtconv"
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := theseFailures := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  theseFailures += filesStatusArr[3]
               If (filesStatusArr[4]>0)
                  skippedFiles += filesStatusArr[4]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
            If (theseFailures>0)
               etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image file formats conversion, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := theseFailures := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        theseFailures += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  Loop, Parse, theFinalList,`n,`r
  {
       If StrLen(A_LoopField)>2
       {
          lineArr := StrSplit(A_LoopField, "?")
          thisIndex := lineArr[1]
          imgPath := lineArr[2]
          If (imgPath && thisIndex)
             resultedFilesList[thisIndex, 1] := imgPath
       }
  }

  zeitOperation := A_TickCount - startOperation
  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to convert " groupDigits(failedFiles) " files"
  If (theseFailures>0)
     someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image file formats conversion aborted.`n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " markedSelectFile " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were converted to ." rDesireWriteFMT someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

WorkLoadMultiCoresSimpleImgProcessing(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-simpleimgproc||" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2 "=" editingSelectionNow "=" simpleOpRotationAngle
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
         ; sleep, 450
         ; ToolTip, % jobsRunning "//" jobDone "//" threadsCrashed "//" totalEnded , , , 2
         ; ToolTip, % thisThreadStatus " // " isPIDalive , , , 2
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupdigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupdigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Processing image files, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := skippedFiles := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        skippedFiles += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

multiCoresJpegLL(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  jpegOperation := argumentsArray[1]
  mustCrop := argumentsArray[2]
  relativeImgSelCoords := argumentsArray[3]
  imgSelX1 := argumentsArray[4]
  imgSelX2 := argumentsArray[5]
  imgSelY1 := argumentsArray[6]
  imgSelY2 := argumentsArray[7]
  prcSelX1 := argumentsArray[8]
  prcSelX2 := argumentsArray[9]
  prcSelY1 := argumentsArray[10]
  prcSelY2 := argumentsArray[11]
  failedFiles := skippedFiles := countFilez := operationDone := 0
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If !RegExMatch(imgPath, "i)(.\.(jpeg|jpg|jpe))$")
       {
          skippedFiles++
          Continue
       }

       r := coreJpegLossLessAction(imgPath, jpegOperation, mustCrop)
       If !r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

multiCoresSimpleImgProcessing(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  ReadSettingsImageProcessing()
  imgSelX1 := argumentsArray[1]
  imgSelX2 := argumentsArray[2]
  imgSelY1 := argumentsArray[3]
  imgSelY2 := argumentsArray[4]
  prcSelX1 := argumentsArray[5]
  prcSelX2 := argumentsArray[6]
  prcSelY1 := argumentsArray[7]
  prcSelY2 := argumentsArray[8]
  editingSelectionNow := argumentsArray[9]
  simpleOpRotationAngle := argumentsArray[10]
  skippedFiles := failedFiles := countFilez := operationDone := 0
  thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       imgPath := StrReplace(imgPath, "||")
       If !RegExMatch(imgPath, thisRegEX)
       {
          skippedFiles++
          Continue
       }

       zPlitPath(imgPath, 0, OutFileName, OutDir)
       destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
       file2save := destImgPath "\" OutFileName
       If (ResizeUseDestDir=1)
       {
          If (FileExist(file2save) && !FolderExist(file2save))
             file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
       }

       If !file2save
       {
          skippedFiles++
          Continue
       }

       r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       If r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

ReadSettingsFormatConvert() {
    IniAction(0, "OnConvertKeepOriginals", "General", 1)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    IniAction(0, "userHQraw", "General", 1)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "userDesireWriteFMT", "General", 2, 1, 16)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "PreserveDateTimeOnSave", "General", 1)

    rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
}

ReadSettingsImageProcessing() {
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "ResizeApplyEffects", "General", 1)
    IniAction(0, "ResizeCropAfterRotation", "General", 1)
    IniAction(0, "ResizeInPercentage", "General", 1)
    IniAction(0, "ResizeKeepAratio", "General", 1)
    IniAction(0, "ResizeQualityHigh", "General", 1)
    IniAction(0, "ResizeRotationUser", "General", 2, 0, 359)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "ResizeWithCrop", "General", 1)
    IniAction(0, "userHQraw", "General", 1)
    IniAction(0, "SimpleOperationsFlipV", "General", 1)
    IniAction(0, "SimpleOperationsFlipH", "General", 1)
    IniAction(0, "SimpleOperationsDoCrop", "General", 1)
    IniAction(0, "SimpleOperationsRotateAngle", "General", 2, 1, 4)
    IniAction(0, "SimpleOperationsScaleXimgFactor", "General", 2, 1, 32000)
    IniAction(0, "SimpleOperationsScaleYimgFactor", "General", 2, 1, 32000)
    IniAction(0, "ResizeMustPerform", "General", 1)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    cleanResizeUserOptionsVars()
}

multiCoresFormatConvert(coreThread, filesList) {
  resultsList := ""
  failedFiles := theseFailures := countFilez := operationDone := 0
  ; FileRead, filesList, %thumbsCacheFolder%\tempList%coreThread%.txt
  ReadSettingsFormatConvert()
  initFIMGmodule()
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT

      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         countFilez++

      wasSucces := r ? 0 : 1
      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, %imgPath%
         Sleep, 2
         FileRecycle, %imgPath%
         If ErrorLevel
            theseFailures++

         If (wasSucces=1)
            resultsList .= lineArr[1] "?" file2save "`n"
      }

      RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   If resultsList
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, UTF-16
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

readSlideSettings(readThisFile, act) {
     IniAction(act, "allowGIFsPlayEntirely", "General", 1,0,0,, readThisFile)
     IniAction(act, "animGIFsSupport", "General", 1,0,0,, readThisFile)
     IniAction(act, "autoAdjustMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "autoPlaySNDs", "General", 1,0,0,, readThisFile)
     IniAction(act, "borderAroundImage", "General", 1,0,0,, readThisFile)
     IniAction(act, "bwDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "chnBdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnGdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnRdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "ColorDepthDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSatAdjusts", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSlidesTransitions", "General", 1,0,0,, readThisFile)
     IniAction(act, "easySlideStoppage", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgH", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgV", "General", 1,0,0,, readThisFile)
     IniAction(act, "GammosAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "GammosGrayAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "hueAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "imageAligned", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgFxMode", "General", 2,1,10,, readThisFile)
     IniAction(act, "IMGresizingMode", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgThreshold", "General", 2,0,1,, readThisFile)
     IniAction(act, "IntensityAlphaChannel", "General", 2,1,30,, readThisFile)
     IniAction(act, "isAlwaysOnTop", "General", 1,0,0,, readThisFile)
     IniAction(act, "isTitleBarHidden", "General", 1,0,0,, readThisFile)
     IniAction(act, "lummyAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "lumosAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "lumosGrayAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "mediaSNDvolume", "General", 2,1,100,, readThisFile)
     IniAction(act, "realGammos", "General", 2,0.01,10,, readThisFile)
     IniAction(act, "resetImageViewOnChange", "General", 1,0,0,, readThisFile)
     IniAction(act, "satAdjust", "General", 2,0,3,, readThisFile)
     IniAction(act, "showHUDnavIMG", "General", 1,0,0,, readThisFile)
     IniAction(act, "showImgAnnotations", "General", 1,0,0,, readThisFile)
     IniAction(act, "skipDeadFiles", "General", 1,0,0,, readThisFile)
     IniAction(act, "SLDcacheFilesList", "General", 1,0,0,, readThisFile)
     IniAction(act, "SlideHowMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "slidesFXrandomize", "General", 1,0,0,, readThisFile)
     IniAction(act, "slideShowDelay", "General", 2,90,25000,, readThisFile)
     IniAction(act, "specialColorFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "syncSlideShow2Audios", "General", 1,0,0,, readThisFile)
     IniAction(act, "thumbsAratio", "General", 2,1,3,, readThisFile)
     IniAction(act, "thumbsZoomLevel", "General", 2,0.35,3,, readThisFile)
     IniAction(act, "TouchScreenMode", "General", 1,0,0,, readThisFile)
     IniAction(act, "uiColorCurveFXchannel", "General", 2,1,4,, readThisFile)
     IniAction(act, "uiColorCurveFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "usrAdaptiveThreshold", "General", 2,-9500,9500,, readThisFile)
     IniAction(act, "usrColorDepth", "General", 2,0,9,, readThisFile)
     IniAction(act, "usrTextureBGR", "General", 1,0,0,, readThisFile)
     IniAction(act, "vpIMGrotation", "General", 2,0,359,, readThisFile)
     IniAction(act, "WindowBgrColor", "General", 3,0,0,, readThisFile)
     IniAction(act, "zatAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "zoomLevel", "General", 2,0.01,20,, readThisFile)
     IniAction(act, "SlidesMusicSong", "General", 0,0,0,, readThisFile)
     IniAction(act, "autoPlaySlidesAudio", "General", 1,0,0,, readThisFile)

     If (act=0)
     {
        If (isWinXP=1 || minimizeMemUsage=1)
           doSlidesTransitions := 0

        If (imageAligned!=1)
           imageAligned := 5

        If (scriptInit=1)
           interfaceThread.ahkFunction("updateWindowColor")

        defineColorDepth()
        recalculateThumbsSizes()
    } Else
    {
       IniAction(1, "appVersion", "General", 0,0,0,, readThisFile)
    }
}

writeMainSettings() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 350)
    {
       lastInvoked := A_TickCount
       SetTimer, writeMainSettings, -500
       Return
    }

    loadMainSettings(1)
    lastInvoked := A_TickCount
}

loadMainSettings(act) {
    EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
    readSlideSettings(mainSettingsFile, act)
    IniAction(act, "allowMultiCoreMode", "General", 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
    IniAction(act, "ShowAdvToolbar", "General", 1)
    IniAction(act, "allowRecordHistory", "General", 1)
    IniAction(act, "alwaysOpenwithFIM", "General", 1)
    IniAction(act, "askDeleteFiles", "General", 1)
    IniAction(act, "deleteFileActAfter", "General", 2, 1, 3)
    IniAction(act, "skipSeenImageSlides", "General", 1)
    IniAction(act, "reverseOrderOnSort", "General", 1)
    IniAction(act, "OnSortdoFilesCheck", "General", 1)
    IniAction(act, "AutoDownScaleIMGs", "General", 1)
    IniAction(act, "autoRemDeadEntry", "General", 1)
    IniAction(act, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(act, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(act, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    IniAction(act, "cycleFavesOpenIMG", "General", 1)
    IniAction(act, "DisplayTimeUser", "General", 2, 1, 99)
    ; IniAction(act, "dynamicThumbsColumns", "General", 1)
    IniAction(act, "EllipseSelectMode", "General", 1)
    IniAction(act, "enableThumbsCaching", "General", 1)
    IniAction(act, "FontBolded", "General", 1)
    IniAction(act, "FontItalica", "General", 1)
    IniAction(act, "highlightAlreadySeenImages", "General", 1)
    IniAction(act, "histogramMode", "General", 2, 1, 3)
    IniAction(act, "LimitSelectBoundsImg", "General", 1)
    IniAction(act, "mainWinMaximized", "General", 1)
    IniAction(act, "mainWinPos", "General", 5)
    IniAction(act, "mainWinSize", "General", 5)
    IniAction(act, "maxMemThumbsCache", "General", 2, 6, 950)
    IniAction(act, "minimizeMemUsage", "General", 1)
    IniAction(act, "multilineStatusBar", "General", 1)
    IniAction(act, "MustLoadSLDprefs", "General", 1)
    IniAction(act, "OSDbgrColor", "General", 3)
    IniAction(act, "OSDtextColor", "General", 3)
    IniAction(act, "OSDfntSize", "General", 2, 10, 350)
    IniAction(act, "PasteFntSize", "General", 2, 10, 350)
    IniAction(act, "OSDFontName", "General", 5)
    IniAction(act, "PrefsLargeFonts", "General", 1)
    IniAction(act, "prevFileMovePath", "General", 5)
    IniAction(act, "prevFileSavePath", "General", 5)
    IniAction(act, "prevOpenFolderPath", "General", 5)
    IniAction(act, "ResizeDestFolder", "General", 5)
    IniAction(act, "rotateSelBoundsKeepRatio", "General", 1)
    IniAction(act, "showHistogram", "General", 2, 1, 6)
    IniAction(act, "showInfoBoxHUD", "General", 2, 0, 2)
    IniAction(act, "showMainMenuBar", "General", 1)
    IniAction(act, "showSelectionGrid", "General", 1)
    IniAction(act, "mustRecordSeenImgs", "General", 1)
    IniAction(act, "thumbsColumns", "General", 2, 2, 100)
    IniAction(act, "thumbsListViewMode", "General", 2, 1, 4)
    IniAction(act, "useCachedSLDdata", "General", 1)
    IniAction(act, "userAllowWindowDrag", "General", 1)
    IniAction(act, "userHQraw", "General", 1)
    IniAction(act, "userimgQuality", "General", 1)
    IniAction(act, "userMultiCoresLimit", "General", 2, 2, thisSystemCores)
    IniAction(act, "usrTextAlign", "General", 5)
    IniAction(act, "ambiTexBrushSize", "General", 2, 25, 950)

    If (act=0)
    {
       If (LimitSelectBoundsImg=1)
          lockSelectionAspectRatio := 1

       If (cmrRAWtoneMapAlgo=1)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 9.9)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, -8, 8)
       } Else If (cmrRAWtoneMapAlgo=2)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, -8, 8)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       } Else If (cmrRAWtoneMapAlgo=3)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 1)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       }

       If !InStr(mainWinPos, "|")
          mainWinPos := ""
       If !InStr(mainWinSize, "|")
          mainWinSize := ""

       imgQuality := (userimgQuality=1) ? 7 : 5
       isTxtAlignOkay := (usrTextAlign="Left" || usrTextAlign="Right" || usrTextAlign="Center") ? 1 : 0
       If !isTxtAlignOkay
          usrTextAlign := "Left"

       If !prevOpenFolderPath
          prevOpenFolderPath := A_WorkingDir

       If !ResizeDestFolder
       {
          If prevOpenFolderPath
             ResizeDestFolder := prevOpenFolderPath
          Else
             ResizeDestFolder := A_WorkingDir
       }

       realSystemCores := userMultiCoresLimit
       SetVolume(mediaSNDvolume)
       calcHUDsize()
       msgDisplayTime := DisplayTimeUser*1000
    }
}

calcHUDsize() {
   imgHUDbaseUnit := (PrefsLargeFonts=1) ? Round(OSDfntSize*2.5) : Round(OSDfntSize*2)
}

writeSlideSettings(file2save) {
    readSlideSettings(file2save, 1)
    ; throwMSGwriteError()
}

readRecentEntries(forceNewList:=0, doFiltering:=1) {
   Static lastInvoked := 1, historyList

   If (StrLen(forceNewList)>4)
   {
      historyList := forceNewList
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(historyList)>4 && (A_TickCount - lastInvoked<5500))
   {
      lastInvoked := A_TickCount
      Return historyList
   }

   historyList := ""
   Loop, 10
   {
       IniRead, newEntry, % mainRecentsFile, RecentOpen, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>4 && doFiltering=1)
          historyList .= newEntry "`n"
       Else If (doFiltering!=1)
          historyList .= newEntry "`n"
   }
  
   List_MakeUnique(historyList, "`n", 0, 1)
   lastInvoked := A_TickCount
   Return historyList
}

List_MakeUnique(ByRef oList, Delimiter:="`n", Case_Sensitive:=0, keepAsEmpty:=0) {
; By [VxE], removes duplicate entries from a list. Special thanks to SKAN.
; SOURCE: https://autohotkey.com/board/topic/34715-removing-duplicates-from-the-list-without-sorting-it/page-2
; modified by Marius Șucan

   ; VarSetCapacity( New_List, StrLen( List ) )
   New_List := Delimiter
   entriesCount := 0
   Loop, Parse, oList, % Delimiter
   {
      If (keepAsEmpty!=1 && !A_LoopField)
         Continue

      If (!InStr(New_List, Delimiter . A_LoopField . Delimiter, !!Case_Sensitive))
         New_List .= A_LoopField . Delimiter
      Else If (keepAsEmpty=1)
         New_List .= A_Space . Delimiter

      entriesCount++
   }
   oList := SubStr(New_List, 2, -1)
   Return entriesCount
}

readMiniFavesEntries() {
   Static lastInvoked := 1, prevList, prevCall

   fileInfos := GetFileAttributesEx(mainFavesFile)
   thisCall := "zzz" fileInfos.size "=" fileInfos.wTime "=" fileInfos.cTime
   If (thisCall!=prevCall || !prevList)
   {
      FileRead, contentu, % miniFavesFile
      Loop, Parse, contentu, `n, `r
      {
           If RegExMatch(A_LoopField, RegExFilesPattern)
           {
              thisIndex++
              historyList .= A_LoopField "`n"
           }

           If (thisIndex>16)
              Break
      }

      prevList := historyList
      prevCall := thisCall
      ; FileRead, historyList, % mainFavesFile
   } Else historyList := prevList

   lastInvoked := A_TickCount
   Return historyList
}

RecentFilesManager(entry2add) {
  If (StrLen(entry2add)<5 || !allowRecordHistory)
     Return

  historyList := readRecentEntries()
  historyList := entry2add "`n" historyList
  List_MakeUnique(historyList, "`n", 0, 0)
  Loop, Parse, historyList, `n, `r
  {
      If (A_Index>11)
         Break

      If (StrLen(A_LoopField)<5 || !FileExist(StrReplace(A_LoopField, "|")))
         Continue

      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentOpen, E%countItemz%
      newHistoryList .= A_LoopField "`n"
  }

  readRecentEntries(newHistoryList)
}

ToggleImgFavourites(thisImg:=0, actu:=0, directCall:=0) {
  Static lastInvoked := 1, prevImg, prevRemSpeed := 1
  imgPath := thisImg ? thisImg : getIDimage(currentFileIndex)
  isPipe := InStr(imgPath, "||")
  imgPath := StrReplace(imgPath, "||")
  If (A_TickCount - lastInvoked<550) && (directCall=1 && prevImg=imgPath) || !imgPath
     Return

  If (!FileRexists(imgPath) && actu!="rem")
  {
     showTOOLtip("ERROR: The file seems to not exist.`nYou cannot add to favourites inexistent files")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  resetSlideshowTimer(0, 1)
  prevImg := imgPath
  isFaved := isPipe ? 0 : resultedFilesList[currentFileIndex, 5]
  If (!isFaved && actu!="rem")
  {
     If !userAddedFavesCount
        IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

     If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
     {
        userAddedFavesCount++
        resultedFilesList[currentFileIndex, 5] := 1
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 1)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        IniAction(1, "userAddedFavesCount", "General")
        showTOOLtip("Image ADDED back to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }


     If (userAddedFavesCount>maxFavesEntries - 1)
     {
        showTOOLtip("WARNING: You have reached the maximum allowed favourite images: " maxFavesEntries " entries.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     lastInvoked := A_TickCount
     whichFile := (userAddedFavesCount>19) ? mainFavesFile : miniFavesFile
     FileAppend, % imgPath "`n", % mainFavesFile, UTF-8
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list`nThe image was not added to favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     userAddedFavesCount++
     IniAction(1, "userAddedFavesCount", "General")
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image ADDED to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
     resultedFilesList[currentFileIndex, 5] := 1
     updateMainUnfilteredList(currentFileIndex, 5, 1)
     If !thisImg
     {
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 1, imgPath)
     }

     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else
  {
     If (!thisImg && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
     {
        If !userAddedFavesCount
           IniAction(0, "userAddedFavesCount", "General", 2, 0, 9876543)

        userAddedFavesCount--
        resultedFilesList[currentFileIndex, 5] := 0
        resultedFilesList[currentFileIndex, 1] := "||" imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 0)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        IniAction(1, "userAddedFavesCount", "General")
        showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     ToolTip, Please wait...
     startZeit := A_TickCount
     lastInvoked := A_TickCount
     IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
     FileRead, historyList, % mainFavesFile
     FileRead, miniList, % miniFavesFile
     If ErrorLevel
     {
        Tooltip
        showTOOLtip("Failed to read the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     historyList := StrReplace(miniList, imgPath) "`n" StrReplace(historyList, imgPath)
     hash := new hashtable()
     arrayList := []
     doDeduplication := (prevRemSpeed<765 && userAddedFavesCount<12345) ? 1 : 0
     miniF:= fileOpen(miniFavesFile, "w")
     If IsObject(miniF)
        mainF:= fileOpen(mainFavesFile, "w", "UTF-8")

     If (!IsObject(miniF) || !IsObject(mainF))
     {
        Tooltip
        showTOOLtip("Failed to read and write the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If !thisImg
     {
        resultedFilesList[currentFileIndex, 5] := 0
        If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
           resultedFilesList[currentFileIndex, 1] := "||" imgPath

        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     ; ToolTip, % doDeduplication "==" prevRemSpeed , , , 2
     Loop, Parse, historyList,`n,`r
     {
         If (realCount>maxFavesEntries)
            Break

         If !RegExMatch(A_LoopField, RegExFilesPattern)
            Continue

         If (doDeduplication=1)
         {
            z := Format("{:L}", A_LoopField)
            w := hash[z]
         }

         If (w!=1)
         {
            realCount++
            If (doDeduplication=1)
               hash[z] := 1

            lineu := A_LoopField "`n"
            If (realCount<20)
               miniF.Write(lineu)
            Else
               mainF.Write(lineu)
         }
     }

     mainF.Close()
     miniF.Close()
     hash := ""
      ; List_MakeUnique(historyList, "`n", 0, 0)
     userAddedFavesCount := realCount
     IniAction(1, "userAddedFavesCount", "General")
     Tooltip
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list file`nThe image was not succesfully removed from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (doDeduplication=1)
        prevRemSpeed := A_TickCount - startZeit
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(realCount), 0, 0, realCount/maxFavesEntries)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  }

  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

retrieveFavesAsArray(ByRef countItemz) {
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    hash := new hashtable(userAddedFavesCount+50)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
          Continue

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          If (StrLen(bonus)>4 && RegExMatch(bonus, RegExFilesPattern))
             hash[Format("{:L}", bonus)] := 1
       }

       hash[Format("{:L}", imgu)] := 1
    }

    countItemz := hash.Count()
    Return hash
}

retrieveFavesAsList(dummy:=0) {
    If GetKeyState("Ctrl", "P")
       ctrlState := 1

    If askAboutFileSave(". The current files list will be discarded as well")
       Return
 
    If AnyWindowOpen
       BtnCloseWindow()

    If askAboutSlidesListSave()
       Return
 
    showTOOLtip("Loading favourites list, please wait")
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    thisList := []
    IniAction(0, "userAddedFavesCount", "General", 4)
    doDeduplication := (userAddedFavesCount<12345) ? 1 : 0
    hash := new hashtable(userAddedFavesCount+50)
    If !ctrlState
       ctrlState := (GetKeyState("Ctrl", "P") || userAddedFavesCount<20101) ? 1 : 0

    ; ToolTip, % "f=" userAddedFavesCount , , , 2
    mustRenewList := countItemz := thisIndexu := 0
    ;  realCount := List_MakeUnique(historyList, "`n", 0, 0)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
       {
          If A_LoopField
             mustRenewList := 1
          Continue
       }

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          thisIndexu++
          thisList[thisIndexu] := [bonus]
          thisList[thisIndexu, 5] := 1
       }

       If (doDeduplication=1)
       {
         z := Format("{:L}", imgu)
         w := hash[z]
       }

       If (w!=1)
       {
          thisIndexu++
          thisList[thisIndexu] := [imgu]
          thisList[thisIndexu, 5] := 1
          ; If (ctrlState=1)
          If (doDeduplication=1)
             hash[z] := 1
       } Else mustRenewList := 1
    }

   hash := ""
   If (thisIndexu> maxFavesEntries - 1)
      msgBoxWrapper(appTitle ": WARNING", "Please take note, you have exceeded the limit of favourite image entries: " maxFavesEntries ".", 0, 0, "exclamation")

   userAddedFavesCount := thisIndexu
   IniAction(1, "userAddedFavesCount", "General")
   If (thisIndexu<2)
   {
      SoundBeep , 300, 100
      showTOOLtip("Found insufficient favourite images")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
   {
      SLDtypeLoaded := 0
      activeSQLdb.CloseDB()
   }

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\favourite-images-list.SLD"
   resultedFilesList := thisList.Clone()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SLDtypeLoaded := 2
   maxFilesIndex := thisList.Count()
   currentFileIndex := (isNumber(dummy)=1 && dummy>0) ? dummy : clampInRange(maxFilesIndex - 2, 1, maxFilesIndex)
   seenEntries := []
   If (mustRenewList=1 || !miniList)
      renewFavesListBasedOnIndexList()

   currentFilesListModified := 0
   INIaction(0, "SlidesMusicSong", "General")
   INIaction(0, "autoPlaySlidesAudio", "General", 1)
   If (thumbsDisplaying!=1 && !isNumber(dummy))
      MenuDummyToggleThumbsMode()

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   GenerateRandyList()
   dummyTimerDelayiedImageDisplay(50)
   SetTimer, TriggerMenuBarUpdate, -90
   showDelayedTooltip("Favourites list loaded`nTotal entries: " groupDigits(maxFilesIndex), 0, 200)
   ; RandomPicture()
}

renewFavesListBasedOnIndexList() {
   ; If StrLen(filesFilter)>1
   ;    Return
   newListu := ""
   realCount := 0
   showTOOLtip("Saving favourites list, please wait")
   If StrLen(filesFilter)>1
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "The current files list has " groupDigits(maxFilesIndex) " images indexed. It is the result of a filter applied on the favourite images list.`n`nPlease confirm you want to save the favourites list as is, filtered. The total of " groupdigits(bckpMaxFilesIndex) " favourited images will no longer be retrievable.", "&Deactivate filter|&Save list|&Cancel", 0, "question")
      If InStr(msgResult, "deactivate")
      {
         MenuRemFilesListFilter()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      } Else If InStr(msgResult, "save")
      {
         Sleep, 100
      } Else
      {
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   Loop, % maxFilesIndex
   {
       ; isFaved := resultedFilesList[currentFileIndex, 5]
       ; If !isFaved
       ;    Continue

       If (realCount>maxFavesEntries)
          Break

       ; If StrLen(filesFilter)>1
       ;    thisImg := bckpResultedFilesList[filteredMap2mainList[A_Index], 1]
       ; Else
          thisImg := resultedFilesList[A_Index, 1]

       If (StrLen(thisImg)>3 && !InStr(thisImg, "||"))
       {
          realCount++
          If (A_Index<20)
             miniList .= thisImg "`n"
          Else
             newListu .= thisImg "`n"
       }
   }

   FileDelete, % mainFavesFile
   FileDelete, % miniFavesFile
   Sleep, 150
   ; realCount := List_MakeUnique(newListu, "`n", 0, 0)
   userAddedFavesCount := realCount
   IniAction(1, "userAddedFavesCount", "General")
   FileAppend, % newListu "`n", % mainFavesFile, UTF-8
   FileAppend, % miniList "`n", % miniFavesFile, UTF-8
   If ErrorLevel
   {
      showTOOLtip("ERROR: Unable to save the favourites list file. Unknown cause.")
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Favourites list saved")
      SoundBeep, 900, 100
   }

   currentFilesListModified := 0
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

eraseAllFavedIMGs() {
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries from the favourites list?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return
  
  FileDelete, % mainFavesFile
  FileDelete, % miniFavesFile
  userAddedFavesCount := 0
  IniAction(1, "userAddedFavesCount", "General")
  showTOOLtip("All entries from the favourites list were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

RandomPicture(dummy:=0, inLoop:=0) {
   ; Static inLoop := 0
   If (maxFilesIndex=0 || maxFilesIndex="") && (!CurrentSLD)
      Return

   currentFileIndex := coreNextPrevImage(1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

PrevRandyPicture(dummy:=0, inLoop:=0) {
   resetSlideshowTimer(0)
   currentFileIndex := coreNextPrevImage(-1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

getSelectedFiles(getItem:=0, forceSort:=0) {
   Static firstItem, lastItem, lastIDcount := 0

   If (getItem=0 && forceSort=0)
      Return markedSelectFile

   If (getItem=1 && markedSelectFile)
      Return firstItem

   If (getItem="L" && markedSelectFile)
      Return lastItem

   If (forceSort=1 && getItem=0)
   {
      thisIDcount := CurrentSLD maxFilesIndex bckpMaxFilesIndex markedSelectFile lastZeitFileSelect
      If (lastIDcount=thisIDcount)
         Return markedSelectFile

      ; ToolTip, % thisIDcount "`n" lastIDcount , , , 2
      lastIDcount := thisIDcount
      firstItem := lastItem := markedSelectFile := 0
      changeMcursor()
      startZeit := A_TickCount
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]=1)
         {
            markedSelectFile++
            lastItem := A_Index
            If !firstItem
               firstItem := A_Index
         }
      }

      If (markedSelectFile=1)
      {
         markedSelectFile := 0
         resultedFilesList[firstItem, 2] := 0
         lastZeitFileSelect := A_TickCount
         If (thumbsDisplaying=1)
            mainGdipWinThumbsGrid()
      }
      changeMcursor("normal")
      Return markedSelectFile
   }
}

filterToFilesSelection() {
   userFilterProperty := 19
   userFilterInvertThis := userFilterDoString := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
}

invertFilesSelection(silentMode:=0) {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   markedSelectFile := 0
   Loop, % maxFilesIndex
   {
       sel := resultedFilesList[A_Index, 2]
       resultedFilesList[A_Index, 2] := !sel
       If (sel!=1)
          markedSelectFile++
   }

   lastZeitFileSelect := A_TickCount
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

   showTOOLtip("Files selection inverted`n" markedSelectFile " files are now selected")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dropFilesSelection(silentMode:=0) {
   If (!markedSelectFile && silentMode=1)
      Return

   EntryMarkedMoveIndex := markedSelectFile := 0
   Loop, % maxFilesIndex
       resultedFilesList[A_Index, 2] := 0

   lastZeitFileSelect := A_TickCount
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   ; selectAllFiles("none")
   ; ToolTip, % A_TickCount - startZeit, , , 2
   If (silentMode!=1)
   {
      showTOOLtip("Files selection dropped")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (thumbsDisplaying=1)
         mainGdipWinThumbsGrid()
      Else
         dummyTimerDelayiedImageDisplay(50)
   }
}

MenuMarkThisFileNow() {
   markThisFileNow()
}

markThisFileNow(thisFileIndex:=0) {
  If (currentFileIndex=0 || maxFilesIndex<2 || AnyWindowOpen>0)
     Return

  If !thisFileIndex
     thisFileIndex := currentFileIndex

  DestroyGIFuWin()
  oSel := resultedFilesList[thisFileIndex, 2]
  sel := oSel ? 0 : 1
  resultedFilesList[thisFileIndex, 2] := sel
  ; sel := (oSel && !sel) ? 0 : 1
  If (oSel!=sel)
  {
     If sel
        markedSelectFile++
     Else
        markedSelectFile--
  }

  lastZeitFileSelect := A_TickCount
  If (markedSelectFile<0)
     getSelectedFiles(0, 1)
  Else If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
  Else
     dummyTimerDelayiedImageDisplay(25)

  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
}

jumpToFilesSelBorderFirst() {
   jumpToFilesSelBorder(-1)
}

jumpToFilesSelBorderLast() {
   jumpToFilesSelBorder(1)
}

jumpToFilesSelBorder(destination) {
  Static prevImgIndex, prevIndexu

  If (slideShowRunning=1)
     ToggleSlideShowu()

  totalCount := getSelectedFiles(0, 1)
  If !totalCount
  {
     RandyIMGnow := currentFileIndex := (destination=-1) ? RandyIMGids[1] : RandyIMGids[maxFilesIndex]
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  theFirst := getSelectedFiles(1)
  theLast := getSelectedFiles("L")
  currentFileIndex := (destination=-1) ? theFirst : theLast
  FriendlyName := (destination=-1) ? "First" : "Last"
  dummyTimerDelayiedImageDisplay(50)
  showTOOLtip(FriendlyName " selected element index: " currentFileIndex "`n" markedSelectFile " total images selected")
  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

navSelectedFilesNext() {
   navSelectedFiles(1)
}

navSelectedFilesPrev() {
   navSelectedFiles(1)
}

navSelectedFiles(direction) {
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   changeMcursor()

   If !markedSelectFile
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         changeMcursor("normal")
         CurrentSLD := backCurrentSLD
         showTOOLtip("No files are currently selected")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   startIndex := currentFileIndex
   newIndex := 0
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? currentFileIndex - A_Index : currentFileIndex + A_Index
        r := getIDimage(thisIndex)
        isSelected := resultedFilesList[thisIndex, 2]
        If (isSelected!=1 || !r || InStr(r, "||"))
           Continue

        If (skipDeadFiles=1)
        {
           If !FileRexists(r)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   CurrentSLD := backCurrentSLD
   changeMcursor("normal")
   If (!newIndex && direction=-1)
   {
      jumpToFilesSelBorderLast()
      Return
   } Else If (!newIndex && direction=1)
   {
      jumpToFilesSelBorderFirst()
      Return
   }

   currentFileIndex := (newIndex) ? newIndex : startIndex
   dummyTimerDelayiedImageDisplay(25)
}

coreSearchIndex(imgPath, givenRegEx, whatu, invertu:=0) {
   If !givenRegEx
      Return
   ; ToolTip, % imgPath "`n" givenRegEx , , , 2
   If (whatu=1)
   {
      stringu := imgPath
   } Else ; If (userSearchWhat=1)
   {
      parentu := zPlitPath(imgPath, 1, OutFileName, OutDir)
      If (whatu=2)
         stringu := OutDir
      Else If (whatu=3)
         stringu := OutFileName
      Else If (whatu=4)
         stringu := parentu
   }

   ; ToolTip, % stringu "`n" thisSearchString "`n" z , , , 2
   If !invertu
      Return RegExMatch(stringu, givenRegEx)
   Else
      Return RegExMatch(stringu, givenRegEx) ? 0 : 1
}

processSearchIndexString(inputu) {
   testRegEx := SubStr(inputu, 1, 2)
   If (testRegEx="\>" && StrLen(inputu)>2)
   {
      thisFilter := SubStr(inputu, 3)
   } Else If (InStr(inputu, ">") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, ">")
      If thisFilter
         thisFilter := "i)(" JEE_StrRegExLiteral(thisFilter) ")$"
   } Else If (InStr(inputu, "/") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, "/")
      If thisFilter
         thisFilter := "i)^(" JEE_StrRegExLiteral(thisFilter) ")"
   } Else If inputu
      thisFilter := "i)(" JEE_StrRegExLiteral(inputu) ")"

   Return thisFilter
}

searchNextIndex(direction, inLoop:=0) {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   thisSearchString := thisFilter
   friendly := (direction=-1) ? "previous" : "next"
   showTOOLtip("Searching " friendly " in index matching:`n" userSearchString)
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   originalIndex := startIndex := currentFileIndex

   newIndex := 0
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := (direction=1 && inLoop!=1) ? maxFilesIndex - startIndex + 1 : startIndex + 1
   If (inLoop=1)
      startIndex := (direction=1) ? 0 : maxFilesIndex + 1

   Loop, % totalLoops
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1000)
        {
           etaTime := ETAinfos(A_Index, totalLoops, startOperation)
           showTOOLtip("Searching in index, please wait" etaTime, 0, 0, A_Index/totalLoops)
           prevMSGdisplay := A_TickCount
        }

        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        imgPath := getIDimage(thisIndex)
        If (!coreSearchIndex(imgPath, thisSearchString, userSearchWhat) || !imgPath)
           Continue

        If (skipDeadFiles=1 && thumbsDisplaying!=1)
        {
           If !FileExist(imgPath)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
   If (abandonAll=1)
   {
      showTOOLtip("Search abandoned by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 300, 100
      Return
   }

   If (!newIndex && inLoop!=1)
   {
      searchNextIndex(direction, 1)
      Return
   }

   If (!newIndex && inLoop=1)
   {
      showTOOLtip("WARNING: No indexed file matched the search criteria:`n" userSearchString)
      userSearchString := ""
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 900, 100
      Return
   }

   RemoveTooltip()
   currentFileIndex := newIndex ? newIndex : originalIndex
   dummyTimerDelayiedImageDisplay(25)
}

setContaintFolderAsProtected(givenPath:=0) {
     imgPath := FolderExist(givenPath) ? givenPath : getIDimage(currentFileIndex)
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     protectedFolderPath := OutDir
     preventDeleteFromProtectedPath := 1
     IniAction(1, "protectedFolderPath", "General")
     IniAction(1, "preventDeleteFromProtectedPath", "General")
     showTOOLtip("The protected folder path is now:`n" OutDir "\")
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

UItoggleMultiDelProtectFolder() {
    If (AnyWindowOpen!=16)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, preventDeleteFromProtectedPath
    GuiControlGet, preventDeleteFromProtectedSubPaths

    IniAction(1, "preventDeleteFromProtectedPath", "General")
    IniAction(1, "preventDeleteFromProtectedSubPaths", "General")
    If !preventDeleteFromProtectedPath
    {
       GuiControl, Disable, preventDeleteFromProtectedSubPaths
       GuiControl, Disable, btnFldr
    } Else
    {
       GuiControl, Enable, preventDeleteFromProtectedSubPaths
       GuiControl, Enable, btnFldr
    }
}

PanelMultiFileDelete() {
    Static lastInvoked := 1

    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(16, A_ThisFunc, 0)
    btnWid := 120
    txtWid := 290
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(0, "userMultiDelChoice", "General", 2, 1, 3)
    IniAction(0, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(0, "preventDeleteFromProtectedSubPaths", "General", 1)
    IniAction(0, "protectedFolderPath", "General")
    If (A_TickCount - lastInvoked>10500)
       move2recycler := 1 

    If !userSearchString
       preventDeleteMatchingSearch := 0

    If !protectedFolderPath
       preventDeleteFromProtectedSubPaths := preventDeleteFromProtectedPath := 0

    lastInvoked := A_TickCount
    thisInfo := protectedFolderPath ? protectedFolderPath "\" : "NONE"
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please choose what to remove:
    Gui, Add, DropDownList, y+10 wp gTglMultiDelChoice AltSubmit Choose%userMultiDelChoice% vuserMultiDelChoice, Delete selected files|Remove file entries from the list|Do both: remove files and the index entries
    Gui, Add, Checkbox, y+10 gTglOptionMove2recycler Checked%move2recycler% vmove2recycler, Move to Recycle Bin the deleted files
    Gui, Add, Checkbox, y+10 Checked%preventDBentryRemoval% vpreventDBentryRemoval, Do not remove the entries from the database 
    Gui, Add, Checkbox, y+10 Checked%preventDeleteMatchingSearch% vpreventDeleteMatchingSearch, Skip the files that match the files list search criteria
    Gui, Add, Checkbox, y+10 gUItoggleMultiDelProtectFolder Checked%preventDeleteFromProtectedPath% vpreventDeleteFromProtectedPath, Skip the files found in the protected folder:
    Gui, Add, Text, xp+15 y+10 w%txtWid% vbtnFldr, % thisInfo
    Gui, Add, Checkbox, y+10 Checked%preventDeleteFromProtectedSubPaths% vpreventDeleteFromProtectedSubPaths, Skip files found in its sub-folders as well 
    Gui, Font, Bold
    Gui, Add, Text, xs y+20, % "Selected entries: " groupDigits(filesElected) "." 
    Gui, Font, Normal
    If (SLDtypeLoaded!=3 || userMultiDelChoice=1)
       GuiControl, Disable, preventDBentryRemoval

    If (userMultiDelChoice=2)
       GuiControl, Disable, move2recycler

    If !protectedFolderPath
    {
       GuiControl, Disable, preventDeleteFromProtectedPath
       GuiControl, Disable, preventDeleteFromProtectedSubPaths
       GuiControl, Disable, btnFldr
    }

    If !userSearchString
       GuiControl, Disable, preventDeleteMatchingSearch

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w%btnWid% gBTNactiveFileDel, &Delete focused file only
    Gui, Add, Button, x+5 hp w95 gBTNmultiDel Default, &Proceed
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Delete files: " appTitle)
    SetTimer, UItoggleMultiDelProtectFolder, -100
}

BTNactiveFileDel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval

   BtnCloseWindow()
   DeleteActivePicture()
   getSelectedFiles(0, 1)
   preventDBentryRemoval := 0
}

DeleteActivePicture() {
   DeletePicture("single")
   getSelectedFiles(0, 1)
}

BTNmultiDel() {
   ; Critical, on
   If !AnyWindowOpen
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval
   GuiControlGet, preventDeleteMatchingSearch
   GuiControlGet, preventDeleteFromProtectedPath
   GuiControlGet, preventDeleteFromProtectedSubPaths
   GuiControlGet, userMultiDelChoice
   IniAction(1, "preventDeleteFromProtectedPath", "deneral")
   IniAction(1, "preventDeleteFromProtectedSubPaths", "deneral")
   Sleep, 10
   dontAlterIndex := (userMultiDelChoice=3) ? "yes" : 0
   TglOptionMove2recycler()
   filesElected := getSelectedFiles(0, 1)
   If (filesElected<2)
      Return

   If (userMultiDelChoice=3 || userMultiDelChoice=1)
   {
      If (filesElected>50 && move2recycler!=1) || (filesElected>95 && move2recycler=1)
      {
         msgInfos := (move2recycler=1) ? " " : "`n`nThe files will be PERMANENTLY deleted."
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete " groupDigits(filesElected) " files?" msgInfos, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      BtnCloseWindow()
      r := batchFileDelete(dontAlterIndex)
   } Else r := 0

   If (userMultiDelChoice=3 || userMultiDelChoice=2) && (r=0)
   {
      If AnyWindowOpen
         BtnCloseWindow()
      Sleep, 500
      InListMultiEntriesRemover(0, "y")
   }

   preventDBentryRemoval := 0
   If AnyWindowOpen
      BtnCloseWindow()
}

TglMultiDelChoice() {
   TglOptionMove2recycler()
}

TglOptionMove2recycler() {
  Gui, SettingsGUIA: Default
  GuiControlGet, move2recycler
  GuiControlGet, userMultiDelChoice
  If (SLDtypeLoaded=3)
  {
     GuiControlGet, preventDBentryRemoval
     If (userMultiDelChoice=1)
        GuiControl, SettingsGUIA: Disable, preventDBentryRemoval
     Else
        GuiControl, SettingsGUIA: Enable, preventDBentryRemoval
  }

  INIaction(1, "userMultiDelChoice", "General")
  If (userMultiDelChoice=1 || userMultiDelChoice=3)
     GuiControl, SettingsGUIA: Enable, move2recycler
  Else
     GuiControl, SettingsGUIA: Disable, move2recycler
}

batchFileDelete(dontAlterIndex:=0) {
   BtnCloseWindow()
   filesElected := markedSelectFile
   friendly := (move2recycler=1) ? "Moving to recycle bin" : "Permanently deleting"
   showTOOLtip(friendly A_Space groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   filesRemoved := abandonAll := failedFiles := skippedFiles := 0
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nFailed to remove " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip(friendly " selected files, please wait" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      thisFileIndex := A_Index
      file2rem := StrReplace(getIDimage(thisFileIndex), "||")
      If (preventDeleteMatchingSearch=1 && file2rem && userSearchString)
      {
         If coreSearchIndex(file2rem, thisSearchString, userSearchWhat)
         {
            skippedFiles++
            Continue
         }
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(file2rem, protectedFolderPath "\") ? protectedFolderPath : ""
         Else
            zPlitPath(file2rem, 0, OutFileName, OutDir)

         If (protectedFolderPath=OutDir)
         {
            skippedFiles++
            Continue
         }
      }

      If (move2recycler=1)
         FileRecycle, %file2rem%
      Else
         FileDelete, %file2rem%

      If ErrorLevel
      {
         Try FileSetAttrib, -R, %file2rem%
         Sleep, 0

         If (move2recycler=1)
            FileRecycle, %file2rem%
         Else
            FileDelete, %file2rem%
      }

      If !ErrorLevel
      {
         filesRemoved++
         If (dontAlterIndex!="yes")
         {
            resultedFilesList[thisFileIndex, 1] := "||" file2rem
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, "||" file2rem)
         }
      } Else failedFiles++
   }

   currentFilesListModified := 1
   If failedFiles
      someErrors := "Failed to delete " groupDigits(failedFiles) " files`n"
   If skippedFiles
      someErrors .= groupDigits(skippedFiles) " files were skipped`n"

   watchFolderDetails := ""
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   If (abandonAll=1)
   {
      SoundBeep, 300, 100
      showTOOLtip(someErrors "Operation aborted. " groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted until now")
   } Else
   {
      SoundBeep, 900, 100
      showTOOLtip(someErrors groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return abandonAll
}

DeletePicture(dummy:=0) {
  Static lastInvoked := 1, prevDelFileIndex := -1
  getSelectedFiles(0, 1)
  If (markedSelectFile>1 && dummy!="single")
  {
     PanelMultiFileDelete()
     Return
  }

  If (slideShowRunning=1)
  {
     ToggleSlideShowu()
     Return
  }

  If (A_TickCount - lastInvoked<200) && (askDeleteFiles!=1)
  {
     lastInvoked := A_TickCount
     Return
  }

  file2rem := getIDimage(currentFileIndex)
  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir)
  If (askDeleteFiles=1 && dummy!="single") || (editingSelectionNow=1 && thumbsDisplaying!=1)
  {
     msgTimer := A_TickCount
     fakeWinCreator(37, A_ThisFunc, 1)
     msgResult := msgBoxWrapper(appTitle "panelu|: Confirmation", "Please confirm you want to delete this image file.`n`n" OutFileName "`n`n" OutDir "\", "&Remove index entry|&Delete|&Cancel", 3, "trash", "Permanently delete file, do not move to recycle bin", 0, "Always prompt before file delete`f`fNo longer prompt before file delete in this session`fNever prompt before file delete")
     If InStr(msgResult.btn, "Delete")
     {
        good2go := 1
     } Else If InStr(msgResult.btn, "remove index")
     {
        remCurrentEntry(0)
        Return
     }

     If (A_TickCount - msgTimer < 550) && InStr(msgResult.btn, "Delete")
     {
        showTOOLtip("Operation aborted. User answered affirmatively too quickly.")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }
  } Else good2go := 1

  If (msgResult.list>1 && good2go=1 && msgResult.check!=1)
  {
     askDeleteFiles := 0
     If (msgResult.list=3)
        INIaction(1, "askDeleteFiles", "General")
  }

  If (good2go!=1) || (imageLoading=1 && animGIFplaying!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     Return
  }

  Sleep, 2
  If (animGIFplaying=1)
  {
     DestroyGIFuWin()
     showDelayedTooltip("GIF animation stopped", 0, 250)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  Sleep, 2
  if (!UserMemBMP && thumbsDisplaying!=1)
  {
     prevDelFileIndex := currentFileIndex
     UserMemBMP := cloneGDItoMem(A_ThisFunc, gdiBitmap)
  }

  destroyGDIfileCache(0, 1)
  Try FileSetAttrib, -R, %file2rem%
  Sleep, 1

  shiftState := (GetKeyState("Shift", "P") && askDeleteFiles!=1) ? 1 : 0
  If (msgResult.check=1) || (shiftState=1)
     FileDelete, %file2rem%
  Else
     FileRecycle, %file2rem%

  If ErrorLevel
  {
     If (thumbsDisplaying=1 && !FileExist(file2rem))
     {
        If (prevDelFileIndex=currentFileIndex)
           terminateIMGediting()

        remCurrentEntry(0)
     } Else
     {
        showTOOLtip("ERROR: File already deleted or access denied`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
     }
  } Else
  {
     If (SLDtypeLoaded=3)
        selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

     If (resultedFilesList[currentFileIndex, 5]=1)
     {
        ToggleImgFavourites(file2rem, "rem")
        resultedFilesList[currentFileIndex, 5] := 0
        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     resultedFilesList[currentFileIndex, 1] := "||" file2rem
     updateMainUnfilteredList(currentFileIndex, 1, "||" file2rem)
     If (msgResult.check=1) || (shiftState=1)
        showTOOLtip("File permanently deleted`n" OutFileName "`n" OutDir "\")
     Else
        showTOOLtip("File moved to recycle bin`n" OutFileName "`n" OutDir "\")

     If (deleteFileActAfter=2)
        NextPicture(0, 0, 1)
     Else If (deleteFileActAfter=3)
        PreviousPicture(0, 0, 1)
  }

  preventDBentryRemoval := 0
  Sleep, 2
  watchFolderDetails := ""
  lastInvoked := A_TickCount
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -50
  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

readRecentMultiRenameEntries() {
   entriesList := ""
   Loop, 35
   {
       IniRead, newEntry, % mainRecentsFile, RecentMultiRename, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>1 && !InStr(entriesList, newEntry "`n"))
          entriesList .= newEntry "`n"
   }
   Return entriesList
}

PanelMultiRenameFiles() {
    Global UsrEditNewFileName
    If (maxFilesIndex<2)
       Return

    thisBtnHeight := createSettingsGUI(8, A_ThisFunc, 0)
    btnWid := 100
    txtWid := 390
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       txtWid := txtWid + 220
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "PreserveDateTimeOnSave", "General", 1)
    getSelectedFiles(0, 1)
    listu := readRecentMultiRenameEntries()
    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid%, Selected files: %markedSelectFile%. Type a pattern to rename the files.
    Gui, Add, ComboBox, y+10 w%EditWid% gMultiRenameComboAction vUsrEditNewFileName, % listu
    Gui, Add, ListView, xp y+1 wp -multi r12 Grid vLViewOthers +hwndhLVmainu, #`nOriginal file name`nNew file name`nFolder
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Text, y+10, In case of file name collisions, you will be prompted.

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gcoreBatchMultiRenameFiles, &Rename files
    Gui, Add, Button, x+5 hp w%btnWid% gEraseMultiRenameHisto, Erase &history
    Gui, Add, Button, x+5 hp w85 gBtnHelpMultiRename, H&elp
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Rename multiple files: " appTitle)
}

BtnHelpMultiRename() {
    GuiControlGet, PreserveDateTimeOnSave
    INIaction(1, "PreserveDateTimeOnSave", "General")
    msgBoxWrapper(appTitle ": HELP", "File extensions remain unchanged regardless of the pattern used. File rename patterns possible:`n`na) Whatever file prefix [this] or suffix with tokens`n[this] - file name`n[pfdname] - parent folder name`n[fDateM] or [fDateC] - file modified/created date`n[counter] - files counter.`ntrim{X,Y} - a function usable only once in the pattern. X and Y designate how many letters to trim from the beginning and/or end of the original file name.`n`nb) Replace string//with this one`nUse // to perform search and replace in file names. Begin with \> to use RegEx. Trim function and the tokens mentioned earlier can be used only after //.`n`nc) abcdefgh01234>>any string`nEvery enumerated character before >> will be replaced with a single character or a string specified after >>. The tokens from a) can be used after >>.`n`nd) any file name without tokens`nThe files will be counted according to their containing folder. This is to avoid naming conflicts and applies only if [this], >> and // are not used.", -1, 0, 0)
}

MultiRenameComboAction() {
   If (A_GuiControlEvent="DoubleClick")
      coreBatchMultiRenameFiles()
   Else
      PopulateLVmultiRename()
}

decideMultiRename(ByRef OriginalNewFileName) {
  obju := []
  obju.renamingCount := 0
  obju.TrimmingMode := 0
  obju.rechecherRemplaceMode := 0
  obju.charsRemplaceMode := 0
  obju.regExRemplaceMode := 0
  obju.IndexModeCount := 0
  If (Trimmer(OriginalNewFileName)="[counter]")
     OriginalNewFileName := "[this] ([counter])"

  matchFoundPosA := RegExMatch(OriginalNewFileName, "i)trim\{..?.?\, ?..?.?\}", matchedStringu)
  If InStr(OriginalNewFileName, "//")
     strArr := StrSplit(OriginalNewFileName, "//")
  Else If InStr(OriginalNewFileName, "\\")
     strArr := StrSplit(OriginalNewFileName, "\\")
  Else If InStr(OriginalNewFileName, ">>")
     chrStrArr := StrSplit(OriginalNewFileName, ">>")
  Else If (!InStr(OriginalNewFileName, "[this]") && !matchedStringu)
     obju.renamingCount := 1

  If (InStr(OriginalNewFileName, "[counter]") && obju.renamingCount!=1)
     obju.IndexModeCount := 1

  If (IsObject(strArr) && obju.renamingCount!=1)
  {
     testRegEx := SubStr(strArr[1], 1, 2)
     If (testRegEx="\>")
     {
        obju.regExRemplaceMode := 1
        obju.strArrA := SubStr(strArr[1], 3)
        obju.strArrB := strArr[2]
     } Else
     {
        obju.strArrA := filterFileName(strArr[1]) ? strArr[1] : ""
        obju.strArrB := filterFileName(strArr[2]) ? strArr[2] : ""
     }

     If (obju.strArrA="")
        Return "err"
     ; If (obju.strArrB="" && StrLen(obju.strArr[2])>0)
     ;    Return "err"

     obju.rechecherRemplaceMode := 1 
  } Else If (IsObject(chrStrArr) && obju.renamingCount!=1)
  {
     obju.strArrA := filterFileName(chrStrArr[1]) ? chrStrArr[1] : ""
     obju.strArrB := filterFileName(chrStrArr[2]) ? chrStrArr[2] : ""
     If (obju.strArrA="")
        Return "err"

     obju.charsRemplaceMode := 1 
  } Else obju.newName := filterFileName(OriginalNewFileName)

  If (obju.renamingCount!=1)
  {
     obju.origMatchedStringu := matchedStringu
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, .)
     matchedStringu := StrReplace(matchedStringu, "trim{")
     matchedStringu := StrReplace(matchedStringu, "}")
     If InStr(matchedStringu, ",")
     {
        trimuObj := StrSplit(matchedStringu, ",")
        obju.leftTrimu := trimuObj[1]
        obju.righttTrimu := trimuObj[2]
        obju.TrimmingMode := (isNumber(obju.leftTrimu) && isNumber(obju.righttTrimu)) ? 1 : 0
     }
     ; ToolTip, % obju.origMatchedStringu "`n" matchedStringu "`n" trimuObj[1] "==" trimuObj[2] , , , 2
  }

  Return obju
}

ChrReplace(string, chars, replacer) {
   If (chars!="")
      Loop, Parse, chars
           string := StrReplace(string, A_LoopField, replacer)

   Return string
}

decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez, parentFolderName, imgPath, obju) {
   If (obju.regExRemplaceMode=1)
      newFileName := RegExReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.rechecherRemplaceMode=1)
      newFileName := StrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.charsRemplaceMode=1)
      newFileName := ChrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (!InStr(OriginalNewFileName, "[this]") && obju.TrimmingMode!=1)
      newFileName := OriginalNewFileName " (" countFilez ")"
   Else ; If (obju.TrimmingMode=1)
      newFileName := OriginalNewFileName

   If (InStr(newFileName, "[pfdname]") && InStr(OriginalNewFileName, "[pfdname]"))
      newFileName := StrReplace(newFileName, "[pfdname]", parentFolderName)

   If (InStr(newFileName, "[counter]") && InStr(OriginalNewFileName, "[counter]") && obju.IndexModeCount=1)
      newFileName := StrReplace(newFileName, "[counter]", countFilez)

   If (InStr(newFileName, "[fDateM]") && InStr(OriginalNewFileName, "[fDateM]"))
   {
      FileGetTime, dateu, % imgPath, M
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateM]", dateu)
   }

   If (InStr(newFileName, "[fDateC]") && InStr(OriginalNewFileName, "[fDateC]"))
   {
      FileGetTime, dateu, % imgPath, C
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateC]", dateu)
   }

   If (InStr(newFileName, "[this]") && InStr(OriginalNewFileName, "[this]"))
      newFileName := StrReplace(newFileName, "[this]", fileNamuNoEXT)

   If (obju.TrimmingMode=1 && obju.origMatchedStringu && obju.renamingCount!=1)
   {
      clampedL := clampInRange(obju.leftTrimu + 1, 0, StrLen(fileNamuNoEXT) - 1)
      trimmedFileName := SubStr(fileNamuNoEXT, clampedL)
      clampedR := clampInRange(obju.righttTrimu, 1, StrLen(trimmedFileName) - 1)
      If (obju.righttTrimu>0)
         trimmedFileName := SubStr(trimmedFileName, 1, StrLen(trimmedFileName) - clampedR)
      newFileName := StrReplace(newFileName, obju.origMatchedStringu, trimmedFileName)
      ; ToolTip, % clampedL "==" clampedR "`n" trimmedFileName "`n" newFileName , , , 2
   }
   ; ToolTip, % obju.TrimmingMode "==" obju.origMatchedStringu "==" obju.renamingCount , , , 2

   Return newFileName
}

PopulateLVmultiRename() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  Gui, SettingsGUIA: ListView, LViewOthers
  LV_Delete()

  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
     Return

  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err")
     Return

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  loopzu := 0
  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"


     Loop, % maxFilesIndex
     {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisFileIndex := A_Index
         imgPath := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, imgPath, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu

         If (file2save=imgPath || newFileName="" || newFileName=A_Space)
            Continue

         loopzu++
         LV_Add(A_Index, thisFileIndex, OutFileName, newFileName "." fileEXTu, OutDir "\")
         ; ToolTip, % A_Index , , , 2
         If (loopzu>=999)
            Break
     }
  }

  ; Loop, 3
  ;    LV_ModifyCol(A_Index, "AutoHdr Left")

}

coreBatchMultiRenameFiles() {
  Critical, on
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  GuiControlGet, PreserveDateTimeOnSave

  INIaction(1, "PreserveDateTimeOnSave", "General")
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err" || OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
  {
     showTOOLtip("WARNING: Incorrect multi-rename pattern provided")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName

  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (filesElected>100)
     {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to rename the selected files.`n`nYou have selected " filesElected " files to be renamed...", 4, 0, "question")
        If (msgResult!="Yes")
           Return
     }

     BtnCloseWindow()
     showTOOLtip("Renaming " filesElected " files, please wait`nPattern: " OriginalNewFileName)
     startOperation := A_TickCount
     prevMSGdisplay := A_TickCount
     destroyGDIfileCache()
     RecentMultiRenamesManager(OriginalNewFileName)
     doStartLongOpDance()
     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     filezRenamed := countFilez := 0
     countTFilez := skippedFiles := failedFiles := overwrittenFiles := 0
     nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
     if (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     BtnCloseWindow()
     Loop, % maxFilesIndex
     {
         wasError := 0
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         changeMcursor()
         thisFileIndex := A_Index
         file2rem := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         countTFilez++
         If !FileExist(file2rem)
         {
            failedFiles++
            Continue
         }

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            someErrors := ETAinfos(countTFilez, filesElected, startOperation)
            If (failedFiles>0)
               someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
            If (skippedFiles>0)
               someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
            If (overwrittenFiles>0)
               someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

            showTOOLtip("Renaming selected files, please wait`nPattern: " OriginalNewFileName someErrors, 0, 0, countTFilez/filesElected)
            prevMSGdisplay := A_TickCount
         }

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, file2rem, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save=file2rem || newFileName="" || newFileName=A_Space)
         {
            skippedFiles++
            Continue
         }

         thisFileExists := 0
         If (PreserveDateTimeOnSave=1)
         {
            FileGetTime, originalMtime, %file2save%, M
            FileGetTime, originalCtime, %file2save%, C
         }

         If (FileExist(file2save) && !FolderExist(file2save))
         {
            thisFileExists := 1
            file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
            If !file2save
            {
               skippedFiles++
               Continue
            } Else If (file2save="abort")
            {
               abandonAll := 1
               Break
            }
         }

         If (thisFileExists=1)
         {
            If (performOverwrite=1 && objuTemp.renamingCount!=1)
            {
               overwrittenFiles++
               FileSetAttrib, -R, %file2save%
               Sleep, 1
               FileRecycle, %file2save%
               If ErrorLevel
                  wasError++
               Sleep, 1
            } Else If (performOverwrite!=2)
            {
               skippedFiles++
               Continue
            }
         }

         FileSetAttrib, -R, %file2rem%
         Sleep, 1
         FileMove, %file2rem%, %file2save%
         If ErrorLevel
         {
            failedFiles++
            wasError++
         } Else
         {
            updateDates := 1
            If (originalMtime && PreserveDateTimeOnSave=1)
            {
               Sleep, 0
               FileSetTime, % originalMtime, % file2save, M
               FileSetTime, % originalCtime, % file2save, C
               updateDates := 0
            } 

            filezRenamed++
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     someErrors := ""
     If (SLDtypeLoaded=3)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           someErrors .= "Failed to commit changes to the SQL database`n"
     }

     If (failedFiles>0)
        someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
     If (skippedFiles>0)
        someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
     If (overwrittenFiles>0)
        someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

     watchFolderDetails := ""
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(100)
     If (abandonAll=1)
        showTOOLtip("Operation aborted. " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files were renamed" someErrors)
     Else
        showTOOLtip("Finished renaming " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files" someErrors)
     SetTimer, ResetImgLoadStatus, -50
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  }
}

RecentMultiRenamesManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentMultiRenameEntries()
  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>35)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentMultiRename, E%countItemz%
  }
}

EraseMultiRenameHisto() {
  IniDelete, % mainRecentsFile, RecentMultiRename
  CloseWindow()
  Sleep, 1
  PanelRenameThisFile()
}

PanelfolderThanEraseThumbsCache() {
   If AnyWindowOpen
      Return

   fakeWinCreator(11, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Clear cached thumbnails: " appTitle, "Erase thumbnails cached older than... (in days)", "&Clean old cache|&Empty entire cache|C&ancel", 3, "trash", "&Always cache generated thumbnails", enableThumbsCaching, 0, "limit3 number -multi", 0)
   remCacheOldDays := Trimmer(msgResult.edit)
   If InStr(msgResult.btn, "old")
   {
      enableThumbsCaching := msgResult.check
      If !remCacheOldDays
         SetTimer, PanelfolderThanEraseThumbsCache, -150 ; allows for this execution line to cease peacefully ^_^ 
      Else
         EraseThumbsCache("daysITis", remCacheOldDays)
   } Else If InStr(msgResult.btn, "entire")
   {
      enableThumbsCaching := msgResult.check
      EraseThumbsCache()
   }
}

defineSQLdbSort() {
   reorder := StrLen(prevFilesSortMode)>3 ? "z" prevFilesSortMode ";" : ";"
   If InStr(reorder, "fsize")
      defaultSort := "File size"
   Else If InStr(reorder, "imgfolder, imgfile;")
      defaultSort := "Path and name"
   Else If InStr(reorder, "imgfolder;")
      defaultSort := "Folder path"
   Else If InStr(reorder, "zimgfile;")
      defaultSort := "File name"
   Else If InStr(reorder, "fmodified")
      defaultSort := "Modified date"
   Else If InStr(reorder, "fcreated")
      defaultSort := "Created date"
   Else If InStr(reorder, "imgwidth")
      defaultSort := "Image width"
   Else If InStr(reorder, "imgheight")
      defaultSort := "Image height"
   Else If InStr(reorder, "imgmegapix")
      defaultSort := "Megapixels"
   Else If InStr(reorder, "imgframes")
      defaultSort := "Frames / pages"
   Else If InStr(reorder, "imgwhratio")
      defaultSort := "Aspect ratio [W/H]"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgavg")
      defaultSort := "Histogram average"
   Else If InStr(reorder, "imgmedian")
      defaultSort := "Histogram median"
   Else If InStr(reorder, "imghrms")
      defaultSort := "Histogram RMS"
   Else If InStr(reorder, "imghmode")
      defaultSort := "Histogram mode"
   Else If InStr(reorder, "imghpeak")
      defaultSort := "Histogram max [range]"
   Else If InStr(reorder, "imghlow")
      defaultSort := "Histogram min [range]"
   Else If InStr(reorder, "imghrange")
      defaultSort := "Histogram range"
   Else If InStr(reorder, "imghminu")
      defaultSort := "Histogram minimum"
   Else If (StrLen(prevFilesSortMode)>2 && !Instr(reorder, "imgidu"))
      defaultSort := prevFilesSortMode
   Else 
      defaultSort := "None/manual"

   Return defaultSort
}

MenuMoveMarkedEntries() {
    EntryMarkedMoveIndex := 1
    moveMarkedEntryNow(currentFileIndex, "move")
}

moveMarkedEntryNow(indexu, modus:=0) {
   If (thumbsDisplaying!=1 || maxFilesIndex<2)
      Return

   If !isNumber(indexu)
      indexu := currentFileIndex

   If !EntryMarkedMoveIndex
   {
      EntryMarkedMoveIndex := indexu
   } Else If (EntryMarkedMoveIndex=indexu)
   {
      EntryMarkedMoveIndex := 0
   } Else If isNumber(EntryMarkedMoveIndex)
   {
      If (modus="move")
         reorderIndexEntryManually(EntryMarkedMoveIndex, indexu)
      Else
         switchIndexEntries(EntryMarkedMoveIndex, indexu)

      ; currentFileIndex := EntryMarkedMoveIndex
      EntryMarkedMoveIndex := 0
   }

   mainGdipWinThumbsGrid()
}

reorderIndexEntryManually(oldIndex, newFileIndex)  {
   Static countu := 0
   getSelectedFiles(0, 1)
   If markedSelectFile
   {
      newArrayu := []
      Loop, % maxFilesIndex
      {
          If resultedFilesList[A_Index, 2]
          {
             thisCounter++
             newArrayu[thisCounter] := resultedFilesList[A_Index]
          }
      }

      finalArrayu := []
      mainIndex := thisIndex := firstu := 0
      Loop, % maxFilesIndex
      {
          If (A_Index=newFileIndex)
          {
             Loop, % newArrayu.Count()
             {

                thisIndex++
                mainIndex++
                finalArrayu[mainIndex] := newArrayu[thisIndex]
                If !firstu
                   firstu := mainIndex
             }
          }

          If !resultedFilesList[A_Index, 2]
          {
             mainIndex++
             finalArrayu[mainIndex] := resultedFilesList[A_Index]
          }
      }

      resultedFilesList := []
      resultedFilesList := finalArrayu.Clone()
      currentFileIndex := firstu ? firstu : newFileIndex
   } Else
   {
      old := resultedFilesList.RemoveAt(oldIndex)
      resultedFilesList.InsertAt(newFileIndex, old)
      currentFileIndex := newFileIndex
   }

   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [oldIndex, resultedFilesList[oldIndex, 1]]
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (SLDtypeLoaded=3 && countu<5)
   {
      countu++
      showTOOLtip("Reordering of index entries is temporary.`nThe changes are not saved in the database.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

switchIndexEntries(newFileIndex, oldIndex) {
   If (SLDtypeLoaded=3)
   {
      SQLstr := "UPDATE images SET imgidu=999999999 WHERE imgidu=" newFileIndex ";"
      If activeSQLdb.Exec(SQLStr)
      {
         SQLstr := "UPDATE images SET imgidu=" newFileIndex " WHERE imgidu=" oldIndex ";"
         If activeSQLdb.Exec(SQLStr)
         {
            SQLstr := "UPDATE images SET imgidu=" oldIndex " WHERE imgidu=999999999;"
            If !activeSQLdb.Exec(SQLStr)
            {
               addJournalEntry("Failed to change index entry position in the SQL database.")
               Return
            } ; Else ToggleDBdefaultSQLsort()
         }
      }
   }

   tempA := resultedFilesList[oldIndex, 1]
   tempB := resultedFilesList[newFileIndex, 1]
   ; ToolTip, % tempA "`n" tempB "`n" oldIndex "===" newFileIndex , , , 2
   resultedFilesList[oldIndex, 1] := tempB
   resultedFilesList[newFileIndex, 1] := tempA
   If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
   {
      tempA := bckpResultedFilesList[filteredMap2mainList[oldIndex], 1]
      tempB := bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1]
      bckpResultedFilesList[filteredMap2mainList[oldIndex], 1] := tempB
      bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1] := tempA
   }

   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   currentFileIndex := oldIndex
   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [newFileIndex, resultedFilesList[newFileIndex, 1]]
   dummyTimerDelayiedImageDisplay(100)
}

PanelUpdateThisFileIndex(dummy:=0) {
    Global newFileName
    If (currentFileIndex=0)
       Return

   imgPath := getIDimage(currentFileIndex)
   fakeWinCreator(21, A_ThisFunc, 1)
   sqlSort := defineSQLdbSort()
   friendlyIndex := (maxFilesIndex>1) ? currentFileIndex "|" : ""
   If (!InStr(sqlSort, "none") && SLDtypeLoaded=3)
      friendlyIndex := ""

   If friendlyIndex
      msgInfos := "`n`nYou can type a new index number before | to move this entry elsewhere in the list."

   msgResult := msgBoxWrapper("panelu|Update files list index entry: " appTitle, "Please type the new file path and name.`nCurrent index: " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) "." msgInfos, "&Update entry|&Erase entry|&Browse file|C&ancel", 1, "modify-entry", 0, 0, 0, "limit9050", friendlyIndex imgPath)
   If InStr(msgResult.btn, "update")
   {
      newFileName := Trimmer(msgResult.edit)
      If (newFileName=imgPath) || (newFileName=currentFileIndex "|" imgPath)
         Return

      If askAboutFileSave(" and the current index entry will be updated")
         Return

      If (posu := InStr(newFileName, "|"))
      {
         newFileIndex := SubStr(newFileName, 1, posu - 1)
         newFileIndex := StrReplace(newFileIndex, ".")
         newFileIndex := StrReplace(newFileIndex, ",")
         If !isNumber(newFileIndex)
            newFileIndex := 0
         Else
            newFileIndex := clampInRange(newFileIndex, 1, maxFilesIndex)
 
         If (newFileIndex=currentFileIndex || maxFilesIndex<2)
            newFileIndex := 0
 
         newFileName := SubStr(newFileName, posu + 1)
         newFileName := Trimmer(newFileName)
      }

      If (!newFileName && maxFilesIndex>1)
      {
         remCurrentEntry(0)
         Return
      } Else If (newFileName!=imgPath && newFileName)
         r := UpdateIndexBTNaction(newFileName, currentFileIndex)

      If (!r && newFileName!=imgPath && newFileName)
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      } Else If (newFileIndex!=currentFileIndex && newFileIndex && friendlyIndex)
         switchIndexEntries(newFileIndex, currentFileIndex)
   } Else If (InStr(msgResult.btn, "erase") && maxFilesIndex>1)
   {
      If askAboutFileSave(" and the current index entry will be erased")
         Return

      remCurrentEntry(0)
   } Else If InStr(msgResult.btn, "browse")
      BrowseReplaceIndexEntry()
   Else If (dummy="reopen")
      PanelRenameThisFile()
}

PanelBrowseAudioAnnotation() {
    If (currentFileIndex=0 || SLDtypeLoaded!=3 || AnyWindowOpen)
       Return

   fakeWinCreator(38, A_ThisFunc, 1)
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
   AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
   editFieldAudioFileu := StrLen(AudioFileu)>3 ? AudioFileu : OutDir "\" OutNameNoExt ". WAV or MP3 or WMA"

   msgResult := msgBoxWrapper("panelu|Associate audio file with image: " appTitle, "Please type or browse the file path of an audio file to associate with the current image.", "&Update entry|&Browse file|&Disassociate|C&ancel", 1, "audio-file", 0, 0, 0, "limit9050", editFieldAudioFileu)
   If InStr(msgResult.btn, "update")
   {
      AudioFileu := Trimmer(msgResult.edit)
      ; If InStr(AudioFileu, OutDir "\" OutNameNoExt ".") || !FileExist(AudioFileu)
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         showTOOLtip("ERROR: Incorrect file path, inexistent audio file or access denied:`n" OutFileName "`n" OutDir "\")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelBrowseAudioAnnotation, -150
         Return
      }

      updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
   } Else If InStr(msgResult.btn, "disassociate")
   {
      updateSQLdbEntryCaption(imgPath, "", "imgAudio")
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Audio files"] := "*.wav;*.mp3;*.wma"
      startPath := AudioFileu ? AudioFileu : imgPath
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse sound file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
      }
      SetTimer, PanelBrowseAudioAnnotation, -150
   }
}

PanelQuickSearchMenuOptions() {
    If (drawingShapeNow=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: -MaximizeBox +ToolWindow -MinimizeBox +Owner%PVhwnd% hwnd%hquickMenuSearchWin%
    Gui, QuickMenuSearchGUIA: Margin, 10, 10
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    btnWid := 105
    txtWid := 360
    lstWid := 399
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Edit, x15 y15 Section -multi w%lstWid% gPopulateQuickMenuSearch vuserQuickMenusEdit +hwndhEditA, % userQuickMenusEdit
    Gui, Add, Button, x+2 w1 h%thisBtnHeight% -TabStop Default gGoQuickSearchAction, &Execute
    Gui, Add, ListView, xs y+0 w%lstWid% r12 Grid -multi gLVGoQuickSearchAction vLViewMetaD AltSubmit, X|Action|Shortcut|Menu|Keywords|Function|#|Score
    ; Gui, Add, Button, x+5 wp hp gBtnCloseWindow, C&lose
    VisibleQuickMenuSearchWin := 1
    repositionWindowCenter("QuickMenuSearchGUIA", hquickMenuSearchWin, PVhwnd, "Quick options search")
    PopulateQuickMenuSearch()
}

LVGoQuickSearchAction(a, b, c) {

   focusEdit := (b="k" && isInRange(c, 33, 40)) ? 0 : 1
   bfocusEdit := RegExMatch(b, "i)^(normal|s|f|i|c|d|colclick|right)") ? 1 : 0
   If (b="K" && c=112 && !AnyWindowOpen)
   {
      Gosub, QuickMenuSearchGUIAGuiClose
      HelpWindow()
   } Else If (b="K" && c=32) || (b="DoubleClick")
   {
      GoQuickSearchAction()
   } Else If (bfocusEdit!=1 && focusEdit=1)
   {
      ; ToolTip, % a "=" b "=" c , , , 2
      GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
   }
}

GoQuickSearchAction() {
   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LViewMetaD
   RowNumber := LV_GetNext(0, "F")
   If !RowNumber
      Return

   LV_GetText(funcu, RowNumber, 6)
   If IsFunc(funcu)
   {
      Gosub, QuickMenuSearchGUIAGuiClose
      Sleep, 5
      %funcu%()
   } Else If IsLabel(funcu)
   {
      Gosub, QuickMenuSearchGUIAGuiClose
      Sleep, 5
      Gosub, %funcu%
   } Else
   {
      showTOOLtip("ERROR: Found no such function in the code to execute:`n" funcu "()")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

QuickMenuSearchGUIAGuiClose:
QuickMenuSearchGUIAGuiEscape:
   Gui, QuickMenuSearchGUIA: Destroy
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   hquickMenuSearchWin := ""
   VisibleQuickMenuSearchWin := 0
Return


EM_SETSEL(hCtrl, s1:=0, s2:="") {
   s2 := (s2="") ? s1 : s2
   r:= DllCall("SendMessage", "Ptr", hCtrl, "UInt", 0xB1, "Int", s1, "Int", s2)      ; EM_SETSEL
   Return r
}

PopulateQuickMenuSearch(a:=0, b:=0, c:=0) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, PopulateQuickMenuSearch, -150
      Return
   }

   deleteMenus()
   mustPreventMenus := 1
   BuildMainMenu("forced")
   If (imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add", "&Large UI fonts", "ToggleLargeUIfonts", "disability handicap eyes eyesight large display")
      kMenu("PVmenu", "Add", "Increase viewport text size`t+", "MenuChangeZoomPlus", "disability handicap eyes eyesight large")
      kMenu("PVmenu", "Add", "Decrease viewport text size`t-", "MenuChangeZoomMinus", "disability handicap eyes eyesight large")
      keyword := (showMainMenuBar=1) ? " hide" : " display"
      kMenu("PVmenu", "Add", "Show &quick bar`tF10", "ToggleQuickBaru", "toolbar" keyword)
      keyword := (ShowAdvToolbar=1) ? "hide" : "display"
      kMenu("PVmenu", "Add", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
      If (ShowAdvToolbar=1)
         kMenu("PVmenu", "Check", "Show &toolbar`tShift+F10", "toggleAppToolbar")

      kMenu("PVmenu", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      kMenu("PVmenu", "Add", "Cop&y file path(s) as text`tShift+C", "CopyImagePath", "clipboard")
      kMenu("PVmenu", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")
      kMenu("PVmenu", "Add", "&Explore the containing folder`tCtrl+E", "OpenThisFileFolder", "external")
      kMenu("PVmenu", "Add", "&Apply gamma correction", "toggleImgEditGammaCorrect")
      If (userimgGammaCorrect=1)
         kMenu("PVmenu", "Check", "&Apply gamma correction")
      If (PrefsLargeFonts=1)
         kMenu("PVmenu", "Check", "&Large UI fonts")
      If (showMainMenuBar=1)
         kMenu("PVmenu", "Check", "Show &quick bar`tF10")
   } Else
      kMenu("PVmenu", "Add", "&Close everything`tCtrl+F4", "closeDocuments")

   BuildSecondMenu()
   objs := kMenu(0, "give", 0)
   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LViewMetaD
   GuiControlGet, userQuickMenusEdit
   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   If InStr(userQuickMenusEdit, "") ; handle ctrl+backspace
   {
      lol := ""
      userQuickMenusEdit := StrReplace(userQuickMenusEdit, A_Space "", "" A_Space)
      Loop, Parse, userQuickMenusEdit, %A_Space%
      {
         If !InStr(A_LoopField, "")
            lol .= A_LoopField A_Space
         Else
            posu := StrLen(lol)
      }
      userQuickMenusEdit := lol
      GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % lol
      EM_SETSEL(hEditA, posu, posu)
   }

   editF2 := StrSplit(userQuickMenusEdit, A_Space)
   mainList := objs[1]
   groups := objs[3]
   thisList := new hashtable()
   LV_Delete()
   matches := score := 0
   Loop, % mainList.Count()
   {
      score := 0
      groupu := mainList[A_Index, 6]
      zgrupu := Trimmer(groups[groupu, 1])
      If (zgrupu && groups[groupu, 2])
      {
         zkl := groups[groupu, 2]
         If (zkl && groups[zkl, 1])
         {
            zgrupu .= " \ " Trimmer(groups[zkl, 1])
            xkl := groups[zkl, 2]
            If (xkl && groups[xkl, 2])
               zgrupu .= " \ " Trimmer(groups[xkl, 1])
         }
      }

      groupu := zgrupu ? " \ " zgrupu : " \ " groupu
      groupu := StrReplace(groupu, " \ PVmenu")
      labelu := Trimmer(mainList[A_Index, 1])
      keywords := mainList[A_Index, 3]
      funcu := mainList[A_Index, 2]
      zlu := labelu groupu keywords StrReplace(funcu, "menu")
      haha := StrSplit(zlu, A_Space)
      If userQuickMenusEdit
      {
         offsetu := 0
         Loop, % editF2.Count()
         {
            thisWord := editF2[A_Index]
            If !thisWord
               Continue

            matches := 0
            If InStr(haha[A_Index], thisWord)
               score += 15

            Loop, % haha.Count()
            {
               userWord := haha[A_Index]
               If !userWord
                  Continue

               offsetu += 0.006
               score += fuzzybit(thisWord, userWord, 0.85 + offsetu, exactMatch)
               matches += exactMatch
            }

            If (matches>=editF2.count())
            {
               ; ToolTip, % matches , , , 2
               score += matches*2
            }
         }
         If (score<0.80)
            Continue
      }

      If mainList[A_Index, 4]
      {
         kbdu := mainList[A_Index, 7]
         xu := mainList[A_Index, 5] ? "X" : ""
         If !thisList[funcu labelu]
         {
            thisList[funcu labelu] := 1
            LV_Add(A_Index, xu, labelu groupu, kbdu, StrReplace(groupu, " \ ", "\"), keywords, funcu, A_Index, Round(score*100))
         }
      }
   }
   groups := ""
   thisList := ""
   mainList := ""
   LV_ModifyCol(7, "Integer")
   LV_ModifyCol(8, "Integer")
   If editF2
      LV_ModifyCol(8, "SortDesc")
   Else
      LV_ModifyCol(2, "Sort")

   LV_Modify(1, "Select Vis Focus")
   thisList := ""
   mustPreventMenus := 0
   Loop, 8
       LV_ModifyCol(A_Index, "AutoHdr Left")

   lastInvoked := A_TickCount
}

fuzzybit(fuzz, master, limitu, ByRef exactMatch) {
/*
Name: fuzzybit
Version 1.0 (Thursday, April 23, 2020)
Created: Thursday, April 23, 2020
Author: tidbit

Description:
   a loose fuzzy search. 

   fuzz   = string to look for, in order
   master = where to look in
   
   returns a percentage. if half of the letters we found in the proper order, returns 0.5
   fuzzybit("abc", "abc") = 1.0
   fuzzybit("aac", "abc") = 0.6667 ; contains the 'a' and 'c' in proper order, but no 'b'
   fuzzybit("bac", "abc") = 0.6667 ; all the letters exist, but not in a proper order

out:="abc `t abc`t=`t" fuzzybit("abc", "abc")
. "`nalffp `t A_LoopFileFullPath`t=`t" fuzzybit("alffp", "A_LoopFileFullPath")
. "`nalffd `t A_LoopFileFullPath`t=`t" fuzzybit("alffd", "A_LoopFileFullPath")
msgbox % fuzzybit("aloo", "A_LoopFileFullPath")
msgbox % fuzzybit("aloog", "A_LoopFileFullPath")
msgbox % fuzzybit("alog", "A_LoopFileFullPath")
; modified by Marius Șucan   
*/

   score := 0, posu := 1
   exactMatch := 0
   If (StrLen(fuzz)=1)
   {
      Return (ST_Count(master, fuzz)+1)/StrLen(master)
   } Else If (master=fuzz)
   {
      exactMatch := 5
      score := 20
   } Else If RegExMatch(master, "i)^(" fuzz ")")
   {
      exactMatch := 0.1
      score := 15
   } Else If InStr(master, fuzz)
   {
      score := 6
   }

   If (ST_Count(master, fuzz)>1)
      score += 0.2

   If (exactMatch=5 || score>7)
      Return score

   ; ToolTip, % "s=" score , , , 2
   for k, char in StrSplit(fuzz)
   {
      segment := substr(master, posu)
      foundPos := inStr(segment, char)
      if (foundPos>0)
      {
         master := segment
         score += 1
         posu := foundPos+1
         continue ; we found a match, check the next letter to find
      }
   }

   r := score/strLen(fuzz)
   If (r<limitu)
      r := 0
 
   return r
}


PanelSetSlidesMusic() {
   If !CurrentSLD
      Return

   fakeWinCreator(65, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate song with slideshow: " appTitle, "Please type or browse the file path of an audio file to associate with the current slideshow / files list. The selected file will be played during the slideshow.", "&Update|&Browse file|&Disassociate|&Test|&Close", 1, "audio-file", 0, 0, 0, "limit9050", SlidesMusicSong)
   AudioFileu := Trimmer(msgResult.edit)
   If (InStr(msgResult.btn, "update") && audioFileu)
   {
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         msgBoxWrapper(appTitle ": ERROR", "ERROR: Incorrect file path, inexistent audio file or access denied:`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         ; SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelSetSlidesMusic, -150
         Return
      }
      If (SlidesMusicSong!=AudioFileu)
         currentFilesListModified := 1

      zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      SlidesMusicSong := AudioFileu
      autoPlaySlidesAudio := 1
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
   } Else If (InStr(msgResult.btn, "disassociate") || (InStr(msgResult.btn, "update") && !audioFileu))
   {
      If StrLen(SlidesMusicSong)>3
         currentFilesListModified := 1
      SlidesMusicSong := ""
      autoPlaySlidesAudio := 0
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music set to: NONE")
   } Else If (InStr(msgResult.btn, "test") && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      startSlidesMusicNow()
      If hSNDsong
      {
         milisec := MCI_Length(hSNDsong)
         lenghtu := MCI_ToHHMMSS(milisec)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Currently playing: " OutFileName " ( " lenghtu " ).`n`nPlease confirm you can hear the audio file.", 4, 0, "question")
         StopMediaPlaying(1)
         If (msgResult="no")
         {
            SlidesMusicSong := ""
            autoPlaySlidesAudio := 0
            saveMusicSlideInfos()
            SetTimer, PanelSetSlidesMusic, -120
            Return
         }
      } Else msgBoxWrapper(appTitle ": ERROR", "ERROR: Unable to properly decode the audio file.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
      SetTimer, PanelSetSlidesMusic, -120
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Audio files"] := "*.wav;*.mp3;*.wma"
      startPath := StrLen(SlidesMusicSong)>3 ? SlidesMusicSong : CurrentSLD
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse music file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If (SlidesMusicSong!=AudioFileu)
            currentFilesListModified := 1

         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         SlidesMusicSong := AudioFileu
         autoPlaySlidesAudio := 1
         saveMusicSlideInfos()
         showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
      }
      SetTimer, PanelSetSlidesMusic, -150
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

saveMusicSlideInfos() {
   If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
   {
      INIaction(1, "SlidesMusicSong", "General")
      INIaction(1, "autoPlaySlidesAudio", "General")
      currentFilesListModified := 0
   } Else If (SLDtypeLoaded=3)
   {
      IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
      IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
      currentFilesListModified := 0
   } Else currentFilesListModified := 1
}

BrowseReplaceIndexEntry() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   ; pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn3 ")"
   ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"

   patternObj := {}
   patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
   patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4
   imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Replace index entry...", patternObj, chosenOption, 2)
   imgPath := Trimmer(imgPath)
   If !imgPath
   {
      SetTimer, PanelUpdateThisFileIndex, -150
      Return "cancel"
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 25
   If StrLen(imgPath)>3
   {
      zPlitPath(imgPath, 0, OutFileName, SelectedDir)
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      If askAboutFileSave(" and the current index entry will be updated")
         Return

      r := UpdateIndexBTNaction(imgPath, currentFileIndex)
      If !r
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      }
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SingularRenameFile() {
   PanelRenameThisFile("single")
}

askAboutFileCollision(srcFile, destFile, allowSkip, doLastOption, forceOption, ByRef performOverwrite) {
   Static lastOption, useLastOption := 0

   If (doLastOption=3)
   {
      lastOption := useLastOption := 0
      Return
   }

   zPlitPath(srcFile, 0, sOutFileName, sOutDir)
   zPlitPath(destFile, 0, dOutFileName, dOutDir, dfileNamuNoEXT, dFileExt)
   If (doLastOption=2)
      useLastOption := 1
   Else If (doLastOption=1)
      useLastOption := 0

   skipBtn := (allowSkip=1) ? "&Skip file|" : ""
   checkBtn := (allowSkip=1) ? "&Do not prompt again, apply the same option for all the subsequent conflicts" : ""
   If (useLastOption=1 && lastOption)
   {
      msgResult := lastOption
   } Else If !isInRange(forceOption, 1, 3)
   {
      FileGetSize, destFileSizu, % destFile, K
      FileGetSize, srcFileSizu, % srcFile, K
      FileGetTime, srcFileDateM, % srcFile, M
      FileGetTime, destFileDateM, % destFile, M
      FormatTime, srcFileDateM, % srcFileDateM, dddd, d MMMM yyyy, HH:mm
      FormatTime, destFileDateM, % destFileDateM, dddd, d MMMM yyyy, HH:mm
      msgResult := msgBoxWrapper(appTitle ": File name conflict", "SOURCE FILE:`n" sOutFileName "`n" groupDigits(srcFileSizu) " Kilobytes (" srcFileDateM ")`n" sOutDir "\`n`nFile name conflict. Do you want to overwrite the destination file?`n`nDESTINATION FILE:`n" dOutFileName "`n" groupDigits(destFileSizu) " Kilobytes (" destFileDateM ")`n" dOutDir "\", "&Overwrite|&Auto-rename|" skipBtn "C&ancel", 2, "question", checkBtn, doLastOption)
   }

   If IsObject(msgResult)
      useLastOption := msgResult.check

   If (forceOption=1)
      msgResult := "skip"
   Else If (forceOption=2)
      msgResult := "auto-rename"
   Else If (forceOption=3)
      msgResult := "overwrite"

   performOverwrite := 0
   msgR := IsObject(msgResult) ? msgResult.btn : msgResult
   If InStr(msgR, "rename")
   {
      performOverwrite := 2
      Loop
      {
          r := dOutDir "\" dfileNamuNoEXT " [" A_Index "]." dFileExt
          If !FileExist(r)
             Break
      } Until (A_Index>9500)
   } Else If InStr(msgR, "overwrite")
   {
      performOverwrite := 1
      r := destFile
   } Else If InStr(msgR, "skip")
      r := ""
   Else If InStr(msgR, "cancel")
      r := "abort"
   Else
      lastOption := r := msgR := ""

   lastOption := (r="abort") ? "" : msgR
   Return r
}

PanelRenameThisFile(dummy:=0) {
    Global newFileName
    Static doLastOption := 0
    If (currentFileIndex=0)
       Return

    getSelectedFiles(0, 1)
    If (markedSelectFile>1 && dummy!="single")
    {
       PanelMultiRenameFiles()
       Return
    }

    Sleep, 2
    file2rem := StrReplace(getIDimage(currentFileIndex), "||")
    zPlitPath(file2rem, 0, OutFileName, OutDir)
    resultedFilesList[currentFileIndex, 1] := file2rem
    If !FileExist(file2rem)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Sleep, 900
       PanelUpdateThisFileIndex()
       Return
    }

   fakeWinCreator(7, A_ThisFunc, 1)
   undoBtn := FileExist(lastRenameUndo[2]) ? "&Undo previous|" : ""
   msgResult := msgBoxWrapper("panelu|Rename file: " appTitle, "File location:`n" OutDir "\`n`nPlease type the new file name.", "&Rename file|" undoBtn "&Modify index entry|C&ancel", 1, "modify-file", "On file name collision, use previously given answer", doLastOption, 0, "limit9050", OutFileName)
   If InStr(msgResult.btn, "Rename")
   {
      doLastOption := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      file2rem := getIDimage(currentFileIndex)
      zPlitPath(file2rem, 0, OutFileName, OutDir)
      If ((Trimmer(OutFileName)=newFileName) || !newFileName)
         Return

      If askAboutFileSave(" and the current file will be renamed and reloaded")
         Return

      r := RenameBTNaction(Trimmer(msgResult.edit), file2rem, doLastOption + 1)
      If !r 
      {
         Sleep, 100
         PanelRenameThisFile(dummy)
      } Else
      {
         file2rem := getIDimage(currentFileIndex)
         If (resultedFilesList[currentFileIndex, 5]=1)
            ToggleImgFavourites(file2rem, "rem")

         resultedFilesList[currentFileIndex, 5] := 0
         updateMainUnfilteredList(currentFileIndex, 5, 0)
         CreateGuiButton("Undo rename,,undoFileRenameAction", 0, msgDisplayTime//1.5 + 500)
      }
   } Else If InStr(msgResult.btn, "modify")
      PanelUpdateThisFileIndex("reopen")
    Else If InStr(msgResult.btn, "undo")
      undoFileRenameAction()
}

PanelSetThumbColumnOptions() {
    If (thumbsDisplaying!=1 || thumbsListViewMode>1 && thumbsDisplaying=1)
    {
       If (thumbsDisplaying!=1)
          PanelColorsAdjusterWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(40, A_ThisFunc)
    btnWid := 100, btnHeight := 25
    txtWid := slideWid := 210
    txtWid2 := txtWid + 80
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 135
       txtWid2 := txtWid2 + 195
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsVPgrid()
    slideWid2 := txtWid//2
    Global UIthumbsAratio, UIvpImgAlignCenter
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    UIthumbsAratio := thumbsAratio + 1
    Gui, Add, Text, x15 y15 Section w%txtWid2%, Please note, most of the options listed here are shared with the full image view.
    Gui, Add, Text, xs y+15, Flip thumbnails:
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%FlipImgH% vFlipImgH, &horizontally
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%FlipImgV% vFlipImgV, &vertically
    Gui, Add, Text, xs y+15, Highlight images:
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%highlightAlreadySeenImages% vhighlightAlreadySeenImages, &already seen
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%markSearchMatches% vmarkSearchMatches, &matching search query
    Gui, Add, DropDownList, xs y+15 w%txtWid% gupdateUIthumbsView AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|-|Grayscale|Red channel|Green channel|Blue channel|-|Inverted colors|Sepia
    Gui, Add, DropDownList, xs y+5 wp gupdateUIthumbsView AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
    Gui, Add, Checkbox, x+5 hp gupdateUIthumbsView Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    Gui, Add, DropDownList, xs y+5 w%slideWid2% AltSubmit gupdateUIthumbsView Choose%UIthumbsAratio% vUIthumbsAratio, Aspect ratios|Wide (1.81)|Tall (0.48)|Square (1.00)
    Gui, Add, Checkbox, x+10 hp gupdateUIthumbsView Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, &Centered alignment
    Gui, Add, Text, xs y+15 hp +0x200 w%slideWid2%, Thumbnail columns:
    Gui, Add, Edit, x+10 w70 gupdateUIthumbsView number -multi limit3 veditF5, % thumbsColumns
    Gui, Add, UpDown, gupdateUIthumbsView vthumbsColumns Range2-99, % thumbsColumns
    Gui, Add, Text, xs+15 y+7 w%txtWid2%, You can press the + / - keys or Ctrl + Wheel Up / Down to increase or decrease the number of columns.

    If (minimizeMemUsage=1)
       GuiControl, SettingsGUIA: Disable, imgFxMode

    Gui, Add, Button, xs y+25 w90 h%thisBtnHeight% Default gBtnCloseWindow, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Thumbnails options: " appTitle, winPos)
}

updateUIthumbsView() {
   Gui, SettingsGUIA: Default
   GuiControlGet, FlipImgH
   GuiControlGet, FlipImgV
   GuiControlGet, UIthumbsAratio
   GuiControlGet, UIvpImgAlignCenter
   GuiControlGet, usrColorDepth
   GuiControlGet, ColorDepthDithering
   GuiControlGet, imgFxMode
   GuiControlGet, highlightAlreadySeenImages
   GuiControlGet, markSearchMatches
   GuiControlGet, editF5
   thumbsColumns := editF5
   imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   thumbsAratio := clampInRange(UIthumbsAratio - 1, 1, 3)
   defineColorDepth()
   recalculateThumbsSizes()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   ; SetTimer, DeepRefreshThumbsNow, -50
   SetTimer, WriteThumbnailsSettingsPanel, -200
}

WriteThumbnailsSettingsPanel() {
   INIaction(1, "FlipImgH", "General")
   INIaction(1, "FlipImgV", "General")
   INIaction(1, "thumbsAratio", "General")
   INIaction(1, "imageAligned", "General")
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "ColorDepthDithering", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "thumbsColumns", "General")
   INIaction(1, "highlightAlreadySeenImages", "General")
   INIaction(1, "markSearchMatches", "General")
}

PanelSetSystemCores() {
   EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
   fakeWinCreator(41, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Multi-threading options: " appTitle, "Please specify the number of threads to use when generating thumbnails or batch processing files. Maximum allowed threads on this system is " thisSystemCores ".`n`nAfter changing this value, a restart of QPV might be necessary.", "&Apply|&Cancel", 1, "gear", "Allow multi-threaded processing [experimental]", allowMultiCoreMode, 0, "limit2 number", userMultiCoresLimit)
   If InStr(msgResult.btn, "apply")
   {
      allowMultiCoreMode := msgResult.check
      userMultiCoresLimit := Trimmer(msgResult.edit)
      userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
      INIaction(1, "allowMultiCoreMode", "General")
      INIaction(1, "userMultiCoresLimit", "General")
      realSystemCores := userMultiCoresLimit
      If (thumbsDisplaying=1 && thumbsListViewMode=1 && multiCoreThumbsInitGood="n")
         initAHKhThumbThreads()
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSaveSlideShowu() {
    Global usePrevSaveFolder := 0, userDesiredSlideFMT := 1

    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient image files are indexed")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    thisBtnHeight := createSettingsGUI(36, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 360
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "prevFileSavePath", "General", 5)
    userDesiredSlideFMT := (SLDtypeLoaded=3) ? 2 : 1
    If (SLDtypeLoaded=3)
       SLDcacheFilesList := 1

    Gui, Add, Text, x15 y15 Section, Slideshow format:
    Gui, Add, DropDownList, xs y+5 w%EditWid% gUItoggleSLDformat AltSubmit Choose%userDesiredSlideFMT% vuserDesiredSlideFMT, .SLD - Plain-text format|.SLDB - SQLite Database format (file details cached)
    Gui, Add, Checkbox, xs y+10 Checked%SLDcacheFilesList% vSLDcacheFilesList, Cache files list (ensures rapid slideshow loading)`nIf this is left unchecked, only the dynamic folders list will be saved.
    If (SLDtypeLoaded=3)
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList

    Gui, Add, Checkbox, xs y+10 Checked%ForceRegenStaticFolders% vForceRegenStaticFolders, Regenerate static folders list`nThe static folders list enables partial files list later updates
    Gui, Add, Text, xs y+10 w%EditWid%, Regardless of the chosen format, the current %appTitle% settings will be stored.
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       infoThisSLD := "Currently opened: «Favourite images list»."
    Else If (SLDtypeLoaded=2)
       infoThisSLD := "Currently opened: plain-text files list`n" CurrentSLD
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "Currently opened: SQLite database files list`nMost actions applied on the files index are automatically saved. Under rare circumstances resaving is required.`n" CurrentSLD
    Else
       infoThisSLD := "No saved files list currently opened."

    If (SLDtypeLoaded=2 && currentFilesListModified=1)
       infoThisSLD .= "`nFiles list has been modified. The changes are unsaved."

    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Text, xs y+20 w%EditWid%, % infoThisSLD
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNopenPanelDynamicFolderzWindow, &Manage folders
    If (SLDtypeLoaded>1 && FileRexists(CurrentSLD)) || InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       thisDefault := ""
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveCurrentSlideshow, &Save...
       Gui, Add, Button, x+0 hp w35 gBTNsaveSlideshowPanel, &AS
    } Else
    {
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveSlideshowPanel, Save &as
    }

    Gui, Add, Button, x+15 hp w%btnWid2% gBTNhelpSlideshows, &Help
    Gui, Add, Button, x+5 hp wp-5 gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save indexed files list: " appTitle)
    checkDLLfiles()
}

BTNhelpSlideshows() {
    msgBoxWrapper(appTitle ": HELP", "In the plain-text SLD format one can store:`n- QPV settings pertaining to viewport and slideshow options`n- a folders list [so-called «main» folders list]; this is the source of the files list and can be [re]scanned at any time.`n- the actual files list. If it is not cached / present when the SLD is opened, the main folders list will be scanned for images to populate the files list index.`n- a «static» folders list; this list is automatically generated when the SLD is saved based on the indexed files' paths - only if the user chooses to cache the files list. In later sessions, one can rescan any of these folders, allowing users to selectively update the files list whenever needed.`n`nIn addition to all of the above, the SQL-Lite database SLDB format can store:`n- image captions [no need for external text files] and also allows users to attach audio files to image files without the constraint of having them located in the same folder(s) with the image(s).`n- file and image details cache: file size, file date created, modified, image information (resolution, pixel format, histogram details and so on)`n`nThe caching of data facilitates management of large image collections, because files list sorting, image and file statistics are performed MUCH faster once the data is cached. The cached data is stored and reused between sessions and can be generated gradually in multiple QPV sessions.", -1, 0, 0)
}

BTNopenPanelDynamicFolderzWindow() {
    PanelDynamicFolderzWindow("reopen")
}

BTNsaveCurrentSlideshow() {
    BtnCloseWindow()
    Sleep, 1
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       renewFavesListBasedOnIndexList()
    Else If (SLDtypeLoaded=2 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveFilesList(CurrentSLD)
    Else If (SLDtypeLoaded=3 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveDBfilesList(CurrentSLD)
    BtnCloseWindow()
}

UItoggleSLDformat() {
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
    {
       GuiControl, SettingsGUIA: Enable, SLDcacheFilesList
    } Else
    {
       SLDcacheFilesList := 1
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList
       GuiControl, , SLDcacheFilesList, 1
    }
}

BTNsaveSlideshowPanel() {
    Gui, SettingsGUIA: Default
    GuiControlGet, SLDcacheFilesList
    GuiControlGet, userDesiredSlideFMT
    GuiControlGet, ForceRegenStaticFolders
    If (userDesiredSlideFMT=1)
       SaveFilesList()
    Else
       SaveDBfilesList()

    RecentFilesManager(CurrentSLD)
}

FolderExist(filePath) {
   If StrLen(filePath)<4
      Return

   Return InStr(FileExist(filePath), "D")
}

PanelSaveImg() {
    Global userDestinationFolder, editF5, UserCropOnSave, usePrevSaveFolder := 0

    If (thumbsDisplaying=1)
    {
       PanelSaveSlideShowu()
       Return
    }

    If throwErrorNoImageLoaded()
       Return

    thisBtnHeight := createSettingsGUI(35, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    INIaction(0, "userDesireWriteFMT", "General", 2, 1, 16)
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)

    INIaction(0, "prevFileSavePath", "General", 5)
    INIaction(0, "usePrevSaveFolder", "General", 1)
    INIaction(0, "PreserveDateTimeOnSave", "General", 1)
    INIaction(0, "userJpegQuality", "General", 2, 1, 100)

    ; Gui, Add, Text,, Default destination format:
    ; Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    entriesList := StrReplace(recentOpenedFolders(), "`n", "|")
    delim := InStr(entriesList, prevFileSavePath "|") ? "|" : ""
    entriesList := StrReplace(entriesList, prevFileSavePath delim, prevFileSavePath "||")
    If StrLen(entriesList)<4
    {
       usePrevSaveFolder := 0
       GuiControl, Disable, usePrevSaveFolder
    } Else If !InStr(entriesList, "||")
       entriesList .= "|"

    UserCropOnSave := 0
    imgPath := getIDimage(currentFileIndex)
    If (InStr(imgPath, "\temporary memory object\") || !imgPath)
    {
       fileStatus := imgPath "`n`nImage bitmap unsaved to disk."
    } Else
    {
       fileStatus := PathCompact(imgPath, 47)
       If !FileExist(imgPath)
          fileStatus .= "`n`nThe image file no longer seems to exist. It will be recreated on save."
       Else If (currentImgModified=1)
          fileStatus .= "`n`nThe image has been modified. The changes should be saved."
       Else If (currentImgModified=2)
          fileStatus .= "`n`nThe image changes have been saved."
       Else
          fileStatus .= "`n`nThe image has not been modified."
    }


    ; Gui, Add, Checkbox, Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Checkbox, x15 y15 Section Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+7 gTglUsePrevSaveFoderu Checked%usePrevSaveFolder% vusePrevSaveFolder, &Open file dialog in a previous location
    Gui, Add, DropDownList, xp+15 y+7 wp+135 vuserDestinationFolder, % entriesList
    Gui, Add, Text, xs y+15, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Text, xs+15 y+7, This applies only for JPG, JP2, J2K, JXR and WEBP files.
    Gui, Add, Text, xs y+10, Image file status:
    Gui, Add, Text, xp+15 y+7 w%txtWid% +wrap, % fileStatus

    If (editingSelectionNow!=1 || testSelectOutsideImgEntirely(useGdiBitmap()))
       GuiControl, Disable, UserCropOnSave

    If !usePrevSaveFolder
       GuiControl, Disable, userDestinationFolder

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBTNsaveImgPanel, &Save image
    Gui, Add, Button, x+0 h%thisBtnHeight% w35 gBTNsaveBrowseImgPanel, &AS
    Gui, Add, Button, x+15 hp w%btnWid% gBtnCopyImageClip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save image file: " appTitle)
}

PanelBrushTool(dummy:=0, modus:=0) {
    If (thumbsDisplaying=1 || throwErrorNoImageLoaded())
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(64, A_ThisFunc)
    btnWid := 100
    EditWid := 395
    txtWid := 285, slideWid := 155
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 60
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    slideWid2 := slideWid//2
    Global infoBrushAopacity, infoBrushBopacity, infoBrushSize, infoBrushAngle, infoBrushDrying, infoBrushBlurel
    , infoBrushAspectRatio, infoBrushSoftness, infoBrushWetness, PickuBrushToolAcolor, PickuBrushToolBcolor
    , infoBrushStepping, UIbtnBrushColorA, UIbtnBrushColorB, uiBtnSetCloner, infoPasteHue, infoPasteSat
    , infoPasteLight, infoPasteGamma, infoBrushRandomSize, infoBrushRandomSoftness, infoBrushRandomAspectRatio
    , infoBrushRandomAngle, infoBrushRandomPosX, infoBrushRandomPosY, infoBrushRandomHue, infoBrushRandomSat
    , infoBrushRandomLight, infoBrushRandomDark

    ReadSettingsBrushPanel()
    initQPVmainDLL()
    liveDrawingBrushTool := 1
    interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
    thisOpacity := Round((BrushToolAopacity / 255) * 100)
    this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
    If (modus="e" && isNumber(dummy))
    {
       BrushToolType := dummy
       If (BrushToolType=2)
          BrushToolWetness := 0
    } Else If (modus="w" && dummy=2)
    {
       ; wet soft brush
       If (BrushToolWetness<3)
          BrushToolWetness := 10
       BrushToolType := dummy
    } Else If (modus="b" && dummy=5)
    {
       ; blur FX brush
       BrushToolApplyColorFX := 0
       If (BrushToolBlurStrength<5)
          BrushToolBlurStrength := 25
       BrushToolType := dummy
    } Else If (modus="fx" && dummy=5)
    {
       ; colors FX brush
       BrushToolApplyColorFX := 1 
       BrushToolBlurStrength := 0
       BrushToolType := dummy
    }

    Gui, Add, Tab3, AltSubmit vCurrentPanelTab gBtnTabsInfoUpdate, General|Effects options|Randomize
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section AltSubmit gupdateUIbrushTool Choose%BrushToolType% vBrushToolType, Simple solid color|Soft edges brush|Cloner|Eraser|Effects|Smudge|Pinch|Bulge
    ; Gui, Add, Checkbox, x+5 hp gupdateUIbrushTool Checked%BrushToolUseSecondaryColor% vBrushToolUseSecondaryColor , &Use secondary color
    Gui, Add, Checkbox, x+5 hp gupdateUIbrushTool Checked%BrushToolEraserRestore% vBrushToolEraserRestore , Restore pixels opacity
    Gui, Add, Button, xp yp hp wp gBtnSetClonerBrushSource vuiBtnSetCloner, &Define cloner source
    Gui, Add, Text, xs y+10 w35 gBtnToggleBrushColors vUIbtnBrushColorA, [X]
    Gui, Add, Slider, x+5 w%slideWid% gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolAopacity Range1-255, % BrushToolAopacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuBrushToolAcolor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolAcolor% vBrushToolAcolor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoBrushAopacity, %thisOpacity%`%
    Gui, Add, Text, xs y+10 w35 gBtnToggleBrushColors vUIbtnBrushColorB, [X]
    Gui, Add, Slider, x+5 w%slideWid% gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolBopacity Range1-255, % BrushToolBopacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuBrushToolBcolor, P
    Gui, Add, ListView, x+5 hp w60%CCLVO% Background%BrushToolBcolor% vBrushToolBcolor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoBrushBopacity, %this2ndOpacity%`%

    ; Gui, Add, Text, xs y+15 w%slideWid2% vinfoBrushSize, Size: %BrushToolSize%
    Gui, Add, Checkbox, xs y+15 w%slideWid% gupdateUIbrushTool Checked%brushToolDoubleSize% vbrushToolDoubleSize, Diameter: 2000 px
    Gui, Add, Text, x+5 wp vinfoBrushStepping gBTNresetBrushStepu, Stepping: %BrushToolStepping%
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolSize Range2-950, % BrushToolSize
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolStepping Range0-251, % brushToolStepping

    Gui, Add, Text, xs y+10 wp vinfoBrushAspectRatio gBTNresetBrushAspectRatio , Aspect ratio: %BrushToolAspectRatio%
    ; Gui, Add, Text, x+5 wp vinfoBrushAngle gBTNresetBrushAngle, Angle: %BrushToolAngle%° 
    Gui, Add, Checkbox, x+5 wp Checked%BrushToolAutoAngle% vBrushToolAutoAngle gupdateUIbrushTool, Angle: %BrushToolAngle%00° 
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolAspectRatio Range-100-100, % BrushToolAspectRatio
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolAngle Range0-359, % BrushToolAngle

    Gui, Add, DropDownList, xs y+10 wp AltSubmit gupdateUIbrushTool Choose%BrushToolTexture% vBrushToolTexture, Soft circle|Texture 1|Texture 2|Texture 3|Texture 4|Texture 5|Texture 6|Texture 7|Texture 8
    ; Gui, Add, Text, xp yp wp vinfoBrushSoftness, Softness: %BrushToolSoftness%
    Gui, Add, Text, x+5 wp hp vinfoBrushDrying gBTNresetBrushDryer, Dry-out rate: %BrushToolDryingRate%
    Gui, Add, Slider, xs y+2 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolSoftness Range1-100, % BrushToolSoftness
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolDryingRate Range0-20, % BrushToolDryingRate

    Gui, -DPIScale
    Gui, Add, Text, xs y+10 w100 h100 +0x1000 +0xE +hwndhCropCornersPic gPanelsLivePreviewResponder, Brush preview
    Gui, +DPIScale
    Gui, Add, Checkbox, x+10 gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode / deformer option
    Gui, Add, Checkbox, y+10 gupdateUIbrushTool Checked%BrushToolDynamicCloner% vBrushToolDynamicCloner , D&ynamic X/Y source coordinates

    Gui, Tab, 2 ; FX
    Gui, Add, Text, x+15 y+15 Section w%slideWid% gBTNresetBrushBluru vinfoBrushBlurel, Blur intensity: %BrushToolBlurStrength%
    Gui, Add, Text, x+5 wp vinfoBrushWetness gBTNresetBrushWet, Wetness: %BrushToolWetness%
    Gui, Add, Slider, xs y+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolBlurStrength Range0-99, % BrushToolBlurStrength
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolWetness Range0-22, % BrushToolWetness

    ; Gui, Add, Checkbox, xs y+10 gupdateUIbrushTool Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Apply color adjustments
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIbrushTool vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIbrushTool vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteLight, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIbrushTool vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIbrushTool vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, -DPIScale
    Gui, Add, Text, xs y+10 w100 h100 +0x1000 +0xE +hwndhCropCornersPic2 gPanelsLivePreviewResponder, Brush preview
    Gui, +DPIScale
    Gui, Add, Checkbox, x+10 gupdateUIbrushTool Checked%BrushToolApplyColorFX% vBrushToolApplyColorFX, Apply color adjustments

    Gui, Tab, 3 ; randomize

    Gui, Add, Text, x+15 y+15 w%slideWid% vinfoBrushRandomSize gBtnResetBrushRandomSize, Size: %BrushToolRandomSize%
    Gui, Add, Text, x+5 wp vinfoBrushRandomSoftness gBtnResetBrushRandomSoftness, Softness: %BrushToolRandomSoftness%
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomSize Range0-200, % BrushToolRandomSize
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomSoftness Range0-80, % BrushToolRandomSoftness

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomAspectRatio gBtnResetBrushRandomAspectRatio, Aspect ratio: %BrushToolRandomAspectRatio%
    Gui, Add, Text, x+5 wp vinfoBrushRandomAngle gBtnResetBrushRandomAngle, Angle: %BrushToolRandomAngle%° 
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomAspectRatio Range0-80, % BrushToolRandomAspectRatio
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomAngle Range0-150, % BrushToolRandomAngle

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomPosX gBtnResetBrushRandomPosX, Offset X: %BrushToolRandomPosX%
    Gui, Add, Text, x+5 wp vinfoBrushRandomPosY gBtnResetBrushRandomPosY, Offset Y: %BrushToolRandomPosY%
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomPosX Range0-200, % BrushToolRandomPosX
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomPosY Range0-200, % BrushToolRandomPosY

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomHue gBtnResetBrushRandomHue, Hue: %BrushToolRandomHue%
    Gui, Add, Text, x+5 wp vinfoBrushRandomSat gBtnResetBrushRandomSat, Saturation: %BrushToolRandomSat%
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomHue Range0-180, % BrushToolRandomHue
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomSat Range0-90, % BrushToolRandomSat

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomLight gBtnResetBrushRandomLight, Lightness: %BrushToolRandomLight%
    Gui, Add, Text, x+5 wp vinfoBrushRandomDark gBtnResetBrushRandomDark, Darkness: %BrushToolRandomDark%
    Gui, Add, Slider, xs y+1 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomLight Range0-90, % BrushToolRandomLight
    Gui, Add, Slider, x+5 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolRandomDark Range0-90, % BrushToolRandomDark
    Gui, Add, Text, xs y+10, Please read the help section for more details.

    Gui, Tab 
    btnWid := (PrefsLargeFonts=1) ? 90 : 55
    Gui, Add, Button, xs-5 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 hp w%btnWid% gBtnHelpBrushes, &Help
    Gui, Add, Button, x+5 hp wp-5 gBtnCloseWindow, C&lose
    Gui, Add, DropDownList, x+5 wp+60 gupdateUIbrushTool AltSubmit Choose%BrushToolOutsideSelection% vBrushToolOutsideSelection, Ignore selection|Paint inside|Paint outside
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Brush tool options: " appTitle)
    SetTimer, updateUIbrushTool, -125
}

BtnHelpBrushes() {
   msgBoxWrapper(appTitle ": HELP", "The brushes tool panel offers 8 distinct types of brushes and each customizable in its own ways. You can use keyboard shortcuts to switch brush types or control their settings when the main window is active. Please see the keyboard shortcuts help panel for more details.`n`nPlease note, the deformer brushes (smudge, pinch and bulge) give best results when the brush softness is set to about 45% and opacity 100%. These brushes may give undesired results when working with images with non-opaque pixels.`n`nBy setting stepping option to a low value, the application may freeze at times, while it paints brushes at every given step.`n`nSome of the brush randomize options apply only to some types of brushes. They might apply at the beginning of a brush stroke or continously during painting, based on brush settings.", -1, 0, 0)
}

ToggleBrushColors() {
   BtnToggleBrushColors("infoz")
}

BtnToggleBrushColors(dummy:=0) {
   ; If (BrushToolType!=1 && BrushToolType!=2)
   ;    Return

   BrushToolUseSecondaryColor := !BrushToolUseSecondaryColor
   If (AnyWindowOpen=64)
   {
      updateUIbrushTool()
   } Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      updateUIpasteInPlacebrushTool()
   } Else If (AnyWindowOpen=23)
   {
      thisA := FillArea2ndColor
      thisB := FillAreaColor
      thisAop := FillArea2ndOpacity
      thisBop := FillAreaOpacity
      FillAreaColor := thisA
      FillArea2ndColor := thisB
      FillAreaOpacity := thisAop
      FillArea2ndOpacity := thisBop
      GuiControl, SettingsGUIA: +Background%thisB%, FillArea2ndColor
      GuiControl, SettingsGUIA: +Background%thisA%, FillAreaColor
      GuiControl, SettingsGUIA:, FillArea2ndOpacity, % FillArea2ndOpacity
      GuiControl, SettingsGUIA:, FillAreaOpacity, % FillAreaOpacity
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? FillArea2ndColor : FillAreaColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? FillAreaColor : FillArea2ndColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? FillArea2ndOpacity : FillAreaOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? FillAreaOpacity : FillArea2ndOpacity
   } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
   {
      If (BrushToolAcolor!=DrawLineAreaColor && BrushToolBcolor!=DrawLineAreaColor)
      {
         BrushToolAcolor := DrawLineAreaColor
         BrushToolAopacity := DrawLineAreaOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      GuiControl, SettingsGUIA: +Background%thisA%, DrawLineAreaColor
      GuiControl, SettingsGUIA:, DrawLineAreaOpacity, % thisAop
      DrawLineAreaColor := thisA
      DrawLineAreaOpacity := thisAop
   } Else If (AnyWindowOpen=32)
   {
      thisA := TextInAreaBgrColor
      thisB := TextInAreaFontColor
      TextInAreaFontColor := thisA
      TextInAreaBgrColor := thisB
      thisAop := TextInAreaBgrOpacity
      thisBop := TextInAreaFontOpacity
      TextInAreaFontOpacity := thisAop
      TextInAreaBgrOpacity := thisBop
      GuiControl, SettingsGUIA: +Background%thisA%, TextInAreaFontColor
      GuiControl, SettingsGUIA: +Background%thisB%, TextInAreaBgrColor
      GuiControl, SettingsGUIA:, TextInAreaFontOpacity, % TextInAreaFontOpacity
      GuiControl, SettingsGUIA:, TextInAreaBgrOpacity, % TextInAreaBgrOpacity
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrColor : TextInAreaFontColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaFontColor : TextInAreaBgrColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrOpacity : TextInAreaFontOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaFontOpacity : TextInAreaBgrOpacity
   }

   If (dummy="infoz")
   {
      labelu := (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31) ? "Brush" : "Primary"
      thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      thisColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      moreInfos .= "`nOpacity: " Round(thisOpacity/255*100) "%"
      showTOOLtip(labelu " color: " thisColor moreInfos, "ToggleBrushColors", 1)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } 

   If (ShowAdvToolbar=1)
      updateTlbrColorsSwatch()

   If (imgEditPanelOpened=1 && AnyWindowOpen)
      livePreviewsImageEditing()
}

updateTlbrColorsSwatch() {
   thisHwnd := tlbrIconzList["BTNcolorsSwatch", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   tlbrSetImageIcon("colorz-swatch", thisHwnd, W, H)
}

pointsOnCircle(radius, angle, cx, cy) {
    Static pi := 3.14159265
    obj := []
    angle := angle * (pi /180)   ; Convert from Degrees to Radians
    obj.x := cx + radius * sin(angle)
    obj.y := cy + radius * cos(angle)
    return obj
}

BtnSetClonerBrushSource() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1 || AnyWindowOpen!=64 || !isImgEditingNow())
      Return

   If (BrushToolType!=3)
      toggleBrushTypeCloner()

   liveDrawingBrushTool := 1
   showTOOLtip("Please click inside the image area to set the cloner brush source")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
}

BtnSetTextureSource() {
   If (FillAreaColorMode!=6)
   {
      showTOOLtip("Gradient center was reset")
      alphaMaskOffsetX := alphaMaskOffsetY := 0
      SetTimer, updateUIfillPanel, -150
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return

   }

   showTOOLtip("Please click inside the image area to set the texture source coordinates")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
}

BtnResetBrushRandomSize() {
   BrushToolRandomSize := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSize, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomSoftness() {
   BrushToolRandomSoftness := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSoftness, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomAspectRatio() {
   BrushToolRandomAspectRatio := 0
   GuiControl, SettingsGUIA:, BrushToolRandomAspectRatio, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomAngle() {
   BrushToolRandomAngle := 0
   GuiControl, SettingsGUIA:, BrushToolRandomAngle, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomPosX() {
    BrushToolRandomPosX := 0
    GuiControl, SettingsGUIA:, BrushToolRandomPosX, 0
    SetTimer, updateUIbrushTool, -50
 }

BtnResetBrushRandomPosY() {
    BrushToolRandomPosY := 0
    GuiControl, SettingsGUIA:, BrushToolRandomPosY, 0
    SetTimer, updateUIbrushTool, -50
 }

BtnResetBrushRandomHue() {
   BrushToolRandomHue := 0
   GuiControl, SettingsGUIA:, BrushToolRandomHue, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomSat() {
   BrushToolRandomSat := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSat, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomLight() {
   BrushToolRandomLight := 0
   GuiControl, SettingsGUIA:, BrushToolRandomLight, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomDark() {
   BrushToolRandomDark := 0
   GuiControl, SettingsGUIA:, BrushToolRandomDark, 0
   SetTimer, updateUIbrushTool, -50
}

updateUIbrushTool() {
   Gui, SettingsGUIA: Submit, NoHide
   If (BrushToolType>2)
      BrushToolUseSecondaryColor := 0

   liveDrawingBrushTool := 1
   If (BrushToolUseSecondaryColor=1)
   {
      GuiControl, SettingsGUIA: Enable, PickuBrushToolBcolor
      GuiControl, SettingsGUIA: Enable, BrushToolBopacity
      GuiControl, SettingsGUIA: Enable, BrushToolBcolor
      GuiControl, SettingsGUIA: Enable, infoBrushBopacity
      GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
      GuiControl, SettingsGUIA: Disable, BrushToolAopacity
      GuiControl, SettingsGUIA: Disable, BrushToolAcolor
      GuiControl, SettingsGUIA: Disable, infoBrushAopacity
      GuiControl, SettingsGUIA:, UIbtnBrushColorB, [X]
      GuiControl, SettingsGUIA:, UIbtnBrushColorA, [-]
      allGood := 0
   } Else
   {
      GuiControl, SettingsGUIA:, UIbtnBrushColorB, [-]
      GuiControl, SettingsGUIA:, UIbtnBrushColorA, [X]
      GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
      GuiControl, SettingsGUIA: Enable, BrushToolAopacity
      GuiControl, SettingsGUIA: Enable, BrushToolAcolor
      GuiControl, SettingsGUIA: Enable, infoBrushAopacity
      GuiControl, SettingsGUIA: Disable, PickuBrushToolBcolor
      GuiControl, SettingsGUIA: Disable, BrushToolBopacity
      GuiControl, SettingsGUIA: Disable, BrushToolBcolor
      GuiControl, SettingsGUIA: Disable, infoBrushBopacity
      allGood := 1
   }

   If (BrushToolType>2)
   {
      GuiControl, SettingsGUIA: Disable, UIbtnBrushColorB
      GuiControl, SettingsGUIA: Disable, UIbtnBrushColorA
      GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
      GuiControl, SettingsGUIA: Disable, BrushToolAcolor
   } Else
   {
      GuiControl, SettingsGUIA: Enable, UIbtnBrushColorB
      GuiControl, SettingsGUIA: Enable, UIbtnBrushColorA
      If (allGood=1)
      {
         GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
         GuiControl, SettingsGUIA: Enable, BrushToolAcolor
      }
   }

   If (BrushToolType<=2 || BrushToolType>=6)
   {
      GuiControl, SettingsGUIA: Enable, infoBrushWetness
      GuiControl, SettingsGUIA: Enable, BrushToolWetness
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoBrushWetness
      GuiControl, SettingsGUIA: Disable, BrushToolWetness
   }

   If (BrushToolType>=7)
   {
      GuiControl, SettingsGUIA: Disable, infoBrushStepping
      GuiControl, SettingsGUIA: Disable, brushToolStepping
   } Else
   {
      GuiControl, SettingsGUIA: Enable, infoBrushStepping
      GuiControl, SettingsGUIA: Enable, brushToolStepping
   }

   If (BrushToolType=2 || BrushToolType=3)
      GuiControl, SettingsGUIA: Disable, BrushToolOverDraw
   Else
      GuiControl, SettingsGUIA: Enable, BrushToolOverDraw

   tehLabel := (BrushToolType>=6) ? "&Auto-scale deformer" : "&Airbrush mode"
   GuiControl, SettingsGUIA: Text, BrushToolOverDraw, %tehLabel%

   If (BrushToolType=3 || BrushToolType=5)
   {
      GuiControl, SettingsGUIA: Enable, infoBrushBlurel
      GuiControl, SettingsGUIA: Enable, BrushToolBlurStrength
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoBrushBlurel
      GuiControl, SettingsGUIA: Disable, BrushToolBlurStrength
   }

   If (BrushToolType=1)
   {
      ; GuiControl, SettingsGUIA: Disable, infoBrushSoftness
      GuiControl, SettingsGUIA: Disable, BrushToolSoftness
   } Else
   {
      ; GuiControl, SettingsGUIA: Enable, infoBrushSoftness
      GuiControl, SettingsGUIA: Enable, BrushToolSoftness
   }

   If (BrushToolType=3)
      GuiControl, SettingsGUIA: Show, uiBtnSetCloner
   Else
      GuiControl, SettingsGUIA: Hide, uiBtnSetCloner

   If (BrushToolType=3 || BrushToolType=8)
      GuiControl, SettingsGUIA: Enable, BrushToolDynamicCloner
   Else
      GuiControl, SettingsGUIA: Disable, BrushToolDynamicCloner

   tehLabel := (BrushToolType=8) ? "Bulge out&wards more" : "D&ynamic X/Y source coordinates"
   GuiControl, SettingsGUIA: Text, BrushToolDynamicCloner, %tehLabel%

   If (BrushToolType=4)
      GuiControl, SettingsGUIA: Show, BrushToolEraserRestore
   Else
      GuiControl, SettingsGUIA: Hide, BrushToolEraserRestore

   If (BrushToolType=3 || BrushToolType=5)
      GuiControl, SettingsGUIA: Enable, BrushToolApplyColorFX
   Else
      GuiControl, SettingsGUIA: Disable, BrushToolApplyColorFX

   If (BrushToolAutoAngle=1)
      GuiControl, SettingsGUIA: Disable, BrushToolAngle
   Else
      GuiControl, SettingsGUIA: Enable, BrushToolAngle

   actu2 := (BrushToolApplyColorFX=1 && (BrushToolType=3 || BrushToolType=5)) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu2, PasteInPlaceLight
   GuiControl, % actu2, PasteInPlaceGamma
   GuiControl, % actu2, PasteInPlaceHue
   GuiControl, % actu2, PasteInPlaceSaturation
   GuiControl, % actu2, infoPasteLight
   GuiControl, % actu2, infoPasteGamma
   GuiControl, % actu2, infoPasteHue
   GuiControl, % actu2, infoPasteSat

   thisOpacity := Round((BrushToolAopacity / 255) * 100)
   this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
   theSize := (brushToolDoubleSize!=1) ? "Diameter" : "Radius"
   stepu := (brushToolStepping<=2 || brushToolStepping=251) ? "AUTO" : brushToolStepping
   If (brushToolStepping=0)
      stepu := "NONE"
   wetLabel := (BrushToolType>=6) ? "Deform intensity" : "Wetness"
   GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
   GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
   GuiControl, SettingsGUIA:, brushToolDoubleSize, %theSize%: %BrushToolSize% px
   ; GuiControl, SettingsGUIA:, infoBrushSoftness, Softness: %BrushToolSoftness%`%
   GuiControl, SettingsGUIA:, infoBrushStepping, Stepping: %stepu%
   GuiControl, SettingsGUIA:, BrushToolAutoAngle, % (BrushToolAutoAngle=1) ? "Automatic rotation" : "Angle: " BrushToolAngle "°"
   GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
   GuiControl, SettingsGUIA:, infoBrushDrying, Dry-out rate: %BrushToolDryingRate%

   GuiControl, SettingsGUIA:, infoBrushBlurel, Blur intensity: %BrushToolBlurStrength%`%
   GuiControl, SettingsGUIA:, infoBrushWetness, %wetLabel%: %BrushToolWetness%
   GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
   GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
   GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
   GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%

   GuiControl, SettingsGUIA:, infoBrushRandomSize, Size: %BrushToolRandomSize%
   GuiControl, SettingsGUIA:, infoBrushRandomSoftness, Softness: %BrushToolRandomSoftness%
   GuiControl, SettingsGUIA:, infoBrushRandomAspectRatio, Aspect ratio: %BrushToolRandomAspectRatio%
   GuiControl, SettingsGUIA:, infoBrushRandomAngle, Angle: %BrushToolRandomAngle%° 
   GuiControl, SettingsGUIA:, infoBrushRandomPosX, Offset X: %BrushToolRandomPosX%
   GuiControl, SettingsGUIA:, infoBrushRandomPosY, Offset Y: %BrushToolRandomPosY%
   GuiControl, SettingsGUIA:, infoBrushRandomHue, Hue: %BrushToolRandomHue%
   GuiControl, SettingsGUIA:, infoBrushRandomSat, Saturation: %BrushToolRandomSat%
   GuiControl, SettingsGUIA:, infoBrushRandomLight, Lightness: %BrushToolRandomLight%
   GuiControl, SettingsGUIA:, infoBrushRandomDark, Darkness: %BrushToolRandomDark%
   If (BrushToolTexture>1)
   {
      GuiControl, SettingsGUIA: Disable, BrushToolSoftness
      GuiControl, SettingsGUIA: Disable, BrushToolAspectRatio
      GuiControl, SettingsGUIA: Disable, infoBrushAspectRatio
   } Else
   {
      GuiControl, SettingsGUIA: Enable, BrushToolSoftness
      GuiControl, SettingsGUIA: Enable, BrushToolAspectRatio
      GuiControl, SettingsGUIA: Enable, infoBrushAspectRatio
   }

   createLivePreviewBrush()
   SetTimer, WriteSettingsBrushPanel, -300
}

BTNresetBrushAngle() {
   BrushToolAngle := 0
   GuiControl, SettingsGUIA:, BrushToolAngle, 0
   If (AnyWindowOpen=64)
      SetTimer, updateUIbrushTool, -125
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpasteInPlacebrushTool, -125
}

BTNresetBrushAspectRatio() {
   BrushToolAspectRatio := 0
   GuiControl, SettingsGUIA:, BrushToolAspectRatio, 0
   If (AnyWindowOpen=64)
      SetTimer, updateUIbrushTool, -125
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpasteInPlacebrushTool, -125
}

BTNresetBrushStepu() {
   brushToolStepping := 0
   GuiControl, SettingsGUIA:, brushToolStepping, 0
   If (AnyWindowOpen=64)
      SetTimer, updateUIbrushTool, -125
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpasteInPlacebrushTool, -125
}

BTNresetBrushWet() {
   BrushToolWetness := 0
   GuiControl, SettingsGUIA:, BrushToolWetness, 0
   SetTimer, updateUIbrushTool, -125
}

BTNresetBrushBluru() {
   BrushToolBlurStrength := 0
   GuiControl, SettingsGUIA:, BrushToolBlurStrength, 0
   SetTimer, updateUIbrushTool, -125
}

BTNresetBrushDryer() {
   BrushToolDryingRate := 0
   GuiControl, SettingsGUIA:, BrushToolDryingRate, 0
   If (AnyWindowOpen=64)
      SetTimer, updateUIbrushTool, -125
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpasteInPlacebrushTool, -125
}

createBrushShapePath(brushSize, tkX, tkY, thisAR, angleu) {
   thisAR := 1 - Abs(thisAR)/105
   brImgSelW := (BrushToolAspectRatio>0) ? brushSize * thisAR : brushSize
   brImgSelH := (BrushToolAspectRatio<0) ? brushSize * thisAR : brushSize
   brimgSelPx := 0 - (brImgSelW - brushSize)/2
   brimgSelPy := 0 - (brImgSelH - brushSize)/2
   tmpMatrix := Gdip_CreateMatrix()
   tmpPath := Gdip_CreatePath()
   Gdip_AddPathEllipse(tmpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
   Gdip_RotatePathAtCenter(tmpPath, angleu)
   Gdip_TranslateMatrix(tmpMatrix, tkX - brushSize/2, tkY - brushSize/2)
   Gdip_TransformPath(tmpPath, tmpMatrix)
   Gdip_DeleteMatrix(tmpMatrix)
   Return tmpPath
}

createLivePreviewBrush() {
    Static imgBoxSize := 100
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, imgBoxSize, imgBoxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GraphicsClear(G, "0xFF888888")
    brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
    whichBitmap := useGdiBitmap()
    If ((BrushToolType=3 || BrushToolType=5) && CurrentPanelTab=2)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 1, 1)
       applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
       thisMainOpacity := 1
    } Else If (BrushToolType=3 && CurrentPanelTab=1)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 0, 1)
       thisMainOpacity := BrushToolAopacity / 255
    } Else
    {
       thisMainOpacity := 1
       If (BrushToolTexture>1)
          thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity / 255 : BrushToolAopacity / 255

       startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       If (BrushToolType>2)
          startToolColor := "ffFFff"

       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       thisOpacity := Format("{1:#x}", thisOpacity)
       brushSofty := (BrushToolType=1) ? 99 : 101 - BrushToolSoftness
       brushu := createGradientBrushBitmap(startToolColor, brushSofty, imgBoxSize, BrushToolAngle, BrushToolAspectRatio, thisOpacity)
    }

    Gdip_DrawImage(G, brushu, 2, 2, 95, 95, , , , , thisMainOpacity)
    thisX := (brushToolDoubleSize=1) ? imgBoxSize//2 : 0
    If (BrushToolAngle=0 && BrushToolAspectRatio=0)
       Gdip_FillRectangle(G, pBrushD, thisX, imgBoxSize//2 - 2, imgBoxSize, 4)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    If (CurrentPanelTab=1)
       SetImage(hCropCornersPic, hBitmap)
    Else If (CurrentPanelTab=2)
       SetImage(hCropCornersPic2, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(brushu, 1)
    trGdip_DisposeImage(cornersBMP, 1)
}

PanelChangeHamDistThreshold() {

    If !testIsDupesList()
    {
       showTOOLtip("WARNING: The files list does not seem to contain pairs of images identified as duplicates")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       If (SLDtypeLoaded=3)
          SetTimer, PanelFindDupes, -200
       Return
    }

    If !InStr(resultedFilesList[currentFileIndex, 23], "_")
    {
       showTOOLtip("WARNING: The files list does not seem to contain pairs of images filtered by Hamming distance")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       If (SLDtypeLoaded=3)
          SetTimer, PanelFindDupes, -200
       Return
    }

    thisBtnHeight := createSettingsGUI(62, A_ThisFunc)
    btnWid := 70
    txtWid := 260
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 80
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    EditWid := Round(btnWid*2.5)
    If !hamUppLim
       hamUppLim := userFindDupesHamDistLvl

    Gui, Add, Text, x15 y15 w%txtWid% Section, Please set the range for the Hamming distance threshold. Lower ranges equate to a stricter criteria - more closely looking images. Cached threshold range: 0 - %userFindDupesHamDistLvl%.
    Gui, Add, Text, y+15 w%btnWid%, Lower limit:
    Gui, Add, Text, x+15 wp, Upper limit:
    Gui, Add, Edit, xs y+5 wp number -multi limit2 veditF5, % hamLowLim
    Gui, Add, UpDown, vhamLowLim Range0-%userFindDupesHamDistLvl%, % hamLowLim

    Gui, Add, Edit, x+15 wp number -multi limit2 veditF6, % hamUppLim
    Gui, Add, UpDown, vhamUppLim Range0-%userFindDupesHamDistLvl%, % hamUppLim
    Gui, Add, Text, xs y+15 wp, String filter:
    Gui, Add, Checkbox, x+5 Checked%UserHamDistStringInvert% vUserHamDistStringInvert, &Must not contain it
    Gui, Add, Edit, xs y+5 w%EditWid% -multi vUserHamDistStringFilter, % UserHamDistStringFilter
    Gui, Add, Checkbox, xs y+25 Checked%UserHamDistCacheFilterMonoGroups%  vUserHamDistCacheFilterMonoGroups, &Filter out matches without pairs

    Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% Default gBtnChangeHamDistThreshold, &Update
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Change Hamming distance threshold: " appTitle)
}

BtnChangeHamDistThreshold() {
   Gui, SettingsGUIA: Default
   GuiControlGet, hamUppLim
   GuiControlGet, hamLowLim
   GuiControlGet, UserHamDistStringFilter
   GuiControlGet, UserHamDistStringInvert
   GuiControlGet, UserHamDistCacheFilterMonoGroups

   BtnCloseWindow()
   r := changeHdistLevelCached(0, hamLowLim, hamUppLim)
   If (r<1)
   {
      showTOOLtip("Found no duplicate images in the specified Hamming distance range.`nFiles list unchanged.")
      SoundBeep 300, 100
      SetTimer, PanelChangeHamDistThreshold, -350
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PanelSearchAndReplaceIndex() {
    Global editF5, editF6, performInSeenDB, performInDynas

    thisBtnHeight := createSettingsGUI(56, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If (SLDtypeLoaded=3)
       infos := "`n`nThis action will affect only folder paths."

    If (mustRecordSeenImgs!=1 || performInSeenDB="")
       performInSeenDB := 0

    If (performInSeenDB=1 || performInDynas="")
       performInDynas := 0

    imgPath := resultedFilesList[currentFileIndex, 1]
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please type what to search for and what to replace it with. This panel is meant to help you fix broken files lists. e.g., files moved to a different folder. RegEx, tokens or wildcards are not supported. %infos%
    Gui, Add, Text, y+15 wp, Search for:
    Gui, Add, Edit, y+5 wp veditF5 r1, % OutDir
    Gui, Add, Text, y+15 wp, Replace with:
    Gui, Add, Edit, y+5 wp veditF6,
    Gui, Add, Checkbox, y+15 Checked%performInSeenDB% vperformInSeenDB gUItogglePerformSearchSeenDB, Perform action in seen images database 
    Gui, Add, Checkbox, y+15 Checked%performInDynas% vperformInDynas , Perform action over the main folders list as well
    If (mustRecordSeenImgs!=1)
       GuiControl, Disable, performInSeenDB

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNperformIndexSearchReplace, &Perform
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Search and replace through the files index: " appTitle)
}

UItogglePerformSearchSeenDB() {
   Gui, SettingsGUIA: Default
   GuiControlGet, performInSeenDB
   If (performInSeenDB=1)
      GuiControl, SettingsGUIA: Disable, performInDynas
   Else
      GuiControl, SettingsGUIA: Enable, performInDynas
}

BTNperformIndexSearchReplace() {
   Gui, SettingsGUIA: Default
   GuiControlGet, editF5
   GuiControlGet, editF6
   GuiControlGet, performInSeenDB
   GuiControlGet, performInDynas
   If !Trimmer(editF5)
   {
      showTOOLtip("WARNING: No search criteria given")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   If (mustRecordSeenImgs=1 && performInSeenDB=1)
   {
      SearchAndReplaceSeenDB(editF5, editF6)
   } Else
   {
      SearchAndReplaceThroughIndex(editF5, editF6, 0, 0)
      If (performInDynas=1)
      {
         listu := getDynamicFoldersList()
         listu := StrReplace(listu, "`n", "\`n")
         listu := StrReplace(listu, Trimmer(editF5), Trimmer(editF6))
         listu := StrReplace(listu, "\\", "\")
         DynamicFoldersList := StrReplace(listu, "\`n", "`n")
         If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(DynamicFoldersList)
      }
   }
}

PanelQuickMoveConfigure() {
    Global btnFldr1, btnFldr2, btnFldr3, btnFldr4, btnFldr5, btnFldr6
    Static afterActionsList := "Do nothing after|Go to next image |Go to previous image"

    thisBtnHeight := createSettingsGUI(47, A_ThisFunc, 1)
    btnWid := 60
    txtWid := 395
    EditWid := 305
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 100
       btnWid := btnWid + 30
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    tiny := (PrefsLargeFonts=1) ? 55 : 30
    tiny2 := (PrefsLargeFonts=1) ? 85 : 50
    ReadSettingsQuickKeysActsPanel()
    Gui, Add, Text, x15 y15 Section w%txtWid%, The keys from 1 to 6 on the keyboard can be associated to quick actions to facilitate the move or copy of images to predefined destination folders.
    Gui, Add, Text, xs y+15 w%tiny%, [ 1 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder1, % QuickFileActFolder1
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr1, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter1% vQuickFileActAfter1, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 2 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder2, % QuickFileActFolder2
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr2, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter2% vQuickFileActAfter2, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 3 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder3, % QuickFileActFolder3
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr3, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter3% vQuickFileActAfter3, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 4 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder4, % QuickFileActFolder4
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr4, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter4% vQuickFileActAfter4, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 5 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder5, % QuickFileActFolder5
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr5, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter5% vQuickFileActAfter5, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 6 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder6, % QuickFileActFolder6
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr6, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter6% vQuickFileActAfter6, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ Del ]
    Gui, Add, Checkbox, x+5 Checked%askDeleteFiles% vaskDeleteFiles, &Prompt before delete
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%deleteFileActAfter% vdeleteFileActAfter, % afterActionsList
    Gui, Add, Text, xs y+15 w%txtWid%, Use Shift to move to given destination folder. Use Alt to open it in Explorer.

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBtnApplyQuickActionsPanel, &Apply
    Gui, Add, Button, x+5 hp wp gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    Gui, Add, Text, x+5 hp +0x200, On file name conflicts:
    Gui, Add, DropDownList, x+5 w135 AltSubmit Choose%QuickFileActConflict% vQuickFileActConflict, Skip files|Auto-rename|Overwrite|Ask user
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Configure quick action keys: " appTitle)
}

BtnApplyQuickActionsPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, QuickFileActAfter1
   GuiControlGet, QuickFileActAfter2
   GuiControlGet, QuickFileActAfter3
   GuiControlGet, QuickFileActAfter4
   GuiControlGet, QuickFileActAfter5
   GuiControlGet, QuickFileActAfter6
   GuiControlGet, QuickFileActFolder1
   GuiControlGet, QuickFileActFolder2
   GuiControlGet, QuickFileActFolder3
   GuiControlGet, QuickFileActFolder4
   GuiControlGet, QuickFileActFolder5
   GuiControlGet, QuickFileActFolder6
   GuiControlGet, askDeleteFiles
   GuiControlGet, deleteFileActAfter
   GuiControlGet, QuickFileActConflict
   WriteSettingsQuickKeysActsPanel()
   BtnCloseWindow()
}

BTNchooseQuickActDestFolder(CtrlHwnd) {
   Static lastFolder
   If !lastFolder
      lastFolder := ResizeDestFolder ? ResizeDestFolder : A_ScriptDir

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2

   thisVar := SubStr(varu, 0)
   SelectImg := openFoldersDialogWrapper("S2", lastFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   } Else
   {
      lastFolder := SelectImg
      GuiControl, SettingsGUIA:, QuickFileActFolder%thisVar%, % OutDir
   }
}

triggerQuickFileAction(keyu) {
   Static hasLoadedSettings := 0, lastInvoked := 1

   If (slideShowRunning=1)
   {
      ToggleSlideShowu()
      Return
   }

   If ((!resultedFilesList[currentFileIndex, 1] || AnyWindowOpen || drawingShapeNow=1)
   || (A_TickCount - lastInvoked<250))
   {
      lastInvoked := A_TickCount
      Return
   }

   If !hasLoadedSettings
   {
      ReadSettingsQuickKeysActsPanel()
      hasLoadedSettings := 1
   }

   thisVar := SubStr(keyu, 0)
   UsrCopyMoveOperation := InStr(keyu, "+") ? 2 : 3   ; 2 = move ; 3 = copy
   UsrEditFileDestination := QuickFileActFolder%thisVar%
   If (thisVar=7)
   {
      If !folderTreeWinOpen
         Return

      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      UsrEditFileDestination := folderTreeGetSelectedPath(c)
      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
      If !UsrEditFileDestination
         Return
   }

   If StrLen(UsrEditFileDestination)<5
   {
      PanelQuickMoveConfigure()
      Return
   }

   altState := GetKeyState("Alt", "P")
   ctrlState := GetKeyState("Ctrl", "P")
   lastInvoked := A_TickCount
   If (altState=1 && ctrlState!=1)
   {
      Try Run, "%UsrEditFileDestination%"
      UsrEditFileDestination := ""
      Return
   } Else If (ctrlState=1 && altState=1)
   {
      OpenNewQPVinstance(UsrEditFileDestination)
      UsrEditFileDestination := ""
      Return
   }

   copyMoveDoLastOption := 1
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   afterAct := QuickFileActAfter%thisVar%
   ForceRefreshNowThumbsList()
   r := BtnCopyMoveAction("quick-actu")
   lastInvoked := A_TickCount
   If (afterAct=2 && StrLen(UserMemBMP)<3 && r=1)
      NextPicture(0, 0, 1)
   Else If (afterAct=3 && StrLen(UserMemBMP)<3 && r=1)
      PreviousPicture(0, 0, 1)

   UsrEditFileDestination := ""
   lastInvoked := A_TickCount
}

WriteSettingsQuickKeysActsPanel() {
    ReadSettingsQuickKeysActsPanel(1)
}

ReadSettingsQuickKeysActsPanel(act:=0) {
   INIaction(act, "QuickFileActAfter1", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter2", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter3", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter4", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter5", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter6", "General", 2, 1, 3)
   INIaction(act, "QuickFileActFolder1", "General", 5)
   INIaction(act, "QuickFileActFolder2", "General", 5)
   INIaction(act, "QuickFileActFolder3", "General", 5)
   INIaction(act, "QuickFileActFolder4", "General", 5)
   INIaction(act, "QuickFileActFolder5", "General", 5)
   INIaction(act, "QuickFileActFolder6", "General", 5)
   INIaction(act, "deleteFileActAfter", "General", 2, 1, 3)
   INIaction(act, "QuickFileActConflict", "General", 2, 1, 4)
   INIaction(act, "askDeleteFiles", "General", 1)
}

TglUsePrevSaveFoderu() {
   GuiControlGet, usePrevSaveFolder
   If !usePrevSaveFolder
      GuiControl, Disable, userDestinationFolder
   Else
      GuiControl, Enable, userDestinationFolder

   INIaction(1, "usePrevSaveFolder", "General")
}

BTNsaveImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If InStr(imgPath, "\temporary memory object\")
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0, 1)

   If (minimizeMemUsage=1)
   {
      HardResetImageView()
      SetTimer, RefreshImageFileAction, -125
   }
}

BTNsaveBrowseImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If (usePrevSaveFolder=1 || InStr(imgPath, "\temporary memory object\"))
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0)
}

BtnCopyImageClip() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, userJpegQuality
   GuiControlGet, PreserveDateTimeOnSave
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userJpegQuality", "General")
   BtnCloseWindow()
   Sleep, 5
   CopyImage2clip()
}

fakeWinCreator(idWin, thisCaller, allowReopen) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    AnyWindowOpen := idWin
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 1]
    isNowFakeWinOpen := 1
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    ; hSetWinGui := PVhwnd
}

PanelAutoSelectDupes() {
   Static SearchedStringz
   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If filesFilter
         SetTimer, PanelEnableFilesFilter, -200
      Return
   }

   If !testIsDupesList()
   {
      showTOOLtip("WARNING: The files list does not seem to contain pairs of images identified as duplicates")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (SLDtypeLoaded=3)
         SetTimer, PanelFindDupes, -200
      Return
   }

   fakeWinCreator(50, A_ThisFunc, 1)
   SearchedStringz := Trimmer(SearchedStringz) "`f"
   widthu := (PrefsLargeFonts=1) ? 1060 : 560
   msgResult := msgBoxWrapper("panelu|Auto-select duplicate images " appTitle, "When Automatic mode is selected, the smallest image in (MPx) will be selected. If all dupes in the group have the same resolution, then the smallest file will be selected. If both size and resolution are equal, the images' folder paths that match the string below will NOT be selected.`n`nYou can use | as the OR operator for multiple keywords. Wildcards ? and * are supported as well. Begin with \> to use Regular Expressions.`n`nUse one of the following symbols to...`n   / match folder paths that begin with given string`n   > match folder paths that end with given string.", "&Select files|&Find duplicates|C&ancel", 1, "search", "", 0, SearchedStringz "`f`f", nullEdit,nullEdit, 1, widthu, "Automatic`f`fSmallest files`fSmallest resolution (MPx)", 2)
   If InStr(msgResult.btn, "select")
   {
      thisString := Trimmer(msgResult.list)
      thisString := StrReplace(thisString, "||", "|")
      thisString := Trimmer(thisString, "|")
      thisStringo := processSearchIndexString(thisString)
      If (thisStringo && !InStr(SearchedStringz, thisString "`f"))
         SearchedStringz .= thisString "`f"
      autoSelectDupesInGroups(msgResult.2ndlist, thisStringo)
   } Else If InStr(msgResult.btn, "find")
      PanelFindDupes()
}

SearchIndexSelectAll(modus:="") {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   showTOOLtip("Searching index for matching files:`n" userSearchString)
   thisSearchString := thisFilter
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection based on the search criteria.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel")
      {
         SetTimer, RemoveTooltip, -250
         thisSearchString := userSearchString := ""
         Return
      }
   }

   wasReplace := 0
   doStartLongOpDance()
   If (msgResult="replace" || !msgResult)
   {
      wasReplace := 1
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := resultedFilesList[A_Index, 1]
      If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
      {
         thisIndex++
         resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
      }
   }

   friendly := thisIndex ? "The files selection was altered." : "The files selection is unchanged."
   ResetImgLoadStatus()
   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If (abandonAll=1)
      showDelayedTooltip("User abandoned the search.`n" friendly)
   Else If !thisIndex
      showDelayedTooltip("No matches found for:`n" userSearchString "`n" friendly)
   Else If (modus!="quick" && wasReplace=1)
      navSelectedFiles(1)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

QuickSelectFilesSameFolder() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    If (!OutDir || !currentFileIndex || maxFilesIndex<3)
       Return

    o := markSearchMatches
    markSearchMatches := 0
    userSearchWhat := 1
    userSearchString := OutDir "\"
    SearchIndexSelectAll("quick")
    userSearchString := ""
    markSearchMatches := o
    dummyTimerDelayiedImageDisplay(50)
}

PanelSearchIndex() {
   Static SearchedStringz
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (AnyWindowOpen=6)
      BtnCloseWindow()
   Else If AnyWindowOpen
      Return
   
   fakeWinCreator(29, A_ThisFunc, 1)
   SearchedStringz := Trimmer(SearchedStringz) "`f"
   prevSearchString := Trimmer(userSearchString) ? userSearchString : Chr(160)
   widthu := (PrefsLargeFonts=1) ? 1160 : 660
   msgResult := msgBoxWrapper("panelu|Search indexed files: " appTitle, "Please type the string to search for in the indexed files. Use | as the OR operator. Wildcards ? and * are supported as well.`n`nUse one of the following tokens to...`n   / match strings that begin with given string`n   > match strings that end with given string.`n`nBegin with \> to use Regular Expressions.", "&Search next|Select &matches|&Filter list panel|&Close", 1, "search", "&Highlight matching files in list view mode", markSearchMatches, SearchedStringz prevSearchString "`f`f", nullEdit,nullEdit, 1, widthu, "Full path`f`fFolder path`fFile name`fParent folder", 2)
   If InStr(msgResult.btn, "filter list")
   {
      OpenFilterPanelBTNaction()
   } Else If (InStr(msgResult.btn, "search") || InStr(msgResult.btn, "select"))
   {
      If askAboutFileSave(" and the files index search will be performed")
         Return

      markSearchMatches := msgResult.check
      userSearchWhat := msgResult.2ndlist
      INIaction(1, "markSearchMatches", "General")
      userSearchString := Trimmer(msgResult.list)
      userSearchString := StrReplace(userSearchString, "||", "|")
      userSearchString := Trimmer(userSearchString, "|")
      If userSearchString
      {
         If !InStr(SearchedStringz, userSearchString "`f")
            SearchedStringz .= userSearchString "`f"
         ; Sort, SearchedStringz, UD`f
         If InStr(msgResult.btn, "search")
            searchNextIndex(1)
         Else If InStr(msgResult.btn, "select")
            SearchIndexSelectAll()
      } Else userSearchString := ""
   }
}

OpenFilterPanelBTNaction() {
   userSearchString := ""
   BtnCloseWindow()
   PanelEnableFilesFilter()
}

PanelEditImgCaption(dummy:=0) {
    Global newFileName, UsrStoreCaptionDB := 1
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If !FileExist(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Return
    }

    INIaction(0, "UsrStoreCaptionDB", "General", 1)
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")
    Else
       UsrStoreCaptionDB := 0

    If !textFileContent
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       Try FileRead, textFileContent, % textFile
    }

    thisBtnHeight := createSettingsGUI(22, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, Please type the caption or annotation you want associated with this image file...
    Gui, Add, Edit, y+7 w%EditWid% r15 limit1024 -wantTab vnewFileName, % textFileContent
    Gui, Add, Checkbox, y+7 Checked%UsrStoreCaptionDB% vUsrStoreCaptionDB, Store image caption into the SQL slideshow database
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w90 Default gSaveCaptionBTNaction, &Save
    Gui, Add, Button, x+5 hp wp gDeleteCaptionBTNaction, &Delete
    Gui, Add, Button, x+5 hp wp gBTNhelpCaptions, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    If (SLDtypeLoaded!=3)
       GuiControl, Disable, UsrStoreCaptionDB

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Edit image caption: " appTitle)
}

BTNhelpCaptions() {
    msgBoxWrapper(appTitle ": HELP", "Image file captions [annotations] are stored in .TXT files [as plain text], where the image file is located, under the same file name.`n`nFor example:`nC:\example-folder\image-file.jpg`nC:\example-folder\image-file.txt`n`nIf you are using SQLite slideshow databases, you have the option to store the captions in the database, not as individual files for each image. However, please keep in mind, when the files list is renewed or regenerated, the captions or audio annotations might get lost.", -1, 0, 0)
}

DeleteCaptionBTNaction() {
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If FileExist(textFile)
       mustShowError := 1

    Try FileDelete, % textFile
    Catch wasError
          Sleep, 2

    If (mustShowError && wasError)
    {
       showTOOLtip("ERROR: Unable to delete text file:`n" OutNameNoExt ".txt`n" OutDir "\")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    If (SLDtypeLoaded=3)
       updateSQLdbEntryCaption(imgPath, "", "imgCaption")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

SaveCaptionBTNaction() {
    GuiControlGet, newFileName
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    newFileName := Trimmer(newFileName)
    If !newFileName
       Return

    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3 && UsrStoreCaptionDB=1)
    {
       updateSQLdbEntryCaption(imgPath, newFileName, "imgCaption")
    } Else
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       FileDelete, % textFile
       Sleep, 2
       Try FileAppend, % newFileName, % textFile, UTF-16
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "Failed to write text file... Permission denied.`n" OutNameNoExt ".txt`n" OutDir "\", 0, 0, "error")
    }

    showImgAnnotations := 1
    If (showImgAnnotations!=1)
       INIaction(1, "showImgAnnotations", "General")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

InvokeUpdateIndexPanelBTNaction() {
   CloseWindow()
   Sleep, 1
   PanelUpdateThisFileIndex()
}

filterFileName(ostring) {
  Static forbiddenCharsREGex := "\<|\>|\:|\""|\/|\\|\||\?|\*"
  Static forbiddenNames := "CON|PRN|AUX|NUL|COM1|COM2|COM3|COM4|COM5|COM6|COM7|COM8|COM9|LPT1|LPT2|LPT3|LPT4|LPT5|LPT6|LPT7|LPT8|LPT9"
  string := Trimmer(ostring)
  string := StrReplace(string, "/", "\")
  string := RegExReplace(string, "\\{2,}", "\")
  If RegExMatch(string, forbiddenCharsREGex)
     Return

  Loop, Parse, forbiddenNames, |
  {
     If (A_LoopField=string)
        Return
  }

  Return string
}

undoFileRenameAction() {
   RenameBTNaction(lastRenameUndo[1], lastRenameUndo[2], 1)
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   lastRenameUndo := []
}

RenameBTNaction(newFileName, file2rem, doLastOption) {
  newFileName := filterFileName(newFileName)
  If (StrLen(newFileName)>3)
  {
     zPlitPath(file2rem, 0, OutFileName, OutDir)
     If (Trimmer(OutFileName)=newFileName)
        Return 1

     If !FileExist(file2rem)
        Return 0

     destroyGDIfileCache()
     FileGetTime, originalMtime, % file2rem, M
     FileGetTime, originalCtime, % file2rem, C
     file2save := OutDir "\" newFileName
     thisFileExists := 0
     If (FileExist(file2save) && !FolderExist(file2save))
     {
        thisFileExists := 1
        file2save := askAboutFileCollision(file2rem, file2save, 0, doLastOption + 1, 0, performOverwrite)
     }

     If (file2save="abort" || !file2save)
     {
        SetTimer, SingularRenameFile, -150
        Return
     }

     If (thisFileExists=1)
     {
        If (performOverwrite=1)
        {
           FileSetAttrib, -R, %file2save%
           Sleep, 2
           FileRecycle, %file2save%
           Sleep, 2
        } Else If (performOverwrite!=2)
        {
           showTOOLtip("Rename operation abandoned.`nA file with the provided name already exists.`nFile name conflict`n" newFileName)
           SetTimer, RemoveTooltip, % -msgDisplayTime
           Return 0
        }
     }

     FileSetAttrib, -R, %file2rem%
     Sleep, 2
     FileMove, %file2rem%, %file2save%, 1
     If ErrorLevel
     {
        showTOOLtip("ERROR: Access denied... The file could not be renamed.`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     } Else
     {
        updateDates := 1
        If originalMtime
        {
           Sleep, 0
           FileSetTime, % originalMtime, % file2save, M
           FileSetTime, % originalCtime, % file2save, C
           updateDates := 0
        }

        lastRenameUndo := []
        lastRenameUndo := [OutFileName, file2save]
        If (SLDtypeLoaded=3)
           updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])

        currentFilesListModified := 1
        resultedFilesList[currentFileIndex, 1] := file2save
        updateMainUnfilteredList(currentFileIndex, 1, file2save)
        watchFolderDetails := ""
        dummyTimerDelayiedImageDisplay(50)
        showTOOLtip("File renamed succesfully to:`n" newFileName "`n" OutDir "\")
        Return 1
     }
  } Else Return 0
}

UpdateIndexBTNaction(newFileName, whichIndex) {
  ; GuiControlGet, newFileName
  newFileName := Trimmer(newFileName)
  newFileName := StrReplace(newFileName, "/", "\")
  newFileName := RegExReplace(newFileName, "\\{2,}", "\")
  allGood := 1
  If !RegExMatch(newFileName, "i)^(.\:\\.)")
     allGood := 0

  strArr := StrSplit(newFileName, "\")
  Loop, % strArr.Count()
  {
      testThis := filterFileName(strArr[A_Index])
      If (!testThis && A_Index>1)
         allGood := 0
  }

  If !RegExMatch(newFileName, RegExFilesPattern)
     allGood := 0

  If !FileRexists(newFileName)
  {
     If (allGood=1)
        fileNotFound := 1
     allGood := 0
  }

  If (StrLen(newFileName)>2 && allGood=1)
  {
     oldFileName := resultedFilesList[whichIndex, 1]
     resultedFilesList[whichIndex, 1] := newFileName
     resultedFilesList[whichIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(oldFileName, newFileName, 0, resultedFilesList[whichIndex, 12])

     updateMainUnfilteredList(whichIndex, 1, OutDir "\" newFileName)
     ForceRefreshNowThumbsList()
     currentFilesListModified := 1
     dummyTimerDelayiedImageDisplay(150)
     showTOOLtip("File index entry updated")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return 1
  } Else If (StrLen(newFileName)>2)
  {
     If (fileNotFound=1)
        showTOOLtip("ERROR: The file index entry was not updated.`nFile not found or access denied`n" newFileName)
     Else
        showTOOLtip("ERROR: The file index entry was not updated.`nIncorrect file name provided:`n" newFileName)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }
}

BtnBrowseAlphaMaskFile() {
    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3)

    If !imgPath
       Return
 
    PasteInPlaceAlphaFile := imgPath
    GuiControl, SettingsGUIA:, PasteInPlaceAlphaFile, % imgPath
    SetTimer, updateUIpastePanel, -50
}

updateUIpastePanel(actionu:=0) {
    Static lastInvoked := 1
    isWinOpen := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
    If (isWinOpen=1)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, PasteInPlaceAdaptMode
    GuiControlGet, PasteInPlaceAlphaChannelFile
    GuiControlGet, PasteInPlaceAlignment
    GuiControlGet, PasteInPlaceOpacity
    GuiControlGet, PasteInPlaceCropSel
    GuiControlGet, PasteInPlaceCropAngular
    GuiControlGet, PasteInPlaceQuality
    GuiControlGet, PasteInPlaceOrientation
    GuiControlGet, PasteInPlaceApplyColorFX
    GuiControlGet, PasteInPlaceBlurAmount
    GuiControlGet, PasteInPlaceLivePreview
    GuiControlGet, PasteInPlaceHue
    GuiControlGet, PasteInPlaceSaturation
    GuiControlGet, PasteInPlaceLight
    GuiControlGet, PasteInPlaceGamma
    GuiControlGet, PasteInPlaceAlphaMaskClrA
    GuiControlGet, PasteInPlaceAlphaMaskClrB
    GuiControlGet, PasteInPlaceAlphaMaskMode
    GuiControlGet, PasteInPlaceBlurEdgesSoft
    GuiControlGet, PasteInPlaceAutoExpandIMG
    GuiControlGet, PasteInPlaceBlendMode
    GuiControlGet, PasteInPlaceGlassy
    GuiControlGet, uiPasteInPlaceAlphaFile
    GuiControlGet, alphaMaskReplaceMode
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientPosA
    GuiControlGet, FillAreaGradientPosB
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaColorReversed

    PasteInPlaceAlphaFile := uiPasteInPlaceAlphaFile
    If (AnyWindowOpen=31)
       GuiControlGet, PasteInPlaceEraseInitial
    Else
       GuiControl, SettingsGUIA: Disable, PasteInPlaceEraseInitial

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIpastePanel, -150
       Return
    }

    If (coreDesiredPixFmt="0x21808")
    {
       PasteInPlaceAlphaMaskMode := 1
       GuiControl, Disable, PasteInPlaceAlphaMaskMode
       GuiControl, Choose, PasteInPlaceAlphaMaskMode, 1
    }

    thisOpacity := Round((PasteInPlaceOpacity / 128) * 100)
    GuiControl, SettingsGUIA:, infoPasteOpacity, Image opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
    GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
    GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    GuiControl, SettingsGUIA:, infoPasteBlur, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientPosA%`%
    GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientPosB%`%
    GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
    If (PasteInPlaceAlphaMaskMode=5)
    {
       thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Blur amount: %thisAlphaBlur%
    } Else GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%

    If (PasteInPlaceAlphaMaskMode>=5 || PasteInPlaceAlphaMaskMode=1)
       GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
    Else
       GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped

    If (PasteInPlaceBlendMode>1)
       GuiControl, SettingsGUIA: Enable, PasteInPlaceGlassy
    Else
       GuiControl, SettingsGUIA: Disable, PasteInPlaceGlassy

    If (PasteInPlaceBlurAmount>1)
       GuiControl, SettingsGUIA: Enable, PasteInPlaceBlurEdgesSoft
    Else
       GuiControl, SettingsGUIA: Disable, PasteInPlaceBlurEdgesSoft

    actu2 := (PasteInPlaceApplyColorFX=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PasteInPlaceLight
    GuiControl, % actu2, PasteInPlaceGamma
    GuiControl, % actu2, PasteInPlaceHue
    GuiControl, % actu2, PasteInPlaceSaturation
    GuiControl, % actu2, infoPasteLight
    GuiControl, % actu2, infoPasteGamma
    GuiControl, % actu2, infoPasteHue
    GuiControl, % actu2, infoPasteSat

    actu := (PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5 && PasteInPlaceAlphaMaskMode!=6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, FillAreaGradientPosA
    GuiControl, % actu, FillAreaGradientPosB
    GuiControl, % actu, FillAreaColorReversed

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientScale

    actu := (PasteInPlaceAlphaMaskMode=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, uiPasteInPlaceAlphaFile
    GuiControl, % actu, PasteInPlaceAlphaChannelFile
    GuiControl, % actu, btnFldr
    GuiControl, % actu, infoAlphaFile
    If (PasteInPlaceAdaptMode=2)
       GuiControl, SettingsGUIA: Disable, PasteInPlaceAlignment
    Else
       GuiControl, SettingsGUIA: Enable, PasteInPlaceAlignment

    If (PasteInPlaceCropSel>1)
    {
       GuiControl, SettingsGUIA: Enable, PasteInPlaceCropAngular
       GuiControl, SettingsGUIA: Enable, editF5
       GuiControl, SettingsGUIA: Enable, infoAngleu
    } Else
    {
       GuiControl, SettingsGUIA: Disable, PasteInPlaceCropAngular
       GuiControl, SettingsGUIA: Disable, editF5
       GuiControl, SettingsGUIA: Disable, infoAngleu
    }

    If (PasteInPlaceAlphaMaskMode=6)
    {
       brLvl := PasteInPlaceAlphaMaskClrA
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255, 3)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Blur amount: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Curve tension: %contrLvl%
    } Else If (PasteInPlaceAlphaMaskMode=5)
    {
       brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Brightness: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Contrast: %contrLvl%
    } Else
    {
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Intensity A: %PasteInPlaceAlphaMaskClrA%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Intensity B: %PasteInPlaceAlphaMaskClrB%
    }

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, FillAreaColorReversed
    GuiControl, % actu, PasteInPlaceAlphaMaskClrA
    GuiControl, % actu, PasteInPlaceAlphaMaskClrB
    GuiControl, % actu, infoPasteAlphaClrA
    GuiControl, % actu, infoPasteAlphaClrB
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientAngle

    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsPasteInPlacePanel, -350
}

WriteSettingsPasteInPlacePanel() {
   ReadSettingsPasteInPlace(1)
}

throwErrorSelectionOutsideBounds(whichBitmap:=0) {
    whichBitmap := StrLen(whichBitmap)>1 ? whichBitmap : useGdiBitmap()
    If testSelectOutsideImgEntirely(whichBitmap)
    {
       SoundBeep , 300, 100
       showDelayedTooltip("WARNING: Invalid image selection area.`nIt seems to be entirely outside the image boundaries.")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

BtnPasteInSelectedArea() {
    If (liveDrawingBrushTool=1)
    {
       togglePaintingMode()
       Return
    }

    If (PasteInPlaceAutoExpandIMG!=1 || PasteInPlaceBlendMode>1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    updateUIpastePanel("noPreview")
    Sleep, 1
    CloseWindow(0, 0)
    ToggleEditImgSelection("show-edit")
    Sleep, 1
    ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    PasteInPlaceNow()
}

importEditGivenImageFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := getIDimage(currentFileIndex)
   currentFileIndex := prevLoadedImageIndex
   MenuReturnIMGedit()
   Sleep, 2
   ToggleEditImgSelection("show-edit")
   Sleep, 2
   PanelPasteInPlace(imgPath)
}

ReadSettingsPasteInPlace(act:=0) {
    If (customShapePoints.Count()<3 && act=0)
    {
       INIaction(0, "FillAreaCustomShape", "General", 5)
       INIaction(0, "initialCustomShapeCoords", "General", 5)
       customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    }
    INIaction(act, "alphaMaskReplaceMode", "General", 1)
    INIaction(act, "FillAreaColorReversed", "General", 1)
    INIaction(act, "FillAreaGradientAngle", "General", 2, 0, 360)
    INIaction(act, "FillAreaGradientPosB", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientScale", "General", 2, 1, 300)
    INIaction(act, "FillAreaGradientPosA", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientWrapped", "General", 1)
    INIaction(act, "PasteInPlaceGlassy", "General", 2, 1, 6)
    INIaction(act, "PasteInPlaceBlendMode", "General", 2, 1, 21)
    INIaction(act, "PasteInPlaceAdaptMode", "General", 2, 1, 3)
    INIaction(act, "PasteInPlaceAlphaMaskClrA", "General", 2, 0, 255)
    INIaction(act, "PasteInPlaceAlphaMaskClrB", "General", 2, 0, 255)
    ; INIaction(act, "PasteInPlaceAlphaMaskMode", "General", 2, 1, 6)
    INIaction(act, "PasteInPlaceApplyColorFX", "General", 1)
    INIaction(act, "PasteInPlaceBlurAmount", "General", 2, 0, 255)
    INIaction(act, "PasteInPlaceBlurEdgesSoft", "General", 1)
    INIaction(act, "PasteInPlaceAlignment", "General", 2, 1, 5)
    INIaction(act, "PasteInPlaceCropSel", "General", 2, 1, 7)
    INIaction(act, "PasteInPlaceCropAngular", "General", 2, 0, 359)
    INIaction(act, "PasteInPlaceEraseInitial", "General", 1)
    INIaction(act, "PasteInPlaceGamma", "General", 2, -100, 100)
    INIaction(act, "PasteInPlaceHue", "General", 2, -180, 180)
    INIaction(act, "PasteInPlaceLight", "General", 2, -255, 255)
    INIaction(act, "PasteInPlaceSaturation", "General", 2, -100, 100)
    INIaction(act, "PasteInPlaceLivePreview", "General", 1)
    INIaction(act, "PasteInPlaceOpacity", "General", 2, 1, 256)
    INIaction(act, "PasteInPlaceOrientation", "General", 2, 1, 4)
    INIaction(act, "PasteInPlaceQuality", "General", 1)
    INIaction(act, "PasteInPlaceAutoExpandIMG", "General", 1)
}

PanelTransformSelectedArea() {
   MainPanelTransformArea(0, "transform")
}

PanelPasteInPlace(dummy:="") {
   MainPanelTransformArea(dummy, "paste")
}

BTNresetPasteInPlaceCropAngle() {
   GuiControl, SettingsGUIA:, editF5, 0
   updateUIpastePanel()
}

BTNtoggleAlphaPainting() {
    GuiControlGet, uiPasteInPlaceAlphaDrawMode, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode
    If (!uiPasteInPlaceAlphaDrawMode && liveDrawingBrushTool!=1)
       Return

    updateUIpasteInPlacebrushTool()
    togglePaintingMode()
    RemoveTooltip()
}

BtnSwitchTabsPasteInPlace() {
   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
   GuiControlGet, uiPasteInPlaceAlphaDrawMode, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode
   If (panelWinCollapsed=1)
      toggleImgEditPanelWindow()

   If (CurrentPanelTab=3 && liveDrawingBrushTool=1 && uiPasteInPlaceAlphaDrawMode=1)
   {
      CurrentPanelTab := 4
      GuiControl, SettingsGUIA: Choose, CurrentPanelTab, 4
   }
}

MainPanelTransformArea(dummy:="", toolu:="") {

    userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    imgPath := getIDimage(currentFileIndex)
    calcScreenLimits()
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || openingPanelNow=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    If throwErrorSelectionOutsideBounds()
       Return

    openingPanelNow := 1
    DestroyGIFuWin()
    changeMcursor()
    setImageLoading()
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (toolu="transform")
    {
       showTOOLtip("Retrieving image selected area, please wait")
       userClipBMPpaste := getTransformToolSelectedArea(1, 0, 1)
       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    } Else If (toolu="paste")
    {
       showTOOLtip("Retrieving clipboard image, please wait")
       If FileRexists(dummy)
       {
          thisPBitmap := LoadBitmapFromFileu(dummy)
          userClipBMPpaste := Gdip_CloneBmpPargbArea(A_ThisFunc, thisPBitmap)
          trGdip_DisposeImage(thisPBitmap, 1)
       } Else
          userClipBMPpaste := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 0)

       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    }

    If (StrLen(userClipBMPpaste)<3 || StrLen(viewportStampBMP)<3)
    {
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       SetTimer, resetOpeningPanel, -200
       showTOOLtip("ERROR: Failed to retrieve image")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    imgEditPanelOpened := 1
    viewportIDstampBMP := A_TickCount
    prevVPselRotation := vPselRotation
    prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
    prevEllipseSelectMode := EllipseSelectMode
    prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
    prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2
    If (toolu="transform")
    {
       recordSelUndoLevelNow()
       Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelX1 := pB.x, imgSelY1 := pB.y
       imgSelX2 := pB.x + pB.w
       imgSelY2 := pB.y + pB.h
       VPstampBMPx := pB.x, VPstampBMPy := pB.y
       vPselRotation := 0
       PasteInPlaceToolMode := 1
       dummyRefreshImgSelectionWindow()
       thisBtnHeight := createSettingsGUI(31, "PanelTransformSelectedArea")
    } Else If (toolu="paste")
    {
       flipBitmapAccordingToViewPort(viewportStampBMP)
       PasteInPlaceToolMode := 0
       thisBtnHeight := createSettingsGUI(24, "PanelPasteInPlace")
    }

    EllipseSelectMode := vPselRotation := 0
    ResetImgLoadStatus()
    ReadSettingsPasteInPlace()
    ReadSettingsBrushPanel()
    If isWinXP
       PasteInPlaceBlendMode := 1

    If (coreDesiredPixFmt="0x21808")
       PasteInPlaceAlphaMaskMode := 1

    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (toolu="transform")
       prevModeViewPortSelectionManager(prevDestPosX, prevDestPosY, oImgW, oImgH)

    thisOpacity := Round((PasteInPlaceOpacity / 128) * 100)
    Global infoPasteBlur, infoPasteOpacity, infoPasteHue, infoPasteSat, infoPasteLight, infoPasteGamma, btnReset
         , infoFillAreaSigma, infoFillAreaBlend, infoFillAreaGradientAngle, infoFillAreaGradientScale
         , infoPasteAlphaClrA, infoPasteAlphaClrB, infoAlphaFile, infoAngleu, uiPasteInPlaceAlphaDrawMode

    Gui, Add, Tab3, gBtnSwitchTabsPasteInPlace AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Adjust colors|Alpha mask|Paint alpha mask
    Gui, Tab, 1 ; general
    If (toolu="transform")
    {
       Gui, Add, Text, x+15 y+15 Section w%txtWid%, Canvas: %oImgW% x %oImgH% px.`nTransformed object: %imgW% x %imgH% px.
    } Else If (toolu="paste")
    {
       Gui, Add, Text, x+15 y+15 w%txtWid%, Please choose how to paste the clipboard content.
       Gui, Add, Text, y+7 Section wp, Canvas: %oImgW% x %oImgH% px.`nClipboard object: %imgW% x %imgH% px.
    }

    Gui, Add, DropDownList, xs y+7 wp gupdateUIpastePanel AltSubmit Choose%PasteInPlaceAdaptMode% vPasteInPlaceAdaptMode, Adjust image to selection|Fill selection area entirely (ignore aspect ratio)|Original image size
    Gui, Add, DropDownList, xs y+7 gupdateUIpastePanel w%txtWid2% AltSubmit Choose%PasteInPlaceOrientation% vPasteInPlaceOrientation, No mirroring|Flip horizontal|Flip vertical|Flip horizontal and vertical
    Gui, Add, DropDownList, x+2 gupdateUIpastePanel wp AltSubmit Choose%PasteInPlaceAlignment% vPasteInPlaceAlignment, Top-left|Top-right|Centered|Bottom-left|Bottom-right
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%PasteInPlaceCropSel% vPasteInPlaceCropSel gupdateUIpastePanel, No cropping|Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus
    Gui, Add, Text, x+2 hp +0x200 vinfoAngleu gBTNresetPasteInPlaceCropAngle, Angle:
    Gui, Add, Edit, x+2 w70 number -multi limit3 veditF5, % PasteInPlaceCropAngular
    Gui, Add, UpDown, vPasteInPlaceCropAngular Range0-359 gupdateUIpastePanel, % PasteInPlaceCropAngular
    ; If (toolu="transform")
       Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceEraseInitial% vPasteInPlaceEraseInitial, &Erase initially selected area
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceQuality% vPasteInPlaceQuality, &High quality image resampling
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit image object
    Gui, Add, Text, xs y+10 w%txtWid2% gBtnResetPanelsSpecificControl vinfoPasteBlur, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    Gui, Add, Checkbox, x+5 hp gupdateUIpastePanel Checked%PasteInPlaceBlurEdgesSoft% vPasteInPlaceBlurEdgesSoft, &Soft edges
    Gui, Add, Slider, xs y+1 gupdateUIpastePanel AltSubmit ToolTip w%txtWid% vPasteInPlaceBlurAmount Range0-255, % PasteInPlaceBlurAmount
    If (coreDesiredPixFmt="0x21808")
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+10 w%txtWid%, WARNING: 32-bits RGBA mode is not activated. This tool may yield erroneous results.
       Gui, Font, Normal
    }

    Gui, Tab, 2 ; colors
    Gui, Add, Checkbox, x+15 y+15 Section gupdateUIpastePanel Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Apply color adjustments
    Gui, Add, DropDownList, x+10 wp-40 gupdateUIpastePanel AltSubmit Choose%PasteInPlaceBlendMode% vPasteInPlaceBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+5 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteLight, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, y+4 gBtnResetPanelsSpecificControl vinfoPasteOpacity , Image opacity: 100`% - ; %thisOpacity%
    Gui, Add, DropDownList, x+25 wp AltSubmit Choose%PasteInPlaceGlassy% vPasteInPlaceGlassy gupdateUIpastePanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Slider, xs y+1 w%txtWid% AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceOpacity Range1-256, % PasteInPlaceOpacity

    Gui, Tab, 3 ; alpha mask
    friendlyMaskInfo := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No alpha mask"
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid2% AltSubmit Choose%PasteInPlaceAlphaMaskMode% vPasteInPlaceAlphaMaskMode gupdateUIpastePanel, %friendlyMaskInfo%|Linear gradient|Radial gradient|Box gradient|Image file|Custom shape
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIpastePanel, &Invert
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIpastePanel, &Tiled
    Gui, Add, Checkbox, x+2 hp Checked%alphaMaskReplaceMode% valphaMaskReplaceMode gupdateUIpastePanel, &Replace
    Gui, Add, Text, xs y+10 w%slideWid% +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrA, Intensity A: 0
    Gui, Add, Text, x+5 hp wp +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrB, Intensity B: 0
    Gui, Add, Slider, xs y+1 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrA Range0-255, % PasteInPlaceAlphaMaskClrA
    Gui, Add, Slider, x+5 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrB Range0-255, % PasteInPlaceAlphaMaskClrB

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientPosA%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientPosB%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientPosA Range0-100, % FillAreaGradientPosA
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientPosB Range0-100, % FillAreaGradientPosB
    Gui, Add, Text, xs y+10 wp vinfoAlphaFile, Image file path or list index number:
    Gui, Add, Combobox, xs y+10 w%txtWid2% vuiPasteInPlaceAlphaFile, obj|%uiPasteInPlaceAlphaFile%||this|prev|next|first|last|user-painted
    Gui, Add, DropDownList, x+5 wp-95 AltSubmit Choose%PasteInPlaceAlphaChannelFile% vPasteInPlaceAlphaChannelFile gupdateUIpastePanel, Red|Green|Blue|Alpha|All gray
    Gui, Add, Button, x+5 hp wp gBtnBrowseAlphaMaskFile vbtnFldr, B&rowse


    Gui, Tab, 4 ; paint alpha
    Gui, Add, Checkbox, x+15 y+15 Section gBTNtoggleAlphaPainting Choose%uiPasteInPlaceAlphaDrawMode% vuiPasteInPlaceAlphaDrawMode, Enable alpha mask painting mode
    Gui, Add, DropDownList, xs y+10 Section AltSubmit gupdateUIpasteInPlacebrushTool Choose%BrushToolType% vBrushToolType, Simple solid color|Soft edges brush
    Gui, Add, Checkbox, x+5 gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode
    Gui, Add, Text, xs y+10 w35 gBtnToggleBrushColors vUIbtnBrushColorA, [X]
    Gui, Add, Slider, x+5 w%slideWid% gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolAopacity Range1-255, % BrushToolAopacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuBrushToolAcolor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolAcolor% vBrushToolAcolor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoBrushAopacity, %thisOpacity%`%
    Gui, Add, Text, xs y+10 w35 gBtnToggleBrushColors vUIbtnBrushColorB, [X]
    Gui, Add, Slider, x+5 w%slideWid% gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolBopacity Range1-255, % BrushToolBopacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuBrushToolBcolor, P
    Gui, Add, ListView, x+5 hp w60%CCLVO% Background%BrushToolBcolor% vBrushToolBcolor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoBrushBopacity, %this2ndOpacity%`%

    ; Gui, Add, Text, xs y+15 w%slideWid2% vinfoBrushSize, Size: %BrushToolSize%
    Gui, Add, Checkbox, xs y+15 w%slideWid% gupdateUIpasteInPlacebrushTool Checked%brushToolDoubleSize% vbrushToolDoubleSize, Diameter: 2000 px
    Gui, Add, Text, x+5 wp vinfoBrushStepping gBTNresetBrushStepu, Stepping: %BrushToolStepping%
    Gui, Add, Slider, xs y+1 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolSize Range2-950, % BrushToolSize
    Gui, Add, Slider, x+5 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolStepping Range0-251, % brushToolStepping

    Gui, Add, Text, xs y+10 wp vinfoBrushAspectRatio gBTNresetBrushAspectRatio , Aspect ratio: %BrushToolAspectRatio%
    Gui, Add, Text, x+5 wp vinfoBrushAngle gBTNresetBrushAngle, Angle: %BrushToolAngle%° 
    Gui, Add, Slider, xs y+1 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolAspectRatio Range-100-100, % BrushToolAspectRatio
    Gui, Add, Slider, x+5 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolAngle Range0-180, % BrushToolAngle

    Gui, Add, Text, xs y+10 wp vinfoBrushSoftness, Softness: %BrushToolSoftness%
    Gui, Add, Text, x+5 wp vinfoBrushDrying gBTNresetBrushDryer, Dry-out rate: %BrushToolDryingRate%
    Gui, Add, Slider, xs y+1 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolSoftness Range1-100, % BrushToolSoftness
    Gui, Add, Slider, x+5 wp gupdateUIpasteInPlacebrushTool NoTicks ToolTip AltSubmit vBrushToolDryingRate Range0-20, % BrushToolDryingRate

    Gui, Tab
    ; friendlyBtn := (toolu="paste") ? "&Paste" : "&Transform"
    friendlyBtn := "&Apply"
    friendlyTitle := (toolu="paste") ? "Paste in place image: " : "Transform selected area: "
    Gui, Add, Button, xm+0 y+15 Section h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w115 hp Default gapplyIMGeditFunction, % friendlyBtn
    Gui, Add, Button, x+5 hp w75 vbtnReset gBtnPasteResetOptions, &Reset
    Gui, Add, Button, x+5 hp wp gBtnHelpTransform, &Help
    Gui, Add, Button, x+5 hp wp gBtnPasteInPlaceCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+7 gupdateUIpastePanel Checked%PasteInPlaceLivePreview% vPasteInPlaceLivePreview, &Live preview (low quality)
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, friendlyTitle appTitle, winPos)
    SetTimer, updateUIpastePanel, -350
    SetTimer, updateUIpasteInPlacebrushTool, -150
    SetTimer, resetOpeningPanel, -300
}

BtnPasteInPlaceCloseWindow() {
   If (liveDrawingBrushTool=1)
   {
      togglePaintingMode()
      Return
   }
   BtnCloseWindow()
}

updateUIpasteInPlacebrushTool() {
   If !(AnyWindowOpen=24 || AnyWindowOpen=31)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, BrushToolOverDraw
   GuiControlGet, BrushToolType
   GuiControlGet, brushToolDoubleSize
   GuiControlGet, brushToolSize
   GuiControlGet, brushToolStepping
   GuiControlGet, BrushToolSoftness
   GuiControlGet, BrushToolAspectRatio
   GuiControlGet, BrushToolAngle
   GuiControlGet, BrushToolDryingRate
   GuiControlGet, BrushToolAopacity
   GuiControlGet, BrushToolBopacity
   GuiControlGet, uiPasteInPlaceAlphaDrawMode

   If (BrushToolUseSecondaryColor=1)
   {
      GuiControl, SettingsGUIA: Enable, PickuBrushToolBcolor
      GuiControl, SettingsGUIA: Enable, BrushToolBopacity
      GuiControl, SettingsGUIA: Enable, BrushToolBcolor
      GuiControl, SettingsGUIA: Enable, infoBrushBopacity
      GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
      GuiControl, SettingsGUIA: Disable, BrushToolAopacity
      GuiControl, SettingsGUIA: Disable, BrushToolAcolor
      GuiControl, SettingsGUIA: Disable, infoBrushAopacity
      GuiControl, SettingsGUIA:, UIbtnBrushColorB, [X]
      GuiControl, SettingsGUIA:, UIbtnBrushColorA, [-]
   } Else
   {
      GuiControl, SettingsGUIA:, UIbtnBrushColorB, [-]
      GuiControl, SettingsGUIA:, UIbtnBrushColorA, [X]
      GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
      GuiControl, SettingsGUIA: Enable, BrushToolAopacity
      GuiControl, SettingsGUIA: Enable, BrushToolAcolor
      GuiControl, SettingsGUIA: Enable, infoBrushAopacity
      GuiControl, SettingsGUIA: Disable, PickuBrushToolBcolor
      GuiControl, SettingsGUIA: Disable, BrushToolBopacity
      GuiControl, SettingsGUIA: Disable, BrushToolBcolor
      GuiControl, SettingsGUIA: Disable, infoBrushBopacity
   }

   If (uiPasteInPlaceAlphaDrawMode=1)
      GuiControl, SettingsGUIA: Enable, BrushToolType
   Else
      GuiControl, SettingsGUIA: Disable, BrushToolType

   If (BrushToolType=1)
   {
      GuiControl, SettingsGUIA: Disable, infoBrushSoftness
      GuiControl, SettingsGUIA: Disable, BrushToolSoftness
      GuiControl, SettingsGUIA: Enable, BrushToolOverDraw
   } Else
   {
      GuiControl, SettingsGUIA: Enable, infoBrushSoftness
      GuiControl, SettingsGUIA: Enable, BrushToolSoftness
      GuiControl, SettingsGUIA: Disable, BrushToolOverDraw
   }

   thisOpacity := Round((BrushToolAopacity / 255) * 100)
   this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
   theSize := (brushToolDoubleSize!=1) ? "Diameter" : "Radius"
   stepu := (brushToolStepping<=2 || brushToolStepping=251) ? "AUTO" : brushToolStepping
   If (brushToolStepping=0)
      stepu := "NONE"

   GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
   GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
   GuiControl, SettingsGUIA:, brushToolDoubleSize, %theSize%: %BrushToolSize% px
   GuiControl, SettingsGUIA:, infoBrushSoftness, Softness: %BrushToolSoftness%`%
   GuiControl, SettingsGUIA:, infoBrushStepping, Stepping: %stepu%
   GuiControl, SettingsGUIA:, infoBrushAngle, Angle: %BrushToolAngle%° 
   GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
   GuiControl, SettingsGUIA:, infoBrushDrying, Dry-out rate: %BrushToolDryingRate%
   SetTimer, WriteSettingsBrushPanel, -250
}

BtnHelpTransform() {
    msgBoxWrapper(appTitle ": HELP", "The transform tool is a multi-functional one. You can clone, crop, resize, rotate, colour adjust and blend images with this tool.`n`nClone image area. Once you have selected an area in the image and opened this panel, deselect «Erase initially selected area» found in the Main tab.`n`nRotate the image. Locate a gray dot with the mouse cursor in the center of the selection area in the viewport, and click 'n drag to adjust the rotation angle.`n`nCrop an image. Set the first drop-down found in the Main tab, to «Original image size», make the selection as small as you need it to be, and set to your preferences the other drop-downs that designate the cropping shape, its angle and the alignment.`n`nAdjust colours and blend images. In the «Adjust colours» tab one can activate the colour adjustments check-box, adjust opacity and choose different blending modes.`n`nWhen alpha masking is activated and the tab pertaining to this is also activated, users can click 'n drag inside the selection area to adjust the mask's gradient center. To reset the position, press Alt+L-Click inside the selection area.", -1, 0, 0)
}

BtnResetPanelsSpecificControl(CtrlHwnd, b, c) {
   ; GuiControlGet, varu, SettingsGUIA: FocusV
   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControlGet, modus, SettingsGUIA:, PasteInPlaceAlphaMaskMode

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2
   If (varu="infoPasteBlur")
   {
      PasteInPlaceBlurAmount := 0
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   }

   If (varu="infoPasteHue")
   {
      PasteInPlaceHue := 0
      GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   }

   If (varu="infoPasteSat")
   {
      PasteInPlaceSaturation := 0
      GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   }

   If (varu="infoPasteLight")
   {
      PasteInPlaceLight := 0
      GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   }

   If (varu="infoPasteGamma")
   {
      PasteInPlaceGamma := 0
      GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   }

   If (varu="infoPasteOpacity")
   {
      PasteInPlaceOpacity := 128
      GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   }

   If (varu="infoPasteAlphaClrA")
   {
      PasteInPlaceAlphaMaskClrA := (modus=5) ? 128 : 0
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrA, % PasteInPlaceAlphaMaskClrA
   }

   If (varu="infoPasteAlphaClrB")
   {
      PasteInPlaceAlphaMaskClrB := (modus=5) ? 0 : 255
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrB, % PasteInPlaceAlphaMaskClrB
   }

   If (varu="infoFillAreaGradientAngle")
   {
      FillAreaGradientAngle := 0
      GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   }

   If (varu="infoFillAreaGradientScale")
   {
      FillAreaGradientScale := (modus=5) ? 1 : 100
      GuiControl, SettingsGUIA:, FillAreaGradientScale, % FillAreaGradientScale
   }

   If (varu="infoFillAreaSigma")
   {
      FillAreaGradientPosA := 0
      GuiControl, SettingsGUIA:, FillAreaGradientPosA, % FillAreaGradientPosA
   }

   If (varu="infoFillAreaBlend")
   {
      FillAreaGradientPosB := 100
      GuiControl, SettingsGUIA:, FillAreaGradientPosB, % FillAreaGradientPosB
   }

   If (AnyWindowOpen=64)
      SetTimer, updateUIbrushTool, -50
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpastePanel, -50
   Else If (AnyWindowOpen=23)
      SetTimer, updateUIfillPanel, -50
}

BtnPasteResetOptions() {
   If (liveDrawingBrushTool=1)
   {
      togglePaintingMode()
      Return
   }

   PasteInPlaceBlurAmount := PasteInPlaceHue := PasteInPlaceSaturation := PasteInPlaceLight := FillAreaGradientAngle := 0
   PasteInPlaceCropSel := PasteInPlaceOrientation := PasteInPlaceAdaptMode := PasteInPlaceAlphaMaskMode := 1
   PasteInPlaceAlignment := 3
   PasteInPlaceApplyColorFX := PasteInPlaceGamma := 0
   PasteInPlaceOpacity := 128
   If (AnyWindowOpen=24)
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   GuiControl, SettingsGUIA:, PasteInPlaceApplyColorFX, % PasteInPlaceApplyColorFX
   GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlphaMaskMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlignment, 3
   GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, 1
   ; WriteSettingsPasteInPlacePanel()
   updateUIpastePanel()
}

ReadSettingsFillAreaPanel(act:=0) {
    If (act=0)
    {
       INIaction(0, "initialCustomShapeCoords", "General", 5)
       If !InStr(FillAreaCustomShape, "|")
          INIaction(0, "FillAreaCustomShape", "General", 5)

       If (drawingShapeNow!=1)
          INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
    } Else If (act=1)
    {
       INIaction(1, "FillAreaCurveTension", "General")
       If InStr(FillAreaCustomShape, "|")
          INIaction(1, "FillAreaCustomShape", "General")
    }

    INIaction(act, "FillAreaColor", "General", 3)
    INIaction(act, "FillAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "FillArea2ndColor", "General", 3)
    INIaction(act, "FillArea2ndOpacity", "General", 2, 1, 255)
    INIaction(act, "FillAreaBlendMode", "General", 2, 1, 21)
    INIaction(act, "FillAreaClosedPath", "General", 1)
    INIaction(act, "FillAreaColorMode", "General", 2, 1, 6)
    INIaction(act, "FillAreaColorReversed", "General", 1)
    INIaction(act, "FillAreaGlassy", "General", 2, 1, 6)
    INIaction(act, "FillAreaGradientAngle", "General", 2, 0, 360)
    INIaction(act, "FillAreaGradientPosB", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientScale", "General", 2, 1, 300)
    INIaction(act, "FillAreaGradientPosA", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientWrapped", "General", 1)
    INIaction(act, "FillAreaInverted", "General", 1)
    INIaction(act, "FillAreaRemBGR", "General", 1)
    INIaction(act, "FillAreaShape", "General", 2, 1, 7)
    INIaction(act, "FillAreaLivePreview", "General", 1)
    INIaction(act, "FillAreaDoContour", "General", 1)
    INIaction(act, "FillAreaApplyColorFX", "General", 1)
    INIaction(act, "DrawLineAreaColor", "General", 3)
    INIaction(act, "DrawLineAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "DrawLineAreaCapsStyle", "General", 1)
    INIaction(act, "DrawLineAreaDoubles", "General", 1)
    INIaction(act, "DrawLineAreaContourAlign", "General", 2, 1, 3)
    INIaction(act, "DrawLineAreaDashStyle", "General", 2, 1, 4)
    INIaction(act, "DrawLineAreaContourThickness", "General", 2, 1, 450)
    INIaction(act, "PasteInPlaceGamma", "General", 2, -100, 100)
    INIaction(act, "PasteInPlaceHue", "General", 2, -180, 180)
    INIaction(act, "PasteInPlaceLight", "General", 2, -255, 255)
    INIaction(act, "PasteInPlaceSaturation", "General", 2, -100, 100)
    INIaction(act, "userimgGammaCorrect", "General", 1)
}

ReadSettingsDrawShapeAreaPanel(act:=0) {
    If (act=0)
    {
       INIaction(0, "initialCustomShapeCoords", "General", 5)
       If !InStr(FillAreaCustomShape, "|")
          INIaction(0, "FillAreaCustomShape", "General", 5)

       If (drawingShapeNow!=1)
          INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
    } Else If (act=1)
    {
       INIaction(1, "FillAreaCurveTension", "General")
       If InStr(FillAreaCustomShape, "|")
          INIaction(1, "FillAreaCustomShape", "General")
    }

    INIaction(act, "DrawLineAreaColor", "General", 3)
    INIaction(act, "DrawLineAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "DrawLineAreaCapsStyle", "General", 1)
    INIaction(act, "DrawLineAreaDoubles", "General", 1)
    INIaction(act, "DrawLineAreaContourAlign", "General", 2, 1, 3)
    INIaction(act, "DrawLineAreaDashStyle", "General", 2, 1, 4)
    INIaction(act, "DrawLineAreaContourThickness", "General", 2, 1, 450)
    INIaction(act, "FillAreaClosedPath", "General", 1)
    INIaction(act, "FillAreaShape", "General", 2, 1, 7)
}

ReadSettingsVPgrid(act:=0) {
    INIaction(act, "vpGridSize", "General", 2, 10, 350)
    INIaction(act, "vpGridAlpha", "General", 2, 1, 255)
    INIaction(act, "vpGridColor", "General", 3)
    INIaction(act, "vpGridFixedSize", "General", 1)
    INIaction(act, "vpGridStepu", "General", 2, 2, 20)
    INIaction(act, "vpGridThickness", "General", 2, 1, 15)
    If (editingSelectionNow!=1 && drawingShapeNow!=1)
       INIaction(act, "LimitSelectBoundsImg", "General", 1)
}

ReadSettingsBrushPanel(act:=0) {
   INIaction(act, "brushToolSize", "General", 2, 2, 950)
   INIaction(act, "brushToolDoubleSize", "General", 1)
   INIaction(act, "BrushToolSoftness", "General")
   INIaction(act, "brushToolStepping", "General", 2, 0, 251)
   INIaction(act, "BrushToolType", "General", 2, 1, 8)
   INIaction(act, "BrushToolUseSecondaryColor", "General", 1)
   INIaction(act, "BrushToolAcolor", "General")
   INIaction(act, "BrushToolBcolor", "General")
   INIaction(act, "BrushToolAopacity", "General", 2, 1, 255)
   INIaction(act, "BrushToolBopacity", "General", 2, 1, 255)
   INIaction(act, "BrushToolAngle", "General", 2, 0, 359)
   INIaction(act, "BrushToolAspectRatio", "General", 2, -100, 100)
   INIaction(act, "BrushToolDryingRate", "General", 2, 0, 20)
   INIaction(act, "BrushToolOverDraw", "General", 1)
   If (AnyWindowOpen=64)
   {
      INIaction(act, "BrushToolTexture", "General", 2, 1, 9)
      INIaction(act, "BrushToolAutoAngle", "General", 1)
      INIaction(act, "BrushToolBlurStrength", "General", 2, 0, 99)
      INIaction(act, "BrushToolDynamicCloner", "General", 1)
      INIaction(act, "BrushToolEraserRestore", "General", 1)
      INIaction(act, "BrushToolOutsideSelection", "General", 2, 1, 3)
      INIaction(act, "BrushToolWetness", "General", 2, 0, 22)
      INIaction(act, "BrushToolApplyColorFX", "General", 1)
      INIaction(act, "PasteInPlaceGamma", "General", 2, -100, 100)
      INIaction(act, "PasteInPlaceHue", "General", 2, -180, 180)
      INIaction(act, "PasteInPlaceLight", "General", 2, -255, 255)
      INIaction(act, "PasteInPlaceSaturation", "General", 2, -100, 100)
   }
}

LEDguiGuiClose:
LEDguiGuiEscape:
   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
Return

StopColorPicker() {
   Critical, on
   colorPickerModeNow := 0
}

StartPickingColor(a:=0, b:=0, c:=0) {
   ; fnOutputDebug(a "=" b "=" c)
   g := A_Gui, ctrl := A_GuiControl
   If (a="isGiven")
   {
      g := b
      ctrl := c
   }

   ctrl := StrReplace(ctrl, "picku")
   If (isWinXP=1 || A_OSVersion="WIN_7")
   {
      msgBoxWrapper(appTitle ": ERROR", "The color picker functionality is not yet implemented for Windows XP or Windows 7... Please use the color selector associated.", 0, 0, "error")
      Return
   }

   initialColor := %ctrl%
   mustCaptureCloneBrush := 0
   If (editingSelectionNow=1)
      toggleLiveEditObject("hide")
   Sleep, 2
   pBitmap := Gdip_BitmapFromHWND(PVhwnd, 1)
   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   If StrLen(pBitmap)>2
   {
      createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
   } Else
   {
      showTOOLtip("Failed to capture main window bitmap`n`nPlease try again to pick a color")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   diffH := diffW := 0
   LEDu := imgHUDbaseUnit
   Gui, LEDgui: -DPIScale +AlwaysOnTop -Caption +Owner +ToolWindow +E0x20 +0x800000 +hwndhColorPrev
   Gui, LEDgui: Color, 000000
   WinSet, AlwaysOnTop, On, ahk_id %hColorPrev%
   Gui, LEDgui: Add, Text, x1 y1 w%LEDu% h%LEDu% gStopColorPicker, -
   Gui, LEDgui: Show, NoActivate x1 y1 w%LEDu% h%LEDu%, QPVcolorPicker
   Sleep, 1
   colorPickerModeNow := 1
   If (panelWinCollapsed!=1 && AnyWindowOpen && imgEditPanelOpened=1)
      toggleImgEditPanelWindow("forced")

   errorOccured := 0
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   While, (colorPickerModeNow=1)
   {
      If (errorOccured>700)
         Break

      Sleep, -1
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX + diffW, 0, imgW)
      mY := clampInRange(mY + diffH, 0, imgH)
      ; ToolTip, % imgW " | " imgH "`n" winW " | " winH "`n" diffW " | " diffH "`n" mX " | " mY , , , 2
      h := Gdip_GetPixelColor(pBitmap, mX, mY, 4)
      If !h
      {
         Sleep, 5
         errorOccured++
         Continue
      }

      ; createColorPrevWin(h)
      Gui, LEDgui: Color, %h%
      GetPhysicalCursorPos(pX, pY)
      pX -= LEDu//2, pY -= LEDu//2
      Gui, LEDgui: Show, NoActivate x%pX% y%pY%
      Sleep, 5
      hwnd := WinActive("A")
      ; ToolTip, % h "`n" z "`n" w , , , 2
      If (A_Index>1950)
      {
         errorOccured := 750
         Break
      }

      If (determineLClickstate() && hwnd=hColorPrev || GetKeyState("Enter") || GetKeyState("Numpad5") )
         Break

      If (GetKeyState("Escape") || GetKeyState("Space") || GetKeyState("Tab") || GetKeyState("MButton") || GetKeyState("RButton"))
      {
         errorOccured := 750
         Break
      }
   }

   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
   If (a!="isGiven" && AnyWindowOpen)
      toggleImgEditPanelWindow("forced")

   trGdip_DisposeImage(pBitmap, 1)
   If (errorOccured>690)
      Return

   If (a="isGiven")
      BrushToolWetness := clampInRange(BrushToolWetness, 0, 19)

   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      h := convertColorToGrayscale(h)

   ; https://autohotkey.com/board/topic/43945-fast-pixelgetcolor-workaround-for-aero-windows-7-and-vista/
   o := %ctrl%
   SoundBeep, 900, 100
   ; ToolTip, % r "`n" ctrl "`n" o "`n" h "`n" g "`n" z , , , 2
   %ctrl% := h

   If ctrl
      INIaction(1, ctrl, "General")

   If (AnyWindowOpen && g && ctrl)
      GuiControl, %g%:+Background%h%, %ctrl%

   If (AnyWindowOpen=63)
   {
      updateUIgridPanel()
   } Else If (imgEditPanelOpened=1 && g)
   {
      fromPanelColorsToColorsSwatch(ctrl, h)
      livePreviewsImageEditing()
   }
   Return [h, initialColor]    ; new color, old color 
}

fromPanelColorsToColorsSwatch(ctrl, newColor) {
   If (ShowAdvToolbar=1)
   {
      thisClr := (BrushToolUseSecondaryColor=1) ? "BrushToolBcolor" : "BrushToolAcolor"
      thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
      If (ctrl="TextInAreaBgrColor" && AnyWindowOpen=32 && TextInAreaPaintBgr=1 && TextInAreaCutOutMode=1)
      {
         %thisClr% := newColor
         %thisOpa% := TextInAreaBgrOpacity
      } Else If (ctrl="TextInAreaFontColor" && AnyWindowOpen=32 && TextInAreaPaintBgr=0)
      {
         %thisClr% := newColor
         %thisOpa% := TextInAreaFontOpacity
      } Else If (ctrl="DrawLineAreaColor" && (AnyWindowOpen=30 || AnyWindowOpen=63))
      {
         %thisClr% := newColor
         %thisOpa% := DrawLineAreaOpacity
      } Else If (ctrl="FillAreaColor" && AnyWindowOpen=23 && FillAreaColorMode=1)
      {
         %thisClr% := newColor
         %thisOpa% := DrawLineAreaOpacity
      } Else If (ctrl="FillAreaColor" || ctrl="TextInAreaFontColor")
      {
         BrushToolAcolor := newColor
         If (ctrl="FillAreaColor")
            BrushToolAopacity := FillAreaOpacity
         Else If (ctrl="TextInAreaFontColor")
            BrushToolAopacity := TextInAreaFontOpacity
      } Else If (ctrl="FillArea2ndColor" || ctrl="TextInAreaBgrColor")
      {
         BrushToolBcolor := newColor
         If (ctrl="FillArea2ndColor")
            BrushToolBopacity := FillArea2ndOpacity
         Else If (ctrl="TextInAreaBgrColor")
            BrushToolBopacity := TextInAreaBgrOpacity
      }

      INIaction(1, "BrushToolAcolor", "General")
      INIaction(1, "BrushToolBcolor", "General")
      INIaction(1, "BrushToolAopacity", "General")
      INIaction(1, "BrushToolBopacity", "General")
      updateTlbrColorsSwatch()
   }
}

convertColorToGrayscale(hexClr) {
   Gdip_FromARGB("0xFF" hexClr, A, R, G, B)
   R := R * 0.308
   G := G * 0.650
   B := B * 0.095
   Z := Round(snapToValues(R + G + B, 0, 255, 2, 1))
   thisColor := Gdip_ToARGB("0xFF", Z, Z, Z)
   clr := SubStr(Format("{1:#x}", thisColor), 5)
   ; ToolTip, % thisColor "`n" R "=" G "=" B "=" Z , , , 2
   Return clr
}

snapToValues(given, valA, valB, errMargin, clamping) {
   If isInRange(given, valA - errMargin, valA + errMargin)
      Return valA
   Else If isInRange(given, valB - errMargin, valB + errMargin)
      Return valB
   Else If (clamping=1)
      Return clampInRange(given, valA, valB)
   Else
      Return given
}

openPanelFillSelectionAfterDrawing() {
   PanelFillSelectedArea("hasDrawn")
}

openPanelDrawShapeSelectionAfterDrawing() {
   PanelDrawShapesInArea("hasDrawn")
}

openPanelDesatureAfterDrawing() {
   PanelDesatureSelectedArea("hasDrawn")
}

cancelDrawingShape() {
   stopDrawingShape("cancel")
}

stopDrawingShape(dummy:="") {
    If (drawingShapeNow!=1)
       Return

    zeitSillyPrevent := A_TickCount
    If (dummy="cancel")
       customShapePoints := oldCustomShapePoints.Clone()
    Else
       customShapePoints := convertCustomShape2relativeCoords(customShapePoints)

    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (!AnyWindowOpen && customShapePoints.Count()>2 && drawingLiveMode!=3 && dummy!="cancel")
    {
       If (prevOpenedWindow[1]=23)
          SetTimer, openPanelFillSelectionAfterDrawing, -150
       Else If (prevOpenedWindow[1]=65)
          SetTimer, openPanelDrawShapeSelectionAfterDrawing, -150
       Else If (prevOpenedWindow[1]=55)
          SetTimer, openPanelDesatureAfterDrawing, -150
       Else
          SetTimer, openPreviousPanel, -150
    }

    If (drawingLiveMode=1 || drawingLiveMode=3)
       Gdip_DeletePen(PenuDrawLive)
    Else
       Gdip_DeleteBrush(PenuDrawLive)

    drawingShapeNow := 0
    PenuDrawLive := ""
    DestroyTempBtnGui("now")

    If (customShapePoints.Count()<3)
    {
       EllipseSelectMode := 0
       If !AnyWindowOpen
          editingSelectionNow := 0

       showDelayedTooltip("Drawing abandoned")
       ; SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else
    {
       If (drawingLiveMode=3 || prevOpenedWindow[1]!=23)
       {
          FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
          INIaction(1, "FillAreaCustomShape", "General")
          INIaction(1, "FillAreaCurveTension", "General")
          editingSelectionNow := 1
       }
       dummyTimerDelayiedImageDisplay(100)
    }

    Global zeitSillyPrevent := A_TickCount
    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    interfaceThread.ahkassign("drawingShapeNow", 0)
    If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
       WinSet, Transparent, % ToolbarOpacity, ahk_id %hQPVtoolbar%
    updateUIctrl()
    MouseMoveResponder()
    If (showMainMenuBar=1)
       TriggerMenuBarUpdate()
}

predefinedVectorShapes(whichShape) {
; 1 = right triangle
; 2 = triangle isoscel
; 3 = rhombus
; 4 = box callout
; 5 = round callout
; 6 = star-5
; 7 = star-4
; 8 = heart
   Static shape1c := "0.0,0.0|0.0,1.0|1.0,1.0"
        , shape1t := 1
        , shape2c := "0.5,0.0|0.0,1.0|1.0,1.0"
        , shape2t := 1
        , shape3c := "0.5,0.0|1.0,0.5|0.5,1.0|0.0,0.5"
        , shape3t := 1
        , shape4c := "0.0,0.0|1.0,0.0|1.0,0.7|0.7,0.7|0.87,1.0|0.5,0.7|0.0,0.7"
        , shape4t := 1
        , shape5c := "0.14,0.07|0.48,0.0|0.88,0.073|1.0,0.4|0.92,0.67|0.72,0.81|1.0,1.0|0.82,0.95|0.55,0.8|0.15,0.69|0.0,0.37"
        , shape5t := 3
        , shape6c := "0.5,0.0|0.3,0.4|0.0,0.45|0.25,0.65|0.1,1.0|0.5,0.77|0.9,1.0|0.75,0.65|1.0,0.45|0.7,0.4"
        , shape6t := 1
        , shape7c := "0.5,0.0|0.35,0.35|0.0,0.5|0.35,0.65|0.5,1.0|0.65,0.65|1.0,0.5|0.65,0.35"
        , shape7t := 1
        , shape8c := "0.682678,0.001382|0.549539,0.140886|0.508866,0.282327|0.449464,0.138629|0.303745,0.000000|0.070881,0.069589|0.000000,0.387251|0.229102,0.783096|0.512461,1.000000|0.785245,0.819754|1.000000,0.380723|0.927203,0.089171"
        , shape8t := 3

     If (whichShape=9)
     {
        INIaction(0, "FillAreaCustomShape", "General", 5)
        INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
     } Else
     {
        thisTension := "shape" whichShape "t"
        thisShape := "shape" whichShape "c"
        FillAreaCurveTension := %thisTension%
        FillAreaCustomShape := %thisShape%
        INIaction(1, "FillAreaCurveTension", "General")
     }

     customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
     decideCustomShapeStyle()
     dummyTimerDelayiedImageDisplay(50)
}

flipWHcustomShape(modus) {
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       If (modus="h")
          customShapePoints[thisIndex] := [1 - c[1], c[2]]
       Else
          customShapePoints[thisIndex] := [c[1], 1 - c[2]]
    }

    modus := (modus="h") ? "HORIZONTALLY" : "VERTICALLY"
    showDelayedTooltip("Custom shape flipped: " modus)
    decideCustomShapeStyle()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

addFluidPointsCustomShape() {
   If (drawingShapeNow!=1 || mustSnapLiveDrawPoints=1)
      Return

   lastInvoked := 1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   newArrayu := new hashtable()
   dotsSize := (FillAreaCurveTension>1) ? SelDotsSize : SelDotsSize//2 + 1
   If (FillAreaCurveTension=3)
      dotsSize := SelDotsSize*2 + 1
   Else If (FillAreaCurveTension=4)
      dotsSize := SelDotsSize*3 + 2

   prevMX := prevMY := 0
   While, (determineLClickstate()=1)
   {
      If (mustSnapLiveDrawPoints=1)
         Break

      If (A_TickCount - lastInvoked<50)
         Continue

      GetMouseCoord2wind(PVhwnd, mX, mY)
      ogmX := (FlipImgH=1) ? mainWidth - mX : mX
      ogmY := (FlipImgV=1) ? mainHeight - mY : mY
      If (newArrayu[ogmX ogmY]=1) || isDotInRect(ogmX, ogmY, prevMX - dotsSize, prevMX + dotsSize, prevMY - dotsSize, prevMY + dotsSize)
         Continue

      mustSnapLiveDrawPoints := 0
      customShapePoints.Push([ogmX, ogmY])
      thisIndex := customShapePoints.MaxIndex()
      initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
      lastInvoked := A_TickCount
      newArrayu[ogmX ogmY] := 1
      newArrayu[ogmX + 1 ogmY + 1] := 1
      newArrayu[ogmX - 1 ogmY - 1] := 1
      newArrayu[ogmX + 1 ogmY - 1] := 1
      newArrayu[ogmX - 1 ogmY + 1] := 1
      lastZeitFileSelect := A_TickCount
      prevMX := ogmX
      prevMY := ogmY
      dummyRefreshImgSelectionWindow()
   }
   newArrayu := []
   SetTimer, addFluidPointsCustomShape, Off
}

resumeCustomShapeSelection(thisZL) {
   If !thisZL
      thisZL := zoomLevel

   zImgSelX1 := imgSelX1*thisZL
   zImgSelY1 := imgSelY1*thisZL
   zImgSelX2 := imgSelX2*thisZL
   zImgSelY2 := imgSelY2*thisZL
   vPimgSelPx := prevDestPosX + min(zImgSelX1, zImgSelX2)
   vPimgSelPy := prevDestPosY + min(zImgSelY1, zImgSelY2)
   vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   If (VPselRotation>0)
   {
      pPath := createImgSelPath(vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 1)
      PointsList := Gdip_GetPathPoints(pPath)
      customShapePoints := convertShapePointsStrToArray(PointsList)
      Gdip_DeletePath(pPath)
   } Else
   {
      PointsList := convertCustomShape2givenArea(customShapePoints, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH)
      customShapePoints := convertShapePointsStrToArray(PointsList)
   }
   ; ToolTip, % customShapePoints.Count() "===" PointsList , , , 2
}

startDrawingShape(modus, dummy:=0, forcePanel:=0) {
     If (thumbsDisplaying=1 || StrLen(gdiBitmap)<3)
        Return

     If (getCaptionStyle(PVhwnd)=1)
     {
        ToggleTitleBaruNow()
        Return
     }

     If (dummy="resume" && customShapePoints.Count()<3)
        dummy := ""

     If VisibleQuickMenuSearchWin
        GoSub, QuickMenuSearchGUIAGuiClose

     If (AnyWindowOpen && imgEditPanelOpened=1)
     {
        If (AnyWindowOpen=55)
           prevOpenedWindow := [55, "PanelDesatureSelectedArea", 1]

        isWinOpen := AnyWindowOpen
        BtnCloseWindow()
        If (dummy="resume")
        {
           If (isWinOpen=65)
              modus := "line"
           Else If (isWinOpen=23 || isWinOpen=25 || isWinOpen=10 || isWinOpen=55)
              modus := "shape"
        }
     }

     Sleep, 5
     If (editingSelectionNow=1)
        recordSelUndoLevelNow()

     If InStr(forcePanel, "draw")
     {
        If (modus="line")
           prevOpenedWindow := [65, "PanelDrawShapesInArea", 1]
        Else
           prevOpenedWindow := [23, "PanelFillSelectedArea", 1]
     }

     drawingShapeNow := 1
     If (customShapePoints.Count()>2)
        oldCustomShapePoints := customShapePoints.Clone()

     interfaceThread.ahkassign("drawingShapeNow", 1)
     If (dummy="resume")
     {
        resumeCustomShapeSelection(zoomLevel)
     } Else 
     {
        customShapePoints := ""
        customShapePoints := []
        ToggleEditImgSelection("show-edit")
     }

     INIaction(0, "FillAreaColor", "General", 3)
     INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
     INIaction(0, "closedLineCustomShape", "General", 1)
     decideCustomShapeStyle()
     thisColorA := (modus="line") ? "0xAA" FillAreaColor : "0x88" FillAreaColor
     If (modus="line")
     {
        PenuDrawLive := (isWinOpen=10) ? Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10) : Gdip_CreatePen(thisColorA, imgHUDbaseUnit//7)
        drawingLiveMode := 1
     } Else If (modus="shape")
     {
        If (isWinOpen=55)
           PenuDrawLive := Gdip_CloneBrush(pBrushF)
        Else
           PenuDrawLive := (isWinOpen=25) ? Gdip_CloneBrush(useHatchedBrush()) : Gdip_BrushCreateSolid(thisColorA)
        drawingLiveMode := 2
     } Else If (modus="selection")
     {
        PenuDrawLive := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        drawingLiveMode := 3
        EllipseSelectMode := 2
        LimitSelectBoundsImg := VPselRotation := 0
        closedLineCustomShape := lockSelectionAspectRatio := 1
     }

     initialDrawingStartCoords := []
     Loop, % customShapePoints.Count()
        initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY]

     LabelCurve := (cardinalCurveCustomShape=1) ? "curved" : "polygonal"
     LabelType := (drawingLiveMode=1) ? "path" : "filled shape"
     If (drawingLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "closed " : "open "
     } Else If (drawingLiveMode=3)
     {
        LabelOpenLine := "selection area"
        LabelCurve := LabelType := ""
     }
     If (showMainMenuBar=1)
        TriggerMenuBarUpdate()

     showTOOLtip("Draw freeform " LabelOpenLine LabelCurve A_Space LabelType "`nPress Right Click to end.")
     showQuickActionButtonsDrawingShape()
     If (showViewPortGrid=1)
        dummyTimerDelayiedImageDisplay(50)

     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
        WinSet, Transparent, 120, ahk_id %hQPVtoolbar%

     SetTimer, dummyRefreshImgSelectionWindow, -150
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

reduceCustomShapelength() {
   ; foundPos := InStr(customShapePoints, "|", 0, -1)
   ; customShapePoints := SubStr(customShapePoints, 1, foundPos)
   customShapePoints.Pop()
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   SetTimer, dummyRefreshImgSelectionWindow, -150
}

ToggleCardinalCurveMode() {
   cardinalCurveCustomShape := !cardinalCurveCustomShape
   INIaction(1, "cardinalCurveCustomShape", "General")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

toggleOpenClosedLineCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   INIaction(1, "closedLineCustomShape", "General")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

showQuickActionButtonsDrawingShape() {
     LabelCurve := (cardinalCurveCustomShape=1) ? "Polygonal" : "Curve"
     If (drawingLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "Open path" : "Closed path"
        btnOpenLine := "||" LabelOpenLine ",,toggleOpenClosedLineCustomShape"
     }

     LabelTension := "||Points tension " FillAreaCurveTension ",,togglePathCurveTension"
     CreateGuiButton("Undo,,reduceCustomShapelength||Cancel,,cancelDrawingShape||Done,,stopDrawingShape" btnOpenLine LabelTension, "Forced", msgDisplayTime*10000)
}

decideCustomShapeStyle() {
   If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1

   cardinalCurveCustomShape := (FillAreaCurveTension>1) ? 1 : 0
}

togglePathCurveTension() {
   FillAreaCurveTension := clampInRange(FillAreaCurveTension + 1, 1, 4, 1)
   decideCustomShapeStyle()
   INIaction(1, "FillAreaCurveTension", "General")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

BtnTabsInfoUpdate() {
   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
}

UIcycleFillShapes() {
   FillAreaShape := clampInRange(FillAreaShape + 1, 1, 7, 1)
   GuiControl, SettingsGUIA: Choose, FillAreaShape, % FillAreaShape
   If (AnyWindowOpen=65)
      updateUIdrawShapesPanel()
   Else If (AnyWindowOpen=23)
      updateUIfillPanel()
}

PanelFillSelectedArea(dummy:=0, which:=0) {
    If (thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(23, A_ThisFunc)
    ReadSettingsFillAreaPanel()
    If (FillAreaShape<=3 || FillAreaShape=7)
    {
       If (EllipseSelectMode=1)
          FillAreaShape := 3
       Else If (EllipseSelectMode=0 && (FillAreaShape=3 || FillAreaShape=7))
          FillAreaShape := 1
       Else If (EllipseSelectMode=2)
          FillAreaShape := 7
    }

    If (dummy="tlbr")
       FillAreaShape := which

    If (dummy="hasDrawn")
    {
       FillAreaShape := 7
       FillAreaClosedPath := closedLineCustomShape
       FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
       INIaction(1, "FillAreaClosedPath", "General")
       INIaction(1, "FillAreaCustomShape", "General")
    } Else customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)

    If (ShowAdvToolbar=1 && FillAreaColorMode=1)
    {
       FillAreaColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       FillAreaOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       updateTlbrColorsSwatch()
    } Else If (ShowAdvToolbar=1)
    {
       FillAreaColor := BrushToolAcolor
       FillAreaOpacity := BrushToolAopacity
       FillArea2ndColor := BrushToolBcolor
       FillArea2ndOpacity := BrushToolBopacity
    }

    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    If isWinXP
    {
       FillAreaBlendMode := 1
       FillAreaGlassy := 1
    }

    FillAreaClosedPath := 1
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, infoFillAreaBlend, PickuFillAreaColor, PickuFillArea2ndColor

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Fill|Border|Adjust colors
    Gui, Tab, 1
    Gui, Add, DropDownList, x+10 y+10 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIfillPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIfillPanel, Polygonal|Smooth corners|Curve|Round curve
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaRemBGR% vFillAreaRemBGR gupdateUIfillPanel, &Erase background behind the new object
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaInverted% vFillAreaInverted gupdateUIfillPanel, &Invert selection area
    Gui, Add, Checkbox, xs y+7 hp Checked%userimgGammaCorrect% vuserimgGammaCorrect gupdateUIfillPanel, &Apply gamma corrections
    Gui, Add, Text, xs y+10 w%slideWid%, Glass effect
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIfillPanel, Not activated|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Text, xs y+7 wp, Blending mode
    Gui, Add, DropDownList, x+5 wp gupdateUIfillPanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Tab, 2
    Gui, Add, DropDownList, x+10 y+10 Section w200 AltSubmit Choose%FillAreaColorMode% vFillAreaColorMode gupdateUIfillPanel, Solid color|Linear gradient|Radial gradient|Box gradient|Random patterns|Texture
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIfillPanel, &Tiling pattern
    Gui, Add, Slider, xs y+10 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillAreaOpacity Range1-255, % FillAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillAreaOpacity, %thisOpacity%`%
    Gui, Add, Slider, xs y+1 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillArea2ndOpacity Range1-255, % FillArea2ndOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillArea2ndColor, P
    Gui, Add, ListView, x+5 hp w60%CCLVO% Background%FillArea2ndColor% vFillArea2ndColor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillArea2ndOpacity, Opacity: %this2ndOpacity%00`%

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientPosA%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientPosB%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientPosA Range0-100, % FillAreaGradientPosA
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientPosB Range0-100, % FillAreaGradientPosB
    Gui, Add, Checkbox, xs y+5 w%slideWid% Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIfillPanel, &Reverse colors
    Gui, Add, Button, x+5 vbtnFldr gBtnSetTextureSource, &Reset gradient center

    Gui, Tab, 3
    Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaDoContour% vFillAreaDoContour gupdateUIfillPanel, &Draw shape outline
    Gui, Add, Slider, xs y+15 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vDrawLineAreaOpacity Range1-255, % DrawLineAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuDrawLineAreaColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoDrawLineAreaOpacity, %thisOpacity%`%
    Gui, Add, Text, xs y+15 w%btnWid%, Alignment
    Gui, Add, Text, x+5 wp, Styling
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign gupdateUIfillPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle gupdateUIfillPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs y+6 w%btnWid% hp Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIfillPanel, &Double line
    Gui, Add, Checkbox, x+2 w%btnWid% hp gupdateUIfillPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
    Gui, Add, Text, xs y+15 w%txtWid% vinfoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIfillPanel ToolTip AltSubmit w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness

    Gui, Tab, 4
    Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaApplyColorFX% vFillAreaApplyColorFX gupdateUIfillPanel, &Apply color adjustments
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIfillPanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIfillPanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteLight, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIfillPanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIfillPanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, xs y+10 Section, These apply only for blending modes and textures.

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaLivePreview% vFillAreaLivePreview gupdateUIfillPanel, &Live preview
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIfillPanel, -50
}

PanelDrawShapesInArea(dummy:=0, which:=0) {
    If (thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(65, A_ThisFunc)
    ReadSettingsDrawShapeAreaPanel()
    If (FillAreaShape<=3 || FillAreaShape=7)
    {
       If (EllipseSelectMode=1)
          FillAreaShape := 3
       Else If (EllipseSelectMode=0 && (FillAreaShape=3 || FillAreaShape=7))
          FillAreaShape := 1
       Else If (EllipseSelectMode=2)
          FillAreaShape := 7
    }

    If (dummy="tlbr")
       FillAreaShape := which

    If (dummy="hasDrawn")
    {
       FillAreaShape := 7
       FillAreaClosedPath := closedLineCustomShape
       FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
       INIaction(1, "FillAreaClosedPath", "General")
       INIaction(1, "FillAreaCustomShape", "General")
    } Else customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)

    If (ShowAdvToolbar=1)
    {
       DrawLineAreaColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       DrawLineAreaOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    }

    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0

    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, PickuFillAreaColor, PickuFillArea2ndColor

    Gui, Add, DropDownList, x+5 y+15 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIdrawShapesPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIdrawShapesPanel, Polygonal|Smooth corners|Curve|Round curve
    Gui, Add, Slider, xs y+10 NoTicks w%slideWid% gupdateUIdrawShapesPanel ToolTip AltSubmit vDrawLineAreaOpacity Range1-255, % DrawLineAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuDrawLineAreaColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoDrawLineAreaOpacity, %thisOpacity%`%
    Gui, Add, Text, xs y+15 w%btnWid%, Alignment
    Gui, Add, Text, x+5 wp, Styling
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign gupdateUIdrawShapesPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle gupdateUIdrawShapesPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIdrawShapesPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs y+6 w%btnWid% hp +0x1000 Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIdrawShapesPanel, &Double line
    Gui, Add, Checkbox, x+2 w%btnWid% hp +0x1000 gupdateUIdrawShapesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
    Gui, Add, Text, xs y+15 w%txtWid% vinfoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIdrawShapesPanel ToolTip AltSubmit w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 wp hp gBtnOpenPanelLines, &Lines
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIdrawShapesPanel, -50
}

toggleViewPortGridu() {
   showViewPortGrid := !showViewPortGrid
   If (showViewPortGrid=1)
      ReadSettingsVPgrid()

   friendly := (showViewPortGrid=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Viewport grid: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If isImgEditingNow()
      dummyTimerDelayiedImageDisplay(100)
}

PanelConfigVPgrid() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(63, A_ThisFunc)
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsVPgrid()
    slideWid2 := slideWid
    slideWid := slideWid*2
    thisOpacity := Round((vpGridAlpha / 255) * 100)
    Global infoOpacity, PickuvpGridColor, infoStepu, infoGridu, infoThick

    Gui, Add, Checkbox, x15 y15 w%slideWid2% Section gupdateUIgridPanel Checked%showViewPortGrid% vshowViewPortGrid, &Show viewport grid
    Gui, Add, Checkbox, x+0 gupdateUIgridPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit to image bounds
    Gui, Add, Slider, xs y+10 gupdateUIgridPanel NoTicks w%slideWid2% ToolTip vvpGridAlpha Range1-255, % vpGridAlpha
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuvpGridColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%vpGridColor% vvpGridColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoOpacity, %thisOpacity%`%
    Gui, Add, Text, xs y+15 w%slideWid2% vinfoGridu, Grid size: ----
    Gui, Add, Checkbox, x+0 gupdateUIgridPanel Checked%vpGridFixedSize% vvpGridFixedSize, &Fixed grid
    Gui, Add, Slider, xs y+1 w%slideWid% gupdateUIgridPanel NoTicks ToolTip vvpGridSize Range10-350, % vpGridSize
    Gui, Add, Text, xs y+10 w%slideWid2% vinfoThick, Thickness: %vpGridThickness%
    Gui, Add, Text, x+5 wp vinfoStepu, Stepping: %vpGridStepu%
    Gui, Add, Slider, xs y+1 wp gupdateUIgridPanel NoTicks ToolTip vvpGridThickness Range1-15, % vpGridThickness
    Gui, Add, Slider, x+5 wp gupdateUIgridPanel NoTicks ToolTip vvpGridStepu Range2-20, % vpGridStepu
    Gui, Add, Text, xs y+10 w%slideWid%, You can use Alt + [-] / [+] in the main window to change the dimensions of the grid.

    Gui, Add, Button, xs y+15 w90 h%thisBtnHeight% Default gBtnCloseWindow, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Viewport grid: " appTitle, winPos)
    SetTimer, updateUIgridPanel, -50
}

changeGridSize(dir) {
   If (thumbsDisplaying=1)
      Return

   If (showViewPortGrid!=1)
   {
      If (dir=1)
         toggleViewPortGridu()
      Return
   }

   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   If (dir=1)
      vpGridSize += 5
   Else
      vpGridSize -= 5

   If (vpGridSize<thisGridThickness + 6)
   {
      vpGridSize := clampInRange(vpGridSize, 10, 350)
      toggleViewPortGridu()
      Return
   }

   vpGridSize := clampInRange(vpGridSize, 10, 350)
   showTOOLtip("Viewport grid size: " vpGridSize, A_ThisFunc, 2, vpGridSize/350)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpGridSize", "General")
   dummyTimerDelayiedImageDisplay(90)
}

updateUIgridPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, vpGridStepu
   GuiControlGet, vpGridThickness
   GuiControlGet, vpGridSize
   GuiControlGet, vpGridAlpha
   GuiControlGet, vpGridFixedSize
   GuiControlGet, showViewPortGrid
   GuiControlGet, LimitSelectBoundsImg
   thisOpacity := Round((vpGridAlpha / 255) * 100)
   GuiControl, SettingsGUIA:, infoOpacity, %thisOpacity%`%
   GuiControl, SettingsGUIA:, infoGridu, Grid size: %vpGridSize% 
   GuiControl, SettingsGUIA:, infoThick, Thickness: %vpGridThickness%
   GuiControl, SettingsGUIA:, infoStepu, Stepping: %vpGridStepu%

   dummyTimerDelayiedImageDisplay(100)
   SetTimer, WriteSettingsVPgrid, -150
}

WriteSettingsVPgrid() {
   ReadSettingsVPgrid(1)
}

WriteSettingsBrushPanel() {
   ReadSettingsBrushPanel(1)
}

ToggleClosePanelApply() {
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   INIaction(1, "closeEditPanelOnApply", "General")
}

ReadSettingsDrawLinesArea(act:=0) {
    INIaction(act, "DrawLineAreaColor", "General", 3)
    INIaction(act, "DrawLineAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "DrawLineAreaKeepBounds", "General", 1)
    INIaction(act, "DrawLineAreaCapsStyle", "General", 1)
    INIaction(act, "DrawLineAreaDoubles", "General", 1)
    INIaction(act, "DrawLineAreaContourAlign", "General", 2, 1, 3)
    INIaction(act, "DrawLineAreaDashStyle", "General", 2, 1, 4)
    INIaction(act, "DrawLineAreaContourThickness", "General", 2, 1, 450)
    INIaction(act, "DrawLineAreaBorderTop", "General", 1)
    INIaction(act, "DrawLineAreaBorderBottom", "General", 1)
    INIaction(act, "DrawLineAreaBorderLeft", "General", 1)
    INIaction(act, "DrawLineAreaBorderRight", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcA", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcB", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcC", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcD", "General", 1)
    INIaction(act, "DrawLineAreaBorderCenter", "General", 2, 1, 7)
}

PanelDrawLines() {
    If (thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    If (editingSelectionNow!=1)
      ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(30, A_ThisFunc)
    ReadSettingsDrawLinesArea()
    If (ShowAdvToolbar=1)
    {
       DrawLineAreaColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       DrawLineAreaOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    }

    EllipseSelectMode := 0
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid := 165
    BtnHeight := thisBtnHeight - 5
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoDrawLineAreaOpacity, infoDrawLineAreaContour, PickuDrawLineAreaColor
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please configure what lines to draw and how.
    Gui, Add, Text, y+10 Section w%txtWid%, Line style. Alignment.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, DropDownList, x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign, Inside|Centered|Outside

    Gui, Add, Checkbox, xs y+10 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcA% vDrawLineAreaBorderArcA,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderTop% vDrawLineAreaBorderTop,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcB% vDrawLineAreaBorderArcB,○
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, Rounded caps
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderLeft% vDrawLineAreaBorderLeft,▏
    Gui, Add, Text, x+1 wp hp Center,.
    ; Gui, Add, Checkbox, x+1 wp hp +0x1000 Checked%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,▏
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderRight% vDrawLineAreaBorderRight,▏
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles, Double line
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcC% vDrawLineAreaBorderArcC,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderBottom% vDrawLineAreaBorderBottom,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcD% vDrawLineAreaBorderArcD,○
    Gui, Add, ListView, x+10 w%btnWid% hp %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor,
    Gui, Add, Button, x+1 hp w25 gStartPickingColor vPickuDrawLineAreaColor, P

    Gui, Add, DropDownList, xs y+0 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,No center line|Vertical|Horizontal|Slash|Backslash|Both diagonals|Both H/V lines
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaKeepBounds% vDrawLineAreaKeepBounds, &Within bounds

    Gui, Add, Text, xs y+10 w%txtWid% vinfoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaOpacity Range3-255, % DrawLineAreaOpacity
    Gui, Add, Text, xs y+10 wp vinfoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w110 hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 wp hp gBtnOpenPanelShapes, &Shapes
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw lines or arcs in selected area: " appTitle, winPos)
    SetTimer, updateUIDrawLinesPanel, -50
}

BtnOpenPanelShapes() {
   BtnCloseWindow()
   Sleep, 2
   PanelDrawShapesInArea()
}

BtnOpenPanelLines() {
   BtnCloseWindow()
   Sleep, 2
   PanelDrawLines()
}

PanelDesatureSelectedArea(dummy:=0) {
    If (thumbsDisplaying=1)
       Return

    If throwErrorNoImageLoaded()
       Return "fail"

    If (editingSelectionNow!=1 && dummy!="hasDrawn")
       selectEntireImage("r")
    Else
       ToggleEditImgSelection("show-edit")

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(55, A_ThisFunc)
    INIaction(0, "DesatureAreaAmount", "General", 2, 1, 100)
    INIaction(0, "DesatureAreaHue", "General", 2, -180, 180)
    INIaction(0, "DesatureAreaAlternate", "General", 1)
    ; INIaction(0, "EraseAreaInvert", "General", 1)
    btnWid := 70
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 20
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If isWinXP
       DesatureAreaAlternate := 0

    thisOpacity := DesatureAreaAmount
    Global infoAmount, infohueAdjust
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide the intensity and mode of image desaturation.
    ; Gui, Add, Checkbox, x+10 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIdesaturatePanel, &Invert selection area
    Gui, Add, Text, xs+15 y+10 wp gBtnResetAmountDesature vinfoAmount, intensity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIdesaturatePanel ToolTip w%txtWid% vDesatureAreaAmount Range1-100, % DesatureAreaAmount
    Gui, Add, Text, xs+15 y+10 wp gBtnResetDesatureHue vinfohueAdjust, Relight: %DesatureAreaHue%°
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIdesaturatePanel ToolTip w%txtWid% vDesatureAreaHue Range-180-180, % DesatureAreaHue

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%DesatureAreaAlternate% vDesatureAreaAlternate gupdateUIdesaturatePanel, &Simple mode
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Desaturate selected area: " appTitle, winPos)
    SetTimer, updateUIdesaturatePanel, -150
}

PanelEraseSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(25, A_ThisFunc)
    INIaction(0, "EraseAreaFader", "General", 1)
    INIaction(0, "EraseAreaOpacity", "General", 2, 4, 251)
    INIaction(0, "EraseAreaInvert", "General", 1)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    Global infoEraseOpacity
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide how to erase or fade selected area:
    Gui, Add, Checkbox, xs y+10 hp Checked%EraseAreaFader% vEraseAreaFader gupdateUIerasePanel, &Fade selected area
    Gui, Add, Checkbox, x+10 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIerasePanel, &Invert selection area
    Gui, Add, Text, xs+15 y+10 wp hp vinfoEraseOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIerasePanel ToolTip w%txtWid% vEraseAreaOpacity Range5-250, % EraseAreaOpacity

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Erase selected area: " appTitle, winPos)
    SetTimer, updateUIerasePanel, -150
}

livePreviewEraseArea() {
      ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
      Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
      calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
      imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
      imgSelW := max(X1, X2) - min(X1, X2)
      imgSelH := max(Y1, Y2) - min(Y1, Y2)
      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)

      thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity : 0
      thisBase := (coreDesiredPixFmt="0x21808") ? "0xFF000000" : "0xFF999999"
      Gdip_FromARGB(thisBase, A, R, G, B)
      thisColorA := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      Gdip_FromARGB("0xFF111111", A, R, G, B)
      thisColorB := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      thisBrush := Gdip_BrushCreateHatch(thisColorA, thisColorB, 50)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      dpX := clampInRange(prevDestPosX, 0, mainWidth)
      dpY := clampInRange(prevDestPosY, 0, mainHeight)
      kW := clampInRange(prevResizedVPimgW, 0, mainWidth)
      kH := clampInRange(prevResizedVPimgH, 0, mainHeight)

      If (EraseAreaInvert=1)
      {
         Gdip_SetClipPath(2NDglPG, pPath, 4)
         Gdip_FillRectangle(2NDglPG, thisBrush, dpX, dpY, kW, kH)
         Gdip_ResetClip(2NDglPG)
      } Else Gdip_FillPath(2NDglPG, thisBrush, pPath)

      Gdip_DeletePath(pPath)
      Gdip_DeleteBrush(thisBrush)
      ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
}

PasteInPlaceEraseArea(G2, mode) {
      If (mode=1)
      {
         imgSelPx := x1 := prevSelDotX + SelDotsSize//2, x2 := prevSelDotAx + SelDotsSize//2
         imgSelPy := y1 := prevSelDotY + SelDotsSize//2, y2 := prevSelDotAy + SelDotsSize//2
         imgSelW := max(X1, X2) - min(X1, X2)
         imgSelH := max(Y1, Y2) - min(Y1, Y2)
      } Else
      {
         Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
         calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 1)
      }

      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio)
      If (mode=1)
      {
         If pPath
            Gdip_FillPath(G2, useHatchedBrush(), pPath)
      } Else
      {
         If pPath
            Gdip_SetClipPath(G2, pPath)
         trGdip_GraphicsClear(A_ThisFunc, G2)
         Gdip_ResetClip(G2)
      }

      Gdip_DeletePath(pPath)
}

WriteSettingsBlurPanel() {
    ReadSettingsBlurPanel(1)
}

ReadSettingsBlurPanel(act:=0) {
    INIaction(act, "blurAreaAmount", "General", 2, 0, 255)
    INIaction(act, "blurAreaMode", "General", 2, 1, 3)
    INIaction(act, "blurAreaPixelizeAmount", "General", 2, 0, 1024)
    INIaction(act, "blurAreaPixelizeMethod", "General", 2, 1, 3)
    INIaction(act, "blurAreaOpacity", "General", 2, 3, 255)
    INIaction(act, "blurAreaInverted", "General", 1)
    INIaction(act, "blurAreaSoftEdges", "General", 1)
    INIaction(act, "blurAreaSoftLevel", "General", 2, 1, 7)
    INIaction(act, "BlurAreaBlendMode", "General", 2, 1, 21)
    INIaction(act, "blurAreaTwice", "General", 1)
}

PanelBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(26, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 75
    txtWid := 280
    EditWid := 60
    thisW := 135
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 40
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    Global infoBlurOpacity, infoBlurAmount, infoPixelize
    If (wasSelect!=1)
    {
       blurAreaSoftEdges := 0
       blurAreaInverted := 0
    }

    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    If (isWinXP=1 && blurAreaMode=1)
    {
       blurAreaMode := 2
       blurAreaSoftEdges := 0
    }
    
    If (coreDesiredPixFmt="0x21808")
       blurAreaSoftEdges := 0

    friendly := (isWinXP=1) ? " (unsupported)" : ""
    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No blending mode"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    Gui, +DPIScale
    Gui, Add, Checkbox, x+20 ys Section Checked%blurAreaSoftEdges% vblurAreaSoftEdges gupdateUIblurPanel, &Soft edges%friendly%
    Gui, Add, DropDownList, x+5 w50 AltSubmit Choose%blurAreaSoftLevel% gupdateUIblurPanel vblurAreaSoftLevel, 0.3x|0.6x|1x|2x|3x|4x|5x
    Gui, Add, Checkbox, xs y+10 hp Checked%blurAreaTwice% vblurAreaTwice gupdateUIblurPanel, &Blur twice in one go (for large images)
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurAmount vinfoBlurAmount, Blur amount: %blurAreaAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaMode% gupdateUIblurPanel vblurAreaMode, High quality%friendly%|Alternate blur|Box blur (slow)
    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaAmount Range0-255, % blurAreaAmount
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetPixelizationAmount vinfoPixelize, Pixelize level: %blurAreaPixelizeAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaPixelizeMethod% gupdateUIblurPanel vblurAreaPixelizeMethod, Method 1|Method 2|Method 3
    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaPixelizeAmount Range0-1024, %blurAreaPixelizeAmount%
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurOpacity vinfoBlurOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+5 wp gupdateUIblurPanel AltSubmit Choose%BlurAreaBlendMode% vBlurAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaOpacity Range5-255, % blurAreaOpacity
    If (wasSelect!=1 && EllipseSelectMode=0)
       GuiControl, Disable, blurAreaInverted

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnBlurSelectedArea, &Blur area
    Gui, Add, Button, x+6 hp w%btnWid% gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+10 Checked%blurAreaInverted% vblurAreaInverted gupdateUIblurPanel, &Invert selection
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Blur/pixelize selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

BTNresetBlurOpacity() {
   GuiControl, SettingsGUIA:, blurAreaOpacity, 255
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else
      updateUIblurPanel()
}

BTNresetPixelizationAmount() {
   GuiControl, SettingsGUIA:, blurAreaPixelizeAmount, 0
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else
      updateUIblurPanel()
}

BTNresetBlurAmount() {
   If (AnyWindowOpen=44)
   {
      GuiControl, SettingsGUIA:, blurAreaAmount, 0
      updateUIaddNoisePanel()
   } Else
   {
      GuiControl, SettingsGUIA:, blurAreaAmount, 25
      updateUIblurPanel()
   }
}

WriteSettingsEdgesPanel() {
    ReadSettingsEdgesPanel(1)
}

WriteSettingsAddNoisePanel() {
    ReadSettingsAddNoisePanel(1)
}

ReadSettingsEdgesPanel(act:=0) {
    INIaction(act, "IDedgesOpacity", "General", 2, 3, 255)
    INIaction(act, "IDedgesEmphasis", "General", 2, -255, 255)
    INIaction(act, "IDedgesContrast", "General", 2, -100, 100)
    INIaction(act, "IDedgesBlendMode", "General", 2, 1, 21)
    INIaction(act, "IDedgesCenterAmount", "General", 2, 1, 6)
    INIaction(act, "IDedgesXuAmount", "General", 2, -3, 3)
    INIaction(act, "IDedgesYuAmount", "General", 2, -3, 3)
    INIaction(act, "IDedgesAfterBlur", "General", 2, 1, 5)
    INIaction(act, "IDedgesEmbossLvl", "General", 2, 1, 6)
    INIaction(act, "IDedgesInvert", "General", 1)
}

ReadSettingsAddNoisePanel(act:=0) {
    INIaction(act, "IDedgesOpacity", "General", 2, 3, 255)
    INIaction(act, "IDedgesEmphasis", "General", 2, -255, 255)
    INIaction(act, "IDedgesContrast", "General", 2, -100, 100)
    INIaction(act, "IDedgesInvert", "General", 1)
    INIaction(act, "IDedgesBlendMode", "General", 2, 1, 21)
    INIaction(act, "UserAddNoiseMode", "General", 1)
    INIaction(act, "UserAddNoiseIntensity", "General", 2, 1, 100)
    INIaction(act, "blurAreaAmount", "General", 2, 0, 200)
    INIaction(act, "blurAreaPixelizeAmount", "General", 2, 0, 100)
}

PanelDetectEdgesImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(43, A_ThisFunc)
    ReadSettingsEdgesPanel()
    btnWid := 100
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130

    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    Gui, Add, Text, x+20 ys Section, Direction and iterations:
    Gui, Add, DropDownList, x+6 w45 gupdateUIedgesPanel AltSubmit Choose%IDedgesEmbossLvl% vIDedgesEmbossLvl, 1|2|3|4|5|6
    Gui, Add, Text, xs y+10 w90, X
    Gui, Add, Text, x+3 wp, Y
    Gui, Add, Text, x+3 wp, C
    Gui, Add, DropDownList, xs y+7 wp gupdateUIedgesPanel vIDedgesXuAmount, -3|-2|-1|0|1|2|3|%IDedgesXuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel vIDedgesYuAmount, -3|-2|-1|0|1|2|3|%IDedgesYuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesCenterAmount% vIDedgesCenterAmount, 0|1|2|3|4|5

    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIedgesPanel Checked%IDedgesInvert% vIDedgesInvert, &Invert image
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesContrast vinfoContrst, Contrast: %IDedgesContrast%
    Gui, Add, DropDownList, x+7 wp AltSubmit gupdateUIedgesPanel Choose%IDedgesAfterBlur% vIDedgesAfterBlur, After blur|4|6|8|10
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesContrast Range-100-100, % IDedgesContrast
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnIDedgesNow w%btnWid%, &Process image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Detect edges in selected area: " appTitle, winPos)
    SetTimer, updateUIedgesPanel, -200
}

PanelAddNoiserImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(44, A_ThisFunc)
    ReadSettingsAddNoisePanel()
    btnWid := 100
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130
    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst, infoNoiseLvl, infoBlurAmount, infoPixelize
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    Gui, Add, Checkbox, x+20 ys Section gupdateUIaddNoisePanel Checked%UserAddNoiseMode% vUserAddNoiseMode, &Grayscale noise
    Gui, Add, Text, x+5 hp gBTNresetNoiseLevel vinfoNoiseLvl -wrap, Noise cut-off: 1000
    Gui, Add, Slider, xs y+5 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vUserAddNoiseIntensity Range1-100, % UserAddNoiseIntensity
    
    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIaddNoisePanel Checked%IDedgesInvert% vIDedgesInvert, &Invert noise
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetEdgesContrast vinfoContrst, Contrast: %IDedgesContrast%
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesContrast Range-100-100, % IDedgesContrast

    Gui, Add, Text, xs y+7 wp gBTNresetPixelizationAmount vinfoPixelize, Pixelize: %blurAreaPixelizeAmount%
    Gui, Add, Slider, xs y+2 AltSubmit gupdateUIaddNoisePanel ToolTip NoTicks w%txtWid% vblurAreaPixelizeAmount Range0-100, %blurAreaPixelizeAmount%
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetBlurAmount vinfoBlurAmount, Blur: %blurAreaAmount%
    Gui, Add, Slider, xs y+2 AltSubmit gupdateUIaddNoisePanel ToolTip NoTicks w%txtWid% vblurAreaAmount Range0-200, % blurAreaAmount

    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIaddNoisePanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnAddNoiseNow w%btnWid%, &Add noise
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Add noise in selected area: " appTitle, winPos)
    SetTimer, updateUIaddNoisePanel, -200
}

BTNresetEdgesOpacity() {
    GuiControl, SettingsGUIA:, IDedgesOpacity, 255
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetNoiseLevel() {
    GuiControl, SettingsGUIA:, UserAddNoiseIntensity, 30
    updateUIaddNoisePanel()
}

BTNresetEdgesBright() {
    GuiControl, SettingsGUIA:, IDedgesEmphasis, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetEdgesContrast() {
    GuiControl, SettingsGUIA:, IDedgesContrast, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BtnIDedgesNow() {
    updateUIedgesPanel("no")
    CloseWindow()
    detectEdgesSelectedArea()
}

BtnAddNoiseNow() {
    updateUIaddNoisePanel("no")
    CloseWindow()
    addNoiseSelectedArea()
}

updateUIedgesPanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=43)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked < 70) 
    {
       SetTimer, updateUIedgesPanel, -125
       Return
    }

    GuiControlGet, IDedgesOpacity
    GuiControlGet, IDedgesEmphasis
    GuiControlGet, IDedgesContrast
    GuiControlGet, IDedgesCenterAmount
    GuiControlGet, IDedgesAfterBlur
    GuiControlGet, IDedgesEmbossLvl
    GuiControlGet, IDedgesXuAmount
    GuiControlGet, IDedgesYuAmount
    GuiControlGet, IDedgesInvert
    GuiControlGet, IDedgesBlendMode

    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    If (dummy!="no")
    {
       SetTimer, WriteSettingsEdgesPanel, -150
       SetTimer, livePreviewIDedges, -50
    }
    lastInvoked := A_TickCount
}

updateUIaddNoisePanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=44)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked < 70) 
    {
       SetTimer, updateUIaddNoisePanel, -125
       Return
    }

    GuiControlGet, IDedgesOpacity
    GuiControlGet, IDedgesEmphasis
    GuiControlGet, IDedgesContrast
    GuiControlGet, IDedgesInvert
    GuiControlGet, IDedgesBlendMode
    GuiControlGet, blurAreaAmount
    GuiControlGet, blurAreaPixelizeAmount
    GuiControlGet, UserAddNoiseIntensity
    GuiControlGet, UserAddNoiseMode

    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    GuiControl, SettingsGUIA:, infoNoiseLvl, % "Noise cut-off: " UserAddNoiseIntensity "%"
    GuiControl, SettingsGUIA:, infoBlurAmount, % "Blur: " blurAreaAmount
    GuiControl, SettingsGUIA:, infoPixelize, % "Pixelize: " blurAreaPixelizeAmount
    If (dummy!="no")
    {
       SetTimer, WriteSettingsAddNoisePanel, -150
       SetTimer, livePreviewAddNoiser, -50
    }
}

PanelNewImage() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(27, A_ThisFunc)
    INIaction(0, "NewDocUseColor", "General", 1)
    INIaction(0, "PredefinedDocsSizes", "General", 2, 1, 13)
    INIaction(0, "NewImageReverseDimensions", "General", 1)
    INIaction(0, "FillAreaColor", "General", 3)
    INIaction(0, "FillAreaOpacity", "General", 2, 1, 255)
    If (!UserNewWidth || !UserNewHeight || !UserNewDPI)
       PredefinedDocsSizes := 1
    Else If (UserNewWidth && UserNewHeight &&UserNewDPI)
       PredefinedDocsSizes := 13

    If (ShowAdvToolbar=1)
    {
       FillAreaColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       FillAreaOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    }

    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoResultRes, PickuFillAreaColor
    Gui, Add, Text, x15 y15 Section, Create new RGBA image. Please set image dimensions.
    Gui, Add, DropDownList, y+10 wp gupdateUInewImagePanel AltSubmit Choose%PredefinedDocsSizes% vPredefinedDocsSizes, Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Previously used dimensions
    Gui, Add, Text, xs y+10 w%EditWid%, Width (px)
    Gui, Add, Text, x+1 wp, Height (px)
    Gui, Add, Text, x+1 wp, DPI
    Gui, Add, Edit, xs y+7 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewWidth, % UserNewWidth
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewHeight, % UserNewHeight
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewDPI, % UserNewDPI
    Gui, Add, Checkbox, xs y+10 Checked%NewImageReverseDimensions% vNewImageReverseDimensions, Rotate canvas 90° degrees
    Gui, Add, Checkbox, xs y+10 gupdateUInewImagePanel Checked%NewDocUseColor% vNewDocUseColor, Fill background with color
    Gui, Add, ListView, xs y+10 h30 w%editWid% %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, Text, x+5 hp +0x200 vinfoFillAreaOpacity, Opacity: %thisOpacity%00`%
    Gui, Add, Slider, xs y+1 hp w%txtWid% gupdateUInewImagePanel ToolTip AltSubmit vFillAreaOpacity Range3-255, % FillAreaOpacity
    ; Gui, Add, Text, xs y+10, Resulted dimensions:
    ; Gui, Add, Text, xs y+10 w%txtWid% vinfoResultRes, --`n--

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnCreateNewImage, &Create new image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Button, x+25 hp w%btnWid% gOpenNewQPVinstance, &New instance
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "New image: " appTitle)
    SetTimer, updateUInewImagePanel, -150
}

ReadSettingsPrintPanel(act:=0) {
    INIaction(act, "TextInAreaAlign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaValign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaFontColor", "General", 3)
    INIaction(act, "TextInAreaFontName", "General", 5)
    INIaction(act, "TextInAreaFontBold", "General", 1)
    INIaction(act, "TextInAreaFontItalic", "General", 1)
    INIaction(act, "TextInAreaFontUline", "General", 1)
    INIaction(act, "PrintTxtSize", "General", 2, 24, 999)
    INIaction(act, "PrintDimensionsXYWH", "General", 5)
    INIaction(act, "PrintOrientation", "General", 2, 0, 359)
    INIaction(act, "PrintDoFlipuH", "General", 1)
    INIaction(act, "PrintDoFlipuV", "General", 1)
    INIaction(act, "PrintColorMode", "General", 1)
    INIaction(act, "PrintAdaptToFit", "General", 1)
    INIaction(act, "PrintUseViewportColors", "General", 1)
    INIaction(act, "PrintStrechedSize", "General", 1)
}

PanelPrintImage() {
    Global PrintPosEditX, PrintPosEditY, PrintPosEditW, PrintPosEditH, PrintPosTxtX, PrintPosTxtY, PrintPosTxtW, PrintPosTxtH
         , PrintCopies, SelectedPrinteru, PrintDoFlipuH, PrintDoFlipuV, PrinterPageInfos, UserTextArea, editF1, PickuTextInAreaFontColor

    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

    If StrLen(useGdiBitmap())>2
       viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, useGdiBitmap(), 450, 450, 1, 3, -1)

    thisBtnHeight := createSettingsGUI(57, A_ThisFunc)
    ReadSettingsPrintPanel()
    printDims := StrSplit(PrintDimensionsXYWH, "|")
    PrintPosX := printDims[1]
    PrintPosY := printDims[2]
    PrintPosW := printDims[3]
    PrintPosH := printDims[4]
    
    btnWid := 70
    txtWid := 350
    EditWid := 50
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    printerlist := SGDIPrint_GetDefaultPrinter() "||" SGDIPrint_EnumPrinters("|") 
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w248 h351 Section +0x1000 +0xE +hwndhCropCornersPic, Print preview
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, -`n-`n-`n-
    Gui, +DPIScale

    Gui, Add, Tab3, x+20 ys Section, General|Text line

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section, Please choose printer:
    Gui, Add, DropDownList, y+7 wp+90 gupdatePrintPreview vSelectedPrinteru, %printerlist%
    Gui, Add, Button, x+5 hp gBtnSetPrinterDefault, Set as &default
    Gui, Add, Edit, xs y+10 w50 r1 limit3 +number -multi -wantTab -wrap vPrintCopies, 1
    Gui, Add, Text, x+5 hp +0x200, copies to print
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintAdaptToFit% vPrintAdaptToFit, Automatically adapt image to cover page
    Gui, Add, Text, xs y+10 vPrintPosTxtY w%EditWid%, Top
    Gui, Add, Text, x+1 vPrintPosTxtX wp, Left
    Gui, Add, Text, x+1 vPrintPosTxtW wp, Width
    Gui, Add, Text, x+1 vPrintPosTxtH wp, Height
    Gui, Add, Text, x+1 wp, Angle
    Gui, Add, Edit, xs y+7 wp gupdatePrintPreview vPrintPosEditY number -multi limit3, % PrintPosY
    Gui, Add, UpDown, vPrintPosY Range0-98, % PrintPosY
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditX number -multi limit3, % PrintPosX
    Gui, Add, UpDown, vPrintPosX Range0-98, % PrintPosX
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditW number -multi limit3, % PrintPosW
    Gui, Add, UpDown, vPrintPosW Range2-100, % PrintPosW
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditH number -multi limit3, % PrintPosH
    Gui, Add, UpDown, vPrintPosH Range2-100, % PrintPosH
    Gui, Add, Edit, x+2 wp gupdatePrintPreview number -multi limit3, % PrintOrientation
    Gui, Add, UpDown, vPrintOrientation Range0-360, % PrintOrientation
    Gui, Add, Text, xs y+10 hp +0x200, Flip image:
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuH% vPrintDoFlipuH, vertically
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuV% vPrintDoFlipuV, horizontally
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintColorMode% vPrintColorMode, Print using colors
    Gui, Add, Checkbox, x+10 gupdatePrintPreview Checked%PrintStrechedSize% vPrintStrechedSize, Stretch to given dimensions
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintUseViewportColors% vPrintUseViewportColors, Apply viewport color adjustments

    Gui, Tab, 2
    EditWid2 := (PrefsLargeFonts!=1) ? 290 : 450
    Gui, Add, Text, x+15 y+15 Section, Text to insert on the page:
    Gui, Add, Edit, xs y+5 w%EditWid2% r2 gupdatePrintPreview vUserTextArea limit2048, % UserTextArea
    Gui, Add, Text, xs y+15 wp, Font name:
    Gui, Add, DropDownList, xs y+5 wp Sort gupdatePrintPreview Choose1 vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Text, xs y+15, Text size and color:
    Gui, Add, Edit, xs+0 y+5 w%editWid% gupdatePrintPreview r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % PrintTxtSize
    Gui, Add, UpDown, vPrintTxtSize gupdatePrintPreview Range25-999, % PrintTxtSize
    Gui, Add, ListView, x+2 w%editWid% hp gupdatePrintPreview %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P
    Gui, Add, Text, xs y+15, Text alignment and style:
    Gui, Add, DropDownList, xs y+5 w%editWid% gupdatePrintPreview Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdatePrintPreview Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontUline% vTextInAreaFontUline, U

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnStartPrintingNow, &Print now
    ; Gui, Add, Button, x+5 hp gupdatePrintPreview, &Preview
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, &Cancel

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Print image: " appTitle)
    ; SetTimer, updatePrintPreview, -500
}

BtnSetPrinterDefault() {
   Gui, SettingsGUIA: Default
   GuiControlGet, SelectedPrinteru
   If !SGDIPrint_SetDefaultPrinter(SelectedPrinteru)
      msgBoxWrapper(appTitle ": ERROR", "Failed to set " SelectedPrinteru " as default.", 0, 0, "error")
}

printSettingsObj() {
   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   GuiControlGet, PrintPosX
   GuiControlGet, PrintPosY
   GuiControlGet, PrintPosW
   GuiControlGet, PrintPosH
   GuiControlGet, PrintColorMode
   GuiControlGet, PrintCopies
   GuiControlGet, SelectedPrinteru
   GuiControlGet, PrintOrientation
   GuiControlGet, PrintDoFlipuH
   GuiControlGet, PrintDoFlipuV
   GuiControlGet, PrintUseViewportColors
   GuiControlGet, TextInAreaAlign
   GuiControlGet, TextInAreaValign
   GuiControlGet, TextInAreaFontName
   GuiControlGet, TextInAreaFontBold
   GuiControlGet, TextInAreaFontItalic
   GuiControlGet, TextInAreaFontUline
   GuiControlGet, PrintTxtSize
   GuiControlGet, PrintStrechedSize
   GuiControlGet, UserTextArea

   PrintOptions := []
   PrintOptions.pPrinterName := SelectedPrinteru
   PrintOptions.adaptFit := PrintAdaptToFit
   PrintOptions.userImgX := PrintPosX
   PrintOptions.userImgY := PrintPosY
   PrintOptions.userImgW := PrintPosW
   PrintOptions.userImgH := PrintPosH
   PrintOptions.colorsMode := PrintColorMode
   PrintOptions.imgOrient := PrintOrientation
   PrintOptions.copiez := PrintCopies
   PrintOptions.flipuV := PrintDoFlipuH
   PrintOptions.flipuH := PrintDoFlipuV
   PrintOptions.applyFX := PrintUseViewportColors
   PrintOptions.text := Trimmer(UserTextArea)
   PrintDimensionsXYWH := PrintPosX "|" PrintPosY "|" PrintPosW "|" PrintPosH
   SetTimer, WriteSettingsPrintPanel, -200

   act := (PrintAdaptToFit=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % act, PrintPosX
   GuiControl, % act, PrintPosY
   GuiControl, % act, PrintPosW
   GuiControl, % act, PrintPosH
   GuiControl, % act, PrintPosEditX
   GuiControl, % act, PrintPosEditY
   GuiControl, % act, PrintPosEditW
   GuiControl, % act, PrintPosEditH
   GuiControl, % act, PrintPosTxtX
   GuiControl, % act, PrintPosTxtY
   GuiControl, % act, PrintPosTxtW
   GuiControl, % act, PrintPosTxtH
   GuiControl, % act, PrintStrechedSize
   Return PrintOptions
}

WriteSettingsPrintPanel() {
    ReadSettingsPrintPanel(2)
}

updatePrintPreview() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, updatePrintPreview, -500
      Return
   }

   PrintOptions := printSettingsObj()
   printImageNow(viewportStampBMP, PrintOptions, 1)
   lastInvoked := A_TickCount
}

BtnStartPrintingNow() {
   PrintOptions := printSettingsObj()
   BtnCloseWindow()
   Sleep, 2
   showTOOLtip("Please wait, preparing to print image")
   Sleep, 2
   printImageNow(useGdiBitmap(), PrintOptions, 0)
   Sleep, 2
   RemoveTooltip()
}

PanelIMGselProperties() {
    If (thumbsDisplaying=1)
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(34, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := EditWid//2 - 2
    Global NewPosX1, NewPosY1, NewPosX2, NewPosY2, NewVProt
         , BtnPosX1m, BtnPosX1p, BtnPosY1m, BtnPosY1p, BtnPosX2m, BtnPosX2p, BtnPosY2m, BtnPosY2p
         , BtnPosXm, BtnPosXp, BtnPosYm, BtnPosYp, BtnPosZm, BtnPosZp

    If !userCustomImgSelRatio
       INIaction(0, "userCustomImgSelRatio", "General", 2, 1, 7)

    INIaction(0, "lockSelectionAspectRatio", "General", 2, 1, 7)
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    Gui, Add, Text, x15 y15 Section, Current image size: %imgW% x %imgH% px.
    Gui, Add, Checkbox, y+7 gupdateUIselPropPanel Checked%userDefinedSelCoords% vuserDefinedSelCoords, Define image selection coordinates in...
    Gui, Add, DropDownList, x+2 w150 AltSubmit gupdateUIchangeSelectionType vSelectionCoordsType, Pixels||Percentages
    Gui, Add, Text, xs y+10 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Text, x+3 wp, Rotation
    Gui, Add, Edit, xs y+7 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX1, % imgSelX1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY1, % imgSelY1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX2, % imgSelX2
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY2, % imgSelY2
    Gui, Add, ComboBox, x+3 wp limit9 -multi -wrap gupdateUIselPropPanel vNewVProt, 0|45|90|105|135|150|180|200|225|250|270|300|315|%vPselRotation%||
    Gui, Add, Text, xs y+10, Adjust current selection coordinates:
    Gui, Add, Text, xs y+5 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Button, xs y+7 w%btnWid2% gOffsetSelProperPanel vBtnPosX1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2p, +
    Gui, Add, Button, xs y+7 wp+8 gOffsetSelProperPanel vBtnPosXm, Up
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosXp, Down
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYm, Left
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYp, Right
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZm, Contract
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZp, Enlarge
    Gui, Add, Checkbox, xs y+15 gupdateUIselPropPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit selection to image boundaries
    Gui, Add, Checkbox, xs y+10 gupdateUIselPropPanel Checked%rotateSelBoundsKeepRatio% vrotateSelBoundsKeepRatio, &Keep aspect ratio on rotation
    thisW := (PrefsLargeFonts=1) ? 170 : 100
    Gui, Add, DropDownList, xs+%thisW% y+15 wp-25 gupdateUIselPropPanel AltSubmit Choose%lockSelectionAspectRatio% vlockSelectionAspectRatio, Unlocked|Square [1:1]|SDTV [4:3]|35mm film [3:2]|HDTV [16:9]|Wide screens [16:10]|Custom ratio
    Gui, Add, Edit, x+5 w65 -wrap gupdateUIselPropPanel vuserCustomImgSelRatio, % userCustomImgSelRatio
    Gui, Add, Text, xs yp w%thisW%, Lock aspect ratio
    ; ToggleEditImgSelection("show-edit")
    ; dummyTimerDelayiedImageDisplay(50)
    Gui, Add, Button, xs y+20 w100 h%thisBtnHeight% gBTNselectEntireImg, &Select all
    Gui, Add, Button, x+10 w125 hp gBTNselectNoneImg, &Select none
    Gui, Add, Button, x+10 w90 hp gBtnCloseWindow Default, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Selection properties: " appTitle, winPos)
    ; SetTimer, updateUIselPropPanel, -350
    updateUIselPropPanel()
}

BTNselectNoneImg() {
   BtnCloseWindow()
   editingSelectionNow := 0
   updateUIctrl()
   MouseMoveResponder()
   dummyTimerDelayiedImageDisplay(50)
}

dummyOffsetSelProperPanel() {
    If (determineLClickstate()=1)
    {
       SetTimer, dummyOffsetSelProperPanel, -25
       OffsetSelProperPanel("usePrev")
    }
}

OffsetSelProperPanel(dummy:=0) {
   Static prevVaru, lastInvoked := 1
   stepu := (A_TickCount - lastInvoked<350) ? 4 : 2
   If (dummy!="usePrev")
      GuiControlGet, varu, SettingsGUIA: FocusV
   Else
      varu := prevVaru

   If (varu="BtnPosYm")
   {
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosXm")
   {
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   } Else If (varu="BtnPosXp")
   {
      arrowKeysAdjustSelectionArea(2, 1, stepu)
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosZm")
      changeSelectZoom(-1)
   Else If (varu="BtnPosZp")
      changeSelectZoom(1)
   Else If (varu="BtnPosX1m")
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
   Else If (varu="BtnPosX1p")
      arrowKeysAdjustSelectionArea(1, 1, stepu)
   Else If (varu="BtnPosY1m")
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
   Else If (varu="BtnPosY1p")
      arrowKeysAdjustSelectionArea(2, 1, stepu)
   Else If (varu="BtnPosX2m")
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   Else If (varu="BtnPosX2p")
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   Else If (varu="BtnPosY2m")
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   Else If (varu="BtnPosY2p")
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   lastInvoked := A_TickCount
   prevVaru := varu
   SetTimer, dummyOffsetSelProperPanel, -250
}

updateUIchangeSelectionType() {
    If (AnyWindowOpen=34)
       Gui, SettingsGUIA: Default
    Else
       Return

   GuiControlGet, SelectionCoordsType
   GuiControlGet, userDefinedSelCoords
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   GuiControl, SettingsGUIA:, NewPosX1, 0
   GuiControl, SettingsGUIA:, NewPosY1, 0
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX2, % imgW//2
      GuiControl, SettingsGUIA:, NewPosY2, % imgH//2
   } Else
   {
      GuiControl, SettingsGUIA:, NewPosX2, 50
      GuiControl, SettingsGUIA:, NewPosY2, 50
   }
   updateUIselPropPanel()
}

BTNselectEntireImg() {
   BtnCloseWindow()
   selectEntireImage()
}

updateUIselPropPanel() {
   If (AnyWindowOpen=34)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, NewPosX1, SettingsGUIA:, NewPosX1
   GuiControlGet, NewPosY1, SettingsGUIA:, NewPosY1
   GuiControlGet, NewPosX2, SettingsGUIA:, NewPosX2
   GuiControlGet, NewPosY2, SettingsGUIA:, NewPosY2
   GuiControlGet, NewVProt, SettingsGUIA:, NewVProt
   GuiControlGet, lockSelectionAspectRatio, SettingsGUIA:, lockSelectionAspectRatio
   GuiControlGet, userCustomImgSelRatio, SettingsGUIA:, userCustomImgSelRatio
   GuiControlGet, userDefinedSelCoords, SettingsGUIA:, userDefinedSelCoords
   GuiControlGet, SelectionCoordsType, SettingsGUIA:, SelectionCoordsType
   GuiControlGet, LimitSelectBoundsImg, SettingsGUIA:, LimitSelectBoundsImg
   GuiControlGet, rotateSelBoundsKeepRatio, SettingsGUIA:, rotateSelBoundsKeepRatio
   
   userCustomImgSelRatio := Trimmer(userCustomImgSelRatio)
   If RegExMatch(userCustomImgSelRatio, "(.\:.|.\\.)")
   {
      If InStr(userCustomImgSelRatio, ":")
         obju := StrSplit(userCustomImgSelRatio, ":")
      Else If InStr(userCustomImgSelRatio, "\")
         obju := StrSplit(userCustomImgSelRatio, "\")

      If (obju[1] && obju[2])
         userCustomImgSelRatio := Round(obju[1] / obju[2], 3)
   }

   If (lockSelectionAspectRatio>1)
   {
      userDefinedSelCoords := 0
      LimitSelectBoundsImg := 0
      GuiControl, SettingsGUIA:, userDefinedSelCoords, 0
      GuiControl, SettingsGUIA:, LimitSelectBoundsImg, 0
      GuiControl, SettingsGUIA: Disable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Disable, LimitSelectBoundsImg
   } Else
   {
      GuiControl, SettingsGUIA: Enable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Enable, LimitSelectBoundsImg
   }

   defineSelectionAspectRatios()
   If (lockSelectionAspectRatio=7)
      GuiControl, SettingsGUIA: Enable, userCustomImgSelRatio
   Else
      GuiControl, SettingsGUIA: Disable, userCustomImgSelRatio

   ; ToggleEditImgSelection("show-edit")
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   actuA := (userDefinedSelCoords=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   actuB := (userDefinedSelCoords=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   INIaction(1, "userCustomImgSelRatio", "General")
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   ; If (userDefinedSelCoords=1)
   ;    lockSelectionAspectRatio := 0

   If (lockSelectionAspectRatio>1)
   {
      GuiControl, SettingsGUIA: Disable, BtnPosX1m
      GuiControl, SettingsGUIA: Disable, BtnPosX1p
      GuiControl, SettingsGUIA: Disable, BtnPosX2m
      GuiControl, SettingsGUIA: Disable, BtnPosX2p
   } Else
   {
      GuiControl, % actuA, BtnPosX1m
      GuiControl, % actuA, BtnPosX1p
      GuiControl, % actuA, BtnPosX2m
      GuiControl, % actuA, BtnPosX2p
   }
   GuiControl, % actuA, BtnPosY1m
   GuiControl, % actuA, BtnPosY1p
   GuiControl, % actuA, BtnPosY2m
   GuiControl, % actuA, BtnPosY2p
   GuiControl, % actuA, BtnPosXm
   GuiControl, % actuA, BtnPosXp
   GuiControl, % actuA, BtnPosYm
   GuiControl, % actuA, BtnPosYp
   GuiControl, % actuA, BtnPosZm
   GuiControl, % actuA, BtnPosZp
   GuiControl, % actuB, NewPosX1
   GuiControl, % actuB, NewPosY1
   GuiControl, % actuB, NewPosX2
   GuiControl, % actuB, NewPosY2
   GuiControl, % actuB, SelectionCoordsType
   If (userDefinedSelCoords=1)
   {
      If (SelectionCoordsType=1)
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := imgW//2
         If !IsNumber(NewPosY2)
            NewPosY2 := imgH//2
         imgSelX1 := Round(NewPosX1), imgSelY1 := Round(NewPosY1)
         imgSelX2 := Round(NewPosX2), imgSelY2 := Round(NewPosY2)
      } Else
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := 50
         If !IsNumber(NewPosY2)
            NewPosY2 := 50
         wNewPosX1 := min(NewPosX1, NewPosX2)
         wNewPosX2 := max(NewPosX1, NewPosX2)

         wNewPosY1 := min(NewPosY1, NewPosY2)
         wNewPosY2 := max(NewPosY1, NewPosY2)
         imgSelX1 := Round(imgW*(Abs(wNewPosX1)/100), 3), imgSelY1 := Round(imgH*(Abs(wNewPosY1)/100), 3)
         imgSelX2 := Round(imgW*(Abs(wNewPosX2)/100), 3), imgSelY2 := Round(imgH*(Abs(wNewPosY2)/100), 3)
      }
   }

   If !IsNumber(NewVProt)
      NewVProt := 0

   vPselRotation := clampInRange(Round(NewVProt), 0, 360, 1)
   dummyTimerDelayiedImageDisplay(50)
   Return
}

updateUInewImagePanel() {
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, PredefinedDocsSizes
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, Opacity: %thisOpacity%`%
    If (NewDocUseColor!=1)
    {
       GuiControl, SettingsGUIA: Disable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, PickuFillAreaColor
    } Else
    {
       GuiControl, SettingsGUIA: Enable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, PickuFillAreaColor
    }

    If (PredefinedDocsSizes=1)
    {
       GetWinClientSize(UserNewWidth, UserNewHeight, PVhwnd, 0)
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=2)
    {
       calcScreenLimits()
       UserNewWidth := ResolutionWidth
       UserNewHeight := ResolutionHeight
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=3)
    {
       If useGdiBitmap()
       {
          Gdip_BitmapGetDPIResolution(useGdiBitmap(), dpix, dpiy)
          Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
          UserNewDPI := (dpix + dpiy)//2
       } Else
       {
          GetWinClientSize(imgW, imgH, PVhwnd, 0)
          UserNewDPI := A_ScreenDPI
       }
       UserNewWidth := imgW
       UserNewHeight := imgH
    } Else If (PredefinedDocsSizes=4)
    {
       UserNewWidth := 640
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=5)
    {
       UserNewWidth := 800
       UserNewHeight := 600
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=6)
    {
       UserNewWidth := 1024
       UserNewHeight := 768
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=7)
    {
       UserNewWidth := 858
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=8)
    {
       UserNewWidth := 1280
       UserNewHeight := 720
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=9)
    {
       UserNewWidth := 1920
       UserNewHeight := 1080
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=10)
    {
       UserNewWidth := 3860
       UserNewHeight := 2160
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=11)
    {
       UserNewWidth := 2480
       UserNewHeight := 3508
       UserNewDPI := 300
    } Else If (PredefinedDocsSizes=12)
    {
       UserNewWidth := 1240
       UserNewHeight := 1754
       UserNewDPI := 150
    }

    If (PredefinedDocsSizes<13)
    {
       GuiControl, SettingsGUIA:, UserNewWidth, % UserNewWidth
       GuiControl, SettingsGUIA:, UserNewHeight, % UserNewHeight
       GuiControl, SettingsGUIA:, UserNewDPI, % UserNewDPI
    }
}

NewImageEditResponder() {
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

   GuiControlGet, UserNewWidth
   GuiControlGet, UserNewHeight
   GuiControlGet, UserNewDPI
   GuiControlGet, whichFocused, FocusV

   If (whichFocused="UserNewWidth" || whichFocused="UserNewHeight" || whichFocused="UserNewDPI")
   {
      PredefinedDocsSizes := 13
      GuiControl, SettingsGUIA: Choose, PredefinedDocsSizes, 13
   }
}

BtnCreateNewImage() {
    Static clippyCount
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, UserNewWidth
    GuiControlGet, UserNewHeight
    GuiControlGet, UserNewDPI
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    If (UserNewWidth<5 || UserNewHeight<5 || UserNewDPI<5)
    {
       SoundBeep, 300, 100
       showTOOLtip("WARNING: Incorrect dimensions provided for the new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (UserNewWidth*UserNewHeight>maxGDIbmpSize) || (UserNewWidth>32500) || (UserNewHeight>32500)
    {
       SoundBeep, 300, 100
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "NewDocUseColor", "General")
    INIaction(1, "PredefinedDocsSizes", "General")
    INIaction(1, "NewImageReverseDimensions", "General")
    INIaction(1, "FillAreaColor", "General")
    INIaction(1, "FillAreaOpacity", "General")

    DestroyGIFuWin()
    BtnCloseWindow()
    If askAboutFileSave(" and new image will be created")
       Return

    PredefinedDocsSizes := 13
    showTOOLtip("Creating the new image, please wait")
    setImageLoading()
    calcScreenLimits()
    mustOpenStartFolder := ""
    terminateIMGediting()
    discardViewPortCaches()
    clippyCount++
    If (NewImageReverseDimensions=1)
    {
       tUserNewWidth := UserNewHeight
       tUserNewHeight := UserNewWidth
    } Else
    {
       tUserNewWidth := UserNewWidth
       tUserNewHeight := UserNewHeight
    }

    UserMemBMP := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, coreDesiredPixFmt)
    If warnUserFatalBitmapError(UserMemBMP, A_ThisFunc)
    {
       showTOOLtip("Failed to create new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       clippyCount--
       Return
    }

    Gdip_BitmapSetResolution(UserMemBMP, UserNewDPI, UserNewDPI)
    If (NewDocUseColor=1)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_DeleteGraphics(G2)
    }

    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\New-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    If (NewDocUseColor=1 && FillAreaOpacity>253)
       currIMGdetails.HasAlpha := 0

    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}

BtnDrawLinesSelectedArea() {
  If throwErrorSelectionOutsideBounds()
     Return

  updateUIDrawLinesPanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

  If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
  && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
  {
     SoundBeep , 300, 100
     showTOOLtip("WARNING: No lines to draw selected")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
  If (closeEditPanelOnApply=1)
     BtnCloseWindow()

  Sleep, 1
  prevImgEditZeit := A_TickCount
  ToggleEditImgSelection("show-edit")
  DrawLinesInSelectedArea(1)
  prevImgEditZeit := A_TickCount
  SetTimer, RemoveTooltip, -250
}

updateUIDrawLinesPanel(actionu=0) {
    If (AnyWindowOpen=30)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, DrawLineAreaOpacity
    GuiControlGet, DrawLineAreaKeepBounds
    GuiControlGet, DrawLineAreaDashStyle
    GuiControlGet, DrawLineAreaCapsStyle
    GuiControlGet, DrawLineAreaContourAlign
    GuiControlGet, DrawLineAreaDoubles
    GuiControlGet, DrawLineAreaBorderTop
    GuiControlGet, DrawLineAreaBorderBottom
    GuiControlGet, DrawLineAreaBorderLeft
    GuiControlGet, DrawLineAreaBorderRight
    GuiControlGet, DrawLineAreaBorderCenter
    GuiControlGet, DrawLineAreaBorderArcA
    GuiControlGet, DrawLineAreaBorderArcB
    GuiControlGet, DrawLineAreaBorderArcC
    GuiControlGet, DrawLineAreaBorderArcD
    GuiControlGet, DrawLineAreaContourThickness

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    ToggleEditImgSelection("show-edit")
    If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
    && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
       dummyRefreshImgSelectionWindow()
    Else If (actionu!="noPreview")
       livePreviewsImageEditing()

    SetTimer, WriteSettingsDrawLinesPanel, -250
}

WriteSettingsDrawLinesPanel() {
    ReadSettingsDrawLinesArea(1)
}

updateUIdrawShapesPanel(actionu=0) {
    If (AnyWindowOpen=65)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, DrawLineAreaOpacity
    GuiControlGet, DrawLineAreaDashStyle
    GuiControlGet, DrawLineAreaCapsStyle
    GuiControlGet, DrawLineAreaContourAlign
    GuiControlGet, DrawLineAreaDoubles
    GuiControlGet, DrawLineAreaContourThickness
    GuiControlGet, FillAreaShape
    GuiControlGet, FillAreaClosedPath
    GuiControlGet, FillAreaCurveTension

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    decideCustomShapeStyle()
    If (FillAreaShape=7)
    {
       GuiControl, SettingsGUIA: Enable, FillAreaClosedPath
       GuiControl, SettingsGUIA: Enable, FillAreaCurveTension
       EllipseSelectMode := 2
    } Else
    {
       GuiControl, SettingsGUIA: Disable, FillAreaClosedPath
       GuiControl, SettingsGUIA: Disable, FillAreaCurveTension
       EllipseSelectMode := 0
    }

    ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview")
       livePreviewsImageEditing()

    SetTimer, WriteSettingsDrawShapeAreaPanel, -250
}

updateUIblurPanel() {
    Static lastInvoked := 1
    If (AnyWindowOpen=26)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, blurAreaAmount
    GuiControlGet, blurAreaPixelizeAmount
    GuiControlGet, blurAreaPixelizeMethod
    GuiControlGet, blurAreaInverted
    GuiControlGet, BlurAreaBlendMode
    GuiControlGet, blurAreaSoftEdges
    GuiControlGet, blurAreaOpacity
    GuiControlGet, blurAreaTwice
    GuiControlGet, blurAreaMode
    GuiControlGet, blurAreaSoftLevel
    If (coreDesiredPixFmt="0x21808")
    {
       blurAreaSoftEdges := 0
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
       GuiControl, SettingsGUIA:, blurAreaSoftEdges, 0
    }

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIblurPanel, -105
       Return
    }

    If (blurAreaPixelizeAmount>1)
       GuiControl, SettingsGUIA: Enable, blurAreaPixelizeMethod
    Else
       GuiControl, SettingsGUIA: Disable, blurAreaPixelizeMethod


    If (blurAreaAmount>1)
    {
       GuiControl, SettingsGUIA: Enable, blurAreaMode
       GuiControl, SettingsGUIA: Enable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Enable, blurAreaSoftLevel
       GuiControl, SettingsGUIA: Enable, blurAreaTwice
    } Else
    {
       GuiControl, SettingsGUIA: Disable, blurAreaMode
       GuiControl, SettingsGUIA: Disable, blurAreaTwice
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, blurAreaSoftLevel
    }

    If (blurAreaSoftEdges>1)
       GuiControl, SettingsGUIA: Enable, blurAreaSoftLevel
    Else
       GuiControl, SettingsGUIA: Disable, blurAreaSoftLevel

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoBlurOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoBlurAmount, Blur amount: %blurAreaAmount%
    GuiControl, SettingsGUIA:, infoPixelize, Pixelize level: %blurAreaPixelizeAmount%
    lastInvoked := A_TickCount
    SetTimer, livePreviewBlurPanel, -50
}

PanelsLivePreviewResponder(a, b, c) {
   ; ToolTip, % a "=" b "=" c , , , 2
   SetTimer, PanelsPanIMGpreviewClick, -15
}

PanelsPanIMGpreviewClick() {
   Static noPreview := 0
   keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0
   If (AnyWindowOpen=64 && (BrushToolType=2 || BrushToolType=4))
   {
      GetPhysicalCursorPos(zX, zY)
      While, (determineLClickstate()=1)
      {
         Sleep, 1
         If !keysState
            keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

         GetPhysicalCursorPos(mX, mY)
         If (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2))
            Continue

         If (mX>zX)
            alphaMaskOffsetX += 0.05
         Else If (mX<zX)
            alphaMaskOffsetX -= 0.05
         If (mY>zY)
            alphaMaskOffsetY += 0.05
         Else If (mY<zY)
            alphaMaskOffsetY -= 0.05

         alphaMaskOffsetX := clampInRange(alphaMaskOffsetX, -0.9, 0.9)
         alphaMaskOffsetY := clampInRange(alphaMaskOffsetY, -0.9, 0.9)
         zX := mX, zY := mY
         Sleep, 2
         createLivePreviewBrush()
      }

      ; ToolTip, % vPosX "==" vPosY "`n" alphaMaskOffsetX "==" alphaMaskOffsetY , , , 2
      If (keysState=1)
         alphaMaskOffsetX := alphaMaskOffsetY := 0

      If (AnyWindowOpen=64)
         SetTimer, updateUIbrushTool, -150
      Return
   }

   If (AnyWindowOpen=64 && !(BrushToolType=3 || BrushToolType=5))
      Return

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := tinyPrevAreaCoordX, oDy := tinyPrevAreaCoordY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   hasRun := 0
   While, (determineLClickstate()=1)
   {
      Sleep, 1
      If !keysState
         keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2)) ? 1 : 0
      Dx := mX - oX + 1
      Dy := mY - oY + 1
      tinyPrevAreaCoordX := oDx - Dx
      tinyPrevAreaCoordY := oDy - Dy
      tinyPrevAreaCoordX := clampInRange(tinyPrevAreaCoordX, 120, imgW)
      tinyPrevAreaCoordY := clampInRange(tinyPrevAreaCoordY, 120, imgH)

      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>750) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      If (A_TickCount - thisZeit>15)
      {
         hasRun := 1
         noPreview := 0
         ; If (A_TickCount - thisZeit>95)
         ; zeitSillyPrevent := A_TickCount
         If (AnyWindowOpen=26)
            livePreviewBlurPanel()
         Else If (AnyWindowOpen=43)
            livePreviewIDedges()
         Else If (AnyWindowOpen=44)
            livePreviewAddNoiser()
         Else If (AnyWindowOpen=64)
            createLivePreviewBrush()
         thisZeit := A_TickCount
      }
   }

   If !keysState
      keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

   If (keysState=1 && hasRun=0 && noPreview=0)
   {
      noPreview := 1
      livePreviewsPanelNoEffects()
   } Else If !hasRun
   {
      If (noPreview=0)
         doubleBlurPreviewArea := !doubleBlurPreviewArea

      noPreview := 0
      If (AnyWindowOpen=26)
         updateUIblurPanel()
      Else If (AnyWindowOpen=43)
         updateUIedgesPanel()
      Else If (AnyWindowOpen=44)
         updateUIaddNoisePanel()
   }
}

livePreviewBlurPanel() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    WriteSettingsBlurPanel()
    whichBmp := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }


    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    thisBlurMode := blurAreaMode
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurMode=1)
       bEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    Else If (thisBlurMode=2)
       bEffect := Gdip_CreateEffect(1, Round(thisBlurAmount*0.85), 0, 0)

    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    If (blurAreaPixelizeAmount>1)
    {
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
       QPV_PixelateBitmap(yBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, uiboxSize))
       prevBMPu := yBitmap
       yBitmap:= pixiBMP
    }

    If (blurAreaTwice=1)
    {
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize//2, uiboxSize//2, 1, 3, -1)
       If xBitmap
       {
          prevBMPa := yBitmap
          yBitmap := xBitmap
       }

       If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
       Else If (thisBlurMode=3)
          QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

       cBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize, uiboxSize, 1, 3, -1)
       If cBitmap
       {
          prevBMPc := yBitmap
          yBitmap := cBitmap
          sF := 1
       } Else sF := 1
    } Else sF := 1

    If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
       ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
    Else If (thisBlurMode=3)
       QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

    If (BlurAreaBlendMode>1)
    {
       rz := QPV_BlendBitmaps(bgrBMPu, yBitmap, BlurAreaBlendMode - 1, 0)
       ; ToolTip, % "l=" rz , , , 2
       ou := yBitmap
       yBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, yBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize // sF, uiboxSize // sF, thisOpacity)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    If (r1!="fail")
       hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)

    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(prevBMPu, 1)
    trGdip_DisposeImage(prevBMPa, 1)
    trGdip_DisposeImage(prevBMPc, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(bEffect)
}

updateUIerasePanel(actionu:=0) {
    If (AnyWindowOpen=25)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, EraseAreaFader
    GuiControlGet, EraseAreaInvert
    GuiControlGet, EraseAreaOpacity

    INIaction(1, "EraseAreaOpacity", "General")
    INIaction(1, "EraseAreaFader", "General")
    INIaction(1, "EraseAreaInvert", "General")
    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoEraseOpacity, Opacity: %thisOpacity%`%
    If (EraseAreaFader=1)
    {
       GuiControl, SettingsGUIA: Enable, infoEraseOpacity
       GuiControl, SettingsGUIA: Enable, EraseAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Disable, infoEraseOpacity
       GuiControl, SettingsGUIA: Disable, EraseAreaOpacity
    }

    If (actionu!="noPreview")
       livePreviewsImageEditing()
}

BtnResetAmountDesature() {
   GuiControl, SettingsGUIA:, DesatureAreaAmount, 100
   updateUIdesaturatePanel()
}

BtnResetDesatureHue() {
   GuiControl, SettingsGUIA:, DesatureAreaHue, 0
   updateUIdesaturatePanel()
}

updateUIdesaturatePanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=55)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked<90)
    {
       SetTimer, updateUIdesaturatePanel, -100
       Return
    }

    GuiControlGet, DesatureAreaAmount
    GuiControlGet, DesatureAreaAlternate
    GuiControlGet, DesatureAreaHue

    INIaction(1, "DesatureAreaAmount", "General")
    INIaction(1, "DesatureAreaAlternate", "General")
    INIaction(1, "DesatureAreaHue", "General")
    thisOpacity := DesatureAreaAmount
    GuiControl, SettingsGUIA:, infoAmount, Intensity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infohueAdjust, Relight: %DesatureAreaHue%°
    If (DesatureAreaAmount>87 && isWinXP=0)
       GuiControl, SettingsGUIA: Enable, DesatureAreaAlternate
    Else
       GuiControl, SettingsGUIA: Disable, DesatureAreaAlternate

    If (DesatureAreaAlternate!=1 && !isWinXP && DesatureAreaAmount>87)
    {
       GuiControl, SettingsGUIA: Enable, infohueAdjust
       GuiControl, SettingsGUIA: Enable, DesatureAreaHue
    } Else
    {
       GuiControl, SettingsGUIA: Disable, infohueAdjust
       GuiControl, SettingsGUIA: Disable, DesatureAreaHue
    }

    If (actionu!="noPreview")
       livePreviewsImageEditing()
    lastInvoked := A_TickCount
}

BtnEraseSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIerasePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   prevImgEditZeit := A_TickCount
   ToggleEditImgSelection("show-edit")
   EraseSelectedArea()
   prevImgEditZeit := A_TickCount
}

coreDesatureAreaFX(ByRef matrix, ByRef pEffect) {
    matrix := GenerateColorMatrix(1, 1, 0, 1 - (DesatureAreaAmount/100))
    thisAmount2 := (DesatureAreaAlternate=1) ? DesatureAreaAmount : 0
    If (DesatureAreaAlternate=1)
       thisHAmount := 0
    Else If (DesatureAreaHue>0)
    {
       thisHAmount := DesatureAreaHue - (100 - DesatureAreaAmount)*16
       thisHAmount := clampInRange(thisHAmount, 0, 180)
    } Else
    {
       thisHAmount := (100 - DesatureAreaAmount)*16 + DesatureAreaHue
       thisHAmount := clampInRange(thisHAmount, -180, 0)
    }

    If (!isWinXP && (thisHAmount!=0 || thisAmount2!=0))
       pEffect := Gdip_CreateEffect(6, thisHAmount, thisAmount2, 0)
}

livePreviewDesaturateArea(modus:=0) {
   Static prevState, prevBMP

   If (modus="kill")
   {
      trGdip_DisposeImage(prevBMP, 1)
      prevBMP := prevState := ""
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
   calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)

   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   coreDesatureAreaFX(matrix, pEffect)
   pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
   Gdip_SetClipPath(2NDglPG, pPath, 0)
   pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
   imgSelPx := pB.x, imgSelPy := pB.y
   imgSelW := pB.w
   imgSelH := pB.h

   thisState := "a" imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight zoomLevel prevDestPosX prevDestPosY IMGresizingMode imageAligned ForceNoColorMatrix imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel useGdiBitmap()
   If (prevState!=thisState)
   {
      trGdip_DisposeImage(prevBMP, 1)
      pBitmap := getTransformToolSelectedArea(1, 0, 0)
      zBitmap := Gdip_ResizeBitmap(pBitmap, imgSelW, imgSelH, 0, 5)
      trGdip_DisposeImage(pBitmap, 1)
      prevBMP := zBitmap
      prevState := thisState
   } Else zBitmap := prevBMP


   If pEffect
      r1 := trGdip_DrawImageFX(funcu, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,, matrix, pEffect)
   Else
      r1 := trGdip_DrawImage(funcu, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,,,, matrix)

   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
   Gdip_ResetClip(2NDglPG)
   ; trGdip_DisposeImage(zBitmap, 1)
}

BtnGraySelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIdesaturatePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   GraySelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnBlurSelectedArea() {
  updateUIblurPanel()
  BtnCloseWindow()
  ToggleEditImgSelection("show-edit")
  BlurSelectedArea()
}

updateUIfillPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=23)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, FillAreaBlendMode
    GuiControlGet, FillAreaCurveTension
    GuiControlGet, FillAreaOpacity
    GuiControlGet, FillAreaShape
    GuiControlGet, FillAreaInverted
    GuiControlGet, FillAreaRemBGR
    GuiControlGet, FillAreaColorMode
    GuiControlGet, FillAreaColorReversed
    GuiControlGet, FillArea2ndOpacity
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientPosA
    GuiControlGet, FillAreaGradientPosB
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaGlassy
    GuiControlGet, FillAreaLivePreview
    GuiControlGet, FillAreaDoContour
    GuiControlGet, FillAreaApplyColorFX
    GuiControlGet, DrawLineAreaOpacity
    GuiControlGet, DrawLineAreaDashStyle
    GuiControlGet, DrawLineAreaCapsStyle
    GuiControlGet, DrawLineAreaContourAlign
    GuiControlGet, DrawLineAreaDoubles
    GuiControlGet, DrawLineAreaContourThickness
    GuiControlGet, PasteInPlaceHue
    GuiControlGet, PasteInPlaceSaturation
    GuiControlGet, PasteInPlaceLight
    GuiControlGet, PasteInPlaceGamma
    GuiControlGet, userimgGammaCorrect

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIfillPanel, -150
       Return
    }

    decideCustomShapeStyle()
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    If (FillAreaShape=7 && FillAreaDoContour=1)
       GuiControl, SettingsGUIA: Enable, FillAreaClosedPath
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaClosedPath

    If (FillAreaInverted=1 && FillAreaBlendMode>1)
       FillAreaGradientWrapped := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoFillArea2ndOpacity, %this2ndOpacity%`%
    If (FillAreaColorMode=5)
    {
       iterations := Round(100*(FillAreaGradientScale/300)) + 1
       modelu := Round(7*(FillAreaGradientPosB/100))
       moduz := Round(9*(FillAreaGradientPosA/100))
       sweepRand := Round(9*(FillAreaGradientAngle/360))
       GuiControl, SettingsGUIA:, infoFillAreaSigma, Style deviation: %moduz%
       GuiControl, SettingsGUIA:, infoFillAreaBlend, Pattern style: %modelu%
       GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Petals sweep: %sweepRand%
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Iterations: %iterations%
       GuiControl, SettingsGUIA:, FillAreaColorReversed, &Reverse colors
       GuiControl, SettingsGUIA: , FillAreaGradientWrapped, -
       GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
    } Else If (FillAreaColorMode=6)
    {
       texSize := 3 * FillAreaGradientScale
       thisAR := texSize + Round(texSize * (FillAreaGradientPosB/100))
       GuiControl, SettingsGUIA:, FillAreaGradientWrapped, Mirror X
       GuiControl, SettingsGUIA:, FillAreaColorReversed, Mirror Y
       GuiControl, SettingsGUIA:, infoFillAreaSigma, Scale: %FillAreaGradientPosA%`%
       GuiControl, SettingsGUIA:, infoFillAreaBlend, Size Y: %thisAR% px
       GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Size X: %texSize% px
       GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped
    } Else
    {
       GuiControl, SettingsGUIA:, FillAreaGradientWrapped, &Tiling pattern
       GuiControl, SettingsGUIA:, FillAreaColorReversed, &Reverse colors
       GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientPosA%`%
       GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientPosB%`%
       GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
       If (FillAreaColorMode=1)
          GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
       Else
          GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped
    }

    actu2 := (FillAreaDoContour=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PickuDrawLineAreaColor
    GuiControl, % actu2, infoDrawLineAreaOpacity
    GuiControl, % actu2, infoDrawLineAreaContour
    GuiControl, % actu2, DrawLineAreaColor
    GuiControl, % actu2, DrawLineAreaOpacity
    GuiControl, % actu2, DrawLineAreaKeepBounds
    GuiControl, % actu2, DrawLineAreaCapsStyle
    GuiControl, % actu2, DrawLineAreaDoubles
    GuiControl, % actu2, DrawLineAreaContourAlign
    GuiControl, % actu2, DrawLineAreaDashStyle
    GuiControl, % actu2, DrawLineAreaContourThickness

    actu2 := (FillAreaApplyColorFX=1 && (FillAreaColorMode>=5 || FillAreaBlendMode>1)) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PasteInPlaceLight
    GuiControl, % actu2, PasteInPlaceGamma
    GuiControl, % actu2, PasteInPlaceHue
    GuiControl, % actu2, PasteInPlaceSaturation
    GuiControl, % actu2, infoPasteLight
    GuiControl, % actu2, infoPasteGamma
    GuiControl, % actu2, infoPasteHue
    GuiControl, % actu2, infoPasteSat
    GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
    GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
    GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%

    If (FillAreaRemBGR=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaGlassy
       GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaGlassy
       GuiControl, SettingsGUIA: Enable, FillAreaBlendMode
       If (FillAreaGlassy>1)
          GuiControl, SettingsGUIA: Enable, FillAreaLivePreview
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
    }

    actu := (FillAreaColorMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, infoFillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, FillAreaGradientPosA
    GuiControl, % actu, FillAreaGradientPosB
    GuiControl, % actu, FillAreaGradientScale
    GuiControl, % actu, FillArea2ndOpacity

    If (isInRange(FillAreaColorMode, 2, 4) || FillAreaColorMode=6)
       GuiControl, SettingsGUIA: Enable, FillAreaColorReversed
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaColorReversed

    If (FillAreaColorMode>4)
    {
       GuiControl, SettingsGUIA: Disable, PickuFillAreaColor
       GuiControl, SettingsGUIA: Disable, FillAreaColor
    } Else
    {
       GuiControl, SettingsGUIA: Enable, PickuFillAreaColor
       GuiControl, SettingsGUIA: Enable, FillAreaColor
    }

    If (FillAreaColorMode=6 || FillAreaColorMode=1)
    {
       GuiControl, SettingsGUIA: Disable, PickuFillArea2ndColor
       GuiControl, SettingsGUIA: Disable, FillArea2ndColor
       GuiControl, SettingsGUIA: Disable, FillArea2ndOpacity
       GuiControl, SettingsGUIA: Disable, infoFillArea2ndOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Enable, PickuFillArea2ndColor
       GuiControl, SettingsGUIA: Enable, FillArea2ndColor
       GuiControl, SettingsGUIA: Enable, FillArea2ndOpacity
       GuiControl, SettingsGUIA: Enable, infoFillArea2ndOpacity
    }

    If (isInRange(FillAreaColorMode, 2, 4) || FillAreaColorMode=6)
       GuiControl, SettingsGUIA: Show, btnFldr
    Else
       GuiControl, SettingsGUIA: Hide, btnFldr

    If (FillAreaColorMode=6)
       GuiControl, SettingsGUIA: , btnFldr, &Set texture source
    Else
       GuiControl, SettingsGUIA: , btnFldr, &Reset gradient center

    If (FillAreaShape=7)
       GuiControl, SettingsGUIA: Enable, FillAreaCurveTension
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaCurveTension

    If (coreDesiredPixFmt="0x21808")
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode

    EllipseSelectMode := (FillAreaShape=7) ? 2 : 0
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsFillAreaPanel, -350
}

WriteSettingsFillAreaPanel() {
    ReadSettingsFillAreaPanel(1)
}

WriteSettingsDrawShapeAreaPanel() {
    ReadSettingsDrawShapeAreaPanel(1)
}

BtnFillSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    FillSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnDrawShapeSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    DrawLinesInSelectedArea(2)
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnInsertTextSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIInsertTextPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    If (closeEditPanelOnApply=1)
       BtnCloseWindow()
    ; Sleep, 1
    prevImgEditZeit := A_TickCount
    ToggleEditImgSelection("show-edit")
    InsertTextSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnViewedImages2List() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages<3)
      Return

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   BtnCloseWindow()
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-current-session.SLD"
   For Key, Value in userSeenSessionImagesArray
       resultedFilesList[A_Index] := [Key]

   SLDtypeLoaded := 2
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BtnALLviewedImages2List(dummy:=0) {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   BtnCloseWindow()
   startOperation := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   showTOOLtip("Gathering seen images list, please wait")
   setImageLoading()
   friendly := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : "ALL"
   dummy := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : ""
   seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 1, dummy)
   If (totalSeenIMGs<3)
   {
      seenEntries := ""
      SetTimer, ResetImgLoadStatus, -50
      CurrentSLD := backCurrentSLD
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("COMMIT TRANSACTION;")
      showTOOLtip("Found no already seen images in the database")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-" friendly ".SLD"
   For Key, Value in seenEntries
       resultedFilesList[A_Index] := [Key,,1]

   seenEntries := ""
   SLDtypeLoaded := 2
   currentFilesListModified := 0
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   etaTime := "Elapsed time to retrieve seen images list from the database:`n" SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   RandomPicture()
}

PanelJournalWindow(tabu:=1) {
    If (AnyWindowOpen=1)
       CloseWindow()

    thisBtnHeight := createSettingsGUI(33, A_ThisFunc)
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 40
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid := Round(editWid*6.25)
    totalIndex := QPVjournal.Count()
    For Key, Value in QPVjournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           textList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    userSeenSlideImages := userSeenSessionImagesArray.Count()
    WinGetTitle, thisTitle, ahk_id %PVhwnd%
    If (mustRecordSeenImgs=1)
    {
       choosu := (tabu=2) ? "||" : ""
       Gui, Add, Tab3,, Journal|Seen images database options%choosu%
       Gui, Tab, 1
       Gui, Add, Button, x+15 y+15 w1 h1 gBtnCloseWindow Default, Clo&se
    } Else
       Gui, Add, Button, x15 y15 w1 h1 gBtnCloseWindow Default, Clo&se

    Gui, Add, Edit, x+1 y+1 Section ReadOnly w%txtWid% r15, % "WinTitle: " thisTitle "`n`n" textList
       ; Gui, Add, Button, xs y+2 h%thisBtnHeight% gPanelSeenIMGsOptions, &Seen images database options

    If (mustRecordSeenImgs=1)
    {
       Gui, Tab, 2
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.

       Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnALLviewedImages2List, &Retrieve list of all recorded seen images
       Gui, Add, Button, y+5 hp wp gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
       Gui, Add, Button, y+5 hp wp geraseSeenIMGsDB, &Erase the entire list
       Gui, Add, Button, y+5 hp wp gPanelSeenStats, &Seen images statistics
       Gui, Add, Text, y+5 wp, TIP: To retrieve the images seen on a given day or month, open the statistics panel.
    } Else
    {
       Gui, Add, Button, xp y+2 h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
    }

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Application journal: " appTitle)
    SetTimer, ResetImgLoadStatus, -100
}

PanelSeenIMGsOptions() {
    PanelJournalWindow(2)
    Return
}

ReadSettingsTextInArea(act:=0) {
    INIaction(act, "TextInAreaAlign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaLineAngle", "General", 2, -900, 900)
    INIaction(act, "TextInAreaCharSpacing", "General", 2, -100, 255)
    INIaction(act, "TextInAreaValign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaBlurAmount", "General", 2, 1, 255)
    INIaction(act, "TextInAreaBlurBorderAmount", "General", 2, 1, 255)
    INIaction(act, "TextInAreaUsrMarginz", "General", 2, 0, 500)
    INIaction(act, "TextInAreaBgrColor", "General", 3)
    INIaction(act, "TextInAreaBgrEntire", "General", 1)
    INIaction(act, "TextInAreaBgrUnified", "General", 1)
    INIaction(act, "TextInAreaCutOutMode", "General", 1)
    INIaction(act, "TextInAreaBgrOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaBorderSize", "General", 2, 1, 650)
    INIaction(act, "TextInAreaBorderOut", "General", 2, 1, 3)
    INIaction(act, "TextInAreaBorderColor", "General", 3)
    INIaction(act, "TextInAreaBorderOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaFontBold", "General", 1)
    INIaction(act, "TextInAreaFontColor", "General", 3)
    INIaction(act, "TextInAreaFontItalic", "General", 1)
    INIaction(act, "TextInAreaFontName", "General", 5)
    INIaction(act, "TextInAreaFontLineSpacing", "General", 2, -950, 950)
    INIaction(act, "TextInAreaFontOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaFontSize", "General", 2, 5, 950)
    INIaction(act, "TextInAreaFontStrike", "General", 1)
    INIaction(act, "TextInAreaFontUline", "General", 1)
    INIaction(act, "TextInAreaOnlyBorder", "General", 1)
    INIaction(act, "TextInAreaPaintBgr", "General", 1)
    INIaction(act, "TextInAreaRoundBoxBgr", "General", 1)
    INIaction(act, "TextInAreaAutoWrap", "General", 1)
    INIaction(act, "TextInAreaLivePreview", "General", 1)
}

PanelInsertTextArea() {
    If (thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()
 
    thisBtnHeight := createSettingsGUI(32, A_ThisFunc)
    ReadSettingsTextInArea()
    btnWid := 70,       txtWid := 350
    columnBpos := 190,  slideWid := 150
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos := columnBpos + 85
       slideWid := slideWid + 55
       EditWid := EditWid + 40
       btnWid := btnWid + 20
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    ddWid := Round(editWid*3.25)
    txtWid := Round(editWid*6.25)
    EllipseSelectMode := 0
    If (ShowAdvToolbar=1 && TextInAreaPaintBgr=1 && TextInAreaCutOutMode=1)
    {
       TextInAreaBgrColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       TextInAreaBgrOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    } Else If (ShowAdvToolbar=1 && TextInAreaPaintBgr=0)
    {
       TextInAreaFontColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       TextInAreaFontOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    } Else If (ShowAdvToolbar=1)
    {
       TextInAreaFontColor := BrushToolAcolor
       TextInAreaFontOpacity := BrushToolAopacity
       TextInAreaBgrColor := BrushToolBcolor
       TextInAreaBgrOpacity := BrushToolBopacity
    }

    Global editF1, editF2, editF3, editF4, editF5, editF6,  editF7, editF8, editF9, editF10, editF11
         , editF12, PickuTextInAreaFontColor, PickuTextInAreaBgrColor, PickuTextInAreaBorderColor

    Gui, Add, Tab3,, Text|Styling|Colors
    Gui, Tab, 1
    Gui, Add, Edit, x+15 y+15 Section w%txtWid% r10 gupdateUIInsertTextPanel vUserTextArea, % UserTextArea
    Gui, Add, Text, , Font name:
    Gui, Add, DropDownList, x+5 w%ddWid% Sort Choose1 gupdateUIInsertTextPanel vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Checkbox, x+5 gupdateUIInsertTextPanel Checked%TextInAreaAutoWrap% vTextInAreaAutoWrap, Auto line wrapping

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section, Line angle / letter spacing
    Gui, Add, Text, xs yp+30, Font size / leading / margins
    Gui, Add, Text, xs yp+30, Text alignment and style 
    Gui, Add, Text, xs yp+30, Border style / thickness
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaDoBlurs% vTextInAreaDoBlurs, Blur amount for text / outline
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaPaintBgr% vTextInAreaPaintBgr, Draw background

    Gui, Add, Edit, xs+%columnBpos% ys+0 Section w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF11, % TextInAreaLineAngle
    Gui, Add, UpDown, vTextInAreaLineAngle Range-900-900, % TextInAreaLineAngle
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF12, % TextInAreaCharSpacing
    Gui, Add, UpDown, vTextInAreaCharSpacing Range-100-255, % TextInAreaCharSpacing

    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % TextInAreaFontSize
    Gui, Add, UpDown, vTextInAreaFontSize Range5-950, % TextInAreaFontSize
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit4 -multi -wantCtrlA -wantTab -wrap veditF9, % TextInAreaFontLineSpacing
    Gui, Add, UpDown, vTextInAreaFontLineSpacing Range-950-950, % TextInAreaFontLineSpacing
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF10, % TextInAreaUsrMarginz
    Gui, Add, UpDown, vTextInAreaUsrMarginz Range0-500, % TextInAreaUsrMarginz

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdateUIInsertTextPanel Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontUline% vTextInAreaFontUline, U
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontStrike% vTextInAreaFontStrike, S

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Altsubmit Choose%TextInAreaBorderOut% vTextInAreaBorderOut, None|Center|Outset
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF2, % TextInAreaBorderSize
    Gui, Add, UpDown, vTextInAreaBorderSize Range1-650, % TextInAreaBorderSize
    Gui, Add, Checkbox, x+2 hp gupdateUIInsertTextPanel Checked%TextInAreaOnlyBorder% vTextInAreaOnlyBorder, Only outline

    Gui, Add, Edit, xs yp+30 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF6, % TextInAreaBlurAmount
    Gui, Add, UpDown, vTextInAreaBlurAmount Range1-255, % TextInAreaBlurAmount
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF8, % TextInAreaBlurBorderAmount
    Gui, Add, UpDown, vTextInAreaBlurBorderAmount Range1-255, % TextInAreaBlurBorderAmount

    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaBgrUnified% vTextInAreaBgrUnified, Unified
    Gui, Add, Checkbox, x+3 yp hp gupdateUIInsertTextPanel Checked%TextInAreaRoundBoxBgr% vTextInAreaRoundBoxBgr, Rounded
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaCutOutMode% vTextInAreaCutOutMode, Cut-out mode
    Gui, Add, Checkbox, x+3 gupdateUIInsertTextPanel Checked%TextInAreaBgrEntire% vTextInAreaBgrEntire, Fill entire line(s)

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 Section, Text opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaFontOpacity Range1-255, % TextInAreaFontOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P

    Gui, Add, Text, xs y+20, Border opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBorderOpacity Range1-255, % TextInAreaBorderOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBorderColor% vTextInAreaBorderColor hwndhLV45,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBorderColor, P

    Gui, Add, Text, xs y+20, Background opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBgrOpacity Range1-255, % TextInAreaBgrOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBgrColor% vTextInAreaBgrColor hwndhLV2,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBgrColor, P

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%TextInAreaLivePreview% vTextInAreaLivePreview gupdateUIInsertTextPanel, Live preview (low quality)
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Insert text into selected area: " appTitle, winPos)
    SetTimer, updateUIInsertTextPanel, -250
}

PopulateFontsList(thisCtrl, guiu) {
    If !FontList._NewEnum()[k, v]
    {
       Fnt_GetListOfFonts()
       FontList := trimArray(FontList)
    }

    Loop, % FontList.Count()
    {
        fontNameInstalled := FontList[A_Index]
        If (fontNameInstalled ~= "i)(@|biz ud|ud digi kyo|oem|extb|symbol|marlett|wst_|glyph|reference specialty|system|terminal|mt extra|small fonts|cambria math|this font is not|fixedsys|emoji|hksc| mdl|wingdings|webdings)") || (fontNameInstalled=OSDFontName)
           Continue
        GuiControl, %guiu%:, %thisCtrl%, %fontNameInstalled%
    }
}

updateUIInsertTextPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=32)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, TextInAreaAlign
    GuiControlGet, TextInAreaAutoWrap
    GuiControlGet, TextInAreaValign
    GuiControlGet, TextInAreaBlurAmount
    GuiControlGet, TextInAreaBlurBorderAmount
    GuiControlGet, TextInAreaDoBlurs
    GuiControlGet, TextInAreaUsrMarginz
    GuiControlGet, TextInAreaBgrOpacity
    GuiControlGet, TextInAreaBgrEntire
    GuiControlGet, TextInAreaBgrUnified
    GuiControlGet, TextInAreaFontLineSpacing
    GuiControlGet, TextInAreaCharSpacing
    GuiControlGet, TextInAreaCutOutMode
    GuiControlGet, TextInAreaBorderSize
    GuiControlGet, TextInAreaBorderOut
    GuiControlGet, TextInAreaBorderOpacity
    GuiControlGet, TextInAreaFontBold
    GuiControlGet, TextInAreaFontItalic
    GuiControlGet, TextInAreaFontName
    GuiControlGet, TextInAreaFontOpacity
    GuiControlGet, TextInAreaFontSize
    GuiControlGet, TextInAreaFontUline
    GuiControlGet, TextInAreaFontStrike
    GuiControlGet, TextInAreaOnlyBorder
    GuiControlGet, TextInAreaPaintBgr
    GuiControlGet, TextInAreaLineAngle
    GuiControlGet, TextInAreaRoundBoxBgr
    GuiControlGet, TextInAreaLivePreview
    GuiControlGet, UserTextArea

    If !isNumber(TextInAreaFontLineSpacing)
       TextInAreaFontLineSpacing := 0

    If (TextInAreaBorderSize>=TextInAreaFontSize*2)
       TextInAreaBorderSize := TextInAreaFontSize*2

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIInsertTextPanel, -200
       Return
    }

    GuiControl, SettingsGUIA:, infoTextBlur, Blur amount: %TextInAreaBlurAmount%
    actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, TextInAreaBgrOpacity
    GuiControl, % actu, TextInAreaBgrColor
    GuiControl, % actu, PickuTextInAreaBgrColor
    GuiControl, % actu, TextInAreaBgrUnified
    GuiControl, % actu, TextInAreaBgrEntire
    GuiControl, % actu, TextInAreaCutOutMode

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
    {
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Enable, TextInAreaCutOutMode
    } Else
    {
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Disable, TextInAreaCutOutMode
    }

    actu2 := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, editF7
    GuiControl, % actu2, editF2
    GuiControl, % actu2, TextInAreaBorderSize
    GuiControl, % actu2, TextInAreaBorderColor
    GuiControl, % actu2, TextInAreaBorderOpacity
    GuiControl, % actu2, TextInAreaBlurBorderAmount
    GuiControl, % actu2, PickuTextInAreaBorderColor
    GuiControl, % actu2, TextInAreaOnlyBorder

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
       GuiControl, SettingsGUIA: Enable, TextInAreaRoundBoxBgr
    Else
       GuiControl, SettingsGUIA: Disable, TextInAreaRoundBoxBgr

    If (actionu!="noPreview" && TextInAreaLivePreview=1)
       livePreviewsImageEditing()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsTextAreaPanel, -300
}

WriteSettingsTextAreaPanel() {
     ReadSettingsTextInArea(1)
}

PanelPrefsWindow() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(14, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    columnBpos2 := 255
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global editF4, editF5, editF6, PickuWindowBGRcolor, PickuOSDbgrColor, PickuOSDtextColor

    Gui, Add, Text, x15 y15 w%txtWid%, The text style options apply to the On-Screen Display in the viewport. The same text style is used to render as images texts pasted from the clipboard.
    Gui, Add, Text, y+15 Section, Font name
    Gui, Add, Text, xs yp+30, Font size (OSD / clipboard)
    Gui, Add, Text, xs yp+30, Text color and style
    Gui, Add, Text, xs yp+30, Alignment (captions / paste)
    Gui, Add, Text, xs yp+30, OSD background color
    Gui, Add, Text, xs yp+30, Display time (in sec.)
    Gui, Add, Text, xs yp+30, Window background color
    Gui, Add, Checkbox, xs yp+30 gupdateUIsettings Checked%usrTextureBGR% vusrTextureBGR, &Ambiental textured background

    Gui, Add, DropDownList, xs+%columnBpos2% ys+0 Section w190 gupdateUIsettings Sort Choose1 vOSDFontName, %OSDFontName%
    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF5, %OSDfntSize%
    Gui, Add, UpDown, vOSDfntSize Range10-350, %OSDfntSize%
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF4, %PasteFntSize%
    Gui, Add, UpDown, vPasteFntSize Range12-350, %PasteFntSize%

    Gui, Add, ListView, xs yp+30 w%editWid% h28 %CCLVO% Background%OSDtextColor% vOSDtextColor hwndhLV1,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDtextColor, P
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontBolded% vFontBolded, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontItalica% vFontItalica, I
    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIsettings vusrTextAlign, %usrTextAlign%||Left|Right|Center
    Gui, Add, ListView,  xs+0 yp+30 gupdateUIsettings w%editWid% hp %CCLVO% Background%OSDbgrColor% vOSDbgrColor hwndhLV2,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDbgrColor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF6, %DisplayTimeUser%
    Gui, Add, UpDown, vDisplayTimeUser Range1-99, %DisplayTimeUser%
    Gui, Add, ListView, xs+0 yp+30 w%editWid% hp %CCLVO% Background%WindowBGRcolor% vWindowBGRcolor hwndhLV3,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuWindowBGRcolor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF7, %ambiTexBrushSize%
    Gui, Add, UpDown, vambiTexBrushSize Range25-950, %ambiTexBrushSize%
    Gui, Add, Checkbox, x15 y+10 gupdateUIsettings Checked%borderAroundImage% vborderAroundImage, &Highlight image borders in the viewport

    PopulateFontsList("OSDFontName", "SettingsGUIA")
    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w%btnWid% gOpenUImenu, &More options
    Gui, Add, Button, x+5 hp w90 gPrefsCloseBTN Default, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Interface settings: " appTitle)
}

PanelAdjustToneMapping() {
    If AnyWindowOpen
       Return

    IniAction(0, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(0, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(0, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    thisBtnHeight := createSettingsGUI(42, A_ThisFunc)
    btnWid := 100
    txtWid := 500
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 20
       Gui, Font, s%LargeUIfontValue%
    }

    If (cmrRAWtoneMapAlgo=1)
    {
       prcA := cmrRAWtoneMapParamA/9.9
       paramA := Round(200*prcA)
       prcB := (cmrRAWtoneMapParamB + 8)/16
       paramB := Round(200*prcB)
    } Else If (cmrRAWtoneMapAlgo=2)
    {
       prcA := (cmrRAWtoneMapParamA + 8)/16
       paramA := Round(200*prcA)
       paramB := 200*cmrRAWtoneMapParamB
    } Else If (cmrRAWtoneMapAlgo=3)
    {
       paramA := 200*cmrRAWtoneMapParamA
       paramB := 200*cmrRAWtoneMapParamB
    }

    showTOOLtip("Initializing tone-mapping panel, please wait")
    Global SliderA, SliderB, infoSliderA, infoSliderB
    Gui, -DPIScale
    Gui, Add, Text, x15 y15 w460 h320 +0x1000 +0xE +hwndhLVmainu, Image before 
    Gui, Add, Text, x480 y15 w460 h320 +0x1000 +0xE +hwndhCropCornersPic, Image after
    ; Gui, Add, Text, xp-480 y+1 w2 h2 +0x1000 +0xE, -
    Gui, +DPIScale
    Gui, Add, Text, x15 y+10 Section w%txtWid%, High-dynamic range images (HDRIs) must be converted to 32 bits to be displayed on screen. You can choose the algorithm to use for this and also configure it.
    Gui, Add, DropDownList, xs y+10 w%txtWid% AltSubmit gupdateUItoneMappingPanel Choose%cmrRAWtoneMapAlgo% vcmrRAWtoneMapAlgo, Adaptive logarithmic mapping (F. Drago, 2003)|HDR reduction inspired by photoreceptors physiology (E. Reinhard, 2005)|Gradient domain HDR compression (R. Fattal, 2002)
    Gui, Add, Text, xs y+10 wp vinfoSliderA, ParamA
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderA Range1-200, % ParamA
    Gui, Add, Text, xs y+10 wp vinfoSliderB, ParamB
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderB Range1-200, % ParamB
    friendly := (PrefsLargeFonts=1) ? "`n" : ""
    Gui, Add, Checkbox, xs y+10 gupdateUItoneMappingPanel Checked%userHQraw% vuserHQraw, Load camera RAW images at high quality`nEnable this to have tone-mapping apply%friendly%on RAW images as well

    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% gBTNtoneMapRefresh Default, &Update viewport
    Gui, Add, Button, x+5 hp w90 gBTNresetToneMap, &Reset
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "HDR tone-mapping options: " appTitle)
    RemoveTooltip()
    SetTimer, updateUItoneMappingPanel, -350
}

initializeFimPreviewIMG(imgPath) {
  Static uiBoxW := 460, uiBoxH := 320
  initFIMGmodule()
  If !wasInitFIMlib
     Return 0

  tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
  If !tempBMP
     Return 0

  Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
  If !Gu
  {
     trGdip_DisposeImage(tempBMP, 1)
     Return 0
  }

  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
  thisX := uiBoxW//2 - thisW//2
  thisY := uiBoxH//2 - thisH//2
  Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
  r1 := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), thisX, thisY, thisW, thisH)
  hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
  SetImage(hLVmainu, hBitmap)
  Gdi_DeleteObject(hBitmap)
  trGdip_DisposeImage(tempBMP, 1)
  Gdip_DeleteGraphics(Gu)

  If globalhFIFimg
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
  }

  loadArgs := 0
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := 0
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
  If hFIFimgA
  {
     FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
     calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
     hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, 0)
  }

  If !hFIFimgB
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
     Return 0
  }

  globalhFIFimg := hFIFimgB ? hFIFimgB : 0
  If !globalhFIFimg
     Return 0
  Else
     Return 1
}

updateUIfimToneMappedIMG() {
   Static uiBoxW := 460, uiBoxH := 320
   hFIFimgE := FreeImage_ToneMapping(globalhFIFimg, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
   imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgE), "-"))
   If (imgBPPc!=32)
      hFIFimgD := FreeImage_ConvertTo(hFIFimgE, "32Bits")

   hFIFimgZ := hFIFimgD ? hFIFimgD : hFIFimgE
   pBitmap := ConvertFIMtoPBITMAP(hFIFimgZ)

   tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
   If !tempBMP
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      trGdip_DisposeImage(tempBMP, 1)
      Return
   }

   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
   thisX := uiBoxW//2 - thisW//2
   thisY := uiBoxH//2 - thisH//2
   Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
   r1 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, thisX, thisY, thisW, thisH)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
   SetImage(hCropCornersPic, hBitmap)
   Gdi_DeleteObject(hBitmap)
   trGdip_DisposeImage(tempBMP, 1)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(pBitmap, 1)

   FreeImage_UnLoad(hFIFimgE)
   If hFIFimgD
      FreeImage_UnLoad(hFIFimgD)
}

BTNtoneMapRefresh() {
   updateUItoneMappingPanel()
   discardViewPortCaches()
   disposeCacheIMGs()
   RefreshImageFileAction()
}

BTNresetToneMap() {
   If (AnyWindowOpen=42)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControl, SettingsGUIA: Choose, cmrRAWtoneMapAlgo, 1
   GuiControl, SettingsGUIA:, SliderA, 38
   GuiControl, SettingsGUIA:, SliderB, 100
   Sleep, 1
   updateUItoneMappingPanel()
}

updateUItoneMappingPanel() {
   Static lastInvoked := 1
   If (AnyWindowOpen=42)
      Gui, SettingsGUIA: Default
   Else
      Return

   If (A_TickCount - lastInvoked<100)
   {
      SetTimer, updateUItoneMappingPanel, -250
      Return
   }

   GuiControlGet, cmrRAWtoneMapAlgo
   GuiControlGet, SliderA
   GuiControlGet, SliderB
   GuiControlGet, userHQraw
   prcA := SliderA/200
   prcB := SliderB/200
   If (cmrRAWtoneMapAlgo=1)
   {
      cmrRAWtoneMapParamA := 9.9*prcA
      GuiControl, SettingsGUIA:, infoSliderA, Gamma: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := 16*prcB - 8
      GuiControl, SettingsGUIA:, infoSliderB, Exposure: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      cmrRAWtoneMapParamA := 16*prcA - 8
      GuiControl, SettingsGUIA:, infoSliderA, Intensity: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Contrast: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=3)
   {
      cmrRAWtoneMapParamA := prcA
      GuiControl, SettingsGUIA:, infoSliderA, Saturation: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Attenuation: %cmrRAWtoneMapParamB%
   }

   updateUIfimToneMappedIMG()
   IniAction(1, "cmrRAWtoneMapAlgo", "General")
   IniAction(1, "cmrRAWtoneMapParamA", "General")
   IniAction(1, "cmrRAWtoneMapParamB", "General")
   lastInvoked := A_TickCount
}

updateUIsettings() {
    If (AnyWindowOpen=14)
       Gui, SettingsGUIA: Default
    Else
       Return

     GuiControlGet, DisplayTimeUser
     GuiControlGet, OSDFontName
     GuiControlGet, OSDfntSize
     GuiControlGet, PasteFntSize
     GuiControlGet, FontBolded
     GuiControlGet, FontItalica
     GuiControlGet, usrTextAlign
     GuiControlGet, borderAroundImage
     GuiControlGet, ambiTexBrushSize
     GuiControlGet, usrTextureBGR

     calcHUDsize()
     msgDisplayTime := DisplayTimeUser*1000
     SetTimer, WriteSettingsUI, -90
     If !throwErrorNoImageLoaded(1)
        SetTimer, RefreshImageFile, -250
}

WriteSettingsUI() {
  INIaction(1, "DisplayTimeUser", "General")
  INIaction(1, "OSDFontName", "General")
  INIaction(1, "WindowBgrColor", "General")
  INIaction(1, "OSDbgrColor", "General")
  INIaction(1, "OSDtextColor", "General")
  INIaction(1, "OSDfntSize", "General")
  INIaction(1, "PasteFntSize", "General")
  INIaction(1, "FontBolded", "General")
  INIaction(1, "FontItalica", "General")
  INIaction(1, "usrTextAlign", "General")
  INIaction(1, "borderAroundImage", "General")
  INIaction(1, "usrTextureBGR", "General")
  INIaction(1, "ambiTexBrushSize", "General")
}

PrefsCloseBTN() {
     updateUIsettings()
     interfaceThread.ahkFunction("updateWindowColor")
     BtnCloseWindow()
}

InvokeStandardDialogColorPicker(hC, event, c, err:=0) {
; Function by Drugwash
; Critical MUST be disabled below! If that's not done, script will enter a deadlock !
  Static
  If (event="RightClick")
  {
     mouseTurnOFFtooltip()
     StartPickingColor()
     SetTimer, mouseTurnOFFtooltip, -50
     Return
  } Else If (event!="Normal")
     Return

  oc := A_IsCritical
  Critical, Off

  ; ToolTip, % event , , , 2
  g := A_Gui, ctrl := A_GuiControl
  theColor := hexRGB(Dlg_Color(%ctrl%, hC))
  isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
  If (isAlphaPainting=1)
     theColor := convertColorToGrayscale(theColor)

  r := %ctrl% := theColor
  Critical, %oc%
  GuiControl, %g%:+Background%r%, %ctrl%
  INIaction(1, ctrl, "General")
  If (AnyWindowOpen=63)
  {
     updateUIgridPanel()
  } Else If (AnyWindowOpen=14)
  {
     interfaceThread.ahkassign("WindowBGRcolor", WindowBGRcolor)
     interfaceThread.ahkFunction("updateWindowColor")
     updateUIsettings()
     refreshWinBGRbrush()
     dummyTimerDelayiedImageDisplay(50)
  } Else If (imgEditPanelOpened=1)
  {
     fromPanelColorsToColorsSwatch(ctrl, theColor)
     livePreviewsImageEditing()
  }
}

hexRGB(c) {
; unknown source
  r := ((c&255)<<16)+(c&65280)+((c&0xFF0000)>>16)
  c := "000000"
  DllCall("msvcrt\sprintf", "AStr", c, "AStr", "%06X", "UInt", r, "CDecl")
  Return c
}

Hex2Str(val, len, x:=false, caps:=true) {
; Function by Drugwash
    VarSetCapacity(out, (len+1)*2, 32), c := caps ? "X" : "x"
    DllCall("msvcrt\sprintf", "AStr", out, "AStr", "%0" len "ll" c, "UInt64", val, "CDecl")
    Result := x ? "0x" out : out
    Return Result
}

getCustomColorsFromImage(whichBitmap) {
  Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
  calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
  c := []
  c[1] := Gdip_GetPixelColor(whichBitmap, X1, Y1, 3)
  c[2] := Gdip_GetPixelColor(whichBitmap, X2, Y2, 3)
  c[3] := Gdip_GetPixelColor(whichBitmap, X1, Y2, 3)
  c[4] := Gdip_GetPixelColor(whichBitmap, X2, Y1, 3)
  c[5] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1 + imgSelH//2, 3)
  c[6] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1, 3)
  c[7] := Gdip_GetPixelColor(whichBitmap, X1, Y1 + imgSelH//2, 3)
  c[8] := Gdip_GetPixelColor(whichBitmap, X2, Y2 - imgSelH//2, 3)
  c[9] := Gdip_GetPixelColor(whichBitmap, X2 - imgSelW//2, Y2, 3)
  c[10] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//4, Y1 + imgSelH//4, 3)
  c[11] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2 + imgSelW//4, Y1 + imgSelH//2 + imgSelH//4, 3)
  c[12] := Gdip_GetPixelColor(whichBitmap, 1, 1, 3)
  c[13] := Gdip_GetPixelColor(whichBitmap, 1, imgH - 1, 3)
  c[14] := Gdip_GetPixelColor(whichBitmap, imgW - 1, imgH - 1, 3)
  c[15] := Gdip_GetPixelColor(whichBitmap, imgW - 1, 1, 3)
  c[16] := Gdip_GetPixelColor(whichBitmap, imgW//2, imgH//2, 3)
  Return c
}

createStandardColorzDialog(hwnd, coloru) {
  theColor := hexRGB(Dlg_Color(coloru, hwnd))
  isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
  If (isAlphaPainting=1)
     theColor := convertColorToGrayscale(theColor)

  Return theColor
  ; GuiControl, %g%:+Background%r%, %ctrl%
}

Dlg_Color(Color,hwnd) {
; Function by maestrith 
; from: [AHK 1.1] Font and Color Dialogs 
; https://autohotkey.com/board/topic/94083-ahk-11-font-and-color-dialogs/
; Modified by Marius Șucan and Drugwash


  VarSetCapacity(CUSTOM,64,0)
  size := VarSetCapacity(CHOOSECOLOR,9*A_PtrSize,0)

  cclrs := getCustomColorsFromImage(useGdiBitmap())
  Loop, 16
  {
     ; BGR HEX
 ;    thisColor := "0x" SubStr(cclrs[A_Index], -1) SubStr(cclrs[A_Index], 7, 2) SubStr(cclrs[A_Index], 5, 2)
     NumPut(cclrs[A_Index], &CUSTOM, (A_Index-1)*4, "UInt")
  }

  oldColor := Color
  Color := "0x" hexRGB(InStr(Color, "0x") ? Color : Color ? "0x" Color : 0x0)
  NumPut(size,CHOOSECOLOR,0,"UInt")
  NumPut(hwnd,CHOOSECOLOR,A_PtrSize,"Ptr")
  NumPut(Color,CHOOSECOLOR,3*A_PtrSize,"UInt")
  NumPut(0x3,CHOOSECOLOR,5*A_PtrSize,"UInt")
  NumPut(&CUSTOM,CHOOSECOLOR,4*A_PtrSize,"Ptr")
  If !ret := DllCall("comdlg32\ChooseColorW","Ptr",&CHOOSECOLOR,"UInt")
     Exit

  SetFormat, Integer, H
  Color := NumGet(CHOOSECOLOR,3*A_PtrSize,"UInt")
  SetFormat, Integer, D
  Return Color
}

OpenUImenu() {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs")
}

invokeTlbrContextMenu() {
   deleteMenus()
   kMenu("PvUItoolbarMenu", "Add", "S&earch menu options`t;", "PanelQuickSearchMenuOptions")
   kMenu("PvUItoolbarMenu", "Add", "&Show quick bar`tF10", "ToggleQuickBaru")
   kMenu("PvUItoolbarMenu", "Add", "Hide toolbar`tShift+F10", "toggleAppToolbar")
   Menu, PvUItoolbarMenu, Add
   If (showMainMenuBar=1)
      kMenu("PvUItoolbarMenu", "Check", "&Show quick bar`tF10")

   kMenu("PvUItoolbarMenu", "Add", "&Vertical toolbar", "TLBRverticalAlign")
   If (TLBRverticalAlign=1 || TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Vertical toolbar")

   kMenu("PvUItoolbarMenu", "Add", "&Two columns vertical", "TLBRapplyTwoColumns")
   If (TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Two columns vertical")

   kMenu("PvUItoolbarMenu", "Add", "Reset &position", "tlbrResetPosition")
   Menu, PvUItoolbarMenu, Add
   kMenu("PvUItoolbarMenu", "Add", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
   kMenu("PvUItoolbarMenu", "Disable", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
   kMenu("PvUItoolbarMenu", "Add", "0.50x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "0.75x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.00x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.25x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.50x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "2.00x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "3.00x", "SetToolbarScaling")

   showThisMenu("PvUItoolbarMenu")
}

SetToolbarScaling(a, b, c) {
   ToolbarScaleFactor := StrReplace(a, "x")
   INIaction(1, "ToolbarScaleFactor", "General")
   createGUItoolbar()
}

InvokeOpenRecentMenu() {
   deleteMenus()
   createMenuOpenRecents()
   showThisMenu("PVopenF")
}

PanelDefineEntireSlideshowLength() {
    Global userHourDur, userMinDur, userSecDur, infoLine, userDefinedSpeedSlideshow
    If StrLen(mustOpenStartFolder)>3
    {
       currentFileIndex := doOpenStartFolder()
       Return
    }

    If (maxFilesIndex<3)
       Return

    thisBtnHeight := createSettingsGUI(19, A_ThisFunc)
    btnWid := 130
    txtWid := 350
    EditWid := 35
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 2
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    infoSliSpeed := DefineSlidesRate()
    etaTime := EstimateSlideShowLength()

    Gui, Add, Text, x15 y15 Section w%txtWid%, Define the total time of the slideshow`nfor %maxFilesIndex% images.
    Gui, Add, Text, y+15 w85, Hours
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserHourDur, % Round(Hrs)
    Gui, Add, Checkbox, x+5 hp Checked%doSlidesTransitions% vdoSlidesTransitions gUpdateSlideshowPanel, &Smooth slide transitions
    Gui, Add, Text, xs y+5 w85, Minutes
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserMinDur, % Round(Min)
    Gui, Add, Text, xs y+5 wp, Seconds
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserSecDur, % Round(Sec)
    Gui, Add, Text, xs y+5 wp, Speed
    Gui, Add, DropDownList, x+5 wp gChooseSlideSpeed AltSubmit vuserDefinedSpeedSlideshow, ---||30 FPS|15 FPS|7 FPS|2 FPS|1 sec.|2 sec.|4 sec.|8 sec.|16 sec.
    Gui, Add, Button, x+5 hp w75 gTimeLapseInfoBox, Infos
    thisW := (PrefsLargeFonts=1) ? 105 : 80
    Gui, Add, Button, x+5 hp w%thisW% gSetTimeLapseMode, Timelapse
    Gui, Add, Text, xs y+5 w85, Mode
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%SlideHowMode% vSlideHowMode, Random|Backwards|Forwards
    Gui, Add, Checkbox, x+5 hp Checked%allowGIFsPlayEntirely% vallowGIFsPlayEntirely gUpdateSlideshowPanel, &Allow GIFs play entirely

    Gui, Add, Text, xs y+15 w%txtWid% vinfoLine, One image every: %infoSliSpeed%`nEstimated slideshow duration: %etaTime%
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gStartSlideINtotalTimeBTNaction, &Start slideshow
    Gui, Add, Button, x+5 hp w90 gResetSlideSpeed, De&fault
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define total slideshow time: " appTitle)
}

TimeLapseInfoBox() {
    msgBoxWrapper(appTitle ": HELP", "The slideshow durations displayed in the panel include the time estimated to load each image. Based on previously loaded images, it takes about " drawModeCzeit " miliseconds to load an image.`n `nFor optimal timelapses [or very fast slideshows] set zoom at 100`%, disable image rotation and color adjustments and «skip already seen images».", -1, 0, 0)
    ; coreResetSlideSpeed(33, 1)
    ; GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
}

SetTimeLapseMode() {
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to set slideshow mode to timelapse? This will set zoom level to 100% and disable any image effect or adjustment.`n`nThe slideshow speed will be set at ~30 FPS [33 images/sec.].", 4, 0, "question")
    If (msgResult="Yes")
    {
       IMGresizingMode := 4
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
       mustRecordSeenImgs := 0
       imgFxMode := usrColorDepth := zoomLevel := 1
       vpIMGrotation := FlipImgH := FlipImgV := 0
       coreResetSlideSpeed(33, 1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
       dummyTimerDelayiedImageDisplay(50)
    }
}

ResetSlideSpeed() {
    coreResetSlideSpeed(4000, 1)
    GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 8
}

ChooseSlideSpeed() {
    GuiControlGet, userDefinedSpeedSlideshow
    If (userDefinedSpeedSlideshow=2)
       coreResetSlideSpeed(33, 1)
    Else If (userDefinedSpeedSlideshow=3)
       coreResetSlideSpeed(67, 1)
    Else If (userDefinedSpeedSlideshow=4)
       coreResetSlideSpeed(143, 1)
    Else If (userDefinedSpeedSlideshow=5)
       coreResetSlideSpeed(500, 1)
    Else If (userDefinedSpeedSlideshow=6)
       coreResetSlideSpeed(1000, 1)
    Else If (userDefinedSpeedSlideshow=7)
       coreResetSlideSpeed(2000, 1)
    Else If (userDefinedSpeedSlideshow=8)
       coreResetSlideSpeed(4000, 1)
    Else If (userDefinedSpeedSlideshow=9)
       coreResetSlideSpeed(8000, 1)
    Else If (userDefinedSpeedSlideshow=10)
       coreResetSlideSpeed(16000, 1)
}

coreResetSlideSpeed(varu, noDDLjump:=0) {
    slideShowDelay := varu
    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    GuiControl, SettingsGUIA:, userHourDur, % Round(Hrs)
    GuiControl, SettingsGUIA:, userMinDur, % Round(Min)
    GuiControl, SettingsGUIA:, userSecDur, % Round(Sec)
    If (noDDLjump!=1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    DefineSlidesTotalTimeBTNaction(0)
}

DefineSlidesRate() {
   slidesDuration := slideShowDelay
   ; slidesDuration := (slideShowDelay<drawModeCzeit) ? Round((drawModeCzeit*0.7+slideShowDelay)//2) : slideShowDelay
  ; If (slidesDuration<1995 && slidesDuration!=1000)
  ;    miliSec := slidesDuration " milisec."
   ; Else
      duration := SecToHHMMSS(Round(slidesDuration/1000, 3))
   Return miliSec ? miliSec : duration
}

StartSlideINtotalTimeBTNaction() {
   DefineSlidesTotalTimeBTNaction(0)
   BtnCloseWindow()
   Sleep, 300
   delayu := (thumbsDisplaying=1) ? 400 : 25
   lastOtherWinClose := 1
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
   Settimer, dummyInfoToggleSlideShowu, % -delayu
}

UpdateSlideshowPanel() {
    Static lastInvoked := 1
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    DefineSlidesTotalTimeBTNaction()
    GuiControlGet, doSlidesTransitions
    GuiControlGet, allowGIFsPlayEntirely
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    If (slideShowDelay<900)
       GuiControl, SettingsGUIA: Disable, doSlidesTransitions
    Else
       GuiControl, SettingsGUIA: Enable, doSlidesTransitions

    INIaction(1, "doSlidesTransitions", "General")
    INIaction(1, "allowGIFsPlayEntirely", "General")
    If (WhatsFocused="userHourDur" || WhatsFocused="userMinDur" || WhatsFocused="userSecDur")
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    lastInvoked := A_TickCount
}

DefineSlidesTotalTimeBTNaction(doDDLjump:=1) {
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, SlideHowMode
    GuiControlGet, userHourDur
    GuiControlGet, userMinDur
    GuiControlGet, userSecDur
    slideShowDelay := 0    
    slideShowDelay += userSecDur*1000
    slideShowDelay += (userMinDur*60)*1000
    slideShowDelay += ((userHourDur*60)*60)*1000
    slideShowDelay := Round(slideShowDelay/maxFilesIndex)
    If (slideShowDelay<16)
       slideShowDelay := 16

    etaTime := EstimateSlideShowLength()
    infoSliSpeed := DefineSlidesRate()
    IniAction(1, "SlideHowMode", "General")
    GuiControl, SettingsGUIA:, InfoLine, One image every: %approxMarker%%infoSliSpeed%`nEstimated slideshow duration: %approxMarker%%etaTime%
}

EstimateSlideShowLength(noPrecision:=0) {
    slidesDuration := (slideShowDelay<drawModeCzeit) ? (drawModeCzeit + slideShowDelay)/2 : drawModeCzeit*0.9 + slideShowDelay
    ; slidesDuration := (slideShowDelay<drawModeCzeit) ? drawModeCzeit : slideShowDelay
    approxMarker := (slideShowDelay<drawModeCzeit) ? "~" : ""
    infoFilesSel := (maxFilesIndex>0) ? maxFilesIndex : 1
    slidesDuration := Round(slidesDuration/1000, 3) * infoFilesSel
    ; MsgBox, % etaTime "--" slidesDuration "--" slideShowDelay "--" drawModeCzeit "--" maxFilesIndex
    etaTime := approxMarker SecToHHMMSS(slidesDuration)
    If (noPrecision=1)
       etaTime := RegExReplace(etaTime, "\...s", "s")
    Return etaTime
}

jumpPreviousImage() {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If askAboutFileSave(" and another image will be loaded")
       Return

    currentFileIndex := clampInRange(prevLastImg[2, 1], 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
}

PanelJump2index() {
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to open panel")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgPath := getIDimage(currentFileIndex)
   isAnim := (RegExMatch(imgPath, "i)(.\.(gif))$") && totalFramesIndex>1) ? "`fSkip to given frame index" : ""
   fakeWinCreator(13, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Skip to given index: " appTitle, "Please type a number to skip at in the files list and choose the action. Total entries: " groupDigits(maxFilesIndex) ".", "&Skip to...|C&ancel", 1, "fast-forward", 0, 0, "Skip to given file index`f`fSelect from current file index to given index" isAnim, "limit9050 +number", currentFileIndex, 2)
   If InStr(msgResult.btn, "skip")
   {
      usrJumpIndex := Trimmer(msgResult.edit)
      If !usrJumpIndex
         Return

      newJumpIndex := clampInRange(usrJumpIndex, 1, maxFilesIndex)
      If (newJumpIndex=currentFileIndex && newJumpIndex>0 && msgResult.list!=3)
         Return

      If askAboutFileSave(" and another image will be loaded")
         Return

      If (IsNumber(newJumpIndex) && newJumpIndex>=1)
      {
         If (msgResult.list=3)
         {
            desiredFrameIndex := clampInRange(usrJumpIndex, 1, totalFramesIndex)
            RefreshImageFile()
            Return
         } Else If (msgResult.list=2)
            jumpSelectRangeGiven(currentFileIndex, newJumpIndex)

         currentFileIndex := newJumpIndex
         dummyTimerDelayiedImageDisplay(50)
      }
   }
}

SaveClipboardImage(dummy:=0, allowCropping:=0, noDialog:=0) {
   Static lastInvoked := 1

   If throwErrorNoImageLoaded()
      Return

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   initFIMGmodule()
   INIaction(0, "userDesireWriteFMT", "General", 2, 1, 16)
   INIaction(0, "prevFileSavePath", "General", 5)
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := (dummy="current") ? OutDir "\" OutNameNoExt : prevFileSavePath "\" OutNameNoExt
   If !defaultu
      defaultu := prevFileSavePath "\" OutNameNoExt
   If FolderExist(dummy)
      defaultu := dummy "\" OutNameNoExt

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." oEXT)
           defFMTindex := A_Index
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (imgW*imgH>maxGDIbmpSize)
   {
      SoundBeep, 300, 100
      showTOOLtip("ERROR: The image size is too large. Image file saving disabled.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If alertReduceSaveColorDepth()
      Return

   If (noDialog=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && imgPath!=file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      If FileExist(imgPath)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         Sleep, 1
         FileSetAttrib, -R, % file2save
      }

      ForceRefreshNowThumbsList()
      If (AnyWindowOpen=35)
         BtnCloseWindow()

      prevFileSavePath := OutDir
      showTOOLtip("Saving image, please wait`n" OutFileName)
      newBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())))
      INIaction(1, "prevFileSavePath", "General")
      lastInvoked := A_TickCount
      If StrLen(newBitmap)>2
      {
         destroyGDIfileCache(1, 1)
         changeMcursor()
         r := QPV_SaveImageFile(A_ThisFunc, newBitmap, file2save, userJpegQuality)
         trGdip_DisposeImage(newBitmap, 1)
      } Else r := "err-no-main-bmp"

      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         resultedFilesList[currentFileIndex, 4] := 1
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
      }

      If r
      {
         msgBoxWrapper(appTitle ": ERROR", appTitle " was unable to save the image file due to an undetermined cause.`n`n" OutFileName "`n" OutDir "\`nError code: " r, 0, 0, "error")
         showTOOLtip("Failed to save image file`n" OutFileName "`n" OutDir "\")
      } Else
      {
         showTOOLtip("Image file succesfully saved`n" OutFileName "`n" OutDir "\")
         testMem := getIDimage(currentFileIndex)

         If (currentFileIndex=0) || (InStr(testMem, "\temporary memory object\") && maxFilesIndex<2)
         {
            currentFileIndex := maxFilesIndex := 1
            resultedFilesList[1, 1] := file2save
            DynamicFoldersList := OutDir "`n"
            prevOpenFolderPath := OutDir
            CurrentSLD := "|" OutDir
            SLDtypeLoaded := 1
         } Else If (imgPath!=file2save)
         {
            obju := [file2save]
            resultedFilesList.InsertAt(currentFileIndex, obju)
            currentFileIndex++
            maxFilesIndex++
         } Else If (imgPath=file2save)
            resultedFilesList[currentFileIndex, 1] := file2save
         Else If (SLDtypeLoaded=3)
            selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

         imgIndexEditing := currentFileIndex
         currentImgModified := 2
      }

      SoundBeep, % r ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -50
   }
}

BtnCpyMvChooseFilesDest() {
   If (currentFileIndex=0)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectedDir := openFoldersDialogWrapper("S2", prevFileMovePath)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
   {
      BtnCloseWindow()
      Sleep, 15
      prevFileMovePath := SelectedDir
      RecentCopyMoveManager(SelectedDir)
      Sleep, 15
      CopyMovePanelWindow()
   } Else
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   }
}

zPlitPath(inputu, fastMode, ByRef fileNamu, ByRef folderu, ByRef fileNamuNoEXT:=0, ByRef fileEXT:=0) {
    If (fastMode=0)
    {
       inputu := Trimmer(StrReplace(inputu, "|"))
       FileGetAttrib, OutputAttribs, %inputu%
    } Else StringRight, OutputVar, inputu, 1

    If InStr(OutputAttribs, "D") || (OutputVar="\")
    {
       ; ToolTip, % OutputVar , , , 2
       ; SoundBeep , 300, 100
       folderu := inputu
       fileEXT := fileNamuNoEXT := fileNamu := ""
    } Else
    {
       lineArr := StrSplit(inputu, "\")
       maxuIndex := lineArr.Count()
       fileNamu := lineArr[maxuIndex]
       fileParentFolder := lineArr[maxuIndex - 1]
       ; folderu := SubStr(inputu, 1, StrLen(inputu) - StrLen(fileNamu) - 1)
       ; fileEXTpos := RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       fileEXTpos := InStr(fileNamu, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       If fileEXTpos
          fileEXT := Trimmer(SubStr(fileNamu, fileEXTpos+1))

       If (fileExt="" || StrLen(fileExt)>4)
       {
          fileNamu := fileEXTpos := ""
          folderu := Trim(Trimmer(inputu), "\")
       } Else
       {
          folderu := ""
          Loop, % maxuIndex - 1
          {
             If (lineArr[A_Index]!="")
                folderu .= lineArr[A_Index] "\"
          }
          folderu := Trim(folderu, "\")
       }

       ; fileNamuNoEXT := fileEXTpos ? RegExReplace(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$") : fileNamu
       fileNamuNoEXT := fileEXTpos!="" ? SubStr(fileNamu, 1, fileEXTpos - 1) : fileNamu
    }
    Return fileParentFolder
}

StringToASC(string) {
   Static lastInvoked, lastAsc
   If (String="")
      Return

   If (string=lastInvoked)
      Return lastAsc

   ; AscString := StrLen(string)
   Loop, Parse, string 
      AscString .= RegExMatch(A_LoopField, "[[:alnum:]]") ? A_LoopField : Ord(A_LoopField)

   ; ToolTip, % AscString , , , 2 
   lastInvoked := string
   lastAsc := AscString
   Return AscString
}

readRecentFileDesties(modus:=0) {
   listu := ""
   If (modus!=1)
   {
      If FolderExist(prevFileMovePath)
         listu .= prevFileMovePath "`n"
      If FolderExist(prevFileSavePath)
         listu .= prevFileSavePath "`n"
      If FolderExist(prevOpenFolderPath)
         listu .= prevOpenFolderPath "`n"
   }

   Loop, 15
   {
       IniRead, newEntry, % mainRecentsFile, RecentFDestinations, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (FolderExist(newEntry) && !InStr(listu, newEntry "`n"))
          listu .= newEntry "`n"
   }
   Return listu
}

PanelMoveCopyFiles() {
   UsrCopyMoveOperation := 2
   CopyMovePanelWindow()
}

InvokeCopyFiles() {
   UsrCopyMoveOperation := 3
   If (maxFilesIndex>0)
      CopyMovePanelWindow()
}

CopyMovePanelWindow() {
    Global BtnCpyMv, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    thisBtnHeight := createSettingsGUI(9, A_ThisFunc)
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    ToolTip, Please wait...,,, 2
    listu := readRecentFileDesties()
    listu .= "--={ other destinations }=--`n"
    setImageLoading()
    historyList := readRecentEntries()
    Loop, Parse, historyList, `n
    {
       If (A_Index>10)
          Break 

       If StrLen(A_LoopField<4)
          Continue 

       changeMcursor()
       OutDir := StrReplace(A_LoopField, "|")
       If InStr(listu, OutDir "`n") || !FolderExist(OutDir)
          Continue

       listu .= OutDir "`n"
    } 

    thisDynaList := getDynamicFoldersList()
    ; DynamicFoldersList := mainDynaFoldersListu
    prevCurrentSLD := CurrentSLD
    lastInvoked := A_TickCount

    Loop, Parse, thisDynaList, `n
    {
        If (A_Index>15)
           Break

        If StrLen(A_LoopField)<4
           Continue

        changeMcursor()
        folderu := StrReplace(A_LoopField, "|")
        If InStr(listu, folderu "`n") || !FolderExist(folderu)
           Continue

        listu .= folderu "`n"
    }

    List_MakeUnique(listu, "`n", 0, 0)
    Loop, Parse, listu, `n
    {
        If !A_LoopField
           Continue

        changeMcursor()
        indexu := InStr(A_LoopField, "{ other dest") ? "" : A_Index - 1 "; "
        finalListu .= indexu A_LoopField "`n"
        If (A_Index=1)
           finalListu .= "`n"
    }

    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       finalListu .= "[group-by-month-year]`n[group-by-years]`n[group-by-file-types]"
       copyMoveDoLastOption := 0
       infoSelection := "Selected files: " markedSelectFile ". "
    }

    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 Section, %infoSelection%Please select or type destination folder...
    Gui, Add, ComboBox, xs y+10 w%EditWid% gCopyMoveComboAction r12 Simple vUsrEditFileDestination, % finalListu
    Gui, Add, Checkbox, y+10 Checked%copyMoveDoLastOption% vcopyMoveDoLastOption, When file name(s) collide, use previously given answer
    If (markedSelectFile>1)
       GuiControl, Disable, copyMoveDoLastOption

    ToolTip,,,,2
    SetTimer, ResetImgLoadStatus, -50
    btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
    Gui, Add, DropDownList, xs y+20 w%btnWid% gchangeCopyMoveAction AltSubmit Choose%UsrCopyMoveOperation% vUsrCopyMoveOperation, Action to perform...`nMove file(s)`nCopy file(s)
    Gui, Add, Button, x+5 hp w%btnWid% gBtnCpyMvChooseFilesDest, &Choose a new folder
    Gui, Add, Button, x+5 hp w90 gBtnHelpCopyMovePanel, Hel&p

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBtnCopyMoveAction vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp wp+30 gEraseCopyMoveHisto, Erase &history
    Gui, Add, Button, x+5 hp wp+60 gBtnMarkFilesExplorer, &Mark file(s) (Explorer)
    Gui, Add, Button, x+5 hp w70 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, btnName " file(s) to...: " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BtnHelpCopyMovePanel() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  If (AnyWindowOpen=9)
     moreInfo := "`n`nIf you click on «Mark files (Explorer)» button, the selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle "."

  msgBoxWrapper(appTitle ": HELP", "Recognized patterns:`n`na) " btnName " files to parent folder: .\`n`nb) " btnName " files to a new or existing sub-folder: \given-folder`n`nc) " btnName " files into a new or exiting folder within the parent folder: .\given-folder`n`nThe destination folder for all selected files [if any] will be calculated relative to the currently focused file index entry: " groupDigits(currentFileIndex) ".`n" OutDir "`n`nUse [group-by-month-year], [group-by-years] or [group-by-file-types] as folder name to automatically group files in newly created folders named based on files' modification date or file types." moreInfo, -1, 0, 0)
}

changeCopyMoveAction() {
  GuiControlGet, UsrCopyMoveOperation
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  ; GuiControl, SettingsGUIA:, BtnCpyMv, &%btnName% file(s)
  Gui, SettingsGUIA: Show,, %btnName% file(s) to...: %appTitle%
  If (UsrCopyMoveOperation=1)
     GuiControl, SettingsGUIA: Disable, BtnCpyMv
  Else
     GuiControl, SettingsGUIA: Enable, BtnCpyMv
}

CopyMoveComboAction() {
  Static lastInvoked := 1
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination
  If (A_GuiControlEvent="DoubleClick")
  {
     BtnCopyMoveAction()
  } Else If (A_GuiControlEvent="Normal") && (A_TickCount - lastInvoked > 50) && StrLen(UsrEditFileDestination)<5
    && !InStr(UsrEditFileDestination, ":\") && InStr(UsrEditFileDestination, ";")
  {
     SendInput, {Up}
     lastInvoked := A_TickCount
  }
}

EraseCopyMoveHisto() {
  IniDelete, % mainRecentsFile, RecentFDestinations
  BtnCloseWindow()
  CopyMovePanelWindow()
}

BtnMarkFilesExplorer() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "Please choose an action to perform: copy or move.`n`nThe selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", 0, 0, "exclamation")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  BtnCloseWindow()
  If (UsrCopyMoveOperation=3)
     MenuExplorerCopyFiles()
  Else
     MenuExplorerCutFiles()
}

BtnCopyMoveAction(dummy:=0) {
  If (dummy!="quick-actu")
  {
     Gui, SettingsGUIA: Default
     GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
     GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
     GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
     If (UsrCopyMoveOperation=1)
     {
        showTOOLtip("WARNING: Please choose an action to perform: copy or move")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     }
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  folderu := Trimmer(UsrEditFileDestination)
  folderu := StrReplace(folderu, "/", "\")
  folderu := RegExReplace(folderu, "\\{2,}", "\")
  groupingMode := 0
  If (folderu="[group-by-month-year]" || folderu="[group-by-years]" || folderu="[group-by-file-types]")
  {
     ; group files by given criteria
     groupingMode := 1
     folderu := OutDir "\" folderu
  } Else If (folderu=".\")
  {
     ; move files one level up
     folderu := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
  } Else If RegExMatch(folderu, "^(\\.)")
  {
     ; move files to a given sub-folder
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  } Else If RegExMatch(folderu, "^(\.\\.)")
  {
    ; move files to a given sibling folder
     OutDir := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  }

  folderu := StrReplace(folderu, "\\", "\")
  folderu := Trimmer(folderu, "\")
  folderu := Trimmer(folderu, ".")
  If (b := InStr(folderu, "; "))
     folderu := SubStr(folderu, b+2)

  wrongNames := 0
  testFolderu := SubStr(folderu, 4)
  Loop, Parse, testFolderu, \
  {
      IF (!filterFileName(A_LoopField) && A_LoopField)
         wrongNames := 1
  }

  If (InStr(folderu, "[group-by-month-year]") || InStr(folderu, "[group-by-file-types]") || InStr(folderu, "[group-by-years]"))
     groupingMode := 1

  If (!RegExMatch(folderu, "^(.\:\\.)") || wrongNames=1)
  {
     showTOOLtip("WARNING: Incorrect file path given:`n" folderu)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }

  If (FolderExist(folderu) || groupingMode=1)
  {
     Sleep, 2
     r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
  } Else If (StrLen(folderu)>4)
  {
     If (dummy!="quick-actu")
        msgResult := msgBoxWrapper(appTitle, "Destination folder does not seem to exist:`n" folderu "\`n`nDo you want to create the folder?", 4, 0, "question")

     If (msgResult="yes" || dummy="quick-actu")
     {
        FileCreateDir, % folderu
        If ErrorLevel
        {
           SoundBeep , 300, 100
           If (dummy="quick-actu")
              showTOOLtip("Failed to create the destination folder:`n" folderu "\")
           Else
              msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n" folderu "\", 0, 0, "error")
           Return 0
        } Else
        {
           Sleep, 2
           r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
        }
     }
  }
  ; MsgBox, %folderu% -- %newentry%
  Return r
}

RecentCopyMoveManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFileDesties(1)

  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu,`n
  {
      If (A_LoopField=entry2add)
      {
         isAddedAlready := 1
         Break
      }
  }

  If (isAddedAlready=1)
     Return

  mainListu := entry2add "`n" mainListu
  Loop, Parse, mainListu, `n
  {
      If (A_Index>15)
         Break

      folderu := Trimmer(A_LoopField)
      folderu := Trimmer(folderu, "\")
      If (!FolderExist(folderu) || !InStr(folderu, ":\"))
         Continue

      countItemz++
      IniWrite, % folderu, % mainRecentsFile, RecentFDestinations, E%countItemz%
  }
}

QuickMoveFile2Dest(finalDest, goLastOption, groupingMode:=0, dummy:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()
 
    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       batchCopyMoveFile(finalDest, groupingMode, dummy)
       Return 0
    } 

    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
    If !FileExist(file2rem)
    {
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("Failed to perform action. File not found or access denied.`n" OldOutFileName "`n" OldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": ERROR", "Failed to perform action. File not found or access denied.`n`n" OldOutFileName "`n" OldOutDir "\", 0, 0, "error")
       Return 0
    }

    If (groupingMode=1)
    {
       FileGetTime, originalMtime, % file2rem, M
       finalDest := determineCreateFileGroupFolder(finalDest, originalMtime, OutFileExt)
    }

    If (OldOutDir=finalDest)
    {
       SetTimer, ResetImgLoadStatus, -200
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("WARNING: Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\")
       Else
          msgBoxWrapper(appTitle ": WARNING", "Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\", 0, 0, "exclamation")
       Return 0
    }

    BtnCloseWindow()
    Sleep, 2
    destroyGDIfileCache()
    FileGetTime, originalCtime, % file2rem, C
    file2save := finalDest "\" OldOutFileName

    thisFileExists := 0
    forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
    If (FileExist(file2save) && !FolderExist(file2save))
    {
       thisFileExists := 1
       file2save := askAboutFileCollision(file2rem, file2save, 0, goLastOption + 1, forceConflictOption, performOverwrite)
       If !file2save
       {
          showTOOLtip("WARNING: Another file with the same file name already exists in the destination folder:`n" OldOutFileName "`n" finalDest "\`nOperation aborted.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -200
          Return 0
       }
    }

    If (file2save="abort" || !file2save) && (dummy!="quick-actu")
    {
       If (UsrCopyMoveOperation!=2)
          SetTimer, InvokeCopyFiles, -150
       Else
          SetTimer, PanelMoveCopyFiles, -150
       Return 0
    }

    If (thisFileExists=1)
    {
       If (performOverwrite=1)
       {
          FileSetAttrib, -R, %file2save%
          Sleep, 5
          FileRecycle, %file2save%
          Sleep, 5
          mustPerformOperation := 1
       } Else If (performOverwrite!=2)
       {
          showTOOLtip("Operation aborted. A file with the same name already exists in the destination folder.`n" OldOutFileName "`n" finalDest "\")
          SoundBeep, 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -25
          Return
       } Else mustPerformOperation := 1
    } Else mustPerformOperation := 1

    If (mustPerformOperation=1)
    {
       operationExecuted := 1
       If (UsrCopyMoveOperation=2)
          FileMove, %file2rem%, %file2save%
       Else
          FileCopy, %file2rem%, %file2save%
       If ErrorLevel
          wasError := 1
    }

    If (wasError!=1 && operationExecuted=1)
    {
       updateDates := 1
       If (originalMtime)
       {
          FileSetTime, % originalMtime, % file2save, M
          FileSetTime, % originalCtime, % file2save, C
          updateDates := 0
       }

       If (dummy!="quick-actu")
       {
          prevFileMovePath := finalDest
          INIaction(1, "prevFileMovePath", "General")
          RecentCopyMoveManager(finalDest)
       }

       actName := (UsrCopyMoveOperation=2) ? "MOVED" : "COPIED"
       zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
       showTOOLtip("File " actName " to`n" OldOutFileName "`n" finalDest "\")
       If (UsrCopyMoveOperation=2)
       {
          resultedFilesList[currentFileIndex, 1] := file2save
          updateMainUnfilteredList(currentFileIndex, 1, file2save)
          If (SLDtypeLoaded=3)
             updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])
       }
       Sleep, 1
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -25
       Return 1
    } Else If (operationExecuted=1)
    {
       actName := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
       showTOOLtip("ERROR: Failed to " actName " file:`n" OldOutFileName "To destination:`n" finalDest "\")
       SoundBeep, 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -25
    Return 0
}

determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt) {
   If ((InStr(oFinalDest, "[group-by-month-year]") && originalMtime)
   || (InStr(oFinalDest, "[group-by-file-types]") && OutFileExt)
   || (InStr(oFinalDest, "[group-by-years]") && originalMtime))
   {
      FormatTime, grouper, % originalMtime, yyyy-MM-MMMM
      FormatTime, groupery, % originalMtime, yyyy
      finalDest := StrReplace(oFinalDest, "[group-by-month-year]", grouper)
      finalDest := StrReplace(finalDest, "[group-by-file-types]", OutFileExt)
      finalDest := StrReplace(finalDest, "[group-by-years]", groupery)
      If !FolderExist(finalDest)
      {
         FileCreateDir, % finalDest
         Sleep, 2
      }
   } Else finalDest := oFinalDest 
   Return FinalDest
}

batchCopyMoveFile(finalDest, groupingMode:=0, dummy:=0) {
   Static lastInvoked := 1
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>150) ; ((A_TickCount - lastInvoked > 29500) && dummy!="quick-actu")
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected " groupDigits(filesElected) " files`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return 0
   }

   BtnCloseWindow()
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly groupDigits(filesElected) " files to`n" finalDest "\`nPlease wait")
   If (dummy!="quick-actu")
   {
      prevFileMovePath := finalDest
      RecentCopyMoveManager(finalDest)
   }

   destroyGDIfileCache()
   Sleep, 25
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   countTFilez := filezMoved := failedFiles := skippedFiles := 0
   oFinalDest := finalDest
   forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      ; grouper := ""
      If (groupingMode=1)
         finalDest := determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt)

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, forceConflictOption, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         updateDates := 1
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
            updateDates := 0
         }

         filezMoved++
         ; zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   watchFolderDetails := ""
   If (UsrCopyMoveOperation=2)
      currentFilesListModified := 1

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   Return 0
}

batchConvert2format() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to convert " groupDigits(filesElected) " files to the ." rDesireWriteFMT " format ? "
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."
      If (OnConvertKeepOriginals!=1)
         msgInfos .= "`n`nThe original files will be ERASED."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
   BtnCloseWindow()
   setImageLoading()
   showTOOLtip("Converting to ." rDesireWriteFMT " format " groupDigits(filesElected) " files, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresConvertFormat(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG lossless processing: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   initFIMGmodule()
   skipDeadFiles := theseFailures := failedFiles := countTFilez := filesConverted := 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
         If (theseFailures>0)
            etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      countTFilez++
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         filesConverted++

      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, % imgPath
         Sleep, 2
         FileRecycle, % imgPath
         If ErrorLevel
            theseFailures++

         resultedFilesList[thisFileIndex, 1] := file2save
         ; resultedFilesList[thisFileIndex, 2] := 1
         updateMainUnfilteredList(thisFileIndex, 1, file2save)
         If (SLDtypeLoaded=3)
            updateSQLdbEntry(imgPath, file2save, 1, resultedFilesList[thisFileIndex, 12])
      }
   }

   currentFilesListModified := 1
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   If (failedFiles>0)
      someErrors := "`nFailed to convert " groupDigits(failedFiles) " files"
   If (theseFailures>0)
      someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
   Else
      showTOOLtip("Finished converting to ." rDesireWriteFMT " format`n" groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

coreConvertImgFormat(imgPath, file2save) {
   If (PreserveDateTimeOnSave=1)
   {
      ; fnOutputDebug("got original date")
      FileGetTime, originalMtime, % imgPath, M
      FileGetTime, originalCtime, % imgPath, C
   }

   maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   If (FIMfailed2init=1 || maxLimitReached=1)
   {
      If FileExist(file2save)
         FileSetAttrib, -R, %file2save%

      pBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(pBitmap)<3
         Return -1

      rawFmt := Gdip_GetImageRawFormat(pBitmap)
      If (rawFmt="JPEG")
         RotateBMP2exifOrientation(pBitmap)

      changeMcursor()
      r := Gdip_SaveBitmapToFile(pBitmap, file2save, 90)
      trGdip_DisposeImage(pBitmap, 1)
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime "  -- fim-fail  " FIMfailed2init " ")
   } Else
   {
      loadArgs := 0
      GFT := FreeImage_GetFileType(imgPath)
      If (GFT=34)
         loadArgs := (userHQraw=1) ? 0 : 5
      Else If (GFT=2)
         loadArgs := 8

      hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
      If !hFIFimgA
         Return -1

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
      If (mustApplyToneMapping=1)
      {
         ; setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
         changeMcursor()
         hFIFimgB := FreeImage_ToneMapping(hFIFimgA, 0, 1.85, 0)
      }

      hFIFimgC := hFIFimgB ? hFIFimgB : hFIFimgA
      If (FileExist(file2save) && hFIFimgC)
      {
         Try FileSetAttrib, -R, % file2save
         Sleep, 1
         FileMove, % file2save, % file2save "-tmp"
         If !ErrorLevel
            tempFileExists := 1

         Sleep, 1
      }

      saveArg := 0
      If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
         saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
      Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
         saveArg := clampInRange(Round(userJpegQuality), 1, 100)

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
      If (RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$") && hFIFimgC)
      {
         changeMcursor()
         hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "24Bits")
         changeMcursor()
         r := FreeImage_Save(hFIFimgD, file2save, saveArg)
         FreeImage_UnLoad(hFIFimgD)
      } Else If hFIFimgC
      {
         r := FreeImage_Save(hFIFimgC, file2save, saveArg)
         If (!r && imgBPP!=32)
         {
            FileDelete, % file2save
            Sleep, 1
            changeMcursor()
            hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")
            changeMcursor()
            r := FreeImage_Save(hFIFimgD, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgD)
          }
      }

      FreeImage_UnLoad(hFIFimgA)
      FreeImage_UnLoad(hFIFimgB)
      If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
      {
         r := 0
         FileDelete, % file2save
         Sleep, 1
         FileMove, % file2save "-tmp", % file2save
      } Else If (tempFileExists=1)
         FileDelete, % file2save "-tmp"

      r := !r
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime " ")
   }
   Return r
}

convert2format() {
  Critical, on
  If (currentFileIndex=0)
     Return "err"

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(currentFileIndex)
  If RegExMatch(file2rem, "i)(.\.(" rDesireWriteFMT "))$")
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "The image file seems to be already in the given file format: ." rDesireWriteFMT ". Please choose another format.", 0, 0, "exclamation")
     Return "err"
  }

  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
  {
     ToolTip
     zPlitPath(file2save, 0, OutFileName, OutDir)
     msgResult := msgBoxWrapper(appTitle ": Confirmation", "A file with the same name already exists in the destination folder... Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
     forceOverwrite := (msgResult="Yes") ? 1 : 0
     If !forceOverwrite
        Return
  }

  BtnCloseWindow()
  destroyGDIfileCache()
  Sleep, 1
  setImageLoading()
  showTOOLtip("Converting image file, please wait")
  If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
     FileCreateDir, % ResizeDestFolder

  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
     FileSetAttrib, -R, %file2save%

  r := coreConvertImgFormat(file2rem, file2save)
  SetTimer, ResetImgLoadStatus, -50
  If r
     showTOOLtip("Failed to convert file`n" OutFileName "`n" OutDir "\")
  Else
     showTOOLtip("File converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

  SoundBeep, % r ? 300 : 900, 100
  If (OnConvertKeepOriginals!=1 && !r)
  {
     Try FileSetAttrib, -R, %file2rem%
     Sleep, 1
     FileRecycle, %file2rem%
     If ErrorLevel
        showTOOLtip("Failed to remove original file, however the file was converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

     resultedFilesList[currentFileIndex, 1] := file2save
     resultedFilesList[currentFileIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(file2rem, file2save, 1, resultedFilesList[currentFileIndex, 12])

     updateMainUnfilteredList(currentFileIndex, 1, file2save)
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenFolders(dummy:=0) {
   If (AnyWindowOpen || imageLoading=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If FolderExist(dummy)
      SelectedDir := dummy
   Else
      SelectedDir := openFoldersDialogWrapper(2, prevOpenFolderPath, "Select the folder to open recursively")

   If (SelectedDir)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      newStaticFoldersListCache := []
      prevOpenFolderPath := StrReplace(SelectedDir, "|")
      INIaction(1, "prevOpenFolderPath", "General")
      coreOpenFolder(SelectedDir, 1, 1, 1)
      If (maxFilesIndex>0)
         SLDtypeLoaded := 1
      ; Else resetMainWin2Welcome()
   }
}

openFoldersDialogWrapper(optionz, startPath, msg:="") {
   Static defaultu := "<Use current folder>"
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
   entriesList := defaultu "`n" recentOpenedFolders()
   r := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, entriesList, 1, "History", entriesList)
   If (!InStr(r.SelectedCombo, defaultu) && StrLen(r.SelectedCombo)>3)
      z := r.SelectedCombo
   Else If StrLen(r.SelectedDir)>4
      z := r.SelectedDir

   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return z
}

renewCurrentFilesList() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
   }

   prevRandyIMGs := []
   resultedFilesList := []
   lastRenameUndo := []
   prevLastImg := []
   reviewSelectedIndexes := []
   hasHamDistCached := 0
   markedSelectFile := EntryMarkedMoveIndex := maxFilesIndex := 0
   lastZeitFileSelect := editingSelectionNow := prevRandyIMGnow := 0
   ForceRefreshNowThumbsList()
   updateUIctrl()
   currentFileIndex := 1
   prevLoadedImageIndex := ""
   currentImgModified := allImagesWereSeen := 0
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   destroyGDIfileCache()
   discardViewPortCaches()
   disposeCacheIMGs()
   hudBTNfuncu := thisSearchString := userSearchString := ""
   terminateIMGediting()
   If hSNDmedia
      StopMediaPlaying()
}

FileExploreUpDownLevel(direction, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel := 0, prevPathArray := []
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   oldFolder := baseFolder
   initialLevel := thisLevel
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   prevMaxLevels := prevPathArray.Length()
   If (prevMaxLevels=thisLevel)
   {
      Loop, Files, % thisFolder "\*", D
      {
         If (A_LoopFileName!="" && A_Index=1)
         {
            thisFolder .= "\" A_LoopFileName
            Break
         }
      }

      If (direction=1)
      {
         Loop, Files, % thisFolder "\*", D
         {
            If (A_LoopFileName!="" && A_Index=1)
            {
               thisFolder .= "\" A_LoopFileName
               Break
            }
         }
      }
   }

   thisFolder := StrReplace(thisFolder, "\\", "\")
   thisFolder := Trimmer(thisFolder, "\")
   folderPathArray := StrSplit(thisFolder, "\")
   maxLevels := folderPathArray.Length()
   Loop, % maxLevels
   {
        If (folderPathArray[A_Index]!=prevPathArray[A_Index])
        {
           thisLevel := 0
           prevPathArray := folderPathArray.Clone()
           Break
        }
   }

   thisParent := SubStr(oldFolder, InStr(oldFolder, "\", 0, -1) + 1)
   If !thisLevel
   {
      Loop, % maxLevels + 1
      {
           If (folderPathArray[A_Index]=thisParent)
           {
              thisLevel := A_Index
              Break
           }
      }
   }

   oldIndex := currentFileIndex
   prevMaxLevels := prevPathArray.Length()
   If (returnObj=1)
   {
      iLevel := thisLevel
      Return prevPathArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, prevMaxLevels)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, prevMaxLevels)

   If forceLevel
      thisLevel := forceLevel

   Loop, % prevMaxLevels
   {
      newFolder .= prevPathArray[A_Index] "\"
      If (A_Index=thisLevel)
         Break
   }

   newFolder := Trimmer(newFolder, "\")
   If (initialLevel!=thisLevel)
      tryOpenGivenFolder(newFolder, oldFolder)
}

FileExploreSiblingsNav(direction, isInLoop:=0, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel, prevFolder, subFoldersArray := []
   If (direction="reset")
   {
      prevFolder := thisLevel := ""
      subFoldersArray := []
      Return
   }

   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   initialLevel := thisLevel
   oldFolder := baseFolder
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   initialSibling := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   thisFolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
   If (thisFolder!=prevFolder)
   {
      subFoldersArray := []
      prevFolder := thisFolder
      Loop, Files, % thisFolder "\*", D
      {
         If (A_LoopFileName=initialSibling)
            thisLevel := A_Index

         If (A_LoopFileName!="")
            subFoldersArray[A_Index] := A_LoopFileName
      }
   }

   oldIndex := currentFileIndex
   maxLevels := subFoldersArray.Count()
   If (maxLevels<2)
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (returnObj=1)
   {
      iLevel := thisLevel
      Return subFoldersArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, maxLevels, 1)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, maxLevels, 1)

   If forceLevel
      thisLevel := forceLevel

   If (subFoldersArray[thisLevel]!="")
   {
      newFolder := thisFolder "\" subFoldersArray[thisLevel]
   } Else If (isInLoop<maxLevels)
   {
      isInLoop++
      FileExploreSiblingsNav(direction, isInLoop)
      Return
   } Else
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (initialLevel!=thisLevel && FolderExist(newFolder))
   {
      r := tryOpenGivenFolder(newFolder, oldFolder)
      If (r=1)
      {
         subFoldersArray[thisLevel] := ""
         thisLevel := initialLevel
      } Else showDelayedTooltip("Sibling folders navigation: " thisLevel " / " maxLevels "`n.\" subFoldersArray[thisLevel] "\")
   } Else If !FolderExist(newFolder)
   {
      ; subFoldersArray[thisLevel] := ""
      FileExploreSiblingsNav(direction, 1)
   }
}

coreOpenFolder(thisFolder, doOptionals:=1, openFirst:=0, doReset:=0, safeMode:=0) {
   testThis := StrReplace(thisFolder, "|")
   mustOpenStartFolder := ""
   If FolderExist(testThis)
   {
      If (A_TickCount - scriptStartTime>350)
         BtnCloseWindow()

      filesFilter := CurrentSLD := ""
      setWindowTitle("Indexing files, please wait...", 1)
      renewCurrentFilesList()
      ; activeSQLdb.Exec("DELETE FROM images;")
      r := GetFilesList(thisFolder "\*")
      If (maxFilesIndex<1 || !maxFilesIndex) && (safeMode=0)
      {
         If (!CurrentSLD || doReset=1)
            resetMainWin2Welcome()
         Else
            FadeMainWindow()

         showTOOLtip("ERROR: Found no recognized image files in the folder`n" thisFolder "\")
         SoundBeep, 300, 100
         setWindowTitle(appTitle " v" appVersion, 1)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GenerateRandyList()
      mustGenerateStaticFolders := 1
      DynamicFoldersList := thisFolder "`n"
      CurrentSLD := thisFolder
      watchFolderDetails := ""
      If (safeMode=0)
         RecentFilesManager(CurrentSLD)

      If (r=1)
      {
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
         RemoveTooltip()
      } Else SetTimer, RemoveTooltip, % -msgDisplayTime

      If (doOptionals=1)
      {
         If (maxFilesIndex>0 && r!=1)
            RandomPicture()
         Else
            dummyTimerDelayiedImageDisplay(25)
      }
   } Else
   {
      setWindowTitle(appTitle " v" appVersion, 1)
      If (!CurrentSLD || maxFilesIndex<2 || !maxFilesIndex)
         resetMainWin2Welcome()
      Else
         FadeMainWindow()

      showTOOLtip("ERROR: The folder seems to be inexistent`n" testThis "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addDynamicFolderSQLdb(whichFolder, renewList, whichTable) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM dynamicfolders;")

    folderu := StrReplace(whichFolder, "|")
    If !FolderExist(folderu)
       Return

    FileGetTime, fileMdate, % folderu, M
    SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES ('" SQLescapeStr(whichFolder) "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Return 0
    }
    Return 1
}

addStaticFolderSQLdb(whichFolder, fileMdate, renewList) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM staticfolders;")

    SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

RefreshImageFileAction() {
   isThumbMode := (thumbsDisplaying=1 && maxFilesIndex>1) ? 1 : 0
   ; imgPath := getIDimage(currentFileIndex)
   ; If (!useGdiBitmap() && !imgPath && isThumbMode!=1) || !imgPath

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (thumbsDisplaying!=1)
   {
      If throwErrorNoImageLoaded()
         Return

      If InStr(imgPath, "\temporary memory object\")
      {
         showTOOLtip("WARNING: This image is currently unsaved. Unable to refresh object.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If askAboutFileSave(" and the original file will be reloaded")
         Return

      currentImgModified := 0
      discardViewPortCaches()
      terminateIMGediting()
      If (AutoDownScaleIMGs=1)
         AutoDownScaleIMGs := 2

      r := IDshowImage(currentFileIndex, 3)
      If !r
         informUserFileMissing()
      Else If (toolTipGuiCreated!=1)
         showTOOLtip("Image file reloaded")

      thisIMGisDownScaled := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   } Else If (thumbsDisplaying=1)
      RefreshFilesList()
}

RefreshImageFile() {
   ; disposeCacheIMGs()
   r := IDshowImage(currentFileIndex, 3)
   If !r
      informUserFileMissing()
}

RefreshFilesList() {
  If !CurrentSLD
  {
     showTOOLtip("WARNING: No folder or files list index currently opened")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
  {
     retrieveFavesAsList()
     Return
  } Else If InStr(CurrentSLD, "\viewed-images-history-")
  {
     showTOOLtip("The current files list index is: `n" CurrentSLD)
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If RegExMatch(CurrentSLD, sldsPattern)
  {
     If askAboutFileSave(" and the files list will be reloaded")
        Return

     If askAboutSlidesListSave()
        Return

     thisIndex := currentFileIndex
     OpenSLD(CurrentSLD, 1)
     currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
     dummyTimerDelayiedImageDisplay(50)
  } Else If StrLen(CurrentSLD)>3
     RegenerateEntireList()
     ; coreOpenFolder(CurrentSLD)
}

OpenDialogFiles(dummy:=0) {
    Static lastInvoked := A_TickCount
    If (AnyWindowOpen || imageLoading=1) || (A_TickCount - lastInvoked<150)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*)"
    ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
    ; pattern .= "|QPV slideshows (*.sld;*.sldb)"

    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.ico;*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O1", "-", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3, "open-folder")

    lastInvoked := A_TickCount
    If !imgPath
       Return

    If (askAboutFileSave(" and another image will be loaded") && !InStr(chosenOption, "instance"))
       Return

   zPlitPath(imgPath, 0, OutFileName, SelectedDir)
   If !FolderExist(SelectedDir)
      SelectedDir := SubStr(SelectedDir, 1, InStr(SelectedDir, "\", 0, -1) - 1)

   ; ToolTip, % SelectedDir , , , 2
   If FolderExist(SelectedDir)
   {
      If InStr(chosenOption, "instance")
      {
         If RegExMatch(imgPath, RegExFilesPattern)
            OpenWithNewQPVinstance(0, imgPath, 2)
         Else
            OpenNewQPVinstance(SelectedDir)
         Return
      }

      newStaticFoldersListCache := []
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      lastInvoked := A_TickCount
      If RegExMatch(imgPath, sldsPattern)
      {
         OpenSLD(imgPath)
         Return
      }

      PopulateIndexFilesStatsInfos("kill")
      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }
 
      doNotRecursive := InStr(chosenOption, "perform") ? "" : "|"
      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath) && InStr(chosenOption, "selected"))
      {
         SLDtypeLoaded := 1
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(imgPath)
         currentFilesListModified := 0
      } Else 
      {
         coreOpenFolder(doNotRecursive SelectedDir, 0, 0, 1)
         currentFilesListModified := 0
         SlidesMusicSong := ""
         If (doNotRecursive && maxFilesIndex<1)
         {
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " SelectedDir "\ to open without recursive scanning. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
            If (msgResult="Yes")
               coreOpenFolder(SelectedDir, 0, 0, 1)
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         SlidesMusicSong := ""
         If FileRexists(imgPath)
         {
            currentFileIndex := detectFileID(imgPath)
            If (allowRecordHistory=1)
               IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

            IDshowImage(currentFileIndex)
         } Else If OutFileName!=""
         {
            FriendlyName := FileExist(imgPath) ? "malformed" : "inexistent"
            msgBoxWrapper(appTitle ": ERROR", "Error opening file: " OutFileName ". It seems to be " FriendlyName " .`n`nAnother file from the folder will be displayed now. Files indexed: " groupDigits(maxFilesIndex) ".", 0, 0, "error")
            RandomPicture()
         }
      } Else If (maxFilesIndex>0)
      {
         SlidesMusicSong := ""
         SLDtypeLoaded := 1
         RandomPicture()
      } ; Else resetMainWin2Welcome()
   }
   SetTimer, TriggerMenuBarUpdate, -90
   lastInvoked := A_TickCount
}

askAboutSlidesListSave() {
   Static lastInvoked := 1, prevAnswer
   If (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (currentFilesListModified=1 && RegExMatch(CurrentSLD, "i)(.\.sld)$") && FileExist(CurrentSLD) && maxFilesIndex>1 && SLDtypeLoaded=2)
   || (currentFilesListModified=1 && maxFilesIndex>1 && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(CurrentSLD, 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save files list", "The currently opened files list has been modified and the changes have not been saved. To continue with the action you chose, select the Discard button.`n`nWould like to save the currently opened files list?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         SetTimer, PanelSaveSlideShowu, -150
         r := 1
      } Else If (msgResult="Discard")
      {
         r := 0
      } Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

askAboutFileSave(msg:="", lvls:=1, dummy:=0, dontOpen:=0) {
   Static lastInvoked := 1, prevAnswer
   lvls := (minimizeMemUsage=1 || A_PtrSize=4) ? 1 : 2
   If (preventUndoLevels=1)
      lvls := -1

   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1) && (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(getIDimage(currentFileIndex), 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save image", "The currently modified image is about to be discarded" msg ".`n`nWould you like to save the current image?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         If (dontOpen!="yes")
            SetTimer, PanelSaveImg, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := (dontOpen="yes") ? 2 : 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

MenuOpenLastImg(forceOpenGiven:=0) {
   If (thumbsDisplaying=1)
   {
      MenuDummyToggleThumbsMode()
      Sleep, 25
   }

   If !FileRexists(forceOpenGiven)
   {
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      LastOpenedImg := Trimmer(LastOpenedImg)
   } Else LastOpenedImg := Trimmer(forceOpenGiven)

   If RegExMatch(LastOpenedImg, RegExFilesPattern) && FileRexists(LastOpenedImg)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      If (thumbsDisplaying=1)
         ToggleThumbsMode()

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      PopulateIndexFilesStatsInfos("kill")
      renewCurrentFilesList()
      setImageLoading()
      currentFileIndex := maxFilesIndex := 1
      resultedFilesList[1, 1] := LastOpenedImg
      IDshowImage(currentFileIndex)
      zPlitPath(LastOpenedImg, 0, OutFileName, OutDir)
      DynamicFoldersList := OutDir "`n"
      prevOpenFolderPath := OutDir
      CurrentSLD := "|" OutDir
      SLDtypeLoaded := 1
      SlidesMusicSong := ""
      currentFilesListModified := 0
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
      updateUIctrl()
      INIaction(1, "prevOpenFolderPath", "General")
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
      winPrefix := defineWinTitlePrefix()
  
      SetTimer, GDIupdaterResize, Off
      mustOpenStartFolder := OutDir
      ; currentFileIndex := detectFileID(LastOpenedImg)
      pVwinTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
      setWindowTitle(pVwinTitle, 1)
      SetTimer, RemoveTooltip, -250
      SetTimer, TriggerMenuBarUpdate, -150
      SetTimer, ResetImgLoadStatus, -50
      If (RegExMatch(OutFileName, "i)(\.gif)$") && totalFramesIndex>1 && animGIFsSupport=1)
      {
         animGIFplaying := 0
         allowNextSlide := 1
         prevAnimGIFwas := ""
         dummyTimerDelayiedImageDisplay(250)
      }
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   }
}

OpenArgFile(inputu) {
    setImageLoading()
    Global scriptStartTime := A_TickCount
    currentFileIndex := maxFilesIndex := 1
    interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)

    ; usrColorDepth := imgFxMode := 1
    ; vpIMGrotation := FlipImgH := FlipImgV := 0
    resultedFilesList[1, 1] := inputu
    IDshowImage(currentFileIndex)
    Global scriptStartTime := A_TickCount
    zPlitPath(inputu, 0, OutFileName, OutDir)
    DynamicFoldersList := OutDir "`n"
    zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
    winPrefix := defineWinTitlePrefix()

    SetTimer, GDIupdaterResize, Off
    mustOpenStartFolder := OutDir
    ; coreOpenFolder("|" OutDir, 0)
    Global scriptStartTime := A_TickCount
    ; currentFileIndex := detectFileID(inputu)
    winTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
    setWindowTitle(winTitle, 1)
    SetTimer, RemoveTooltip, -250
    SetTimer, ResetImgLoadStatus, -50
    CurrentSLD := "|" OutDir
    prevOpenFolderPath := OutDir
    INIaction(1, "prevOpenFolderPath", "General")
    If (allowRecordHistory=1 && FileRexists(inputu))
       IniWrite, % inputu, % mainSettingsFile, General, LastOpenedImg

    updateUIctrl()
    SLDtypeLoaded := 1
    If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
       CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)

    SetTimer, TriggerMenuBarUpdate, -90
    ; Else resetMainWin2Welcome()
    ; IDshowImage(currentFileIndex)
}

addNewFile2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ")"
   pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   pattern .= "|QPV files lists / slideshows (*.sld;*.sldb)"

   imgsListu := openFileDialogWrapper("M", "AllowMultiSelect FileMustExist", prevOpenFolderPath, "Add image file(s) to the list...", pattern, null, 1)
   If !imgsListu
      Return "cancel"

   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 25
   If askAboutFileSave(" and the selected file(s) will be added to the list")
      Return

   showTOOLtip("Processing files list, please wait")
   setImageLoading()
   If InStr(imgsListu, "`n")
      firstFile := Trimmer(SubStr(imgsListu, 1, InStr(imgsListu, "`n")))
   Else
      firstFile := Trimmer(imgsListu)

   zPlitPath(firstFile, 0, OutFileName, SelectedDir)
   countFiles := ST_Count(imgsListu, "`n") + 1
   ; msgbox, % firstFile "a`n" countFiles "`n" imgsListu
   If StrLen(SelectedDir)>3
   {
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
   }

   If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
   {
      importSLDBintoPlainText(firstFile)
   } Else If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
   {
      importSLDBintoSLDB(firstFile)
   } Else If RegExMatch(firstFile, "i)(.\.sld)$")
   {
      importSLDplainText(firstFile)
   } Else If StrLen(imgsListu)>3
   {
      showTOOLtip("Processing files list, please wait")
      setImageLoading()
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir)
      GenerateRandyList()
      currentFileIndex := maxFilesIndex - 1
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }

   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDplainText(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sld)$") || !RegExMatch(CurrentSLD, "i)(.\.sld)$"))
      Return

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened files list`nNo one likes duplicates :-)")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   mustOpenStartFolder := ""
   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   showTOOLtip("Importing plain-text files list, please wait`n" OutFileName "`n" SelectedDir "\")
   If (SLDtypeLoaded=2)
      DynamicFoldersList := getDynamicFoldersList()

   FileReadLine, firstLine, % whichFile, 1
   FileRead, tehFileVar, % whichFile
   mustRemQuotes := InStr(firstLine, "[General]") ? 0 : 1
   If !mustRemQuotes
   {
      IniRead, testDynaFolderz, % whichFile, DynamicFolderz, DF1, @
      If StrLen(testDynaFolderz)>4
         DynamicFoldersList .= "`n" coreLoadDynaFolders(whichFile)
   } Else
   {
      tehFileVar := StrReplace(tehFileVar, """-")
      tehFileVar := StrReplace(tehFileVar, """")
   }

   Sort, DynamicFoldersList, UD`n
   DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
   If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
      recreateDynaFoldersSQLdbList(DynamicFoldersList)

   countFiles := ST_Count(tehFileVar, "`n") + 1
   coreAddNewFiles(tehFileVar, countFiles, SelectedDir)

   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , 900, 100
   currentFilesListModified := 1
   GenerateRandyList()
   RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDBintoSLDB(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sldb)$") || SLDtypeLoaded!=3)
      Return

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened database")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startZeit := A_TickCount
   mustOpenStartFolder := ""
   zPlitPath(CurrentSLD, 0, OutFileName, SelectedDir)
   showTOOLtip("Preparing main database content, please wait`n" OutFileName "`n" SelectedDir "\")
   setImageLoading()
   SQLa := "SELECT imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, innerpixelz, outerpixelz, entireHush, pixelzHash, imgmedian FROM images"
   If !activeSQLdb.GetTable(SQLa, mainRecordSet)
   {
      ResetImgLoadStatus()
      throwSQLqueryDBerror(A_ThisFunc)
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := mainRecordSet.RowCount
   totalArrayu := []
   mainArrayu := []
   uniqueArrayu := new hashtable()
   doStartLongOpDance()
   allIndex := 0
   Loop, % mainRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Preparing main database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := mainRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           mainArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := "m"
           uniqueArrayu[Rowu[2] "\" Rowu[1]] := 1
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   otherSQLdb := new SQLiteDB
   If !otherSQLdb.OpenDB(whichFile)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      throwSQLqueryDBerror(A_ThisFunc)
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showTOOLtip("Retrieving imported database content, please wait`n" OutFileName "`n" SelectedDir "\")
   If !otherSQLdb.GetTable(SQLa, otherRecordSet)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      mainRecordSet.Free()
      throwSQLqueryDBerror(A_ThisFunc)
      otherSQLdb.CloseDB()
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := otherRecordSet.RowCount
   otherArrayu := []
   Loop, % otherRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Retrieving imported database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := otherRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           otherArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := uniqueArrayu.hasKey(Rowu[2] "\" Rowu[1]) ? "b" : "o"
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      totalArrayu := ""
      mainArrayu := ""
      uniqueArrayu := ""
      otherArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Merging databases contents, please wait")
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM images;")

   sqlDBrowID := 1
   baseSQLstr := "INSERT INTO images (imgidu, imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, innerpixelz, outerpixelz, entireHush, pixelzHash, imgmedian) VALUES ("
   k1 := k2 := k3 := k4 := k5 := k6 := k7 := k8 := k9 := k10 := k11 := k12 := k13 := k14 := k15 := k16 := k17 := k18 := k19 := k20 := k21 := k22 := ""

   newIndex := 0
   newArrayu := []
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := allIndex ; totalArrayu.Count()
   ; For Key, Value in totalArrayu
   Loop, % allIndex
   {
      key := A_Index
      value := totalArrayu[key]
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>1500)
      {
         etaTime := ETAinfos(A_Index, countFiles, startOperation)
         If errorsOccured
            moreSpam := "`n" groupDigits(errorsOccured) " errors occured until now"

         showTOOLtip("Merging databases contents, please wait" moreSpam etaTime, 0, 0, A_Index/countFiles)
         prevMSGdisplay := A_TickCount
      }

      If (value="m")
      {
         thisIndex := mainArrayu[key]
         Rowu := mainRecordSet.Rows[thisIndex]
      } Else If (value="o")
      {
         thisIndex := otherArrayu[key]
         Rowu := otherRecordSet.Rows[thisIndex]
      } Else If (value="b")
      {
         thisIndex := otherArrayu[key]
         oRowu := otherRecordSet.Rows[thisIndex]
         thisIndex := mainArrayu[key]
         mRowu := mainRecordSet.Rows[thisIndex]
         Loop, 22
            k%A_Index% := oRowu[A_Index] ? oRowu[A_Index] : mRowu[A_Index]
      }

      If (value="m" || value="o")
      {
         Loop, 22
            k%A_Index% := Rowu[A_Index]
      }

      activeSQLdb.EscapeStr(k1)
      activeSQLdb.EscapeStr(k2)
      moreSQL := baseSQLstr "'" sqlDBrowID "', " k1 ", " k2 ", '" k3 "', '" k4 "', '" k5 "', '" k6 "', '" k7 "', '" k8 "', '" k9 "', '" k10 "', '" k11 "', '" k12 "', '" k13 "', '" k14 "', '" k15 "', '" k16 "', '" k17 "', '" k18 "', '" k19 "', '" k20 "', '" k21 "', '" k22 "');"
      If !activeSQLdb.Exec(moreSQL)
      {
         errorsOccured++
      } Else
      {
         newIndex++
         sqlDBrowID++
      }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      activeSQLdb.Exec("ROLLBACK TRANSACTION;")
      totalArrayu := ""
      mainArrayu := ""
      otherArrayu := ""
      newArrayu := ""
      uniqueArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Finalising database import operations, please wait")
   Static cols := "fsize,fmodified,fcreated,imgwidth,imgheight,imgframes,imgdpi,imgpixfmt,imgavg,imghpeak,imghlow,imghmode,imghrms,imghminu,imghrange,innerpixelz,outerpixelz,entireHush,pixelzHash,imgmedian"
   Loop, Parse, cols, CSV
   {
      If !activeSQLdb.Exec("UPDATE images SET " A_LoopField " = NULL WHERE " A_LoopField "='';")
         errorsOccured++
   }

   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)

   SQL := "SELECT imgfolder FROM dynamicfolders;"
   otherSQLdb.GetTable(SQL, gRecordSet)
   Loop, % gRecordSet.RowCount
   {
       Rowu := gRecordSet.Rows[A_Index]
       If Rowu[1]
          DynamicFoldersList .= Rowu[1] "`n"
   }

   maxFilesIndex := newIndex
   resultedFilesList := []
   ; resultedFilesList := newArrayu.Clone()
   newArrayu := []
   totalArrayu := []
   mainArrayu := []
   otherArrayu := []
   uniqueArrayu := []
   gRecordSet.Free()
   otherRecordSet.Free()
   mainRecordSet.Free()
   otherSQLdb.CloseDB()
   Sort, DynamicFoldersList, UD`n
   newListu := cleanDynamicFoldersList(DynamicFoldersList)
   recreateDynaFoldersSQLdbList(newListu)
   If errorsOccured
      someErrors := "`n" groupDigits(errorsOccured) " errors occured during merger."

   zeitOperation := A_TickCount - startZeit
   etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
   OpenSLD(CurrentSLD, 1)
   showDelayedTooltip("Databases merger has finished in " etaTime someErrors "`nTotal files: " groupDigits(maxFilesIndex))
   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , % errorsOccured ? 300 : 900, 100
   ; GenerateRandyList()
   ; RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

importSLDBintoPlainText(whichFile) {
   If !RegExMatch(whichFile, "i)(.\.sldb)$")
      Return

    If CurrentSLD
       dropFilesSelection(1)

    mustOpenStartFolder := ""
    zPlitPath(whichFile, 0, OutFileName, SelectedDir)
    showTOOLtip("Importing files list from database`n" OutFileName "`n" SelectedDir "\")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    OpenSLDBdataBase(whichFile, 1)
    currentFilesListModified := 1
    Sort, DynamicFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    GenerateRandyList()
    RandomPicture()
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

coreAddNewFiles(imgsListu, countFiles, SelectedDir, selectNewOnes:=0) {
    If CurrentSLD
       dropFilesSelection(1)

    showTOOLtip("Adding " groupDigits(countFiles) " files into the current files list")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    doStartLongOpDance()
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    isFaves := InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 1 : 0
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    Loop, Parse, imgsListu, `n`r
    {
       line := Trimmer(A_LoopField)
       If StrLen(line)<3
          Continue

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, countFiles, startOperation)
          showTOOLtip("Adding image files to the current list" etaTime, 0, 0, A_Index/countFiles)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (SLDtypeLoaded=3 && maxFilesIndex>0)
          {
             zPlitPath(line, 1, OutFileName, OutDir)
             erru := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1)
          }

          If !erru
          {
             added++
             maxFilesIndex++
             If (selectNewOnes=1)
                markedSelectFile++

             resultedFilesList[maxFilesIndex] := [line, selectNewOnes]
             If (isFaves=1)
                resultedFilesList[maxFilesIndex, 5] := 1

             If (SLDtypeLoaded=3 && maxFilesIndex>0)
                resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
          }
       }
    }

    If (SLDtypeLoaded=3)
    {
       If !activeSQLdb.Exec("COMMIT TRANSACTION;")
          throwSQLqueryDBerror(A_ThisFunc)
       getMaxRowIDsqlDB()
    }

    If added
       currentFilesListModified := 1

    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    mustOpenStartFolder := ""
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

wrapperAddNewFolderToList(folderu, forceRemAll, isInLoop:=0) {
    showTOOLtip("Preparing files list, please wait`n" folderu "\")
    z := coreAddNewFolder(folderu, forceRemAll, 0, 0, 0)
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2 && isInLoop!=1)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1 || InStr(folderu, "|"))
          good2go := "null"
    } Else good2go := "null"

    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
    {
       good2go := 0
       SQLdeleteEntriesMarked()
       isPipe := InStr(folderu, "|") ? 1 : 0
       folderuz := StrReplace(folderu, "|")
       SQLdbRetrieveGivenFolder(folderuz, !isPipe)
       getMaxRowIDsqlDB()
    }

    If (isInLoop=1)
       Return z
    Else
       GenerateRandyList()

    Return good2go
}

addNewFolder2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectImg := openFoldersDialogWrapper("S2", prevOpenFolderPath, "Add new folder(s) to the list")
   If !Trim(SelectImg)
      Return "cancel"

   SelectedDir := Trimmer(SelectImg)
   If SelectedDir
   {
      If askAboutFileSave(" and new files will be added from the selected folder")
         Return

      If InStr(DynamicFoldersList, SelectedDir "`n")
      {
         msgResult := msgBoxWrapper(appTitle, "The folder you want to add, seems to be already indexed. Are you sure you want to add it again? This action will likely lead to duplicate entries in the list.`n`n" SelectedDir "\", 4, 0, "question")
         If (msgResult!="yes")
            Return "cancel"
      }

      msgResult := msgBoxWrapper(appTitle, "Do you want to scan for image files recursively, through all its subfolders?`n`n" SelectedDir "\", 3, 0, "question")
      If (msgResult="no")
         isNotRecursive := "|"
      Else If (msgResult="cancel")
         Return "cancel"

      BtnCloseWindow()
      Sleep, 1
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      newListA := compareFoldersList(DynamicFoldersList, "`n" isNotRecursive SelectedDir "`n")
      newListB := cleanDynamicFoldersList(newListA.newListu)
      newListC := compareFoldersList(DynamicFoldersList, newListB)
      toAdd := newListC.newEntries
      If StrLen(toAdd)<3
      {
         msgBoxWrapper(appTitle ": WARNING", "The folder seems to be already in the list or it is contained in another folder already indexed.`n`n" SelectedDir "\", 0, 0, "exclamation")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return "cancel"
      }

      mustOpenStartFolder := ""
      modus := isNotRecursive ? 1 : 0
      z := wrapperAddNewFolderToList(isNotRecursive SelectedDir, !modus)
      If (mustGenerateStaticFolders=0 && z!="null" && RegExMatch(CurrentSLD, sldsPattern))
         updateCachedStaticFolders(SelectedDir, modus)
      Else mustGenerateStaticFolders := 1

      listu := DynamicFoldersList "`n" isNotRecursive SelectedDir "`n"
      Sort, listu, UD`n
      DynamicFoldersList := cleanDynamicFoldersList(listu)
      If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
         recreateDynaFoldersSQLdbList(DynamicFoldersList)

      If !CurrentSLD
      {
         SLDtypeLoaded := 2
         CurrentSLD := SelectedDir "\newFile.SLD"
         RandomPicture()
      }
   }
}

coreAddNewFolder(SelectedDir, forceRemAll, noRandom:=0, forReal:=1, factCheck:=1) {
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    ; markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    thisFolder := (forceRemAll=1) ? StrReplace(SelectedDir, "|") : SelectedDir
    If (forReal=0 && SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    remFilesFromList(thisFolder, 1, forReal)
    z := GetFilesList(SelectedDir "\*", 0, 1, factCheck)
    If (factCheck=1)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
    }

    CurrentSLD := backCurrentSLD
    If (noRandom=1)
    {
       currentFileIndex := maxFilesIndex - 1
       dummyTimerDelayiedImageDisplay(150)
    } Else RandomPicture()
    Return z
}

detectFileID(imgPath) {
    Loop, % maxFilesIndex + 1
    {
       If (resultedFilesList[A_Index, 1]=imgPath)
       {
          good := A_Index
          Break
       }
    }
    If !good
       good := 1

    Return good
}

GuiDroppedFiles(imgsListu, foldersListu, sldFile, countFiles, isCtrlDown) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<900)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   lastInvoked := A_TickCount
   If (imgsListu && isCtrlDown=1)
   {
      OpenWithNewQPVinstance(0, imgsListu, countFiles)
      Return
   }
   ; ToolTip, % "l=" sldFile , , , 2
   If sldFile
   {
      zPlitPath(sldFile, 0, FileName, OutDir)
      If (CurrentSLD && maxFilesIndex>1)
         msgResult := msgBoxWrapper(appTitle ": Import file", "Would you like to import the dropped files list into the current one?`n`nFile to open or import:`n" FileName "`n" OutDir "\", "&Import|&Open files list|&Cancel", 1, "question")
      Else msgResult := "open"

      If (msgResult="import")
      {
         If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
            importSLDBintoPlainText(sldFile)
         Else If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
            importSLDBintoSLDB(sldFile)
         Else If RegExMatch(sldFile, "i)(.\.sld)$")
            importSLDplainText(sldFile)

         TriggerMenuBarUpdate()
      } Else If InStr(msgResult, "open")
         OpenSLD(sldFile)
      lastInvoked := A_TickCount
      Return
   }

   If (CurrentSLD && maxFilesIndex>1 && StrLen(foldersListu)>3)
      msgResult := msgBoxWrapper(appTitle ": Import files", "Would you like to import the dropped folder(s) to the current files list?", "&Import|&New list|&Cancel", 1, "question")

   If (msgResult="cancel")
   {
      lastInvoked := A_TickCount
      Return
   } Else If InStr(msgResult, "new")
   {
      SlidesMusicSong := ""
      mainFoldersListu := CurrentSLD := DynamicFoldersList := ""
      renewCurrentFilesList()
      AnyWindowOpen := 1000
      resetMainWin2Welcome()
      AnyWindowOpen := ""
   }
   watchFolderDetails := ""
   updateUIctrl()
   If StrLen(foldersListu)>3
   {
      mustOpenStartFolder := ""
      mainFoldersListu := getDynamicFoldersList()
      doStartLongOpDance()
      dropFilesSelection(1)
      showTOOLtip("Opening folders, please wait")
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      newListA := compareFoldersList(mainFoldersListu, foldersListu)
      newListB := cleanDynamicFoldersList(newListA.newListu)
      newListC := compareFoldersList(mainFoldersListu, newListB)
      toAdd := newListC.newEntries
      Loop, Parse, toAdd,`n
      {
          linea := Trimmer(A_LoopField)
          If StrLen(linea)<4
             Continue

          changeMcursor()
          r := wrapperAddNewFolderToList(linea, 1, 1)
          ; r := GetFilesList(linea "\*")
          If (r="abandoned")
             Break

          stuffAdded := 1
          lastOne := linea
      }

      DynamicFoldersList := cleanDynamicFoldersList(newListC.newListu)
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
         recreateDynaFoldersSQLdbList(DynamicFoldersList)

      If (stuffAdded=1)
      {
         newStaticFoldersListCache := []
         mustGenerateStaticFolders := 1
         GenerateRandyList()
      }

      If !CurrentSLD
      {
         If FolderExist(StrReplace(Trimmer(DynamicFoldersList), "|"))
         {
            SLDtypeLoaded := 1
            CurrentSLD := Trimmer(DynamicFoldersList)
         } Else
         {
            SLDtypeLoaded := 2
            CurrentSLD := lastOne "\newFile.SLD"
         }
      }

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      TriggerMenuBarUpdate()
      RandomPicture()
   } Else If (imgsListu && countFiles=1 && !CurrentSLD)
   {
      imgPath := Trimmer(imgsListu)
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If (OutDir="")
      {
         lastInvoked := A_TickCount
         Return
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath))
      {
         SLDtypeLoaded := 1
         lastInvoked := A_TickCount
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

         MenuOpenLastImg(imgPath)
         lastInvoked := A_TickCount
         Return
      }

      showTOOLtip("Opening file`n" imgPath)
      newStaticFoldersListCache := []
      dropFilesSelection(1)
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      If !InStr(msgResult, "new")
      {
         prevMaxFilesIndex := maxFilesIndex
         prevFoldersDyna := DynamicFoldersList
         bckpResultedFilesList := resultedFilesList.Clone()
      }

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      coreOpenFolder("|" OutDir, 0)
      If prevMaxFilesIndex
      {
         DynamicFoldersList .= prevFoldersDyna
         Loop, % prevMaxFilesIndex
         {
             r := bckpResultedFilesList[A_Index, 1]
             If (r && !InStr(r, "||"))
             {
                maxFilesIndex++
                resultedFilesList[maxFilesIndex, 1] := r
             }
         }
         bckpResultedFilesList := []
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         currentFileIndex := detectFileID(imgPath)
         TriggerMenuBarUpdate()
         IDshowImage(currentFileIndex)
      } Else resetMainWin2Welcome()
   } Else If StrLen(imgsListu)>3
   {
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, prevOpenFolderPath)
      mustGenerateStaticFolders := 1
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      SetTimer, ResetImgLoadStatus, -50
      If (A_TickCount - lastInvoked>2000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      currentFileIndex := maxFilesIndex
      TriggerMenuBarUpdate()
      dummyTimerDelayiedImageDisplay(50)
   }

   lastInvoked := A_TickCount
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyPrevShowToolTip() {
   showTOOLtip("nully")
}

dummyDelayShowToolTip() {
   showTOOLtip(delayiedHUDmsg, 0, 0, delayiedHUDperc)
}

showDelayedTooltip(msg, perc:=0, delayu:=450, expire:=0) {
    delayiedHUDmsg := msg
    delayiedHUDperc := perc
    SetTimer, dummyDelayShowToolTip, % -delayu
    expire := (expire<100) ? msgDisplayTime + delayu*2 : expire + delayu
    SetTimer, RemoveTooltip, % -expire
}

showTOOLtip(msg, funcu:=0, typeFuncu:=0, perc:=0) {
   Critical, on
   Static prevMsg
   If (msg="nully" && prevMsg)
      msg := prevMsg

   prevMsg := msg
   CreateOSDinfoLine(msg, 0, 0, perc, funcu, typeFuncu)
   If (AnyWindowOpen>0 && WinActive("A")=hSetWinGui && panelWinCollapsed=0)
   {
      GetPhysicalCursorPos(mX, mY)
      ToolTip, % msg, % mX + 25, % mY + 25
   } Else If (AnyWindowOpen>0)
      ToolTip
}

RemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   CreateOSDinfoLine(1, 1)
}

PanelAssociateQPV() {
   fakeWinCreator(52, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate " appTitle, "Please choose what to associate " appTitle " with.", "&Proceed|C&ancel", 1, "settings", "Add file explorer context menu entry for folders: Open in QPV", 0, "Associate with common image formats`f`fAssociate with all supported image formats`fAssociate with QPV slideshow / files list formats`fRemove QPV files associations`fDo not change files associations", 0, 0)
   If InStr(msgResult.btn, "Proceed")
   {
      If !A_IsCompiled
      {
         msgBoxWrapper(appTitle ": ERROR", "This feature is only available when this application is compiled.", 0, 0, "error")
         Return
      }

      associateWithImages(msgResult.list)
      If (msgResult.check=1)
         associateWithExplorer(1)
      Else
         associateWithExplorer(3)
   }
}

associateWithExplorer(modus) {
   Static q := Chr(34)
   zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
   Cmd := q fullPath2exe q A_Space q "%1" q
   Cmd := StrReplace(Cmd, "\", "\\")
   Cmd := StrReplace(Cmd, """", "\""")

   regFile := "Windows Registry Editor Version 5.00`n`n"
   If (modus=1)
   {
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n""Icon""=" q StrReplace(fullPath2exe, "\", "\\") q "`n"
      regFile .= "@=""Open in QPV""`n"
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer\Command]`n"
      regFile .= "@=""\" q StrReplace(fullPath2exe, "\", "\\") "\"" fd=|\""%1\" q q "`n"
   } Else If (modus=3) ; remove explorer context menu
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n"
   } Else If (modus=4) ; remove file associations
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n"
      regFile .= "[-HKEY_CLASSES_ROOT\QPVslideshow]`n"
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\QPVslideshow]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= "[-HKEY_CLASSES_ROOT\QPVimage." A_LoopField "]`n"
         regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\QPVimage." A_LoopField "]`n"
      }
   } Else
   {
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell]`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open\command]`n@=" q Cmd q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\SupportedTypes]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= q "." A_LoopField q "=" q q "`n"
      }
   }

   If !FolderExist(mainCompiledPath "\regFiles")
   {
      FileCreateDir, %mainCompiledPath%\regFiles
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   Sleep, 1
   FileAppend, % regFile, %mainCompiledPath%\regFiles\RegExplGeneral.reg, UTF-16
   If ErrorLevel
      errorOccured := 1

   runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegExplGeneral.reg" q "`n"
   FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
   If ErrorLevel
      errorOccured := 1

   ;  msgbox, % "loool=" A_ThisFunc "==" modus
   If !errorOccured
      Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
   Sleep, 1
   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   If (errorOccured && modus!=2)
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while associating " appTitle " with Explorer context menu options.", 0, 0, "error")
}

associateSLDsNow() {
    z := FileAssociate("QPVslideshow",".sld", fullPath2exe)
    If z
       FileAssociate("QPVslideshow",".sldb", fullPath2exe)
    Else
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when associating " appTitle " with slideshow / files list formats.", 0, 0, "error")
}

associateWithImages(modus) {
  Static FileFormatsCommon := "|png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd|"
       , allFormats := 0 ; "dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif"

  If !allFormats
     allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")

  If (modus=3)
  {
     associateSLDsNow()
     Return
  } Else If (modus=4)
  {
     associateWithExplorer(4)
     Return
  } Else Return

  Loop, Parse, FileFormatsCommon, |
  {
      If !A_LoopField
         Continue

      z := FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
      If !z
      {
         errorOccured := 1
         Break
      }

  }

  Sleep, 25
  If !errorOccured
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
  Sleep, 5
  FileDelete, %mainCompiledPath%\regFiles\*.reg
  FileDelete, %mainCompiledPath%\regFiles\*.bat

  ; msgResult := msgBoxWrapper(appTitle, appTitle " was now associated with common image file formats. Would you like to associate it with all the 85 supported file formats?", 4, 0, "question")
  ; If (msgResult="yes")
  If (modus=2 && !errorOccured)
  {
     Loop, Parse, allFormats, |
     {
         If (!A_LoopField || InStr(FileFormatsCommon, "|" A_LoopField "|"))
            Continue
 
         z := FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
         If !z
         {
            errorOccured := 1
            Break
         }
     }
 
     Sleep, 25
     If !errorOccured
        Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 5
     FileDelete, %mainCompiledPath%\regFiles\*.reg
     FileDelete, %mainCompiledPath%\regFiles\*.bat
  }

  If errorOccured
  {
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured during associating " appTitle " with image file formats.", 0, 0, "error")
     Return
  } Else associateWithExplorer(2)

  addJournalEntry(appTitle " has been associated with image file formats")
}

closeDocuments() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (animGIFplaying=1)
   {
      DestroyGIFuWin()
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   PopulateIndexFilesStatsInfos("kill")
   SLDtypeLoaded := 1
   resetMainWin2Welcome()
   addJournalEntry("All images/documents closed.")
   ResetImgLoadStatus()
}

restartAppu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will restart")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("restart")
      Return

   ; writeMainSettings()
   If A_IsCompiled
      Try Run, "%fullPath2exe%"
   Else
      Try Run, %unCompiledExePath%

   TrueCleanup(0)
   Sleep, 5
   ExitApp
}

exitAppu(dummy:=0) {
   If (A_IsSuspended && MsgBox2hwnd && InStr(dummy, "external"))
   {
      interfaceThread.ahkPostFunction("dummyTimerExit")
      terminateIMGediting()
      TrueCleanup()
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will exit")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("exit")
      Return

   terminateIMGediting()
   TrueCleanup()
}

askAboutFilesSelect(act) {
   If (markedSelectFile>50 && maxFilesIndex>100)
   {
      msgResult := msgBoxWrapper(appTitle ": " act " confirmation", "The current opened files list has " groupDigits(markedSelectFile) " files selected. Are you sure you want to " act " ?", "&Yes|&No", 0, "question")
      If (msgResult!="Yes")
         Return 1
   }
}

InitGuiContextForcedMenu() {
   InitGuiContextMenu("forced")
}

InitSecondMenu() {
   Static lastInvoked := 1
   Critical, off

   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   SetTimer, BuildSecondMenu, -50
}

InitGuiContextMenu(keyu:=0) {
   Static lastInvoked := 1
   Critical, off

   If (drawingShapeNow=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      GetMouseCoord2wind(PVhwnd, mX, mY)
      addNewCustomShapePoints(mX, mY, mainWidth, mainHeight, "rClick", 0)
      Return
   }

   If (A_TickCount - lastPointerUseZeit<600)
      Return
   If (keyu!="forced")
   {
      If (A_TickCount - lastInvoked<250) && (keyu="extern") || (A_TickCount - zeitSillyPrevent<250)
         Return

      Au := WinActive("A")
      If !InStr(keyu, "appsk")
         MouseGetPos, , , Bu
      Else
         Bu := Au

      okay := (Au=PVhwnd || Au=hGDIwin || Au=hGDIthumbsWin) && (Bu=PVhwnd || Bu=hGDIwin || Bu=hGDIthumbsWin) ? 1 : 0
      If (okay!=1)
         Return 1

      If (slideShowRunning=1)
         ToggleSlideShowu()

      DestroyGIFuWin()
      If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1)
      {
         GetMouseCoord2wind(PVhwnd, mX, mY)
         Gdip_SetPenWidth(pPen1d, SelDotsSize)
         hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
         If (hitB=1)
         {
            lastInvoked := A_TickCount
            invokeSelectionAreaMenu("DoubleClick")
            Return
         }
      }

      delayu := 1
      If (thumbsDisplaying=1 && maxFilesIndex>1 && !InStr(keyu, "appskey"))
      {
         delayu := 10
         MouseGetPos, ox, oy, OutputVarWin
         JEE_ScreenToClient(PVhwnd, ox, oy, nx, ny)
         r := WinClickAction("rclick", "nona", OutputVarWin, nx, ny, ox, oy)
         dummyTimerDelayiedImageDisplay(50)
      }
   } Else Sleep, 350

   If (r="scrollbar")
      SetTimer, invokeNavigationMenu, -10
   Else If (r="StatusBar")
      SetTimer, MenuPanelFoldersTree, -10
   Else If (InStr(keyu, "+") || InStr(keyu, "^"))
      SetTimer, BuildSecondMenu, % -10 - delayu
   Else
      SetTimer, BuildMainMenu, % -10 - delayu

   lastInvoked := A_TickCount
   ; WinActivate, ahk_id %PVhwnd%
}

Win_SetMenu(Hwnd, hMenu=0) {
   hPrevMenu := DllCall("GetMenu", "uint", hwnd, "Uint")
   DllCall("SetMenu", "uint", hwnd, "uint", hMenu)
   return hPrevMenu
}

PathCompact(givenPath, CharMax) {
    If (StrLen(givenPath)>CharMax+3)
    {
       partB := SubStr(givenPath, InStr(givenPath, "\", 0, 0))
       If (StrLen(partB)>CharMax)
          partB := SubStr(givenPath, 1, 3) "[...]" SubStr(givenPath, -CharMax + 3)
       Else
          partA := SubStr(givenPath, 1, max(CharMax - StrLen(partB), 3)) "..."
       Return partA partB
    } Else Return givenPath
}

createMenuSelectionRotationAspectRatio() {
   ; defiSelAR := defineSelectionAspectRatios()
   kMenu("PVselRatio", "Add", "&Increase rotation by 2°`t0", "MenuSelIncRotation")
   kMenu("PVselRatio", "Add", "&Decrease rotation by 2°`t9", "MenuSelDecRotation")
   kMenu("PVselRatio", "Add", "R&otate by 45°`tShift+R", "MenuSelRotation")
   kMenu("PVselRatio", "Add", "R&eset rotation`tShift+\", "resetSelectionRotation")
   kMenu("PVselRatio", "Add", "&Keep aspect ratio on rotation", "ToggleSelKeepRatioRotation")
   kMenu("PVselRatio", "Add", "Set to s&quare ratio (1:1)`tR", "makeSquareSelection")
   If (lockSelectionAspectRatio>1)
      kMenu("PVselRatio", "Disable", "Set to s&quare ratio (1:1)`tR")
   Menu, PVselRatio, Add
   kMenu("PVselRatio", "Add", "Cycle loc&k aspect ratios`tShift+A", "toggleImgSelectionAspectRatio")
   kMenu("PVselRatio", "Add", "&Unlocked", "MenuSetLockSelRatioUnlocked")
   kMenu("PVselRatio", "Add", "&Square [1:1]", "MenuSetLockSelRatioSquare")
   kMenu("PVselRatio", "Add", "&SDTV [4:3]", "MenuSetLockSelRatioSDTV")
   kMenu("PVselRatio", "Add", "&35mm film [3:2]", "MenuSetLockSelRatio35mmFilm")
   kMenu("PVselRatio", "Add", "&HDTV [16:9]", "MenuSetLockSelRatioHDTV")
   kMenu("PVselRatio", "Add", "&Wide screens [16:10]", "MenuSetLockSelRatioWide")
   kMenu("PVselRatio", "Add", "&Custom ratio [" userCustomImgSelRatio "]", "MenuSetLockSelRatioCustom")
   If (lockSelectionAspectRatio<=1)
      kMenu("PVselRatio", "Check", "&Unlocked")
   Else If (lockSelectionAspectRatio=2)
      kMenu("PVselRatio", "Check", "&Square [1:1]")
   Else If (lockSelectionAspectRatio=3)
      kMenu("PVselRatio", "Check", "&SDTV [4:3]")
   Else If (lockSelectionAspectRatio=4)
      kMenu("PVselRatio", "Check", "&35mm film [3:2]")
   Else If (lockSelectionAspectRatio=5)
      kMenu("PVselRatio", "Check", "&HDTV [16:9]")
   Else If (lockSelectionAspectRatio=6)
      kMenu("PVselRatio", "Check", "&Wide screens [16:10]")
   Else If (lockSelectionAspectRatio=7)
      kMenu("PVselRatio", "Check", "&Custom ratio [" lockSelectionAspectRatio "]")

   If (rotateSelBoundsKeepRatio=1)
      kMenu("PVselRatio", "Check", "&Keep aspect ratio on rotation")
}

createMenuSelectShapeTension() {
   kMenu("PVshapeTension", "Add", "&Polygonal", "MenuSetShapeTension", "shape tension")
   kMenu("PVshapeTension", "Add", "&Smooth corners", "MenuSetShapeTension", "shape tension")
   kMenu("PVshapeTension", "Add", "&Curve", "MenuSetShapeTension", "shape tension")
   kMenu("PVshapeTension", "Add", "&Rounded curve", "MenuSetShapeTension", "shape tension")
   If (FillAreaCurveTension=1)
      kMenu("PVshapeTension", "Check", "&Polygonal")
   Else If (FillAreaCurveTension=2)
      kMenu("PVshapeTension", "Check", "&Smooth corners")
   Else If (FillAreaCurveTension=3)
      kMenu("PVshapeTension", "Check", "&Curve")
   Else If (FillAreaCurveTension=4)
      kMenu("PVshapeTension", "Check", "&Rounded curve")
}

createMenuSelectSizeShapes(dummy:=0) {
   If (dummy!="simple")
   {
      kMenu("PVselSize", "Add", "C&ycle selection types`tShift+E", "toggleEllipseSelection")
      kMenu("PVselSize", "Add", "&Rectangular", "MenuSetSelectionShapeRect", "shape type")
      kMenu("PVselSize", "Add", "&Ellipse / oval", "MenuSetSelectionShapeEllipse", "shape type")
      kMenu("PVselSize", "Add", "&Custom shape", "MenuSetSelectionShapeFreeform", "freeform type spline polygonal")

      If (EllipseSelectMode=1)
         kMenu("PVselSize", "Check", "&Ellipse / oval")
      Else If (EllipseSelectMode=2)
         kMenu("PVselSize", "Check", "&Custom shape")
      Else
         kMenu("PVselSize", "Check", "&Rectangular")
   }

   kMenu("PVselSize", "Add", "Predefined custom shapes", "dummy")
   kMenu("PVselSize", "Disable", "Predefined custom shapes")
   kMenu("PVselSize", "Add", "R&ight triangle", "MenuSetSelectShapeRightTriangle")
   kMenu("PVselSize", "Add", "&Triangle", "MenuSetSelectShapeTriangle")
   kMenu("PVselSize", "Add", "R&hombus", "MenuSetSelectShapeRhombus")
   kMenu("PVselSize", "Add", "&Box callout", "MenuSetSelectShapeBoxCallout")
   kMenu("PVselSize", "Add", "Round c&allout", "MenuSetSelectShapeRoundCallout")
   kMenu("PVselSize", "Add", "&5 star", "MenuSetSelectShape5star")
   kMenu("PVselSize", "Add", "&4 star", "MenuSetSelectShape4star")
   kMenu("PVselSize", "Add", "&Heart", "MenuSetSelectShapeHeart")
   kMenu("PVselSize", "Add", "&User defined", "MenuSetSelectShapeUser")
   Menu, PVselSize, Add, 
   infoKbd := (EllipseSelectMode=0) ? "`tShift+L" : ""
   If (dummy!="simple")
      kMenu("PVselSize", "Add", "&Draw new freeform shape" infoKbd, "MenuStartDrawingSelectionArea", "edit freeform selection")

   If (EllipseSelectMode=2)
   {
      kMenu("PVselSize", "Add", "&Modify custom shape`tShift+L", "MenuResumeDrawingShapes", "edit draw freeform selection")
      createMenuSelectShapeTension()
      kMenu("PVselSize", "Add", "&Points tension", ":PVshapeTension")
   }

   kMenu("PVselSize", "Add", "Flip shape &horizontally`tH", "MenuSelectionFlipH")
   kMenu("PVselSize", "Add", "&Flip shape vertically`tV", "MenuSelectionFlipV")
   If (EllipseSelectMode!=2)
   {
      kMenu("PVselSize", "Disable", "Flip shape &horizontally`tH")
      kMenu("PVselSize", "Disable", "&Flip shape vertically`tV")
   }
}

createMenuSelectionArea(modus:=0) {
   createMenuSelectSizeShapes()
   If (modus="DoubleClick")
   {
      kMenu("PVselv", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
      Menu, PVselv, Add, 
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1 && editingSelectionNow=1)
   {
      friendly := (modus="DoubleClick") ? " selection" : ""
      kMenu("PVselv", "Add", "&Undo" friendly "`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("PVselv", "Add", "&Redo" friendly "`tCtrl+Shift+Y", "ImgSelRedoAct")
      Menu, PVselv, Add,
   }

   infoImgEditingNow := isImgEditingNow()
   If (infoImgEditingNow=1)
   {
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add", "&Show selection area`tE", "ToggleEditImgSelection", keyword)
      If (editingSelectionNow=1)
         kMenu("PVselv", "Check", "&Show selection area`tE")
   }

   If (modus!="DoubleClick")
      kMenu("PVselv", "Add", "&Drop and reset`tCtrl+D", "resetImgSelection", "hide")

   If (infoImgEditingNow=1)
      kMenu("PVselv", "Add", "Se&lect all`tCtrl+A", "selectEntireImage")

   If (editingSelectionNow=1 && infoImgEditingNow=1)
   {
      kMenu("PVselv", "Add", "Limit to image bo&undaries`tL", "toggleLimitSelection")
      If (lockSelectionAspectRatio<=1)
         kMenu("PVselv", "Add", "Flip width / &height`tW", "flipSelectionWH")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "Limit to image bo&undaries`tL")

      createMenuSelectionRotationAspectRatio()
      kMenu("PVselv", "Add", "&Shapes", ":PVselSize")
      kMenu("PVselv", "Add", "Rotation and &aspect ratio", ":PVselRatio")
      Menu, PVselv, Add, 
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add", "Sho&w grid", "ToggleSelectGrid", keyword)
      kMenu("PVselv", "Add", "Selection properties`tAlt+E", "PanelIMGselProperties")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid")

   }

   If (infoImgEditingNow=1 && modus="DoubleClick")
   {
      createMenuImageEditSubMenus()
      Menu, PVselv, Add
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image")
      kMenu("PVselv", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace", "image editing")
      Menu, PVselv, Add
      kMenu("PVselv", "Add", "&Filters", ":PVimgFilters")
      kMenu("PVselv", "Add", "&Draw", ":PVimgDraw")
      kMenu("PVselv", "Add", "&Transform", ":PVimgTransform")
   }
}

createMenuImageEditSubMenus() {
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      kMenu("PVimgTransform", "Add", "&Adjust canvas size`tAlt+A", "PanelAdjustImageCanvasSize")
      kMenu("PVimgTransform", "Add", "A&uto-crop image`tAlt+Y", "PanelImgAutoCrop")
      kMenu("PVimgDraw", "Add", "Draw f&reeform filled shape`tShift+P", "MenuStartDrawingShapes", "curve polygonal")
      kMenu("PVimgDraw", "Add", "Draw freeform &outline`tAlt+P", "MenuStartDrawingLines", "curve polygonal lines")
      kMenu("PVimgDraw", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects")
      kMenu("PVimgFilters", "Add", "&Blur/pixelize`tShift+B", "PanelBlurSelectedArea", "effects")
      kMenu("PVimgFilters", "Add", "&Invert colors`tShift+I", "InvertSelectedArea", "effects")
      kMenu("PVimgFilters", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea", "grayscale effects")
      kMenu("PVimgFilters", "Add", "&Detect edges filter", "PanelDetectEdgesImage", "emboss effects")
      kMenu("PVimgFilters", "Add", "&Add noise filter", "PanelAddNoiserImage", "effects")
      kMenu("PVimgDraw", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
      kMenu("PVimgDraw", "Add", "&Fill shapes`tAlt+Bksp", "PanelFillSelectedArea", "curve polygonal glass effects blur")
      kMenu("PVimgDraw", "Add", "Draw s&hape contours", "PanelDrawShapesInArea", "lines")
      kMenu("PVimgDraw", "Add", "&Draw simple lines or arcs`tCtrl+L", "PanelDrawLines")
      kMenu("PVimgDraw", "Add", "Insert te&xt into selection`tShift+T", "PanelInsertTextArea", "write")
      kMenu("PVimgTransform", "Add", "&Advanced live transform`tCtrl+T", "PanelTransformSelectedArea", "crop rotate resize clone blend alpha-masking flip blur glass effects adjust colors")
      Menu, PVimgTransform, Add, 
      kMenu("PVimgTransform", "Add", "Flip selected &horizontally`tShift+H", "FlipSelectedAreaH")
      kMenu("PVimgTransform", "Add", "Flip selected &vertically`tShift+V", "FlipSelectedAreaV")
      kMenu("PVimgTransform", "Add", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
      kMenu("PVimgTransform", "Add", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")
      kMenu("PVimgFilters", "Add", "&Apply viewport colors inside selection`tShift+U", "ApplyColorAdjustsSelectedArea", "effects")
      If (mustPreventMenus!=1)
         kMenu("PVimgFilters", "Add", "&... outside the selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea", "colors effects")

      If (editingSelectionNow!=1)
      {
         kMenu("PVimgDraw", "Disable", "&Erase or fade area`tDelete")
         ; kMenu("PVimgDraw", "Disable", "&Fill shapes`tAlt+Bksp")
         ; kMenu("PVimgDraw", "Disable", "&Draw simple lines or arcs`tCtrl+L")
         ; kMenu("PVimgDraw", "Disable", "Insert te&xt into selection`tShift+T")
         ; kMenu("PVimgDraw", "Disable", "Draw s&hape contours")
         kMenu("PVimgTransform", "Disable", "&Advanced live transform`tCtrl+T")
         kMenu("PVimgTransform", "Disable", "Flip selected &horizontally`tShift+H")
         kMenu("PVimgTransform", "Disable", "Flip selected &vertically`tShift+V")
         kMenu("PVimgTransform", "Disable", "&Crop image to selection`tShift+Enter")
         kMenu("PVimgTransform", "Disable", "&Resize image to selection`tAlt+R")
         kMenu("PVimgFilters", "Disable", "&Apply viewport colors inside selection`tShift+U")
         If (mustPreventMenus!=1)
            kMenu("PVimgFilters", "Disable", "&... outside the selection`tCtrl+Shift+U")
      }
   }
}

createMenuNavigation() {
   If (thumbsDisplaying!=1)
   {
      kMenu("PVnav", "Add", "&Skip missing files", "ToggleSkipDeadFiles")
      If (skipDeadFiles=1)
         kMenu("PVnav", "Check", "&Skip missing files")
      Menu, PVnav, Add,
   }

   kMenu("PVnav", "Add", "&First`tHome", "FirstPicture")
   kMenu("PVnav", "Add", "&Previous`tPage down", "PreviousPicture")
   kMenu("PVnav", "Add", "&Next`tPage up", "NextPicture")
   kMenu("PVnav", "Add", "&Last`tEnd", "LastPicture")
   If (totalFramesIndex>0 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "Previous &frame`tShift+Page Down", "prevDesiredFrame", "gifs")
      kMenu("PVnav", "Add", "Ne&xt frame`tShift+Page Up", "nextDesiredFrame", "gifs")
   }

   If (markedSelectFile>1 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "F&irst selected`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu("PVnav", "Add", "Pr&evious selected`tCtrl+Left", "navSelectedFilesPrev")
      kMenu("PVnav", "Add", "Nex&t selected`tCtrl+Right", "navSelectedFilesNext")
      kMenu("PVnav", "Add", "L&ast selected`tCtrl+End", "jumpToFilesSelBorderLast")
   }

   thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
   Menu, PVnav, Add,
   kMenu("PVnav", "Add", "&Skip to index`tJ", "PanelJump2index", "frames")
   kMenu("PVnav", "Add", "&Random`tShift+Bksp", "RandomPicture")
   kMenu("PVnav", "Add", "Pre&v. random image`tBksp", "PrevRandyPicture", "previous")
   If (SLDtypeLoaded=1 && FolderExist(thisFolder))
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "Folders explorer menu`tShift+F4", "chainInvokerFoldersListMenu")
   }
}

createMenuHelpQPV() {
   kMenu("PVhelp", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions", "keyboard")
   kMenu("PVhelp", "Add", "&Keyboard shortcuts`tF1", "HelpWindow", "keyboard shortcuts")
   kMenu("PVhelp", "Add", "Session &events journal`tShift+``", "PanelJournalWindow", "journal history")
   kMenu("PVhelp", "Add", "&Command line options", "MenuCmdLineHelp")
   If (TouchScreenMode=1)
      kMenu("PVhelp", "Add", "&Viewport help map", "drawViewportHelpMap")

   Menu, PVhelp, Add,
   kMenu("PVhelp", "Add", "C&heck for updates", "checkForUpdatesNow")
   kMenu("PVhelp", "Add", "&About", "AboutWindow", "author")
}

MenuSetShapeTension(a,b,c) {
   FillAreaCurveTension := b
   If (AnyWindowOpen=23)
      GuiControl, SettingsGUIA: Choose, FillAreaCurveTension, % FillAreaCurveTension

   decideCustomShapeStyle()
   INIaction(1, "FillAreaCurveTension", "General")
   SetTimer, dummyRefreshImgSelectionWindow, -150
   ; If (imgEditPanelOpened=1)
   ;    livePreviewsImageEditing()
}

checkForUpdatesNow() {
  Static iniURL := "http://marius.sucan.ro/media/files/blog/ahk-scripts/qpv-version.ini"
  iniTMP := mainCompiledPath "\resources\update-infos.ini"

  BtnCloseWindow()
  showTOOLtip("Checking for updates, please wait")
  newVersion := newDate := 0
  FileDelete, %iniTmp%
  Sleep, 150
  UrlDownloadToFile, %iniURL%, %iniTmp%
  Sleep, 950
  If FileExist(iniTMP)
  {
     FileRead, OutputVar, %iniTmp%
     Loop, Parse, OutputVar, `n,`r
     {
        If InStr(A_LoopField, "version=")
        {
           klop := StrSplit(A_LoopField, "=")
           newVersion := Trimmer(klop[2])
        } Else If InStr(A_LoopField, "ReleaseDate=")
        {
           klop := StrSplit(A_LoopField, "=")
           newDate := Trimmer(klop[2])
        }
        If (A_Index>10)
           Break
     }
  }

  failed := (InStr(newVersion, ".") && InStr(newDate, "/")) ? 0 : 1
  new := (newVersion=appVersion && newDate=vReleaseDate) ? 0 : 1
  If (failed=1)
  {
     msg := "Failed to check for updates... Please click on «Manual check» to open the " appTitle " web site."
     friendly := "Manual check"
  } Else
  {
     msg := "Running version:`n" appVersion " [ " vReleaseDate " ]"
     msg .= "`n`nOnline version:`n" newVersion " [ " newDate " ]"
     msg .= (new=1) ? "`n`nA" : "`n`nNo"
     msg .= " new version seems to be available."
     friendly := (new!=1) ? "Open QPV web page" : "Download latest version"
  }
  RemoveTooltip()
  msgResult := msgBoxWrapper(appTitle ": Check for updates", msg, "&" friendly "|&Cancel", 0, "settings")

  If (InStr(msgResult, "open") || InStr(msgResult, "manual") || InStr(msgResult, "download"))
     OpenGitHub()

  RemoveTooltip()
}

MenuCmdLineHelp() {
   HelpWindow("cmdu")
}

createMenuSoloFile() {
   kMenu("PVtActFile", "Add", "&Open with external app`tO", "OpenThisFileMenu")
   kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
   If RegExMatch(CurrentSLD, sldsPattern)
      kMenu("PVtActFile", "Add", "Open in QPV containin&g folder", "OpenQPVfileFolder")

   kMenu("PVtActFile", "Add", "&Explore containing folder`tCtrl+E", "OpenThisFileFolder")
   kMenu("PVtActFile", "Add", "Set containing folder as the &protected folder", "setContaintFolderAsProtected")
   kMenu("PVtActFile", "Add", "Set as &wallpaper`tCtrl+W", "setImageWallpaper", "desktop")
   If (mustPreventMenus=1)
   {
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "System «Open with» dialog", "invokeSHopenWith", "external")
   }

   Menu, PVtActFile, Add, 
   If (thumbsDisplaying=1)
   {
      kMenu("PVtActFile", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
      If !EntryMarkedMoveIndex
         kMenu("PVtActFile", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
      Else
         kMenu("PVtActFile", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
   }

   If !markedSelectFile
      kMenu("PVtActFile", "Add", "&Select / deselect file`tTab", "MenuMarkThisFileNow")

   kMenu("PVtActFile", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
   kMenu("PVtActFile", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
   Menu, PVtActFile, Add, 
   kMenu("PVtActFile", "Add", "&Delete file`tDelete", "DeleteActivePicture")
   kMenu("PVtActFile", "Add", "&Rename file`tShift+F2", "SingularRenameFile")
   kMenu("PVtActFile", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "show details properties image")
}

chainInvokerFoldersListMenu() {
   Global lastOtherWinClose := 1
   SetTimer, invokeFoldersListerMenu, -60
}

MenuIncVProtation() {
   changeImgRotationInVP(1)
}

MenuDecVProtation() {
   changeImgRotationInVP(-1)
}

MenuResetVProtation() {
   vpIMGrotation := 0
   dummyTimerDelayiedImageDisplay(50)
}

createMenuImgVProt() {
   kMenu("PVimgVProt", "Add", "&Increase rotation by 15°`t0", "MenuIncVProtation")
   kMenu("PVimgVProt", "Add", "&Decrease rotation by 15°`t9", "MenuDecVProtation")
   If (mustPreventMenus=1)
   {
      kMenu("PVimgVProt", "Add", "&Reset rotation`t\", "MenuResetVProtation")
      Return
   }

   Menu, PVimgVProt, Add
   kMenu("PVimgVProt", "Add", "0°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "23°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "45°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "90°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "135°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "180°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "225°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "270°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "315°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", vpIMGrotation "°", "dummy")
   kMenu("PVimgVProt", "Disable", vpIMGrotation "°")
   kMenu("PVimgVProt", "Check", vpIMGrotation "°")
}

createMenuImgSizeAdapt() {
   kMenu("PvImgAdapt", "Add", "C&ycle adapt to window modes`tT", "ToggleImageSizingMode")
   Menu, PvImgAdapt, Add
   kMenu("PvImgAdapt", "Add", "&Adapt all into view`t/", "MenuSetImageAdaptAll")
   kMenu("PvImgAdapt", "Add", "Adapt only &large images", "MenuSetImageAdaptLarge")
   kMenu("PvImgAdapt", "Add", "&Fixed to original size (100%)", "MenuSetImageOriginalFixed")
   kMenu("PvImgAdapt", "Add", "Custom &zoom level (" Round(zoomLevel*100) "%)", "MenuSetImageCustomZoom")
   kMenu("PvImgAdapt", "Add", "Stretched to &window", "MenuSetImageStretchedWin")
   If (IMGresizingMode=1)
      kMenu("PvImgAdapt", "Check", "&Adapt all into view`t/")
   Else If (IMGresizingMode=2)
      kMenu("PvImgAdapt", "Check", "Adapt only &large images")
   Else If (IMGresizingMode=3)
      kMenu("PvImgAdapt", "Check", "&Fixed to original size (100%)")
   Else If (IMGresizingMode=4)
      kMenu("PvImgAdapt", "Check", "Custom &zoom level (" Round(zoomLevel*100) "%)")
   Else If (IMGresizingMode=5)
      kMenu("PvImgAdapt", "Check", "Stretched to &window")

   If (mustPreventMenus!=1)
   {
      Menu, PvImgAdapt, Add
      kMenu("PvImgAdapt", "Add", "6%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "12%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "25%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "50%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "100%`tNUM *", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "200%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "400%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "800%", "MenuSetImgZoom")
      Menu, PvImgAdapt, Add
   }

   kMenu("PvImgAdapt", "Add", "&High quality image resampling", "ToggleImgQuality", "settings performance")
   If (userimgQuality=1)
      kMenu("PvImgAdapt", "Check", "&High quality image resampling")
   If (IMGresizingMode=4)
   {
      kMenu("PvImgAdapt", "Add", "&Keep zoom level between images", "toggleLockZoom")
      If (lockZoomLevel=1)
         kMenu("PvImgAdapt", "Check", "&Keep zoom level between images")
   }
}

createMenuMainPreferences() {
   kMenu("PVperfs", "Add", "&Limit memory usage", "ToggleLimitMemUsage")
   kMenu("PVperfs", "Add", "&Do not record undo levels", "TogglePreventUndos", "history")
   If (preventUndoLevels=1)
      kMenu("PVperfs", "Check", "&Do not record undo levels")
   kMenu("PVperfs", "Add", "&Multi-threaded processing", "PanelSetSystemCores")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")

   If (A_PtrSize=4)
   {
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")
      kMenu("PVperfs", "Disable", "&Limit memory usage")
      kMenu("PVperfs", "Check", "&Limit memory usage")
   }

   kMenu("PVperfs", "Add", "&High quality image resampling", "ToggleImgQuality")
   If (thumbsDisplaying!=1)
   {
      kMenu("PVperfs", "Add", "&Downscale images to viewport dimensions`tCtrl+Q", "ToggleImgDownScaling")
      If (AutoDownScaleIMGs=1)
         kMenu("PVperfs", "Check", "&Downscale images to viewport dimensions`tCtrl+Q")
   }
   kMenu("PVperfs", "Add", "&Perform dithering on color depth changes", "ToggleImgColorDepthDithering")
   kMenu("PVperfs", "Add", "&Apply gamma correction", "toggleImgEditGammaCorrect")
   kMenu("PVperfs", "Add", "&Load Camera RAW files at high quality", "ToggleRAWquality")
   If (userimgGammaCorrect=1)
      kMenu("PVperfs", "Check", "&Apply gamma correction")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Check", "&Limit memory usage")
   If (allowMultiCoreMode=1)
      kMenu("PVperfs", "Check", "&Multi-threaded processing")
   If (ColorDepthDithering=1)
      kMenu("PVperfs", "Check", "&Perform dithering on color depth changes")
   If (userimgQuality=1)
      kMenu("PVperfs", "Check", "&High quality image resampling")
   If (userHQraw=1)
      kMenu("PVperfs", "Check", "&Load Camera RAW files at high quality")

   kMenu("PVprefs", "Add", "Save settings into a .SLD file", "WritePrefsIntoSLD")
   kMenu("PVprefs", "Add", "&Never load settings from a .SLD", "ToggleIgnoreSLDprefs")
   kMenu("PVprefs", "Add", "Associate QPV with image formats", "PanelAssociateQPV", "system")
   If !A_IsAdmin
      kMenu("PVprefs", "Add", "Run in admin mode", "RunAdminMode")

   Menu, PVprefs, Add, 
   kMenu("PVprefs", "Add", "Load an&y image format using FreeImage", "ToggleAlwaysFIMus")
   kMenu("PVprefs", "Add", "Performance options", ":PVperfs")
   Menu, PVprefs, Add, 
   If (thumbsDisplaying!=1)
   {
      kMenu("PVprefs", "Add", "Auto-play an&imated GIFs", "ToggleAnimGIFsupport")
      If (animGIFsSupport=1)
         kMenu("PVprefs", "Check", "Auto-play an&imated GIFs")
      If (alwaysOpenwithFIM=1)
         kMenu("PVprefs", "Disable", "Auto-play an&imated GIFs")
   }

   kMenu("PVprefs", "Add", "&Quick file actions", "PanelQuickMoveConfigure", "index list")
   kMenu("PVprefs", "Add", "&Record seen images", "ToggleRecordSeenImages", "history")
   If (mustRecordSeenImgs=1)
      kMenu("PVprefs", "Check", "&Record seen images")

   kMenu("PVprefs", "Add", "&Prompt before file delete", "TogglePromptDelete")
   If (askDeleteFiles=1)
      kMenu("PVprefs", "Check", "&Prompt before file delete")
   If (MustLoadSLDprefs=0)
      kMenu("PVprefs", "Check", "&Never load settings from a .SLD")

   Menu, PVprefs, Add, 
   If (mustRecordSeenImgs=1)
      kMenu("PVprefs", "Add", "Seen images database options", "PanelSeenIMGsOptions")
   If FolderExist(thumbsCacheFolder)
      kMenu("PVprefs", "Add", "Erase cached thumbnails", "PanelfolderThanEraseThumbsCache")

   kMenu("PVprefs", "Add", "Cache generated thumbnails", "ToggleThumbsCaching")
   If (alwaysOpenwithFIM=1)
      kMenu("PVprefs", "Check", "Load an&y image format using FreeImage")

   If (enableThumbsCaching=1)
   {
      If (thumbsDisplaying=1)
         kMenu("PVprefs", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")

      kMenu("PVprefs", "Check", "Cache generated thumbnails")
   }
}

createMenuMainView() {
   If (thumbsDisplaying=1)
   {
      infoThumbZoom := thumbsColumns " | " thumbsW "x" thumbsH " px" ; " (" Round(thumbsZoomLevel*100) "%)"
      kMenu("PVview", "Add", "&Cycle aspect ratios`tT", "ToggleThumbsAratio")
      Try kMenu("PVview", "Add", defineThumbsAratio(), "ToggleThumbsAratio")
      Try kMenu("PVview", "Disable", defineThumbsAratio())
      Menu, PVview, Add,
      kMenu("PVview", "Add", "&Set columns and other options", "PanelSetThumbColumnOptions")
      ; kMenu("PVview", "Disable", "Thumbnails columns and size:")
      kMenu("PVview", "Add", infoThumbZoom, "ToggleThumbsAratio")
      kMenu("PVview", "Disable", infoThumbZoom)
   } Else
   {
      createMenuImgSizeAdapt()
      If !AnyWindowOpen
         createMenuImgVProt()

      createMenuVPhudHisto()
      If (InStr(currIMGdetails.PixelFormat, "TONE-MAPPED") && !AnyWindowOpen)
         kMenu("PVview", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic")

      If !AnyWindowOpen
         kMenu("PVview", "Add", "Viewport and color adjustments panel`tU", "PanelColorsAdjusterWindow")

      kMenu("PVview", "Add", "Show histogram", ":PVimgHistos")
      friendlyPix := (coreDesiredPixFmt="0x21808") ? "24-RGB" : "32-RGBA"
      Menu, PVview, Add,
      If (A_PtrSize=4)
         kMenu("PVview", "Add", "Pi&xel format mode: " friendlyPix, "ToggleCorePixFmt")

      If !AnyWindowOpen
         kMenu("PVview", "Add", "&Rotation ("vpIMGrotation "°)", ":PVimgVProt")
      kMenu("PVview", "Add", "&Zoom and adapt modes", ":PvImgAdapt")
   }

   kMenu("PVview", "Add", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
   If (imageAligned=5)
      kMenu("PVview", "Check", "Centered &alignment`tA")

   createMenuColorDepth()
   dontShow := (thumbsDisplaying=1 && minimizeMemUsage=1) ? 1 : 0
   Menu, PVview, Add,
   kMenu("PVview", "Add", "Simulated color &depth", ":PVimgSdepth")
   If (dontShow!=1)
   {
      createMenuImgColorsFX()
      kMenu("PVview", "Add", "Colors F&X and display modes", ":PVimgColorsFX")
   }

   Menu, PVview, Add,
   kMenu("PVview", "Add", "Mirror &horizontally`tH", "VPflipImgH", "viewport flip image")
   kMenu("PVview", "Add", "Mirror &vertically`tV", "VPflipImgV", "viewport flip image")
   Menu, PVview, Add,
   If (thumbsDisplaying!=1 && !AnyWindowOpen)
      kMenu("PVview", "Add", "Configure viewport &grid", "PanelConfigVPgrid")

   kMenu("PVview", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
   If (FlipImgV=1)
      kMenu("PVview", "Check", "Mirror &vertically`tV")
   If (FlipImgH=1)
      kMenu("PVview", "Check", "Mirror &horizontally`tH")

   If (mustPreventMenus=1 && thumbsDisplaying!=1)
   {
      keyword := (showViewPortGrid=1) ? "hide" : "display"
      kMenu("PVview", "Add", "Increase viewport grid size`tAlt+[+]", "MenuIncVPgridSize")
      kMenu("PVview", "Add", "Decrease viewport grid size`tAlt+[-]", "MenuDecVPgridSize")
      kMenu("PVview", "Add", "Show viewport &grid", "toggleViewPortGridu", keyword)
      If (showViewPortGrid=1)
         kMenu("PVview", "Check", "Show viewport &grid")
   }

   If (thumbsDisplaying!=1)
   {
      If !AnyWindowOpen
      {
         kMenu("PVview", "Add", "Reset adjustments on image change", "ToggleAutoResetImageView")
         If (resetImageViewOnChange=1)
            kMenu("PVview", "Check", "Reset adjustments on image change")
      } Else
      {
         kMenu("PVview", "Add", "Show viewport &grid", "toggleViewPortGridu")
         If (showViewPortGrid=1)
            kMenu("PVview", "Check", "Show viewport &grid")
      }
   } Else
   {
      Menu, PVview, Add
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      If (thumbsDisplaying=1 && thumbsListViewMode=1)
         kMenu("PVview", "Add", friendly "`tAlt+F5", "DeepRefreshThumbsNow")
      If (enableThumbsCaching=1)
         kMenu("PVview", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")
   }
}

createMenuCurrentFilesActs() {
   kMenu("PVfilesActs", "Add", "Cop&y file path(s) as text`tShift+C", "CopyImagePath", "clipboard")
   If markedSelectFile
      kMenu("PVfilesActs", "Add", "Copy folder paths as text", "CopyImageFolderPaths", "text clipboard")

   If (thumbsDisplaying=1 || markedSelectFile)
   {
      infoKbd := (thumbsDisplaying=1) ? "`tCtrl+C" : ""
      kMenu("PVfilesActs", "Add", "Copy file(s) (for Explorer)" infoKbd, "MenuExplorerCopyFiles", "clipboard")
      infoKbd := (thumbsDisplaying=1) ? "`tCtrl+X" : ""
      kMenu("PVfilesActs", "Add", "C&ut file(s) (for Explorer)" infoKbd, "MenuExplorerCutFiles", "clipboard")
   }

   Menu, PVfilesActs, Add, 
   If !markedSelectFile
      kMenu("PVtFileOpen", "Add", "&Open with external app`tO", "OpenThisFileMenu")

   If markedSelectFile
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")
   Else
      kMenu("PVtFileOpen", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")

   If (!markedSelectFile && RegExMatch(CurrentSLD, sldsPattern))
      kMenu("PVtFileOpen", "Add", "&Open in QPV the containing folder", "OpenQPVfileFolder")

   If !markedSelectFile
      kMenu("PVtFileOpen", "Add", "&Explore the containing folder`tCtrl+E", "OpenThisFileFolder", "external")

   If (thumbsDisplaying=1 && !markedSelectFile)
      kMenu("PVtFileOpen", "Add", "&Import into currently loaded image", "importEditGivenImageFile")

   If !markedSelectFile
   {
      kMenu("PVfilesActs", "Add", "&Open...", ":PVtFileOpen")
      kMenu("PVfilesActs", "Add", "Set as &wallpaper`tCtrl+W", "setImageWallpaper", "desktop image")
   } Else
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")

   Menu, PVfilesActs, Add, 
   kMenu("PVfilesActs", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
   ; If markedSelectFile
   ; {
      file2rem := getIDimage(currentFileIndex)
      kMenu("PVtFileImgAct", "Add", "&JPEG lossless operations`tK", "PanelJpegPerformOperation")
      If !RegExMatch(file2rem, "i)(.\.(jpg|jpeg))$")
         kMenu("PVtFileImgAct", "Disable", "&JPEG lossless operations`tK")

      kMenu("PVtFileImgAct", "Add", "Resi&ze/rotate/crop image(s)`tCtrl+R", "PanelSimpleResizeRotate", "process advanced")
      If markedSelectFile
         kMenu("PVtFileImgAct", "Add", "&Auto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")

      If (thumbsDisplaying=1 || markedSelectFile)
      {
         infoKbd := (thumbsDisplaying=1) ? "`tShift+U" : ""
         kMenu("PVtFileImgAct", "Add", "Apply vie&wport color adjustments" infoKbd, "filesListApplyColors", "image")
         infoKbd := (thumbsDisplaying=1) ? "`tShift+H" : ""
         kMenu("PVtFileImgAct", "Add", "Flip image horizontally" infoKbd, "filesListFlipHimage")
         infoKbd := (thumbsDisplaying=1) ? "`tShift+V" : ""
         kMenu("PVtFileImgAct", "Add", "Flip image vertically" infoKbd, "filesListFlipVimage")
         infoKbd := (thumbsDisplaying=1) ? "`tShift+0" : ""
         kMenu("PVtFileImgAct", "Add", "Rotate image by 90°" infoKbd, "filesListFlipRotatePlus")
         infoKbd := (thumbsDisplaying=1) ? "`tShift+9" : ""
         kMenu("PVtFileImgAct", "Add", "Rotate image by -90°" infoKbd, "filesListFlipRotateMinus")
      }
   ; }

   kMenu("PVfilesActs", "Add", "Modify image(s)", ":PVtFileImgAct")
   Menu, PVfilesActs, Add, 
   If markedSelectFile
      kMenu("PVfilesActs", "Add", "Remove file inde&x entries`tDelete", "InListMultiEntriesRemover", "erase")
   kMenu("PVfilesActs", "Add", "&Delete file(s)`tDelete", "DeletePicture", "erase")
   kMenu("PVfilesActs", "Add", "&Rename file(s)`tF2", "PanelRenameThisFile")
   kMenu("PVfilesActs", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
   kMenu("PVfilesActs", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   Menu, PVfilesActs, Add,
   If !markedSelectFile
      kMenu("PVfilesActs", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "properties image details")
   Else
      kMenu("PVfilesActs", "Add", "&Calculate total files size`tAlt+L", "CalculateSelectedFilesSizes", "file details")

   If !markedSelectFile
      kMenu("PVfilesActs", "Add", "&Select / deselect file`tTab", "MenuMarkThisFileNow")
   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
      kMenu("PVfilesActs", "Add", "&Toggle Seen status`tShift+S", "ToggleSeenIMGstatus")
}

createMenuFilesSort() {
   kMenu("PVsort", "Add", "File details", "dummy")
   kMenu("PVsort", "Disable", "File details")
   kMenu("PVsort", "Add", "&Path and name`tCtrl+1", "ActSortName")
   kMenu("PVsort", "Add", "&Folder path`tCtrl+2", "ActSortPath")
   kMenu("PVsort", "Add", "&File name`tCtrl+3", "ActSortFileName")
   kMenu("PVsort", "Add", "File si&ze`tCtrl+4", "ActSortSize")
   kMenu("PVsort", "Add", "&Modified date`tCtrl+5", "ActSortModified")
   kMenu("PVsort", "Add", "&Created date`tCtrl+6", "ActSortCreated")
   If testIsDupesList()
   {
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "&Duplicates ID group", "ActSortDupeGroups")
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add", "&Reversed order on sort", "TglRvrSort")
   If (reverseOrderOnSort=1)
      kMenu("PVsort", "Check", "&Reversed order on sort")

   kMenu("PVsort", "Add", "&Remove inexistent files on sort", "TglCheckDeadFilesSort")
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      kMenu("PVsort", "Disable", "&Remove inexistent files on sort")
   Else If (OnSortdoFilesCheck=1)
      kMenu("PVsort", "Check", "&Remove inexistent files on sort")

   If (SLDtypeLoaded=3)
   {
      kMenu("PVsort", "Add", "&Purge cached data", "PanelPurgeCachedSQLdata")
      kMenu("PVsort", "Add", "&Use cached data", "TglUseCacheSLDinfo")
      If (useCachedSLDdata=1)
         kMenu("PVsort", "Check", "&Use cached data")

      defaultSort := defineSQLdbSort()
      StringUpper, defaultSort, defaultSort
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "Default sorting:", "ToggleDBdefaultSQLsort")
      kMenu("PVsort", "Add", "[" defaultSort "]", "ToggleDBdefaultSQLsort")
      kMenu("PVsort", "Disable", "[" defaultSort "]")
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add", "Image information", "dummy")
   kMenu("PVsort", "Disable", "Image information")
   kMenu("PVsort", "Add", "&Resolution`tCtrl+7", "PanelResolutionSorting")
   kMenu("PVsort", "Add", "&Histogram`tCtrl+8", "PanelHistogramSorting")
   If (mustPreventMenus=1)
   {
      kMenu("PVsort", "Add", "Resolution (MPx)", "MenuSortImageResolutionMGPX")
      kMenu("PVsort", "Add", "Image width", "MenuSortImageWdithRes")
      kMenu("PVsort", "Add", "Image height", "MenuSortImageHeightRes")
      kMenu("PVsort", "Add", "Aspect ratio (W/H)", "MenuSortImageAspectRatioRes")
      kMenu("PVsort", "Add", "Image DPI", "MenuSortImageDPIres")
      kMenu("PVsort", "Add", "Pages / frames", "MenuSortImageFrameRes")
      kMenu("PVsort", "Add", "Histogram average", "MenuActSortHisto1")
      kMenu("PVsort", "Add", "Histogram median", "MenuActSortHisto2")
      kMenu("PVsort", "Add", "Histogram peak range", "MenuActSortHisto3")
      kMenu("PVsort", "Add", "Histogram minimum range", "MenuActSortHisto4")
      kMenu("PVsort", "Add", "Histogram range", "MenuActSortHisto5")
      kMenu("PVsort", "Add", "Histogram mode", "MenuActSortHisto6")
      kMenu("PVsort", "Add", "Histogram minimum", "MenuActSortHisto7")
      kMenu("PVsort", "Add", "Histogram root-mean square", "MenuActSortHisto8")
   }

   Menu, PVsort, Add, 
   kMenu("PVsort", "Add", "R&everse list`tCtrl+0", "ReverseListNow", "files")
   kMenu("PVsort", "Add", "R&andomize list", "RandomizeListNow", "files")
}

MenuSortImageResolutionMGPX() {
   ActSortImageProperties(1)
}

MenuSortImageWdithRes() {
   ActSortImageProperties(2)
}

MenuSortImageHeightRes() {
   ActSortImageProperties(3)
}

MenuSortImageAspectRatioRes() {
   ActSortImageProperties(4)
}

MenuSortImageDPIres() {
   ActSortImageProperties(5)
}

MenuSortImageFrameRes() {
   ActSortImageProperties(6)
}

MenuActSortHisto1() {
   ActSortHistogram(1)
}

MenuActSortHisto2() {
   ActSortHistogram(2)
}

MenuActSortHisto3() {
   ActSortHistogram(3)
}

MenuActSortHisto4() {
   ActSortHistogram(4)
}

MenuActSortHisto5() {
   ActSortHistogram(5)
}

MenuActSortHisto6() {
   ActSortHistogram(6)
}

MenuActSortHisto7() {
   ActSortHistogram(7)
}

MenuActSortHisto8() {
   ActSortHistogram(8)
}

createMenuSlideshows() {
   sliSpeed := Round(slideShowDelay/1000, 2) " sec."
   kMenu("PVslide", "Add", "&Start slideshow`tSpace", "dummyInfoToggleSlideShowu", "play")
   kMenu("PVslide", "Add", "Smoot&h transitions", "ToggleSlidesTransitions", "fade")
   kMenu("PVslide", "Add", "&Easy to stop slideshows", "ToggleEasySlideStop")
   kMenu("PVslide", "Add", "&Randomize colour effects", "ToggleSlidesFXmode", "slideshow")
   kMenu("PVslide", "Add", "&Wait for GIFs to play once", "ToggleGIFsPlayEntirely", "animations")
   If (animGIFsSupport!=1 || alwaysOpenwithFIM=1)
      kMenu("PVslide", "Disable", "&Wait for GIFs to play once")
   If (slidesFXrandomize=1)
      kMenu("PVslide", "Check", "&Randomize colour effects")

   kMenu("PVslide", "Add", "S&kip already seen images", "ToggleSkipSeenIMGs")
   If (mustRecordSeenImgs!=1)
      kMenu("PVslide", "Disable", "S&kip already seen images")
   Else If (skipSeenImageSlides=1)
      kMenu("PVslide", "Check", "S&kip already seen images")
   Menu, PVslide, Add, 
   kMenu("PVslide", "Add", "De&fine slideshow duration`tShift+/", "PanelDefineEntireSlideshowLength")
   kMenu("PVslide", "Add", EstimateSlideShowLength(1), "dummy")
   kMenu("PVslide", "Disable", EstimateSlideShowLength(1))
   Menu, PVslide, Add,
   kMenu("PVslide", "Add", "C&ycle slideshow directions`tS", "ToggleSlideshowModes")
   kMenu("PVslide", "Add", DefineSlideShowType(), "ToggleSlideshowModes")
   kMenu("PVslide", "Disable", DefineSlideShowType())
   Menu, PVslide, Add,
   thisMusic := StrLen(SlidesMusicSong)>3 ? PathCompact(SlidesMusicSong, 30) : "NONE"
   kMenu("PVslide", "Add", "Automatically play music", "ToggleAutoPlaySlidesMusic")
   kMenu("PVslide", "Add", "Set back&ground music", "PanelSetSlidesMusic")
   kMenu("PVslide", "Add", thisMusic, "dummy")
   kMenu("PVslide", "Disable", thisMusic)
   If (autoPlaySlidesAudio=1)
      kMenu("PVslide", "Check", "Automatically play music")
   Menu, PVslide, Add,
   kMenu("PVslide", "Add", "&Increase speed`tDot [ . ]", "IncreaseSlideSpeed")
   kMenu("PVslide", "Add", "&Decrease speed`tComma [ , ]", "DecreaseSlideSpeed")
   kMenu("PVslide", "Add", "Current speed: " sliSpeed, "DecreaseSlideSpeed")
   kMenu("PVslide", "Disable", "Current speed: " sliSpeed)
   If (allowGIFsPlayEntirely=1)
      kMenu("PVslide", "Check", "&Wait for GIFs to play once")
   If (doSlidesTransitions=1)
      kMenu("PVslide", "Check", "Smoot&h transitions")
   If (minimizeMemUsage=1)
      kMenu("PVslide", "Disable", "Smoot&h transitions")
   If (easySlideStoppage=1)
      kMenu("PVslide", "Check", "&Easy to stop slideshows")
}

createMenuAnnotations() {
   kMenu("PVsounds", "Add", "&Edit image captions`tShift+N", "PanelEditImgCaption", "modify")
   keywords := (showImgAnnotations=1) ? "hide viewport" : "display viewport"
   kMenu("PVsounds", "Add", "&Show image captions`tN", "ToggleImgCaptions", keywords)
   If (showImgAnnotations=1)
      kMenu("PVsounds", "Check", "&Show image captions`tN")
   Menu, PVsounds, Add, 
   If (SLDtypeLoaded=3)
      kMenu("PVsounds", "Add", "&Choose audio file", "PanelBrowseAudioAnnotation")
   kMenu("PVsounds", "Add", "&Play associated sound file`tX", "PlayAudioFileAssociatedNow")
   kMenu("PVsounds", "Add", "&Stop playing`tShift+X", "StopMediaPlaying")
   If !hSNDmedia
      kMenu("PVsounds", "Disable", "&Stop playing`tShift+X")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add", "&Auto-play sound files", "ToggleAutoPlaySND")
   If (autoPlaySNDs=1)
      kMenu("PVsounds", "Check", "&Auto-play sound files")
   kMenu("PVsounds", "Add", "Slidesho&w speed based on audio length", "ToggleSyncSlide2sndDuration")
   If (syncSlideShow2Audios=1)
      kMenu("PVsounds", "Check", "Slidesho&w speed based on audio length")
   If (autoPlaySNDs!=1)
      kMenu("PVsounds", "Disable", "Slidesho&w speed based on audio length")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add", "&Increase audio volume`tShift + [ . ]", "MenuSetVolumeUp")
   kMenu("PVsounds", "Add", "&Decrease audio volume`tShift + [ , ]", "MenuSetVolumeDown")
   kMenu("PVsounds", "Add", "Audio volume: " mediaSNDvolume "%", "dummy")
   kMenu("PVsounds", "Disable", "Audio volume: " mediaSNDvolume "%")
}

createMenuVPhudHisto() {
   kMenu("PVimgHistos", "Add", "C&ycle histogram modes`tShift+G", "ToggleImgHistogram")
   Menu, PVimgHistos, Add, 
   kMenu("PVimgHistos", "Add", "&None", "MenuSetVPhistoNone", "histogram")
   kMenu("PVimgHistos", "Add", "&Luminance", "MenuSetVPhistoLuminance", "histogram")
   kMenu("PVimgHistos", "Add", "&Red", "MenuSetVPhistoRed", "histogram")
   kMenu("PVimgHistos", "Add", "&Green", "MenuSetVPhistoGreen", "histogram")
   kMenu("PVimgHistos", "Add", "&Blue", "MenuSetVPhistoBlue", "histogram")
   kMenu("PVimgHistos", "Add", "&All mixed", "MenuSetVPhistoAll", "histogram")
   Menu, PVimgHistos, Add, 
   kMenu("PVimgHistos", "Add", "Graph emphasis", "dummy")
   kMenu("PVimgHistos", "Disable", "Graph emphasis")
   kMenu("PVimgHistos", "Add", "&Lows", "MenuSetVPgraphHistoLows", "graph histogram")
   kMenu("PVimgHistos", "Add", "&Balanced", "MenuSetVPgraphHistoMids", "graph histogram")
   kMenu("PVimgHistos", "Add", "&Peaks", "MenuSetVPgraphHistoPeaks", "graph histogram")

   If (showHistogram=1)
      kMenu("PVimgHistos", "Check", "&None")
   Else If (showHistogram=2)
      kMenu("PVimgHistos", "Check", "&Luminance")
   Else If (showHistogram=3)
      kMenu("PVimgHistos", "Check", "&Red")
   Else If (showHistogram=4)
      kMenu("PVimgHistos", "Check", "&Green")
   Else If (showHistogram=5)
      kMenu("PVimgHistos", "Check", "&Blue")
   Else If (showHistogram=6)
      kMenu("PVimgHistos", "Check", "&All mixed")

   If (showHistogram=1)
   {
      kMenu("PVimgHistos", "Disable", "&Lows")
      kMenu("PVimgHistos", "Disable", "&Balanced")
      kMenu("PVimgHistos", "Disable", "&Peaks")
   }

   If (histogramMode=1)
      kMenu("PVimgHistos", "Check", "&Lows")
   Else If (histogramMode=2)
      kMenu("PVimgHistos", "Check", "&Balanced")
   Else If (histogramMode=3)
      kMenu("PVimgHistos", "Check", "&Peaks")
}

createMenuColorDepth() {
   infoColorDepth := (usrColorDepth>1) ? "Original / reset" : defineColorDepth()
   kMenu("PVimgSdepth", "Add", "C&ycle simulate color depths`tQ", "ToggleImgColorDepth")
   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add", infoColorDepth, "MenuResetImageColorDepth")
   kMenu("PVimgSdepth", "Add", "2 bits (4 colors)", "MenuSetImageDepth2bits")
   kMenu("PVimgSdepth", "Add", "3 bits (8 colors)", "MenuSetImageDepth3bits")
   kMenu("PVimgSdepth", "Add", "4 bits (16 colors)", "MenuSetImageDepth4bits")
   kMenu("PVimgSdepth", "Add", "5 bits (32 colors)", "MenuSetImageDepth5bits")
   kMenu("PVimgSdepth", "Add", "6 bits (64 colors)", "MenuSetImageDepth6bits")
   kMenu("PVimgSdepth", "Add", "7 bits (128 colors)", "MenuSetImageDepth7bits")
   kMenu("PVimgSdepth", "Add", "8 bits (256 colors)", "MenuSetImageDepth8bits")
   kMenu("PVimgSdepth", "Add", "16 bits (65536 colors)", "MenuSetImageDepth16bits")
   If (usrColorDepth<2)
   {
      kMenu("PVimgSdepth", "Check", infoColorDepth)
      kMenu("PVimgSdepth", "Disable", infoColorDepth)
   } Else If (usrColorDepth=2)
      kMenu("PVimgSdepth", "Check", "2 bits (4 colors)")
   Else If (usrColorDepth=3)
      kMenu("PVimgSdepth", "Check", "3 bits (8 colors)")
   Else If (usrColorDepth=4)
      kMenu("PVimgSdepth", "Check", "4 bits (16 colors)")
   Else If (usrColorDepth=5)
      kMenu("PVimgSdepth", "Check", "5 bits (32 colors)")
   Else If (usrColorDepth=6)
      kMenu("PVimgSdepth", "Check", "6 bits (64 colors)")
   Else If (usrColorDepth=7)
      kMenu("PVimgSdepth", "Check", "7 bits (128 colors)")
   Else If (usrColorDepth=8)
      kMenu("PVimgSdepth", "Check", "8 bits (256 colors)")
   Else If (usrColorDepth=9)
      kMenu("PVimgSdepth", "Check", "16 bits (65536 colors)")

   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add", "&Perform dithering on color depth changes", "ToggleImgColorDepthDithering", "settings performance quality")
   If (ColorDepthDithering=1)
      kMenu("PVimgSdepth", "Check", "&Perform dithering on color depth changes")
}

createMenuImgColorsFX() {
   infolumosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(lumosAdjust, 2) : Round(lumosGrayAdjust, 2)
   infoGammosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(GammosAdjust, 2) : Round(GammosGrayAdjust, 2)
   infoSatAdjust := (imgFxMode=4) ? zatAdjust : Round(satAdjust*100)
   kMenu("PVimgColorsFX", "Add", "C&ycle colors display modes`tF", "ToggleImgFX")
   kMenu("PVimgColorsFX", "Add", DefineFXmodes(), "ToggleImgFX")
   kMenu("PVimgColorsFX", "Disable", DefineFXmodes())
   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4)
   {
      kMenu("PVimgColorsFX", "Add", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust, "ToggleImgFX")
      kMenu("PVimgColorsFX", "Disable", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust)
   }

   Menu, PVimgColorsFX, Add
   kMenu("PVimgColorsFX", "Add", "&Original colors", "MenuSetColorModeOriginal")
   kMenu("PVimgColorsFX", "Add", "&Personalized colors", "MenuSetColorModePersonalized")
   kMenu("PVimgColorsFX", "Add", "&Auto-adjusted colors", "MenuSetColorModeAuto")
   kMenu("PVimgColorsFX", "Add", "Grays&cale", "MenuSetColorModeGrayscale")
   kMenu("PVimgColorsFX", "Add", "&Red channel", "MenuSetColorModeRedC")
   kMenu("PVimgColorsFX", "Add", "&Green channel", "MenuSetColorModeGreenC")
   kMenu("PVimgColorsFX", "Add", "&Blue channel", "MenuSetColorModeBlueC")
   kMenu("PVimgColorsFX", "Add", "Alp&ha channel", "MenuSetColorModeAlphaC")
   kMenu("PVimgColorsFX", "Add", "&Inverted colors", "MenuSetColorModeInverted")
   kMenu("PVimgColorsFX", "Add", "&Sepia", "MenuSetColorModeSepia")
   If (thumbsDisplaying=1)
   {
      kMenu("PVimgColorsFX", "Disable", "&Auto-adjusted colors")
      kMenu("PVimgColorsFX", "Disable", "Alp&ha channel")
   }

   If (imgFxMode=1)
      kMenu("PVimgColorsFX", "Check", "&Original colors")
   Else If (imgFxMode=2)
      kMenu("PVimgColorsFX", "Check", "&Personalized colors")
   Else If (imgFxMode=3)
      kMenu("PVimgColorsFX", "Check", "&Auto-adjusted colors")
   Else If (imgFxMode=4)
      kMenu("PVimgColorsFX", "Check", "Grays&cale")
   Else If (imgFxMode=5)
      kMenu("PVimgColorsFX", "Check", "&Red channel")
   If (imgFxMode=6)
      kMenu("PVimgColorsFX", "Check", "&Green channel")
   Else If (imgFxMode=7)
      kMenu("PVimgColorsFX", "Check", "&Blue channel")
   Else If (imgFxMode=8)
      kMenu("PVimgColorsFX", "Check", "Alp&ha channel")
   Else If (imgFxMode=9)
      kMenu("PVimgColorsFX", "Check", "&Inverted colors")
   Else If (imgFxMode=10)
      kMenu("PVimgColorsFX", "Check", "&Sepia")
}

MenuSelectAllAction() {
   selectEntireImage("rm")
}

MenuDoOpenStartFolder() {
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()
   dummyTimerDelayiedImageDisplay(50)
   RemoveTooltip()
}

MenuToggleColorAdjustments() {
   If (imgFxMode=1)
   {
      ColorPanelTriggerImageUpdate("ignore-zoom")
   } Else
   {
      o_usrColorDepth := usrColorDepth
      imgFxMode := usrColorDepth := 1
      If (o_usrColorDepth=1)
         dummyTimerDelayiedImageDisplay(50)
      Else
         dummyTimerReloadThisPicture(50)
   }
}

MenuStartDrawingSelectionArea() {
   startDrawingShape("selection")
}

MenuStartDrawingShapes(dummy:=0) {
   startDrawingShape("shape", 0, dummy)
}

MenuResumeDrawingShapes() {
   startDrawingShape("selection", "resume")
}

MenuStartDrawingLines(dummy:=0) {
   startDrawingShape("line", 0, dummy)
}

createMenuLiveTools() {
   kMenu("PVlTools", "Add", "Live tools", "dummy")
   kMenu("PVlTools", "Disable", "Live tools")
   kMenu("PVlTools", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects")
   kMenu("PVlTools", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
   kMenu("PVlTools", "Add", "&Fill shapes`tAlt+Bksp", "PanelFillSelectedArea")
   kMenu("PVlTools", "Add", "Draw s&hape contours", "PanelDrawShapesInArea", "lines")
   kMenu("PVlTools", "Add", "&Draw predetermined lines or arcs`tCtrl+L", "PanelDrawLines")
   kMenu("PVlTools", "Add", "Draw f&reeform filled shape`tShift+P", "MenuStartDrawingShapes")
   kMenu("PVlTools", "Add", "Draw freeform &outline`tAlt+P", "MenuStartDrawingLines")
   kMenu("PVlTools", "Add", "&Insert te&xt`tShift+T", "PanelInsertTextArea")
   kMenu("PVlTools", "Add", "&Adjust vie&wport colours and effects`tU", "PanelColorsAdjusterWindow")
   kMenu("PVlTools", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea")
   If (AnyWindowOpen=10)
      kMenu("PVlTools", "Check", "&Adjust vie&wport colours and effects`tU")
   Else If (AnyWindowOpen=23)
      kMenu("PVlTools", "Check", "&Fill shapes`tAlt+Bksp")
   Else If (AnyWindowOpen=25)
      kMenu("PVlTools", "Check", "&Erase or fade area`tDelete")
   Else If (AnyWindowOpen=30)
      kMenu("PVlTools", "Check", "&Draw predetermined lines or arcs`tCtrl+L")
   Else If (AnyWindowOpen=32)
      kMenu("PVlTools", "Check", "&Insert te&xt`tShift+T")
   Else If (AnyWindowOpen=55)
      kMenu("PVlTools", "Check", "Desaturate color&s`tCtrl+G")
   Else If (AnyWindowOpen=64)
      kMenu("PVlTools", "Check", "&Paint brushes`tP")
   Else If (AnyWindowOpen=65)
      kMenu("PVlTools", "Check", "Draw s&hape contours")

   Menu, PVlTools, Add,
   kMenu("PVlTools", "Add", "Other operations", "dummy")
   kMenu("PVlTools", "Disable", "Other operations")
   kMenu("PVlTools", "Add", "Flip selected &horizontally`tShift+H", "FlipSelectedAreaH")
   kMenu("PVlTools", "Add", "Flip selected &vertically`tShift+V", "FlipSelectedAreaV")
   kMenu("PVlTools", "Add", "&Invert colors`tShift+I", "InvertSelectedArea")
   If (AnyWindowOpen!=10)
   {
      kMenu("PVlTools", "Add", "&Apply color effects inside selection`tShift+U", "ApplyColorAdjustsSelectedArea")
      kMenu("PVlTools", "Add", "&... outside the selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea")
   }
}

BuildImgLiveEditMenu() {
      If (editingSelectionNow!=1 && !AnyWindowOpen) || (thumbsDisplaying=1)
         Return

      deleteMenus()
      kMenu("PVmenu", "Add", "&Toggle tool panel`tM-Click\F8", "toggleImgEditPanelWindow")
      kMenu("PVmenu", "Add", "&Cancel / close panel`tEscape", "BtnCloseWindow")
      If (AnyWindowOpen!=10)
         kMenu("PVmenu", "Add", "&Apply tool`tEnter", "applyIMGeditFunction")

      Menu, PVmenu, Add,
      If (AnyWindowOpen!=24 && AnyWindowOpen!=31 && editingSelectionNow=1)
      {
         createMenuLiveTools()
         kMenu("PVmenu", "Add", "S&witch tool", ":PVlTools")
      }

      If (AnyWindowOpen=10)
      {
         Menu, PVmenu, Add,
         If (editingSelectionNow=1)
         {
            kMenu("PVmenu", "Add", "&Apply color effects inside selection`tShift+U", "ApplyColorAdjustsSelectedArea")
            kMenu("PVmenu", "Add", "&... outside the selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea")
         }

         kMenu("PVmenu", "Add", "&Activate viewport color adjustments`t\", "MenuToggleColorAdjustments")
         If (ForceNoColorMatrix!=1 && imgFxMode!=1)
            kMenu("PVmenu", "Check", "&Activate viewport color adjustments`t\")
         kMenu("PVmenu", "Add", "&Reset all adjustments to defaults`tCtrl+\", "BtnResetImageView")
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         Menu, PVmenu, Add, 
         kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction")
         kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction")
      }

      If (AnyWindowOpen=10 || AnyWindowOpen=64)
      {
         kMenu("PVmenu", "Add", "&Show selection`tE", "ToggleEditImgSelection")
         If (editingSelectionNow=1)
            kMenu("PVmenu", "Check", "&Show selection`tE")

         If (editingSelectionNow=1)
            kMenu("PVselv", "Add", "&Reset selection", "newImgSelection")
         Else
            kMenu("PVmenu", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && editingSelectionNow=1)
      {
         Menu, PVselv, Add, 
         kMenu("PVselv", "Add", "&Undo selection`tCtrl+Shift+Z", "ImgSelUndoAct")
         kMenu("PVselv", "Add", "&Redo selection`tCtrl+Shift+Y", "ImgSelRedoAct")
      }

      Menu, PVselv, Add, 
      kMenu("PVselv", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
      kMenu("PVselv", "Add", "Sho&w grid", "ToggleSelectGrid")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid")

      decideLiveSelectionBasedOnWindow(angleu, isToolGood)
      If (isToolGood=1)
      {
         infoSelShape := DefineVPselAreaMode()
         kMenu("PVselv", "Add", "C&ycle selection shape types`tShift+E", "toggleEllipseSelection")
         kMenu("PVselv", "Add", infoSelShape, "dummy")
         kMenu("PVselv", "Disable", infoSelShape)
      }

      kMenu("PVselv", "Add", "&Flip selection W/H`tW", "flipSelectionWH")
      kMenu("PVselv", "Add", "&Limit selection to image area`tL", "toggleLimitSelection")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "&Limit selection to image area`tL")

      Menu, PVmenu, Add, 
      If (editingSelectionNow=1)
      {
         If (AnyWindowOpen=24 || AnyWindowOpen=31) 
         {
            ; paste in place / transform tools
            kMenu("PVmenu", "Add", "&Paint alpha mask", "togglePaintingMode")
            If (liveDrawingBrushTool=1)
               kMenu("PVmenu", "Check", "&Paint alpha mask")
         } Else If (AnyWindowOpen=64)
         {
            kMenu("PVmenu", "Add", "&Painting mode", "togglePaintingMode")
            kMenu("PVmenu", "Add", "&Cycle painting modes`tK", "toggleBrushDrawInOutModes")
            If (liveDrawingBrushTool=1)
               kMenu("PVmenu", "Check", "&Painting mode")
         }

         createMenuSelectionRotationAspectRatio()
         kMenu("PVmenu", "Add", "&Selection area", ":PVselv")
         kMenu("PVmenu", "Add", "&Rotation and aspect ratio", ":PVselRatio")
      }

      If ((AnyWindowOpen=23 || AnyWindowOpen=65) && FillAreaShape=7) || ((AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55) && EllipseSelectMode=2 && editingSelectionNow=1)
      {
         createMenuSelectSizeShapes("simple")
         kMenu("PVmenu", "Add", "&Custom shape options", ":PVselSize")
      }

      If !AnyWindowOpen
         kMenu("PVmenu", "Add", "Selection &properties`tAlt+E", "PanelIMGselProperties")

      createMenuMainView()
      Menu, PVmenu, Add, 
      kMenu("PVmenu", "Add", "Image vie&w", ":PVview")
      If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && AnyWindowOpen!=64)
         kMenu("PVmenu", "Add", "&Hide dynamic object`tD", "toggleLiveEditObject")

      showThisMenu("PVmenu")
}

MenuCopyAction() {
   If (thumbsDisplaying=1)
      InvokeCopyFiles()
   Else
      CopyImage2clip()
}

MenuSelectAction() {
   If (thumbsDisplaying=1)
      MenuMarkThisFileNow()
   Else
      ToggleEditImgSelection()
}

MenuChangeZoomMinus() {
  changeZoom(-1)
}

MenuChangeZoomPlus() {
  changeZoom(1)
}

BuildSecondMenu() {
   ; main menu
   If (thumbsDisplaying=1)
   {
      invokeFileOptionsMenu()
      Return
   } Else If (editingSelectionNow=1 && useGdiBitmap() && StrLen(getIDimage(currentFileIndex))>4 && imgEditPanelOpened!=1)
   {
      invokeSelectionAreaMenu("DoubleClick")
      Return
   }

   deleteMenus()
   If (imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add", "Collapse panel`tF11", "toggleImgEditPanelWindow")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
      {
         kMenu("PVmenu", "Add", "Apply vie&wport effects inside selection`tEnter", "ApplyColorAdjustsSelectedArea")
         kMenu("PVmenu", "Add", "&... outside the selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea")
      } Else kMenu("PVmenu", "Add", "&Apply tool`tEnter", "applyIMGeditFunction")

      labelu := (AnyWindowOpen=10) ? "Close panel" : "Cancel tool"
      kMenu("PVmenu", "Add", labelu "`tEscape", "CloseWindow")
      Menu, PVmenu, Add, 
      kMenu("PVmenu", "Add", "Undo`tCtrl+Z", "ImgUndoAction", "image editing")
      kMenu("PVmenu", "Add", "Redo`tCtrl+Y", "ImgRedoAction", "image editing")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Select area`tE", "ToggleEditImgSelection", "image editing")
      Else
         kMenu("PVmenu", "Add", "Select all`tCtrl+A", "MenuSelectAllAction")
      kMenu("PVmenu", "Add", "Square`tR", "makeSquareSelection", "image editing selection")
      kMenu("PVmenu", "Add", "Flip selection W/H`tW", "flipSelectionWH", "image editing selection")
      kMenu("PVmenu", "Add", "Limit selection to image boundaries`tL", "toggleLimitSelection")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen!=10)
         kMenu("PVmenu", "Add", "&Rotate selection by 45°`tShift+R", "MenuSelRotation")

      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Reset image vie&w", "BtnResetImageView", "viewport")
      Else
         kMenu("PVmenu", "Add", "&Reset selection rotation`tShift+\", "resetSelectionRotation")

      Menu, PVmenu, Add, 
      kMenu("PVmenu", "Add", "Adapt image to viewport`t/", "ToggleImageSizingMode")
      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Toggle FX", "MenuToggleColorAdjustments")
      Else
         kMenu("PVmenu", "Add", "Hide tool preview object`tD", "toggleLiveEditObject")

      showThisMenu("PVmenu")
      Return
   }

   isWelcome := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   ; zt := (thumbsDisplaying=1) ? "file(s) to" : ""
   zt2 := (thumbsDisplaying=1) ? "list" : "image"
   kMenu("PVmenu", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "&Open image`tCtrl+O", "OpenDialogFiles")
   If isWelcome
      kMenu("PVmenu", "Add", "Open &folder`tShift+O", "OpenFolders")

   If (thumbsDisplaying!=1)
   {
      kMenu("PVmenu", "Add", "&New image`tCtrl+N", "PanelNewImage", "editing")
      kMenu("PVmenu", "Add", "&Acquire image", "AcquireWIAimage", "editing")
   }

   If !isWelcome
   {
      kMenu("PVmenu", "Add", "&Save " zt2 "`tCtrl+S", "PanelSaveImg")
      kMenu("PVmenu", "Add", "&Refresh " zt2 "`tF5", "RefreshImageFileAction", "reload revert image")
      Menu, PVmenu, Add, 

      If (thumbsDisplaying=1)
         kMenu("PVmenu", "Add", "S&elect file`tSpace", "MenuSelectAction")
      Else
         kMenu("PVmenu", "Add", "S&election area`tE", "MenuSelectAction", "create")

      kMenu("PVmenu", "Add", "&All / none`tCtrl+A", "MenuSelectAllAction")
      Menu, PVmenu, Add, 
      If (thumbsDisplaying!=1)
      {
         kMenu("PVmenu", "Add", "&Copy image`tCtrl+C", "CopyImage2clip")
         If (editingSelectionNow=1)
            kMenu("PVmenu", "Add", "Cut area`tCtrl+X", "CutSelectedArea", "create image editing selection")

         kMenu("PVmenu", "Add", "&Paste image`tCtrl+V", "tlbrPasteClipboardIMG")
      } Else
      {
         kMenu("PVmenu", "Add", "Cut file(s) (for E&xplorer)`tCtrl+X", "MenuExplorerCutFiles")
         kMenu("PVmenu", "Add", "&Copy file(s) to`tC", "InvokeCopyFiles")
         kMenu("PVmenu", "Add", "&Move file(s) to`tM", "PanelMoveCopyFiles")
         kMenu("PVmenu", "Add", "Pas&te file(s)`tCtrl+V", "MenuPasteHDropFiles")
      }

      kl := (editingSelectionNow=1 && thumbsDisplaying!=1) ? "area" : "file(s)"
      kMenu("PVmenu", "Add", "Er&ase " kl "`tDelete", "deleteKeyAction")
      Menu, PVmenu, Add, 
      If (maxFilesIndex>1)
      {
         kMenu("PVmenu", "Add", "Searc&h index`tF3", "PanelSearchIndex")
         kMenu("PVmenu", "Add", "&Jump to`tJ", "PanelJump2index")
      }

      kMenu("PVmenu", "Add", "Reset " zt2 " vie&w`t\", "ResetImageView")
      If (thumbsDisplaying=1)
      {
         Menu, PVmenu, Add, 
         kMenu("PVmenu", "Add", "&Toggle list modes`tL", "toggleListViewModeThumbs")
         If (thumbsListViewMode>1)
         {
            kMenu("PVmenu", "Add", "Increase text size`t+", "MenuChangeZoomPlus")
            kMenu("PVmenu", "Add", "Decrease text size`t-", "MenuChangeZoomMinus")
         } Else
         {
            kMenu("PVmenu", "Add", "More columns`t+", "MenuChangeZoomPlus")
            kMenu("PVmenu", "Add", "Fewer columns`t-", "MenuChangeZoomMinus")
         }
      } Else
      {
         Menu, PVmenu, Add, 
         If (maxFilesIndex>1)
         {
            infoThumbsMode := (thumbsDisplaying=1) ? "Image view" : "List view"
            kMenu("PVmenu", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode", "full view list")
            kMenu("PVmenu", "Add", "Start slideshow`tSpace", "dummyInfoToggleSlideShowu", "play")
         }
         kMenu("PVmenu", "Add", "Image information`tI", "ToggleHistoInfoBoxu", "histogram")
         kMenu("PVmenu", "Add", "Open previous panel`tF8", "openPreviousPanel", "last opened")
      }
   } Else
   {
      createMenuFavourites()
      createMenuHelpQPV()
      kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
      kMenu("PVmenu", "Add", "&Help", ":PVhelp")
   }

   showThisMenu("PVmenu")
}

BuildMainMenu(dummy:=0) {
   Static lastInvoked := 1
   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   If (imgEditPanelOpened=1)
   {
      deleteMenus()
      BuildImgLiveEditMenu()
      Return
   }

   If (AnyWindowOpen>0 && dummy!="forced")
   {
      If ((A_TickCount - lastInvoked < 650) && !MsgBox2hwnd)
         CloseWindow()
      Else If (panelWinCollapsed!=1)
         WinActivate, ahk_id %hSetWinGui%
      lastInvoked := A_TickCount
      Return
   }

   SetTimer, drawWelcomeImg, Off
   deleteMenus()
   ResetImgLoadStatus()
   Global lastWinDrag := A_TickCount
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1)
   {
      kMenu("PVedit", "Add", "New image`tCtrl+N", "PanelNewImage", "image editing")
      If (infoImgEditingNow=1)
      {
         kMenu("PVedit", "Add", "&Save image as...`tCtrl+S", "PanelSaveImg", "image editing")
         kMenu("PVedit", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image editing")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "C&ut selected area`tCtrl+X", "image editing")
         kMenu("PVedit", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
         kMenu("PVedit", "Add", "Close ima&ge and files list`tCtrl+F4", "closeDocuments", "renew reset")
      }

      kMenu("PVedit", "Add", "P&aste clipboard`tCtrl+V", "PasteClipboardIMG")
      If (thumbsDisplaying!=1 && infoImgEditingNow=1)
      {
         kMenu("PVedit", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "&Paste in place`tCtrl+Shift+V")
      }

      Menu, PVedit, Add,
      If (infoImgEditingNow=1)
         kMenu("PVedit", "Add", "Print image`tCtrl+P", "PanelPrintImage")

      kMenu("PVedit", "Add", "Ac&quire image (WIA)", "AcquireWIAimage")
      Menu, PVedit, Add, 
      If (editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1 && (CurrentSLD || StrLen(UserMemBMP)>2))
         kMenu("PVedit", "Add", "Create &selection area`tE", "newImgSelection", "image editing")
      Else If (editingSelectionNow!=1 && infoImgEditingNow=1)
         kMenu("PVedit", "Add", "Sho&w selection area`tE", "ToggleEditImgSelection", "image editing")

      createMenuImageEditSubMenus()
      ; Try kMenu("PVedit", ""Add", &Create", ":PVimgCreate")
      Try kMenu("PVedit", "Add", "&Filters", ":PVimgFilters")
      Try kMenu("PVedit", "Add", "&Draw", ":PVimgDraw")
      Try kMenu("PVedit", "Add", "&Transform", ":PVimgTransform")
   }

   createMenuFavourites()
   createMenuOpenRecents()

; main menu
   kMenu("PVmenu", "Add", "&Open...", ":PVopenF")
   kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
   If StrLen(mustOpenStartFolder)>3
      kMenu("PVmenu", "Add", "&Scan files in folder`tSpace/Wheel", "MenuDoOpenStartFolder", "open index")
   If (thumbsDisplaying=1)
      kMenu("PVmenu", "Add", "&Paste files`tCtrl+V", "PasteClipboardIMG", "index list")

   If (StrLen(UserMemBMP)>2 && thumbsDisplaying!=1)
   {
      Menu, PVmenu, Add,
      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction", "image edit")
         kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction", "image edit")
      }
      kMenu("PVmenu", "Add", "&Save image`tCtrl+S", "PanelSaveImg", "image edit")
      If CurrentSLD
         kMenu("PVmenu", "Add", "&Revert changes...`tF5", "RefreshImageFileAction", "reload refresh")
   } Else If (StrLen(UserMemBMP)>2 && thumbsDisplaying=1)
      kMenu("PVmenu", "Add", "&Return to image editing", "MenuReturnIMGedit", "back")

   Menu, PVmenu, Add,
   If (thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "&Edit image", ":PVedit")

   friendlyImgView := (thumbsDisplaying=1) ? "&Thumbnails view" : "Image vie&w"
   If (maxFilesIndex>0 && CurrentSLD)
   {
      infoThisFile := markedSelectFile ? "S&elected files" : "C&urrent file"
      If (thumbsDisplaying!=1 && editingSelectionNow=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion area", ":PVselv")
      }

      createMenuCurrentFilesActs()
      kMenu("PVmenu", "Add", infoThisFile, ":PVfilesActs")
      If markedSelectFile
      {
         createMenuSoloFile()
         kMenu("PVmenu", "Add", "&Active / focused file", ":PVtActFile")
      }

      If (thumbsDisplaying=1) || (thumbsDisplaying!=1 && editingSelectionNow!=1)
      {
         createMenuFilesIndexOptions()
         kMenu("PVmenu", "Add", "Files inde&x/list", ":PVfList")
      }

      If (thumbsDisplaying=1 && maxFilesIndex>1)
      {
         okay := (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_")) ? 0 : 1
         If okay
         {
            createMenuFilesSort()
            kMenu("PVmenu", "Add", "Sort images list b&y", ":PVsort", "images files")
         }
      }

      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbsListViewMode=1)
      {
         createMenuMainView()
         kMenu("PVmenu", "Add", friendlyImgView, ":PVview")
      }

      If (thumbsDisplaying!=1 && StrLen(UserMemBMP)<3 && currentFileIndex!=0)
      {
         createMenuAnnotations()
         kMenu("PVmenu", "Add", "&Annotation", ":PVsounds")
      }

      If (maxFilesIndex>2 || mustOpenStartFolder)
      {
         createMenuNavigation()
         kMenu("PVmenu", "Add", "Navi&gation", ":PVnav")
         If (thumbsDisplaying!=1 && editingSelectionNow!=1)
         {
            createMenuSlideshows()
            kMenu("PVmenu", "Add", "Slides&how", ":PVslide")
         }
      }
      Menu, PVmenu, Add,
   } Else If StrLen(UserMemBMP)>2
   {
      If (editingSelectionNow=1 && thumbsDisplaying!=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion", ":PVselv")
         kMenu("PVmenu", "Add", "&Edit image", ":PVedit")
      }

      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbsListViewMode=1)
      {
         createMenuMainView()
         kMenu("PVmenu", "Add", friendlyImgView, ":PVview")
      }
   }

   If (markedSelectFile && thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "Dro&p files selection`tShift+Tab", "dropFilesSelection")

   If (thumbsDisplaying=1 || mustPreventMenus=1)
   {
      createMenuFilesSelections()
      kMenu("PVmenu", "Add", "F&iles selection", ":PVfileSel")
   }

   If StrLen(filesFilter)>1
   {
      Menu, PVmenu, Add,
      kMenu("PVmenu", "Add", "Remove files list filter`tCtrl+Space", "MenuRemFilesListFilter")
      If testIsDupesList()
      {
         kMenu("PVmenu", "Add", "Auto-select &duplicates", "PanelAutoSelectDupes")
         If InStr(resultedFilesList[currentFileIndex, 23], "_")
            kMenu("PVmenu", "Add", "Change filter threshold", "PanelChangeHamDistThreshold")
      }
      Menu, PVmenu, Add,
   } Else If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
   {
      Menu, PVmenu, Add,
      thisKey := (thumbsDisplaying=1) ? "Ctrl+S" : "Ctrl+Shift+S"
      kMenu("PVmenu", "Add", "Save files list now`t" thisKey, "BTNsaveCurrentSlideshow")
      Menu, PVmenu, Add,
   }

   createMenuInterfaceOptions()
   createMenuMainPreferences()
   If (mustRecordSeenImgs=1 && mustPreventMenus=1)
   {
      createMenuSeenImages()
      kMenu("PVmenu", "Add", "Seen images options", ":PVseenImgs")
   }

   createMenuHelpQPV()
   kMenu("PVmenu", "Add", "Inter&face", ":PvUIprefs")
   kMenu("PVmenu", "Add", "Prefe&rences", ":PVprefs")
   ; If StrLen(UserMemBMP)<3
   kMenu("PVmenu", "Add", "Help", ":PVhelp")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "Restart`tShift+Esc", "restartAppu", "close renew")
   kMenu("PVmenu", "Add", "Exit`tEscape", "exitAppu", "close")
   showThisMenu("PVmenu")
}

createMenuSeenImages() {
   kMenu("PVseenImgs", "Add", "&Images seen in this session", "BtnViewedImages2List")
   kMenu("PVseenImgs", "Add", "&Retrieve list of all recorded seen images", "BtnALLviewedImages2List")
   kMenu("PVseenImgs", "Add", "&Purge records of inexistent files (seen images)", "CleanDeadFilesSeenImagesDB", "erase")
   kMenu("PVseenImgs", "Add", "&Erase the entire list of recorded seen images", "eraseSeenIMGsDB", "purge")
   kMenu("PVseenImgs", "Add", "&Seen images statistics", "PanelSeenStats")
}

kMenu(mena, actu, labelu, funcu:=0, keywords:=0) {
   Static objuA := [], indexu := 0
        , objuB := new hashtable()
        , objuC := []

   If (actu="Reset" && !mena)
   {
      indexu := 0
      objuA := []
      objuC := []
      objuB := ""
      objuB := new hashtable()
      Return
   } Else If (actu="Give" && !mena)
      Return [objuA, objuB, objuC]

   zLabelu := StrReplace(labelu, "%", "`%")
   zLabelu := StrReplace(zlabelu, ",", "`,")
   If (actu="Add" && funcu && labelu)
   {
      If !InStr(funcu, ":")
      {
         kLabelu := StrReplace(labelu, "&")
         gup := StrSplit(kLabelu, "`t")
         indexu++
         objuA[indexu] := [gup[1], funcu, keywords, 1, 0, mena, gup[2]]
         objuB[mena "-" klabelu] := indexu
      } Else
      {
         kLabelu := StrReplace(labelu, "&")
         kfuncu := StrReplace(funcu, ":")
         objuC[kfuncu, 1] := kLabelu ? kLabelu : "Q" mena
         objuC[kfuncu, 2] := mena
      }

      Menu, % mena, % actu, % zLabelu, % funcu
   } Else If (actu="Disable" || actu="Check") && labelu
   {
      kLabelu := StrReplace(labelu, "&")
      thisindexu := objuB[mena "-" klabelu]
      If (actu="Disable")
         objuA[thisindexu, 4] := 0
      Else If (actu="Check")
         objuA[thisindexu, 5] := 1

      Menu, % mena, % actu, % zLabelu
   }

}

SetMenuInfo(hMenu, maxHeight:=0, autoDismiss:=0, modeLess:=0, noCheck:=0) {
   cbSize := (A_PtrSize=8) ? 40 : 28
   VarSetCapacity(MENUINFO, cbSize)
   fMaskFlags := 0x80000000         ; MIM_APPLYTOSUBMENUS
   cyMax := maxHeight ? maxHeight : 0
   If maxHeight
      fMaskFlags |= 0x00000001      ; MIM_MAXHEIGHT

   If (autoDismiss=1 || modeLess=1 || noCheck=1)
      fMaskFlags |= 0x00000010      ; MIM_STYLE

   dwStyle := 0
   If (autoDismiss=1)
      dwStyle |= 0x10000000         ; MNS_AUTODISMISS

   If (modeLess=1)
      dwStyle |= 0x40000000         ; MNS_MODELESS

   If (noCheck=1)
      dwStyle |= 0x80000000         ; MNS_NOCHECK

   NumPut(cbSize, MENUINFO, 0, "UInt") ; DWORD
   NumPut(fMaskFlags, MENUINFO, 4, "UInt") ; DWORD
   NumPut(dwStyle, MENUINFO, 8, "UInt") ; DWORD
   NumPut(cyMax, MENUINFO, 12, "UInt") ; UINT
   ; NumPut(hbrBack, MENUINFO, 16, "Ptr") ; HBRUSH
   ; NumPut(dwContextHelpID, MENUINFO, 20, "UInt") ; DWORD
   ; NumPut(dwMenuData, MENUINFO, 24, "UPtr") ; ULONG_PTR

   Return DllCall("User32\SetMenuInfo","Ptr", hMenu, "Ptr", &MENUINFO)
}

showThisMenu(menarg) {
   If (VisibleQuickMenuSearchWin=1 && mustPreventMenus!=1)
      GoSub, QuickMenuSearchGUIAGuiClose

   If (A_TickCount - lastOtherWinClose<10) || (mustPreventMenus=1)
      Return

   doSuspendu(1)
   addJournalEntry("Invoked UI menu: " menarg)
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   interfaceThread.ahkassign("allowMenuReader", "yes")
   ; SetMenuInfo(MenuGetHandle(menarg), 0, 1)
   Menu, % menarg, Show
   interfaceThread.ahkassign("allowMenuReader", "no")
   ; showDelayedTooltip("Menu item selected:`n" A_ThisMenuItem " [" A_ThisMenu "]")
   isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
   If (isFakeWin=0)
      SetTimer, dummyUnSuspendu, -150
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   Global lastWinDrag := A_TickCount
   Global lastOtherWinClose := A_TickCount + 100
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
}

dummyUnSuspendu() {
   doSuspendu(0)
}

deleteMenus() {
    If (mustPreventMenus=1)
       Return

    Static menusList := "PVmenu|PVtFileOpen|PVtFileImgAct|PVselSize|PVselRatio|PVimgTransform|PVimgCreate|PVimgFilters|PVimgDraw|PVperfs|PVfileSel|PVslide|PVnav|PVview|PVfList|PVtActFile|PVfilesActs|PVprefs|PvUIprefs|PVfaves|PVopenF|PVsort|PVedit|PVselv|PVsounds|PvImgAdapt|PVimgColorsFX|PVimgSdepth|PVimgVProt|PVimgHistos|PVlTools|PVstats|PVseenImgs|PVhelp|PvUItoolbarMenu|PVshapeTension"
    kMenu(0, "Reset", 0)
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete
}

MenuSetImageAdaptAll() {
   IMGresizingMode := 0
   ToggleImageSizingMode()
}

MenuSetImageAdaptLarge() {
   IMGresizingMode := 1
   ToggleImageSizingMode()
}

MenuSetImageOriginalFixed() {
   IMGresizingMode := 2
   ToggleImageSizingMode()
}

MenuSetImageCustomZoom() {
   IMGresizingMode := 3
   ToggleImageSizingMode()
}

MenuSetImageStretchedWin() {
   IMGresizingMode := 4
   ToggleImageSizingMode()
}

MenuSetLockSelRatioUnlocked() {
   lockSelectionAspectRatio := 0
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSquare() {
   lockSelectionAspectRatio := 1
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSDTV() {
   lockSelectionAspectRatio := 2
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatio35mmFilm() {
   lockSelectionAspectRatio := 3
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioHDTV() {
   lockSelectionAspectRatio := 4
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioWide() {
   lockSelectionAspectRatio := 5
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioCustom() {
   lockSelectionAspectRatio := 6
   toggleImgSelectionAspectRatio()
}

MenuSetColorModeOriginal() {
   imgFxMode := 0
   ToggleImgFX(1)
}

MenuSetColorModePersonalized() {
   imgFxMode := 1
   ToggleImgFX(1)
}

MenuSetColorModeAuto() {
   imgFxMode := 2
   ToggleImgFX(1)
}

MenuSetColorModeGrayscale() {
   imgFxMode := 3
   ToggleImgFX(1)
}

MenuSetColorModeRedC() {
   imgFxMode := 4
   ToggleImgFX(1)
}

MenuSetColorModeGreenC() {
   imgFxMode := 5
   ToggleImgFX(1)
}

MenuSetColorModeBlueC() {
   imgFxMode := 6
   ToggleImgFX(1)
}

MenuSetColorModeAlphaC() {
   imgFxMode := 7
   ToggleImgFX(1)
}

MenuSetColorModeInverted() {
   imgFxMode := 8
   ToggleImgFX(1)
}

MenuSetColorModeSepia() {
   imgFxMode := 9
   ToggleImgFX(1)
}

MenuSetVPhistoNone() {
   showHistogram := 0
   ToggleImgHistogram(1)
}

MenuSetVPhistoLuminance() {
   showHistogram := 1
   ToggleImgHistogram(1)
}

MenuSetVPhistoRed() {
   showHistogram := 2
   ToggleImgHistogram(1)
}

MenuSetVPhistoGreen() {
   showHistogram := 3
   ToggleImgHistogram(1)
}

MenuSetVPhistoBlue() {
   showHistogram := 4
   ToggleImgHistogram(1)
}

MenuSetVPhistoAll() {
   showHistogram := 5
   ToggleImgHistogram(1)
}

MenuSetVPgraphHistoPeaks() {
   histogramMode := 2
   ToggleHistogramMode()
}

MenuSetVPgraphHistoMids() {
   histogramMode := 1
   ToggleHistogramMode()
}

MenuSetVPgraphHistoLows() {
   histogramMode := 0
   ToggleHistogramMode()
}

MenuSetSelectionShapeRect() {
   toggleEllipseSelection(0)
}

MenuSetSelectionShapeEllipse() {
   toggleEllipseSelection(1)
}

MenuSetSelectionShapeFreeform() {
   toggleEllipseSelection(2)
}

MenuSetSelectionPredefinedShape(a) {
   toggleEllipseSelection(2)
   predefinedVectorShapes(a)
}

MenuSetSelectShapeRightTriangle() {
   MenuSetSelectionPredefinedShape(1)
}

MenuSetSelectShapeTriangle() {
   MenuSetSelectionPredefinedShape(2)
}

MenuSetSelectShapeRhombus() {
   MenuSetSelectionPredefinedShape(3)
}

MenuSetSelectShapeBoxCallout() {
   MenuSetSelectionPredefinedShape(4)
}

MenuSetSelectShapeRoundCallout() {
   MenuSetSelectionPredefinedShape(5)
}

MenuSetSelectShape5star() {
   MenuSetSelectionPredefinedShape(6)
}

MenuSetSelectShape4star() {
   MenuSetSelectionPredefinedShape(7)
}

MenuSetSelectShapeHeart() {
   MenuSetSelectionPredefinedShape(8)
}

MenuSetSelectShapeUser() {
   MenuSetSelectionPredefinedShape(9)
}

MenuIncVPgridSize() {
   changeGridSize(1)
}

MenuDecVPgridSize() {
   changeGridSize(-1)
}

MenuResetImageColorDepth() {
   usrColorDepth := 0
   ToggleImgColorDepth(1)
}

MenuSetImageDepth2bits() {
   usrColorDepth := 1
   ToggleImgColorDepth(1)
}

MenuSetImageDepth3bits() {
   usrColorDepth := 2
   ToggleImgColorDepth(1)
}

MenuSetImageDepth4bits() {
   usrColorDepth := 3
   ToggleImgColorDepth(1)
}

MenuSetImageDepth5bits() {
   usrColorDepth := 4
   ToggleImgColorDepth(1)
}

MenuSetImageDepth6bits() {
   usrColorDepth := 5
   ToggleImgColorDepth(1)
}

MenuSetImageDepth7bits() {
   usrColorDepth := 6
   ToggleImgColorDepth(1)
}

MenuSetImageDepth8bits() {
   usrColorDepth := 7
   ToggleImgColorDepth(1)
}

MenuSetImageDepth16bits() {
   usrColorDepth := 8
   ToggleImgColorDepth(1)
}

MenuSelectionFlipH() {
   flipWHcustomShape("h")
}

MenuSelectionFlipV() {
   flipWHcustomShape("v")
}

MenuSelIncRotation() {
   changeSelRotation(1)
}

MenuSelDecRotation() {
   changeSelRotation(-1)
}

MenuSetVolumeDown() {
   ChangeVolume(-1)
}

MenuSetVolumeUp() {
   ChangeVolume(1)
}

MenuSetImgZoom(a, b) {
   zoomLevel := StrReplace(StrReplace(a, "`tNUM *"), "%")/100
   IMGresizingMode := 4
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   INIaction(1, "IMGresizingMode", "General")
   INIaction(1, "zoomLevel", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

MenuSetVProt(a, b) {
   vpIMGrotation := StrReplace(a, "°")
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   INIaction(1, "vpIMGrotation", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

ToggleDBdefaultSQLsort() {
   prevFilesSortMode := 0
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   INIaction(1, "prevOpenFolderPath", "General")
   showTOOLtip("Default sorting of the files is now set to none.`nTo set it otherwise,please choose a sorting mode in the Sort menu.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createMenuFilesSelections() {
   If (markedSelectFile>1)
   {
      kMenu("PVfileSel", "Add", "&First`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu("PVfileSel", "Add", "&Previous`tCtrl+Left", "navSelectedFilesPrev")
      kMenu("PVfileSel", "Add", "&Next`tCtrl+Right", "navSelectedFilesNext")
      kMenu("PVfileSel", "Add", "&Last`tCtrl+End", "jumpToFilesSelBorderLast")
      Menu, PVfileSel, Add
      kMenu("PVfileSel", "Add", "Invert selection`tShift+I", "invertFilesSelection", "files list")
   }

   If (markedSelectFile>1 || EntryMarkedMoveIndex)
      kMenu("PVfileSel", "Add", "Select none`tCtrl+D", "dropFilesSelection", "files list")
   kMenu("PVfileSel", "Add", "Select all`tCtrl+A", "selectAllFiles", "files list")
   kMenu("PVfileSel", "Add", "Select / deselect file`tTab / Space", "MenuMarkThisFileNow")
   kMenu("PVfileSel", "Add", "Select random", "PanelSelectRandomFiles")
   kMenu("PVfileSel", "Add", "Select all in same folder`tE", "QuickSelectFilesSameFolder")
   Menu, PVfileSel, Add
   If (markedSelectFile>1)
   {
      kMenu("PVfileSel", "Add", "Revie&w selected files`tR", "filterToFilesSelection")
      kMenu("PVfileSel", "Add", "Filter files list to selection`tCtrl+Tab", "filterToFilesSelection")
   }

   If (testIsDupesList()=1)
      kMenu("PVfileSel", "Add", "Select the other images in dupes group`tS", "keepSelectedDupeInGroup")
}

InvokeRecentMenu() {
   deleteMenus()
   createMenuOpenRecents("simple")
   showThisMenu("PVopenF")
}

InvokeFavesMenu() {
   deleteMenus()
   createMenuFavourites()
   showThisMenu("PVfaves")
}

createMenuOpenRecents(modus:=0) {
   countItemz := 0
   If (modus!="simple")
   {
      kMenu("PVopenF", "Add", "&Image or slideshow`tCtrl+O", "OpenDialogFiles", "open image files")
      kMenu("PVopenF", "Add", "&Folder recursively`tShift+O", "OpenFolders", "open image folder files")
      kMenu("PVopenF", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      If (maxFilesIndex<1 || !CurrentSLD)
         kMenu("PVopenF", "Add", "Insert file(s)`tInsert", "addNewFile2list", "images list")
   }

   If (allowRecordHistory=1 && mustPreventMenus!=1)
   {
      Menu, PVopenF, Add,
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      If (RegExMatch(Trimmer(LastOpenedImg), RegExFilesPattern) && FileRexists(Trimmer(LastOpenedImg)))
         kMenu("PVopenF", "Add", "&0. " PathCompact(Trimmer(LastOpenedImg), 30), "MenuOpenLastImg")

      historyList := readRecentEntries(0, 0)
      Loop, Parse, historyList, `n
      {
         If (A_Index>10)
            Break

         countItemz++
         testThis := StrReplace(A_LoopField, "|")
         If (StrLen(A_LoopField)<4 || !FileExist(testThis))
            Continue

         entryu := PathCompact(testThis, 30)
         If InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= "\" ; entryu
         If !InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= " (*)"
         If RegExMatch(A_LoopField, sldsPattern)
            entryu := "# " entryu

         kMenu("PVopenF", "Add", "&" countItemz ". " entryu, "OpenRecentEntry")
      }

      Menu, PVopenF, Add, 
      If FolderExist(prevFileSavePath)
         aListu := prevFileSavePath "`n"
      If (FolderExist(prevFileMovePath) && !InStr(aListu, prevFileMovePath "`n"))
         aListu .= prevFileMovePath "`n"
      If (FolderExist(prevOpenFolderPath) && !InStr(aListu, prevOpenFolderPath "`n"))
         aListu .= prevOpenFolderPath "`n"

      Loop, Parse, aListu, `n
      {
         If !A_LoopField
            Continue

         kMenu("PVopenF", "Add", "O" A_Index ". " PathCompact(A_LoopField, 30), "OpenRecentEntry")
         ; kMenu("PVopenF", "Add", "% "O" A_Index ". " SubStr(A_LoopField, -30)", "OpenRecentEntry")
      }
   }

   Menu, PVopenF, Add, 
   If (countItemz>0 || mustPreventMenus=1)
      kMenu("PVopenF", "Add", "&Erase history list", "EraseOpenedHistory", "files")

   kMenu("PVopenF", "Add", "&Record recently opened", "ToggleRecordOpenHistory", "files")
   If (allowRecordHistory=1)
      kMenu("PVopenF", "Check", "&Record recently opened")
}

createMenuFavourites() {
   If (mustPreventMenus!=1)
      favesList := readMiniFavesEntries()

   Loop, Parse, favesList, `n
   {
      If (A_Index>15)
         Break

      countItemz++
      If !Trimmer(A_LoopField)
         Continue

      entryu := PathCompact(A_LoopField, 30)
      If StrLen(entryu)>3
      {
         countFaved++
         kMenu("PVfaves", "Add", "&" countItemz ". " entryu, "OpenFavesEntry")
      }
   }

   If !countFaved
   {
      kMenu("PVfaves", "Add", "No image added to favourites", "dummy")
      kMenu("PVfaves", "Disable", "No image added to favourites")
   } Else If (userAddedFavesCount>15)
   {
      moru := userAddedFavesCount - 15
      kMenu("PVfaves", "Add", "... and another " moru " images", "dummy")
      kMenu("PVfaves", "Disable", "... and another " moru " images")
   }

   Menu, PVfaves, Add
   kMenu("PVfaves", "Add", "&Cycle favourites list on open", "ToggleCycleFavesOpen")
   If (cycleFavesOpenIMG=1)
      kMenu("PVfaves", "Check", "&Cycle favourites list on open")

   kMenu("PVfaves", "Add", "&Add/remove current image to favourites`tB", "ToggleImgFavourites")
   If !(maxFilesIndex>0 && CurrentSLD)
      kMenu("PVfaves", "Disable", "&Add/remove current image to favourites`tB")

   If !countFaved
      IniAction(0, "userAddedFavesCount", "General", 4)

   If (countFaved>1 || userAddedFavesCount>1)
   {
      kMenu("PVfaves", "Add", "&Manage the favourites list", "retrieveFavesAsList", "open faves favorites")
      kMenu("PVfaves", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")
   }
}

createMenuStatistics() {
   kMenu("PVstats", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")
   kMenu("PVstats", "Add", "Open &file statistics panel", "PanelIndexedFilesStats")
   kMenu("PVstats", "Add", "&Collect file details", "BtnCollectFileInfos")
   kMenu("PVstats", "Add", "Open &images statistics panel", "PanelIndexedImagesStats")
   kMenu("PVstats", "Add", "Collect/index image &properties", "BtnCollectImageInfos")
   kMenu("PVstats", "Add", "Collect/index image &histograms properties", "BtnCollectHistoInfos")
   kMenu("PVstats", "Add", "C&reate custom files list filter`tCtrl+F", "PanelEnableFilesFilter")
}

createMenuFilesIndexOptions() {
   StringRight, infoPrevMovePath, prevFileMovePath, 25
   infoMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "Reload .SLD file" : "Refresh opened folder(s)"
   pathu := PathCompact(CurrentSLD, 40)
   If pathu
   {
      kMenu("PVfList", "Add", infoMenuRefresh "`tShift+F5", "RefreshFilesList", "reload refresh list files")
      If RegExMatch(CurrentSLD, sldsPattern)
      {
         kMenu("PVfList", "Add", pathu, "RefreshFilesList")
         kMenu("PVfList", "Disable", pathu)
      }
   }

   Menu, PVfList, Add,
   kMenu("PVfList", "Add", "Import list / insert file(s)`tInsert", "addNewFile2list")
   kMenu("PVfList", "Add", "&Add folder(s)`tShift+Insert", "addNewFolder2list")
   kMenu("PVfList", "Add", "Mana&ge folder(s) list`tAlt+U", "PanelDynamicFolderzWindow")
   If (maxFilesIndex>2)
   {
      kMenu("PVfList", "Add", "Save files list as &.SLD`tCtrl+Shift+S", "PanelSaveSlideShowu")
      Menu, PVfList, Add,
      If (thumbsDisplaying=1 && !markedSelectFile)
      {
         If !EntryMarkedMoveIndex
            kMenu("PVfList", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
         Else
            kMenu("PVfList", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
      } Else If (thumbsDisplaying=1 && markedSelectFile>1)
            kMenu("PVfList", "Add", "Move sele&cted entries to focused index`tShift+X", "MenuMoveMarkedEntries")

      If !markedSelectFile
      {
         kMenu("PVfList", "Add", "&Modify focused index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         kMenu("PVfList", "Add", "Remove focused inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      }

      kMenu("PVfList", "Add", "Auto-remove entries of dead files", "ToggleAutoRemEntries")
      If (autoRemDeadEntry=1)
         kMenu("PVfList", "Check", "Auto-remove entries of dead files")

      Menu, PVfList, Add,
      ; If RegExMatch(CurrentSLD, sldsPattern)
      kMenu("PVfList", "Add", "Clean &duplicate / inexistent entries", "cleanDeadFilesList", "remove dead files erase")
      If StrLen(DynamicFoldersList)>6
         kMenu("PVfList", "Add", "&Regenerate the entire list", "RegenerateEntireList")
      If (RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         kMenu("PVfList", "Add", "&Update files list selectively`tCtrl+U", "PanelStaticFolderzManager")
      If (mustRecordSeenImgs=1)
         kMenu("PVfList", "Add", "Remove alread&y seen images", "removeFilesListSeenImages", "eliminate")
      If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         kMenu("PVfList", "Add", "Remove fa&vourited images from list", "removeFilesListFavouritedImages", "eliminate")

      Menu, PVfList, Add, 
      kMenu("PVfList", "Add", "&Find duplicate images", "PanelFindDupes")
      If (mustPreventMenus=1)
      {
         createMenuStatistics()
         kMenu("PVfList", "Add", "&Statistics main panel", "PanelWrapperFilesStats")
         kMenu("PVfList", "Add", "&Statistics", ":PVstats")
      } Else
         kMenu("PVfList", "Add", "&Statistics", "PanelWrapperFilesStats", "files index list")

      kMenu("PVfList", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
      kMenu("PVfList", "Add", "Search and re&place`tCtrl+H", "PanelSearchAndReplaceIndex", "files index list")
      kMenu("PVfList", "Add", "&Index filters`tCtrl+F", "PanelEnableFilesFilter", "files list")
      If StrLen(filesFilter)>1
         kMenu("PVfList", "Check", "&Index filters`tCtrl+F")
   }
}

createMenuInterfaceOptions() {
   infoThumbsList := defineListViewModes()
   infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
   If (thumbsDisplaying=1)
      kMenu("PvUIprefs", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")

   If (maxFilesIndex>0 && !AnyWindowOpen)
      kMenu("PvUIprefs", "Add", infoThumbsMode "`tEnter/MClick", "MenuDummyToggleThumbsMode")
   If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
      kMenu("PvUIprefs", "Add", "Open pre&vious panel`tF8", "openPreviousPanel", "show")

   If (thumbsDisplaying!=1 && !AnyWindowOpen)
      kMenu("PvUIprefs", "Add", "&Toggle full-screen mode`tF11", "ToggleFullScreenMode")

   If (thumbsDisplaying!=1)
   {
      kMenu("PvUIprefs", "Add", "&Touch screen mode", "ToggleTouchMode")
      If (TouchScreenMode=1)
         kMenu("PvUIprefs", "Check", "&Touch screen mode")
   }

   kMenu("PvUIprefs", "Add", "&Large UI fonts", "ToggleLargeUIfonts", "disability handicap eyes eyesight large display")
   If (PrefsLargeFonts=1)
      kMenu("PvUIprefs", "Check", "&Large UI fonts")

   kMenu("PvUIprefs", "Add", "Increase viewport text size`tCtrl+Plus", "MenuChangeZoomPlus", "disability handicap eyes eyesight large")
   kMenu("PvUIprefs", "Add", "Decrease viewport text size`tCtrl+Minus", "MenuChangeZoomMinus", "disability  handicap eyes eyesight large")
   Menu, PvUIprefs, Add,
   kMenu("PvUIprefs", "Add", "&Always on top", "ToggleAllonTop", "window")
   If (getTopMopStyle(PVhwnd)=1)
      kMenu("PvUIprefs", "Check", "&Always on top")

   keyword := (folderTreeWinOpen=1) ? " hide" : " display"
   kMenu("PvUIprefs", "Add", "Show &folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview explore" keyword)
   If (folderTreeWinOpen=1)
      kMenu("PvUIprefs", "Check", "Show &folders tree panel`tF4")

   If (thumbsDisplaying!=1)
   {
      createMenuVPhudHisto()
      kMenu("PvUIprefs", "Add", "Show histogram", ":PVimgHistos")
   }

   keyword := (showMainMenuBar=1) ? " hide" : " display"
   kMenu("PvUIprefs", "Add", "Show &quick bar`tF10", "ToggleQuickBaru", "toolbar" keyword)
   If (showMainMenuBar=1)
      kMenu("PvUIprefs", "Check", "Show &quick bar`tF10")

   keyword := (ShowAdvToolbar=1) ? "hide" : "display"
   kMenu("PvUIprefs", "Add", "Show &toolbar", "toggleAppToolbar", keyword)
   If (ShowAdvToolbar=1)
      kMenu("PvUIprefs", "Check", "Show &toolbar", "toggleAppToolbar")

   If (thumbsDisplaying!=1)
   {
      kMenu("PvUIprefs", "Add", "&Hide title bar", "ToggleTitleBaru", "window")
      If (getCaptionStyle(PVhwnd)=1)
         kMenu("PvUIprefs", "Check", "&Hide title bar")
   }

   Menu, PvUIprefs, Add,
   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
   {
      kMenu("PvUIprefs", "Add", "&Highlight already seen images", "ToggleMarkSeenIMGs", "thumbnails")
      If (highlightAlreadySeenImages=1)
         kMenu("PvUIprefs", "Check", "&Highlight already seen images")
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
      kMenu("PvUIprefs", "Add", "&Viewport and image details`tI", "ToggleInfoBoxu", "files information properties " keyword)
      If (showInfoBoxHUD>=1)
         kMenu("PvUIprefs", "Check", "&Viewport and image details`tI")
   }

   If (maxFilesIndex>0 && CurrentSLD && thumbsDisplaying!=1 && !AnyWindowOpen)
   {
      kMenu("PvUIprefs", "Add", "&Ambiental textured background", "ToggleTexyBGR", "viewport image performance")
      If (usrTextureBGR=1)
         kMenu("PvUIprefs", "Check", "&Ambiental textured background")
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showHUDnavIMG=1) ? " hide" : " show display"
      friendly := (thumbsDisplaying=1) ? "Image previe&w box`tZ" : "Auto-display image navi&gator`tZ"
      kMenu("PvUIprefs", "Add", friendly, "ToggleImgNavBox", "map" keyword)
      If (thumbsListViewMode=1 && thumbsDisplaying=1)
         Menu, PvUIprefs, Delete, % friendly
      Else If (showHUDnavIMG=1)
         kMenu("PvUIprefs", "Check", friendly)
   }

   Menu, PvUIprefs, Add, 
   If !AnyWindowOpen
      kMenu("PvUIprefs", "Add", "Additional settings`tF12", "PanelPrefsWindow")
}

EraseOpenedHistory() {
   Loop, 15
       IniWrite, 0, % mainRecentsFile, RecentOpen, E%A_Index%
   IniWrite, 0, % mainSettingsFile, General, LastOpenedImg
}

OpenRecentEntry(menuItem) {
  testOs := menuItem
  If askAboutFileSave(" and another image will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  startZeit := A_TickCount
  If RegExMatch(testOs, "i)^(o1\. )")
     openThisu := prevFileSavePath
  Else If RegExMatch(testOs, "i)^(o2\. )")
     openThisu := prevFileMovePath
  Else If RegExMatch(testOs, "i)^(o3\. )")
     openThisu := prevOpenFolderPath

  If openThisu
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     PopulateIndexFilesStatsInfos("kill")
     SlidesMusicSong := ""
     coreOpenFolder("|" openThisu, 1, 0, 1)
     currentFilesListModified := 0
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
     SetTimer, TriggerMenuBarUpdate, -90
     If (maxFilesIndex>0)
        SLDtypeLoaded := 1
     ; Else resetMainWin2Welcome()
     Return
  }

  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  IniRead, newEntry, % mainRecentsFile, RecentOpen, E%openThisu%, @
  ; MsgBox, %openthisu% -- %newentry%
  newEntry := Trimmer(newEntry)
  If StrLen(newEntry)>4
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     If RegExMatch(newEntry, sldsPattern)
     {
        OpenSLD(newEntry)
     } Else
     {
        PopulateIndexFilesStatsInfos("kill")
        prevOpenFolderPath := StrReplace(newEntry, "|")
        If FolderExist(prevOpenFolderPath)
           INIaction(1, "prevOpenFolderPath", "General")
        coreOpenFolder(newEntry, 1, 0, 1)
        currentFilesListModified := 0
        SlidesMusicSong := ""
        interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
        If (maxFilesIndex>0)
           SLDtypeLoaded := 1

        SetTimer, TriggerMenuBarUpdate, -90
        ; Else resetMainWin2Welcome()
     }
  }
  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

OpenFavesEntry(menuItem) {
  testOs := menuItem
  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  If (InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") && maxFilesIndex>500)
  {
     currentFileIndex := openThisu
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  If askAboutFileSave(" and the selected image from favourites will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  startZeit := A_TickCount
  contentu := readMiniFavesEntries()
  Loop, Parse, contentu, `n, `r
  {
      If (openThisu=A_Index)
      {
         newEntry := Trimmer(A_LoopField)
         Break
      }
   }

  ; IniRead, newEntry, % mainRecentsFile, favourites, E%openThisu%, @
  If !FileRexists(newEntry)
  {
     msgResult := msgBoxWrapper(appTitle ": ERROR", "The file you are trying to open seems to no longer exist. Would you like to remove it from the favourites list?", 4, 0, "question")
     If InStr(msgResult, "yes")
        ToggleImgFavourites(newEntry, "rem")
  } Else If (cycleFavesOpenIMG=1 && newEntry!="@" && StrLen(newEntry)>2)
  {
     retrieveFavesAsList(openThisu)
     Return
  } Else If (newEntry!="@" && StrLen(newEntry)>2)
  {
     MenuOpenLastImg(newEntry)
     resultedFilesList[currentFileIndex, 5] := 1
     currentImgModified := 0
     SlidesMusicSong := ""
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  }

  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

INIaction(act, var, section, type:=0, mini:=0, maxy:=0, forcedDef:="", iniFile:="") {
   thisIniFile := iniFile ? iniFile : mainSettingsFile
   varValue := %var%
   If (act=1)
   {
      If (var="FillAreaCustomShape")
         varValue := SubStr(varValue, 1, 64321)
      IniWrite, %varValue%, % thisIniFile, %section%, %var%
      If ErrorLevel
         fnOutputDebug("Error saving INI settings: " var )
   } Else
   {
      defaultu := (forcedDef!="") ? forcedDef : %var%
      IniRead, %var%, % thisIniFile, %section%, %var%, %varValue%
      If ErrorLevel
         fnOutputDebug("Error loading INI settings: " var )

      loadedValue := %var%
      If (type=1) ; binary
      {
         loadedValue := (Round(loadedValue)=0 || Round(loadedValue)=1) ? Round(loadedValue) : defaultu
         %var% := loadedValue
      } Else If (type=2)  ; range min/max
      {
         If !isNumber(loadedValue)
         {
            %var% := defaultu
         } Else
         {
            loadedValue := clampInRange(loadedValue, mini, maxy)
            %var% := loadedValue
         }
      } Else If (type=3)  ; HEX colour
      {
         loadedValue := Trimmer(loadedValue)
         If (loadedValue ~= "[^[:xdigit:]]") || (StrLen(loadedValue)!=6)
            loadedValue := defaultu
         %var% := loadedValue
      } Else If (type=4)  ; isNumber
      {
         If !isNumber(loadedValue)
            %var% := defaultu
      } Else If (loadedValue="error" && type=5)
         %var% := defaultu
   }
}

ToggleFullScreenMode() {
   Static prevState := 1, o_TouchScreenMode := "a"
   If (thumbsDisplaying=1)
   {
      ; o_TouchScreenMode := TouchScreenMode
      ToggleThumbsMode()
      Return
   }

  ; If (tempBtnVisible!="null")
     ; DestroyTempBtnGui("now")

  prevState := !prevState
  If (prevState=0)
  {
     If (showMainMenuBar=1)
     {
        showMainMenuBar := 0
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        Win_SetMenu(PVhwnd, 0)
        TriggerMenuBarUpdate()
     }
     ; o_TouchScreenMode := TouchScreenMode
     If (userAllowWindowDrag=1)
        TouchScreenMode := 0
     isTitleBarHidden := 0
     If (editingSelectionNow=1)
       ToggleEditImgSelection()
     WinSet, Style, -0xC00000, ahk_id %PVhwnd%
     WinMaximize, ahk_id %PVhwnd%
  } Else
  {
     ; If (o_TouchScreenMode!="a")
     ;    TouchScreenMode := o_TouchScreenMode
     isTitleBarHidden := 1
     WinSet, Style, +0xC00000, ahk_id %PVhwnd%
     WinRestore, ahk_id %PVhwnd%
     INIaction(0, "showMainMenuBar", "General", 1)
     INIaction(0, "TouchScreenMode", "General", 1)
     If (showMainMenuBar=1)
     {
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        TriggerMenuBarUpdate()
     }
  }

  interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
  interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
  interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
  ; INIaction(1, "isTitleBarHidden", "General")
  ; INIaction(1, "TouchScreenMode", "General")

  SetTimer, dummyFullScreenButtons, -350
}

dummyFullScreenButtons() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  If (editingSelectionNow=1 || showHistogram>1 || showInfoBoxHUD>=1)
  {
     2ndLabel := "Hide viewport elements"
     2ndact := "turnOffViewportStuff"
  }

  If (userAllowWindowDrag=1 && isTitleBarHidden=0)
  {
     1stLabel := "Deactivate window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else If (userAllowWindowDrag=0 && isTitleBarHidden=0)
  {
     1stLabel := "Allow window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else ; If (isTitleBarHidden=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  showTOOLtip(friendly)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleWindowDraggableMode() {
   userAllowWindowDrag := !userAllowWindowDrag
   If (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1)
      TouchScreenMode := 0
   Else If (userAllowWindowDrag=0)
      INIaction(0, "TouchScreenMode", "General", 1)

   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
   INIaction(1, "userAllowWindowDrag", "General")
}

turnOffViewportStuff() {
   If (showHistogram>1 || showInfoBoxHUD>=1)
      ToggleHistoInfoBoxu()
   If (editingSelectionNow=1)
      ToggleEditImgSelection()
   DestroyTempBtnGui("now")
}

ToggleAllonTop() {
   isAlwaysOnTop := !isAlwaysOnTop
   WinSet, AlwaysOnTop, % isAlwaysOnTop, ahk_id %PVhwnd%
   INIaction(1, "isAlwaysOnTop", "General")
   interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
   friendly := (isAlwaysOnTop=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Window always on top: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleEasySlideStop() {
   easySlideStoppage := !easySlideStoppage
   INIaction(1, "easySlideStoppage", "General")
}

ToggleSlidesFXmode() {
   slidesFXrandomize := !slidesFXrandomize
   INIaction(1, "slidesFXrandomize", "General")
   interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
   friendly := (slidesFXrandomize=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Randomize colour FX during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSelKeepRatioRotation() {
   rotateSelBoundsKeepRatio := !rotateSelBoundsKeepRatio
   INIaction(1, "rotateSelBoundsKeepRatio", "General")
   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
}

ToggleGIFsPlayEntirely() {
   allowGIFsPlayEntirely := !allowGIFsPlayEntirely
   INIaction(1, "allowGIFsPlayEntirely", "General")
   friendly := (allowGIFsPlayEntirely=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Allow GIFs play entirely during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleRecordSeenImages() {
   mustRecordSeenImgs := !mustRecordSeenImgs
   If (sqlFailedInit=1 && mustRecordSeenImgs=1)
   {
      mustRecordSeenImgs := 0
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when attempting to initialize SqlLite Database.`n`nFeature not available.", 0, 0, "error")
   }

   INIaction(1, "mustRecordSeenImgs", "General")
   friendly := (mustRecordSeenImgs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Record images seen through QPV: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipSeenIMGs() {
   skipSeenImageSlides := !skipSeenImageSlides
   INIaction(1, "skipSeenImageSlides", "General")
   friendly := (skipSeenImageSlides=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Skip already seen images: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoResetImageView() {
   If (AnyWindowOpen=10)
      GuiControlGet, resetImageViewOnChange, SettingsGUIA:, resetImageViewOnChange
   Else
      resetImageViewOnChange := !resetImageViewOnChange

   INIaction(1, "resetImageViewOnChange", "General")
   If !AnyWindowOpen
   {
      friendly := (resetImageViewOnChange=1) ? "ACTIVATED" : "DEACTIVATED"
      showTOOLtip("Reset viewing options on image change: " friendly)
      SetTimer, RemoveTooltip, % -msgDisplayTime 
   }
}

toggleListViewModeThumbs() {
   If (thumbsDisplaying!=1)
      Return

   thumbsListViewMode++
   If (thumbsListViewMode>4)
      thumbsListViewMode := 1

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      initAHKhThumbThreads()

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   friendly := defineListViewModes()
   If StrLen(userSearchString)>1
      friendly .= "`nFiles matching search criteria are highlighted:`n" userSearchString

   If (ShowAdvToolbar=1)
      decideIconBTNthumbsList()
   showTOOLtip("List view: " friendly, A_ThisFunc, 1, thumbsListViewMode/4)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineListViewModes() {
   infoThumbsSize := (thumbsDisplaying=1) ? " (" thumbsW " x " thumbsH " px )" : ""
   If (thumbsListViewMode=1)
      friendly := "THUMBNAILS"
   Else If (thumbsListViewMode=2)
      friendly := "COMPACT"
   Else If (thumbsListViewMode=3)
      friendly := "FILE DETAILS"
   Else If (thumbsListViewMode=4)
      friendly := "IMAGE DETAILS"

   Return friendly
}

ToggleAutoPlaySND() {
   autoPlaySNDs := !autoPlaySNDs
   INIaction(1, "autoPlaySNDs", "General")
   friendly := (autoPlaySNDs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-play associated sound file: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSyncSlide2sndDuration() {
   syncSlideShow2Audios := !syncSlideShow2Audios
   INIaction(1, "syncSlideShow2Audios", "General")
   friendly := (syncSlideShow2Audios=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Wait for complete playback of audio files during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSlidesTransitions() {
   doSlidesTransitions := !doSlidesTransitions
   INIaction(1, "doSlidesTransitions", "General")
   friendly := (doSlidesTransitions=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Smooth slideshow transitions: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMarkSeenIMGs() {
   highlightAlreadySeenImages := !highlightAlreadySeenImages
   INIaction(1, "highlightAlreadySeenImages", "General")
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      dummyTimerDelayiedImageDisplay(50)
}

TglUseCacheSLDinfo() {
   useCachedSLDdata := !useCachedSLDdata
   INIaction(1, "useCachedSLDdata", "General")
   If (useCachedSLDdata=1)
      showTOOLtip("SQL database cached data will be used to sort the files list", A_ThisFunc, 1)
   Else
      showTOOLtip("SQL database cached data will NOT be used to sort the files list", A_ThisFunc, 1)

   SetTimer, RemoveTooltip, % -msgDisplayTime + 1500
}

TglRvrSort() {
   reverseOrderOnSort := !reverseOrderOnSort
   INIaction(1, "reverseOrderOnSort", "General")
   friendly := (reverseOrderOnSort=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Reverse order on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TglCheckDeadFilesSort() {
   OnSortdoFilesCheck := !OnSortdoFilesCheck
   INIaction(1, "OnSortdoFilesCheck", "General")
   friendly := (OnSortdoFilesCheck=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-remove inexistent files on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleHistoInfoBoxu() {
   prevState := (showHistogram>1 || showInfoBoxHUD>=1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (prevState!=1)
   {
      If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
         Return
   }

   showHistogram := (prevState=0) ? 1 : 0
   showInfoBoxHUD := (prevState=0) ? 1 : 2
   ToggleImgHistogram(1)
   ToggleInfoBoxu()
   RemoveTooltip()
}

ToggleInfoBoxu() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 85) ; || (thumbsDisplaying=1)
       Return

    lastInvoked := A_TickCount
    showInfoBoxHUD++
    showInfoBoxHUD := clampInRange(showInfoBoxHUD, 0, 2, 1)
    INIaction(1, "showInfoBoxHUD", "General")
    If (thumbsDisplaying=1)
       SetTimer, mainGdipWinThumbsGrid, -50
    Else
       SetTimer, dummyRefreshImgSelectionWindow, -50
    ; dummyTimerDelayiedImageDisplay(50)
}

ToggleImgCaptions() {
    Static lastInvoked := 1
    If (thumbsDisplaying=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    showImgAnnotations := !showImgAnnotations
    INIaction(1, "showImgAnnotations", "General")
    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (showImgAnnotations=1)
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       textFile := OutDir "\" OutNameNoExt ".txt"
       If (SLDtypeLoaded=3)
          textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

       If (!FileExist(textFile) && SLDtypeLoaded!=3) || (!textFileContent && SLDtypeLoaded=3)
          showTOOLtip("Display image captions: ACTIVATED`n" OutNameNoExt ".txt (NOT FOUND)`nNo image caption / annotation file associated`nPress Shift+N to create/edit one.", A_ThisFunc, 1)
       Else
          showTOOLtip("Display image captions: ACTIVATED", A_ThisFunc, 1)
    } Else showTOOLtip("Display image captions: DEACTIVATED", A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiLineStatus() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55)
       Return

    lastInvoked := A_TickCount
    multilineStatusBar := !multilineStatusBar
    INIaction(1, "multilineStatusBar", "General")
    dummyTimerDelayiedImageDisplay(50)
    CreateGuiButton("File options,,invokeFileOptionsMenu", 0, msgDisplayTime//1.5 + 500)
}

invokeFileOptionsMenu() {
   deleteMenus()
   createMenuCurrentFilesActs()
   showThisMenu("PVfilesActs")
}

invokeSelectionAreaMenu(modus:=0) {
   deleteMenus()
   createMenuSelectionArea(modus)
   showThisMenu("PVselv")
}

invokeNavigationMenu() {
   deleteMenus()
   createMenuNavigation()
   showThisMenu("PVnav")
}

folderzNavLoadAllSiblings() {
   initialFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)
   baseFolder := StrReplace(baseFolder, "|")
   If FolderExist(baseFolder)
      OpenFolders(baseFolder)
}

invokeFoldersListerMenu() {
    Static menusList := "PVmFsibs|PVmFsubs|PVmFparents|PVmFexplorer"

    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete

    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    If !InStr(baseFolder, ":\")
       Return "err"

    showTOOLtip("Identifing sibling and parent folders for`n" baseFolder)
    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    If (sibsObj.Count()>1)
    {
       Try Menu, PVmFsibs, Add, &See all, folderzNavLoadAllSiblings
       Try Menu, PVmFsibs, Add,
    }

    Loop, % sibsObj.Count()
    {
       Try Menu, PVmFsibs, Add, % A_Index ". " sibsObj[A_Index], folderzNavInvokeSib
       If (A_Index=currentSib)
          Try Menu, PVmFsibs, Check, % A_Index ". " sibsObj[A_Index]
    }

    Loop, % parentsObj.Count()
    {
       Try Menu, PVmFparents, Add, % A_Index ". " parentsObj[A_Index], folderzNavInvokeParents
       If (A_Index=1)
          Try Menu, PVmFparents, Disable, % A_Index ". " parentsObj[A_Index]

       If (A_Index=currentParent)
          Try Menu, PVmFparents, Check, % A_Index ". " parentsObj[A_Index]
    }

    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If (SLDtypeLoaded=1)
    {
       Menu, PVmFsubs, Add, &See all`tCtrl+F5, invertCurrentFolderRecursiveness
       If !InStr(CurrentSLD, "|")
          Menu, PVmFsubs, Check, &See all`tCtrl+F5
       Menu, PVmFsubs, Add,
    }

    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_LoopFileName!="")
          {
             Try Menu, PVmFsubs, Add, % A_Index ". " A_LoopFileName, folderzNavInvokeSubs
             hasAddedSubs := 1
          }
       }
    }

    friendly := (SLDtypeLoaded=1) ? "Currently opened" : "Selected file"
    Menu, PVmFexplorer, Add, %friendly% folder:, dummy
    Menu, PVmFexplorer, Disable, %friendly% folder:
    Try Menu, PVmFexplorer, Add, % PathCompact(baseFolder, 40), OpenQPVfileFolder
    If (SLDtypeLoaded=1)
       Try Menu, PVmFexplorer, Disable, % PathCompact(baseFolder, 40)

    Menu, PVmFexplorer, Add
    If (FolderExist(thisFolder) && hasAddedSubs=1)
    {
       Try Menu, PVmFexplorer, Add, Sub-folders, :PVmFsubs
    } Else
    {
       Try Menu, PVmFexplorer, Add, No sub-folders, dummy
       Try Menu, PVmFexplorer, Disable, No sub-folders
    }

    If (parentsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try Menu, PVmFexplorer, Add, Breadcrumb folders hierarchy, :PVmFparents
       If (parentsObj.Count()>1 && SLDtypeLoaded=1)
       {
          Menu, PVmFexplorer, Add, Next breadcrumb`tCtrl+Page Down, MenuFolderExplorerUpDown
          Menu, PVmFexplorer, Add, Previous breadcrumb`tCtrl+Page Up, MenuFolderExplorerUpDown
       }
    }

    If (sibsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try Menu, PVmFexplorer, Add, Sibling folders, :PVmFsibs
       If (SLDtypeLoaded=1)
       {
          Menu, PVmFexplorer, Add, Next sibling`tAlt+Page Down, MenuFolderExplorerSiblings
          Menu, PVmFexplorer, Add, Previous sibling`tAlt+Page Up, MenuFolderExplorerSiblings
       }
    } Else
    {
       Try Menu, PVmFexplorer, Add, No sibling folders, dummy
       Try Menu, PVmFexplorer, Disable, No sibling folders
    }

    Menu, PVmFexplorer, Add
    If (folderTreeWinOpen!=1)
    {
       Menu, PVmFexplorer, Add, Folders tree view`tF4, MenuPanelFoldersTree
    } Else
    {
       Menu, PVmFexplorer, Add, Copy folder tree path, folderTreeCopyPath
       Menu, PVmFexplorer, Add, Collapse/expand entire folder tree, folderTreeExpandCollapseAll
    }

    RemoveTooltip()
    showThisMenu("PVmFexplorer")
    Return "m"
}

MenuFolderExplorerUpDown(menuItem) {
   If InStr(menuItem, "next")
      FileExploreUpDownLevel(1)
   Else
      FileExploreUpDownLevel(-1)
}

MenuFolderExplorerSiblings(menuItem) {
   If InStr(menuItem, "next")
      FileExploreSiblingsNav(1)
   Else
      FileExploreSiblingsNav(-1)
}

folderzNavInvokeSubs(menuItem) {
    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    oldFolder := baseFolder
    openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_Index=openThisu)
          {
             hasFound := 1
             thisFolder .= "\" A_LoopFileName
             Break
          }
       }
    }
    If (hasFound!=1)
       Return

    tryOpenGivenFolder(thisFolder, oldFolder)
}

tryOpenGivenFolder(thisFolder, oldFolder) {
   oldFolderu := StrReplace(oldFolder, "|")
   thisFolder := StrReplace(thisFolder, "|")
   thisFolder := StrReplace(Trimmer(thisFolder, "\"), "\\", "\")
   If !FolderExist(thisFolder)
   {
      showTOOLtip("ERROR: Folder not found or access denied:`n" thisFolder)
      SoundBeep , 300, 100
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   initially := thisFolder
   maxFilesIndex := 0
   SLDtypeLoaded := 1
   coreOpenFolder("|" thisFolder, 0, 0, 0, 1)
   If (maxFilesIndex<1)
   {
      addJournalEntry("Failed to find image files in: |" thisFolder)
      If !FolderExist(oldFolderu)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have attempted to open: " thisFolder "\. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
      Else msgResult := "Yes"

      If (msgResult="Yes" || !FolderExist(oldFolderu))
      {
         coreOpenFolder(thisFolder, 0, 0, 0, 1)
         CurrentSLD := thisFolder
      }
   } Else CurrentSLD := "|" thisFolder

   hasFailed := 0
   If (maxFilesIndex<1 && FolderExist(oldFolderu))
   {
      addJournalEntry("Failed to recursively find image files in: " thisFolder "\`nReopening initial folder: " oldFolder)
      coreOpenFolder(oldFolder, 0, 0, 0, 1)
      CurrentSLD := oldFolder
      hasFailed := 1
   } Else If (maxFilesIndex<1)
      resetMainWin2Welcome()

   If (maxFilesIndex>1)
      prevOpenFolderPath := StrReplace(CurrentSLD, "|")

   currentFilesListModified := 0
   currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
   If maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)

   If (hasFailed=1 || maxFilesIndex<1)
   {
      showDelayedTooltip("WARNING: No image files found in the folder:`n" initially)
      SoundBeep , 300, 100
   } Else RemoveTooltip()
   Return hasFailed
}

folderzNavInvokeSib(menuItem) {
   sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreSiblingsNav(1, 0, 0, iLevel, openThisu)
   ; ToolTip, % menuItem "-" openThisu "-" c , , , 2

}

folderzNavInvokeParents(menuItem) {
   parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreUpDownLevel(1, 0, prevMaxLevels, openThisu)
   ; ToolTip, % menuItem "==" openThisu "==" c , , , 2
}

toggleImgSelCoords() {
   relativeImgSelCoords := !relativeImgSelCoords
   calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)
   INIaction(1, "relativeImgSelCoords", "General")
}

ToggleSelectGrid() {
   showSelectionGrid := !showSelectionGrid
   INIaction(1, "showSelectionGrid", "General")
   If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleEllipseSelection(modus:=-1) {
   If (editingSelectionNow!=1 && thumbsDisplaying!=1)
      ToggleEditImgSelection()
   
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   liveDrawingBrushTool := 0
   EllipseSelectMode := clampInRange(EllipseSelectMode + 1, 0, 2, 1)
   If isInRange(modus, 0, 2)
      EllipseSelectMode := modus

   If (customShapePoints.Count()<3 && EllipseSelectMode=2)
   {
      INIaction(0, "FillAreaCustomShape", "General", 5)
      INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
      customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
      decideCustomShapeStyle()
      If (customShapePoints.Count()<3)
      {
         MenuStartDrawingSelectionArea()
         Return
      }
   }

   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)

   INIaction(1, "EllipseSelectMode", "General")
   showTOOLtip("Selection area: " DefineVPselAreaMode(), 0, 0, (EllipseSelectMode+1)/3)
   If (EllipseSelectMode=2)
      dummy := "||Points tension " FillAreaCurveTension ",,togglePathCurveTension"

   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   CreateGuiButton("Draw new form,,MenuStartDrawingSelectionArea" dummy, 0, msgDisplayTime//1.5 + 500)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleImgSelectionAspectRatio() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   If !userCustomImgSelRatio
      INIaction(0, "userCustomImgSelRatio", "General", 2, 1, 7)

   lockSelectionAspectRatio++
   If (lockSelectionAspectRatio>7)
      lockSelectionAspectRatio := 1

   friendly := defineSelectionAspectRatios()
   If (LimitSelectBoundsImg=1)
      infou := "WARNING: The selection area is now no longer limited to the image boundaries"

   LimitSelectBoundsImg := 0
   ; INIaction(1, "desiredSelAspectRatio", "General")
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   showTOOLtip(infou "Selection area aspect ratio locked to:`n" friendly, 0, 0, lockSelectionAspectRatio/7)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyRefreshImgSelectionWindow()
}

defineSelectionAspectRatios() {
   Static types := {0:"NONE", 1:"NONE", 2:"SQUARE [1:1]", 3:"SDTV [4:3]", 4:"35MM FILM [3:2]", 5:"HDTV [16:9]", 6:"WIDE SCREENS [16:10]", 7:"CUSTOM"}
   If (!lockSelectionAspectRatio || !isNumber(lockSelectionAspectRatio))
      lockSelectionAspectRatio := 1

   If (lockSelectionAspectRatio=2)
      desiredSelAspectRatio := 1
   Else If (lockSelectionAspectRatio=3)
      desiredSelAspectRatio := 4/3
   Else If (lockSelectionAspectRatio=4)
      desiredSelAspectRatio := 3/2
   Else If (lockSelectionAspectRatio=5)
      desiredSelAspectRatio := 16/9
   Else If (lockSelectionAspectRatio=6)
      desiredSelAspectRatio := 16/10
   Else If (lockSelectionAspectRatio=7)
      desiredSelAspectRatio := userCustomImgSelRatio
   Else
      desiredSelAspectRatio := 0

   If (lockSelectionAspectRatio=7)
      friendly := " [" userCustomImgSelRatio "]"

   Return types[lockSelectionAspectRatio] friendly
}

ToggleRecordOpenHistory() {
   allowRecordHistory := !allowRecordHistory
   INIaction(1, "allowRecordHistory", "General")
   friendly := (allowRecordHistory=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Keep history of opened files and folders: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; If !allowRecordHistory
   ;    EraseOpenedHistory()
}

toggleLimitSelection() {
   If (showViewPortGrid!=1 && editingSelectionNow!=1) || (thumbsDisplaying=1) || (liveDrawingBrushTool=1 && editingSelectionNow=1)
      Return

   LimitSelectBoundsImg := !LimitSelectBoundsImg
   If (lockSelectionAspectRatio>1)
      infou := "WARNING: The selection area aspect ratio is now no longer locked.`n"

   lockSelectionAspectRatio := 1
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   friendly1 := (LimitSelectBoundsImg=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (editingSelectionNow=1) ? "selection area" : "viewport grid"
   showTOOLtip(infou "Limit " friendly2 " to image boundaries: " friendly1, A_ThisFunc, 1)
   If (imgEditPanelOpened=1 && showViewPortGrid!=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAlwaysFIMus() {
   alwaysOpenwithFIM := !alwaysOpenwithFIM
   r := initFIMGmodule()
   If InStr(r, "err - 126")
      friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2015."
   Else If InStr(r, "err - 404")
      friendly := "`n`nThe FreeImage.dll file seems to be missing..."

   INIaction(1, "alwaysOpenwithFIM", "General")
   If (FIMfailed2init=1)
      msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Various image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
   Else If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0 && StrLen(UserMemBMP)<4)
      RefreshImageFileAction()
}

ToggleAnimGIFsupport() {
   animGIFsSupport := !animGIFsSupport
   INIaction(1, "animGIFsSupport", "General")
   friendly := (animGIFsSupport=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically play animated GIFs: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoRemEntries() {
   autoRemDeadEntry := !autoRemDeadEntry
   INIaction(1, "autoRemDeadEntry", "General")
   friendly := (autoRemDeadEntry=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically remove entries to inexistent files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TogglePromptDelete() {
   askDeleteFiles := !askDeleteFiles
   INIaction(1, "askDeleteFiles", "General")
   friendly := (askDeleteFiles=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Prompt before deleting files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleTitleBaruNow(dummy:=0) {
   If (getCaptionStyle(PVhwnd)=0)
   {
      isTitleBarHidden := 0
      If (userAllowWindowDrag=1)
         TouchScreenMode := 0
      ; If (editingSelectionNow=1)
      ;    ToggleEditImgSelection()
      WinSet, Style, -0xC00000, ahk_id %PVhwnd%
   } Else
   {
      isTitleBarHidden := 1
      WinSet, Style, +0xC00000, ahk_id %PVhwnd%
   }
   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   INIaction(1, "isTitleBarHidden", "General")
   ; INIaction(1, "TouchScreenMode", "General")
   ; If (isTitleBarHidden=0)
   If (drawingShapeNow!=1)
      SetTimer, dummyToggleTitleBarActionBtns, -350
}

dummyToggleTitleBarActionBtns() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  1stLabel := (userAllowWindowDrag=1 && isTitleBarHidden=0) ? "Deactivate window dragging" : "Allow window dragging"
  1stact := "toggleWindowDraggableMode"
  If (TouchScreenMode!=1)
  {
     2ndLabel := "Activate touch screen mode"
     2ndact := "ToggleTouchMode"
  }
  If (getCaptionStyle(PVhwnd)!=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  ; If (isTitleBarHidden=0)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  showTOOLtip(friendly)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleQuickBaru() {
   Critical, on
   Static lastInvoked := 1
   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   showMainMenuBar := !showMainMenuBar
   INIaction(1, "showMainMenuBar", "General")
   interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
   If !showMainMenuBar
      Win_SetMenu(PVhwnd, 0)

   TriggerMenuBarUpdate("forced")
   If (A_TickCount - lastInvoked > 900)
      CreateGuiButton("Interface options,,OpenUImenu", 0, msgDisplayTime//1.5 + 500)

   If (isImgEditingNow()=1 || (thumbsDisplaying=1 && maxFilesIndex>1))
   {
      ; If (thumbsDisplaying=1)
      ForceRefreshNowThumbsList()
      SetTimer, dummyUpdateWin, -300, 100
   }
   If hasTrans
      SetTimer, tlbrResetPosition, -300, 100
   lastInvoked := A_TickCount
}

dummyUpdateWin() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   ; ToolTip, % mainWidth "=" mainHeight , , , 2
   createGDIPcanvas(mainWidth, mainHeight, 1)
   dummyTimerDelayiedImageDisplay(50)
}

ToggleTitleBaru() {
    SetTimer, ToggleTitleBaruNow, -150
}

ToggleLargeUIfonts() {
    PrefsLargeFonts := !PrefsLargeFonts
    ; If (AnyWindowOpen=14)
    ;    PanelPrefsWindow()

    calcHUDsize()
    INIaction(1, "PrefsLargeFonts", "General")
    interfaceThread.ahkassign("PrefsLargeFonts", PrefsLargeFonts)
    thisFunc := prevOpenedWindow[2]
    If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    } Else
    {
      friendly := (PrefsLargeFonts=1) ? "ACTIVATED" : "DEACTIVATED"
      showTOOLtip("Large user interface fonts: " friendly, A_ThisFunc, 1)
      SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

ToggleTexyBGR() {
    usrTextureBGR := !usrTextureBGR
    INIaction(1, "usrTextureBGR", "General")
    friendly := (usrTextureBGR=1) ? ambiTexBrushSize " px" : "DEACTIVATED"
    RefreshImageFile()
    showDelayedTooltip("Viewport ambiental texture: " friendly)
}

ToggleImgNavBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    showHUDnavIMG := !showHUDnavIMG
    INIaction(1, "showHUDnavIMG", "General")
    dummyTimerDelayiedImageDisplay(25)
    SetTimer, dummyNavBoxInfo, -150
    lastInvoked := A_TickCount
}

ToggleImgNavSizeBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (showHUDnavIMG!=1)
       Return

    HUDnavBoxSize := (HUDnavBoxSize=75) ? 125 : 75
    If (thumbsDisplaying=1)
       mainGdipWinThumbsGrid()
    Else
       dummyTimerDelayiedImageDisplay(25)
    lastInvoked := A_TickCount
}

dummyNavBoxInfo() {
    friendly := (IMGlargerViewPort=1) ? "" : "`nThe navigator will be displayed`nwhen the image is larger than the viewport."
    If (thumbsDisplaying=1)
       friendly := (thumbsListViewMode>1) ? "" : "`nImage preview box will be displayed in other list modes`nPress L to toggle between modes"

    labelu := (thumbsDisplaying=1) ? "preview" : "navigator"
    If (showHUDnavIMG=1)
       showTOOLtip("Image " labelu " display: AUTO" friendly, "ToggleImgNavBox", 1)
    Else
       showTOOLtip("Image " labelu ": OFF", "ToggleImgNavBox", 1)

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgHistogram(direction) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    If (direction=1)
       showHistogram++
    Else
       showHistogram--

    showHistogram := clampInRange(showHistogram, 1, 6, 1)
    INIaction(1, "showHistogram", "General")
    If (showHistogram>1)
       showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode(), A_ThisFunc, 2, showHistogram/6)
    Else
       showTOOLtip("Histogram: NONE", A_ThisFunc, 2, 1/6)

    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, showHistogram, % showHistogram
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
    lastInvoked := A_TickCount
}

ToggleHistogramMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 || showHistogram<=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    lastInvoked := A_TickCount
    histogramMode++
    histogramMode := clampInRange(histogramMode, 1, 3, 1)
    INIaction(1, "histogramMode", "General")
    showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode(), 0, 0, histogramMode/3)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, histogramMode, % histogramMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

defineHistogramType() {
    If (showHistogram=1)
       friendly := "NONE"
    Else If (showHistogram=2)
       friendly := "LUMINANCE"
    Else If (showHistogram=3)
       friendly := "RED"
    Else If (showHistogram=4)
       friendly := "GREEN"
    Else If (showHistogram=5)
       friendly := "BLUE"
    Else If (showHistogram=6)
       friendly := "ALL MIXED"

    Return friendly
}

defineHistogramMode() {
    If (histogramMode=1)
       friendly := "LOWS"
    Else If (histogramMode=2)
       friendly := "BALANCED"
    Else If (histogramMode=3)
       friendly := "PEAKS"

    Return friendly
}

ToggleThumbsCaching() {
    enableThumbsCaching := !enableThumbsCaching
    INIaction(1, "enableThumbsCaching", "General")
    friendly := (enableThumbsCaching=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Image thumbnails caching on disk: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipDeadFiles() {
    skipDeadFiles := !skipDeadFiles
    INIaction(1, "skipDeadFiles", "General")
    friendly := (skipDeadFiles=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Skip inexistent files in image view: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleIgnoreSLDprefs() {
    MustLoadSLDprefs := !MustLoadSLDprefs
    INIaction(1, "MustLoadSLDprefs", "General")
}

ToggleCycleFavesOpen() {
    cycleFavesOpenIMG := !cycleFavesOpenIMG
    INIaction(1, "cycleFavesOpenIMG", "General")
    friendly := (cycleFavesOpenIMG=1) ? "The favourites list will be opened when one of the 15 entries is opened." : "The containing folder of the favourite image will be opened."
    showTOOLtip(friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgQuality(modus:=0) {
    userimgQuality := !userimgQuality
    If (modus="lowu")
       userimgQuality := 0
    Else If (modus="highu")
       userimgQuality := 1
    Else
       INIaction(1, "userimgQuality", "General")

    fnOutputDebug("Set viewport quality: " modus "--" forceIT "==" userimgQuality)
    imgQuality := (userimgQuality=1) ? 7 : 5
    PixelMode := (userimgQuality=1) ? 2 : 0
    smoothMode := (userimgQuality=1) ? 4 : 1
    compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1

    Gdip_SetInterpolationMode(glPG, imgQuality)
    Gdip_SetPixelOffsetMode(glPG, 2)
    Gdip_SetSmoothingMode(glPG, smoothMode)
    Gdip_SetCompositingQuality(glPG, compositingQuality)

    Gdip_SetInterpolationMode(2NDglPG, imgQuality)
    Gdip_SetPixelOffsetMode(2NDglPG, 2)
    Gdip_SetSmoothingMode(2NDglPG, smoothMode)
    Gdip_SetCompositingQuality(2NDglPG, compositingQuality)
}

toggleImgEditGammaCorrect() {
    userimgGammaCorrect := !userimgGammaCorrect
    INIaction(1, "userimgGammaCorrect", "General")
    friendly := (userimgGammaCorrect=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Gamma correction for image editing: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleScreenSaverMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked<600)
       Return

    screenSaverMode := !screenSaverMode
    SoundBeep , % (screenSaverMode=1) ? 900 : 300, 100
    If (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -50
    Else
       SetTimer, drawWelcomeImg, Off

    lastInvoked := A_TickCount
}

ToggleRAWquality() {
    userHQraw := !userHQraw
    INIaction(1, "userHQraw", "General")
    friendly := (userHQraw=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Load Camera RAW images at high quality:: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoPlaySlidesMusic() {
    autoPlaySlidesAudio := !autoPlaySlidesAudio
    INIaction(1, "autoPlaySlidesAudio", "General")
    friendly := (autoPlaySlidesAudio=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Automatically play music during slideshows: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleLockZoom() {
    lockZoomLevel := !lockZoomLevel
    INIaction(1, "lockZoomLevel", "General")
    friendly := (lockZoomLevel=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Lock zoom level: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiCoreSupport() {
    allowMultiCoreMode := !allowMultiCoreMode
    INIaction(1, "allowMultiCoreMode", "General")
    If (thumbsDisplaying=1 && thumbsListViewMode=1 && multiCoreThumbsInitGood="n")
       initAHKhThumbThreads()
}

ToggleLimitMemUsage() {
    minimizeMemUsage := !minimizeMemUsage
    INIaction(1, "minimizeMemUsage", "General")
    If (minimizeMemUsage=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "By limiting memory usage, the performance of Quick Picto Viewer will likely be drastically reduced. Additionally, some features or functions might be disabled.", 0, 0, "exclamation")
       discardViewPortCaches()
    }
}

TogglePreventUndos() {
    preventUndoLevels := !preventUndoLevels
    maxMemUndoLevels := (preventUndoLevels=1) ? 100 : 979394
    friendly := (preventUndoLevels=1) ? "NO" : "YES"
    showTOOLtip("Record undo levels: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgColorDepthDithering() {
    ColorDepthDithering := !ColorDepthDithering
    INIaction(1, "ColorDepthDithering", "General")
    If (thumbsDisplaying!=1)
       RefreshImageFile()
    friendly := (ColorDepthDithering=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Color depth dithering: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgDownScaling() {
    If (thumbsDisplaying=1 || StrLen(UserMemBMP)>3)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    AutoDownScaleIMGs := !AutoDownScaleIMGs
    INIaction(1, "AutoDownScaleIMGs", "General")
    If (AutoDownScaleIMGs=1)
       showTOOLtip("Images larger than the screen resolution will be`ndownscaled prior to any potential effect.")
    Else
       showTOOLtip("Downscaling: DISABLED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, RefreshImageFileAction, -300
}

toggleAppToolbar() {
    ShowAdvToolbar := !ShowAdvToolbar
    INIaction(1, "ShowAdvToolbar", "General")
    interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
    createGUItoolbar()
}

ToggleTouchMode() {
    DestroyTempBtnGui("now")
    TouchScreenMode := !TouchScreenMode
    updateUIctrl()
    interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
    interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
    INIaction(1, "TouchScreenMode", "General")
    INIaction(1, "isTitleBarHidden", "General")
    If (getCaptionStyle(PVhwnd)=1 && TouchScreenMode=1 && userAllowWindowDrag=1)
       toggleWindowDraggableMode()

    friendly := (TouchScreenMode=1) ? "ACTIVATED" : "DEACTIVATED"
    If (TouchScreenMode=1)
       friendly .= "`nThe viewport is now split into different response areas.`nSee the Help menu for more details."

    showTOOLtip("Touch screen mode: " friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineWinTitlePrefix() {
   Static FXmodesLabels := {2:"cP", 3:"cAUTO", 4:"cGR", 5:"cR", 6:"cG", 7:"cB", 8:"cA", 9:"cI"}

   If StrLen(UserMemBMP)>1
      winPrefix .= "IMAGE EDITING | "

   If StrLen(filesFilter)>1
      winPrefix .= "F "

   If hSNDmedia
      winPrefix .= "(A) "

   If (editingSelectionNow=1)
      winPrefix .= "SEL "

   If (slideShowRunning=1)
   {
      winPrefix .= "s"
      If (SlideHowMode=1)
         winPrefix .= "R "
      Else If (SlideHowMode=2)
         winPrefix .= "B "
      Else If (SlideHowMode=3)
         winPrefix .= "F "
   }

   If (usrColorDepth>1)
      winPrefix .= internalColorDepth  " bits "

   If (FlipImgV=1)
      winPrefix .= "V "
   If (FlipImgH=1)
      winPrefix .= "H "

   If (thisIMGisDownScaled=1)
      winPrefix .= "DWS "

   If FXmodesLabels.HasKey(imgFxMode)
      winPrefix .= FXmodesLabels[imgFxMode] A_Space

   If (IMGresizingMode=3)
      winPrefix .= "O "
   Else If (IMGresizingMode=4)
      winPrefix .= "Z "

   Return winPrefix
}

calculateTouchMargins(ByRef thisX, ByRef thisY, ByRef thisW, ByRef thisH) {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   thisX := (editingSelectionNow=1) ? mainWidth//8 : mainWidth//7
   thisY := (editingSelectionNow=1) ? mainHeight//6 : mainHeight//5
   thisW := mainWidth - thisX*2
   thisH := mainHeight - thisY*2
}

drawWelcomeImg() {
    Critical, on
    If StrLen(UserMemBMP)>2
       thisClippyIMG := 1

    If (maxFilesIndex>0 || thisClippyIMG=1 || StrLen(CurrentSLD)>1 || AnyWindowOpen>0)
    {
       screenSaverMode := 0
       Return
    }

    If (A_TickCount - scriptStartTime>550)
    {
       If (identifyThisWin()!=1)
       {
          screenSaverMode := 0
          Return
       }
    }

    thisZeit := A_TickCount
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Random, modelu, 1, 8
    If (modelu=8)
       Random, modelu, 1, 8

    Random, moduz, 1, 9
    Random, iterations, 10, 30
    Random, sweepRand, 1, 9

    ; pBr4 := Gdip_BrushCreateSolid("0x55030201")
    BMPcache := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, 5, 5, 1)
    If !BMPcache
    {
       Gdip_DeleteBrush(pBr4)
       addJournalEntry("Welcome screen failed to render... mainBMP=" BMPcache " -- pG=" G)
       setWindowTitle(appTitle " v" appVersion, 1)
       SetTimer, drawWelcomeImg, Off
       Return
    }

    createGDIPcanvas()
    getColors := (imgFxMode=3 || imgFxMode=8) ? 0 : 1
    If (getColors=1)
       decideGDIPimageFX(matrix, imageAttribs, zEffect)

    If !isWinXP
       pEffect := Gdip_CreateEffect(1, 3, 0, 0)

    If pEffect
       Gdip_BitmapApplyEffect(BMPcache, pEffect)

    r1 := trGdip_DrawImage(A_ThisFunc, glPG, BMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight,,, imageAttribs)
    Gdip_AddPathGradient(glPG, 0, 0, mainWidth, mainHeight, mainWidth//2, mainHeight//2, "0x00000000", "0x65010101", 1, 0, 0, 1)
    If (TouchScreenMode=1 && screenSaverMode!=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//11
       Penuha := Gdip_CreatePen("0x34334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x05EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x10778877)
       Gdip_FillRectangle(glPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(glPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(glPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)

       Gdip_SetClipRect(glPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(glPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(glPG)
       Gdip_DrawRectangle(glPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(glPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
    }

    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    trGdip_DisposeImage(BMPcache, 1)
    Gdip_DeleteBrush(pBr4)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    updateUIctrl()
    addJournalEntry("Welcome screen rendered in " A_TickCount - thisZeit " ms." r2 " - " r1)
    setWindowTitle(appTitle " v" appVersion, 1)
    If (A_TickCount - thisZeit<250) || (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -3500
    Else
       SetTimer, drawWelcomeImg, Off
}

coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, minX, minY, startMode, previewMode:=0, usePrevious:=0) {
    Static prevObj := [], prevBMPu, prevState

    If (modelu="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisState := "a" kimgSelW kimgSelH AnyWindowOpen vPselRotation FillAreaInverted modelu iterations moduz sweepRand minX minY startMode previewMode usePrevious
    If (thisState=prevState && previewMode=1 && StrLen(prevBMPu)>2)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
 
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    BMPcache := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
    If BMPcache
    {
       compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
       If (userimgQuality!=1 && previewMode=1) || (previewMode=1) || (startMode=1 && userimgQuality!=1)
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 1, 3,, compositingQuality)
       Else
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 7, 4,, compositingQuality)
    }

    If (!BMPcache || !G)
    {
       prevState := 0
       trGdip_DisposeImage(BMPcache, 1)
       Return
    }

    If (usePrevious=1 && prevObj.type!=modelu)
       usePrevious := 0

    If (usePrevious!=1)
    {
       scaleuX := scaleuY := 1
       prevObj.type := modelu
       prevObj.mW := mainWidth
       prevObj.mH := mainHeight
       Random, a, 22, 66
       Random, b, 22, 66
       Random, c, 22, 66
       Random, d, 66, 99
       Random, anglu, 0.0, 24.5
       If (startMode!=1)
          anglu := vPselRotation ; + anglu/12
       prevObj.a := a
       prevObj.b := b
       prevObj.c := c
       prevObj.d := d
       prevObj.anglu := anglu
    } Else
    {
       scaleuX := prevObj.mW/mainWidth
       scaleuY := prevObj.mH/mainHeight
    }

    pBr1 := Gdip_BrushCreateSolid("0x" prevObj.a "882211")
    pBr2 := Gdip_BrushCreateSolid("0x" prevObj.b "112288")
    pBr3 := Gdip_BrushCreateSolid("0x" prevObj.c "118822")
    pBr5 := Gdip_BrushCreateSolid("0x" prevObj.d "939291")
    ; MsgBox, % minX "--" minY "`n" mainWidth "--" mainHeight "`n" bgrBrush
    If (GetKeyState("CapsLock", "T") && startMode=1)
       Gdip_FillRectangle(G, pBr5, 0, 0, mainWidth, mainHeight)
    ; Else If (startMode!=1)
    ;    Gdip_FillRectangle(G, bgrBrush, 0, 0, mainWidth, mainHeight)

    If (startMode=1)
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF" WindowBgrColor)

    Gdip_SetClipRect(G, 0, 0, mainWidth, mainHeight)
    cX := 0 + (mainWidth / 2)
    cY := 0 + (mainHeight / 2)
    pMatrix := Gdip_CreateMatrix()
    Gdip_TranslateMatrix(pMatrix, -cX , -cY)
    Gdip_RotateMatrix(pMatrix, prevObj.anglu, 1)
    Gdip_TranslateMatrix(pMatrix, cX, cY, 1)
    Gdip_SetWorldTransform(G, pMatrix)
    Gdip_DeleteMatrix(pMatrix)

    If (modelu=1)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth
             Random, h, % minY, % mainHeight
             w += 10
             h += 10
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          ; MsgBox, % xPos "--" yPos "`n" w "--" h "`n" tBrsh
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=2)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth//2 + mainHeight//2
             w += 5
             h := w
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=3 || modelu=5)
    {
       ; Random, moduz, 1, 9
       Loop, % iterations
       {  
          If (usePrevious!=1)
          {
             Random, w, 5, % mainWidth//1.5 + mainHeight//1.5
             w += 5
             h := w
             Random, deviation, -25, 25
             If (modelu=5)
                Random, moduz, 1, 9

             If (moduz=1)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=2)
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=3)
             {
                xPos := 1 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=4)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=5)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=6)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=7)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=8)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             }
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=6)
    {
       ; maurer rose; based on the implemention by hellbent found on AHK Forums
       If (startMode!=1)
          iterations := Ceil(iterations/10)
       Else
          Random, iterations, 2, 5

       o_sweepRand := sweepRand
       PetalPenA := Gdip_CreatePenFromBrush(pBr5, thickness)
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, thickness, 2.0, 3.5
             Random, tBrsh, 1, 3
             Random, ttBrsh, 1, 3
             If (startMode!=1)
                Random, sweepRand, 1, 9
             Else If (A_Index=1)
                sweepRand := o_sweepRand - 1
             Else If (A_Index=2)
                sweepRand := o_sweepRand + 1
             Else
                sweepRand := o_sweepRand

             Random, Petals, 2, 7
             If (startMode!=1)
                Petals := clampInRange(moduz + 1, 2, 9)

             prevObj[A_Index] := [thickness, Petals, sweepRand, ttBrsh, tBrsh]
          } Else
          {
             thickness := prevObj[A_Index, 1] / ((scaleuX + scaleuY)/2)
             Petals := prevObj[A_Index, 2]
             sweepRand := prevObj[A_Index, 3]
             ttBrsh := prevObj[A_Index, 4]
             tBrsh := prevObj[A_Index, 5]
          }

          PetalPen := Gdip_CreatePenFromBrush(pBr%ttBrsh%, thickness)
          SweepPen := Gdip_CreatePenFromBrush(pBr%tBrsh%, thickness)
          PetalList := SweepList := mainWidth//2 "," mainHeight//2 "|", Sweep := sweepRand
          Loop, 360
          {
              SweepList .= CalculateSweep(A_Index*Sweep, Petals, mainWidth//2, mainHeight//2)
              PetalList .= CalculateSweep(A_Index*3.14159/180, Petals, mainWidth//2, mainHeight//2)
          }
          PetalList .= mainWidth//2 "," mainHeight//2
          SweepList .= mainWidth//2 "," mainHeight//2
          Gdip_DrawLines(G, PetalPenA, PetalList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          ; Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, PetalPen, PetalList)
          Gdip_DeletePen(PetalPen)
          Gdip_DeletePen(SweepPen)
       }
       Gdip_DeletePen(PetalPenA)
    } Else If (modelu=4)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % -mainHeight, % minY
             Random, w, % minX, % mainWidth//2
             w += 5
             h := mainHeight*3
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=8)
    {
       Random, z, 0.02, 0.09 ; scale
       Random, l, 0.1, 0.45 ; opacity
       Gdip_SetInterpolationMode(G, 5)
       Gdip_SetPixelOffsetMode(G, 2)
       Gdip_ResetWorldTransform(G)
       noiseBMP := QPV_CreateBitmapNoise(Ceil(mainWidth*z), Ceil(mainHeight*z), 1, 0, 1)
       trGdip_DrawImage(A_ThisFunc, G, noiseBMP, 0, 0, mainWidth, mainHeight,,,,, l)
       trGdip_DisposeImage(noiseBMP, 1)
    } Else ; If (modelu=6)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % -mainWidth, % minY
             Random, yPos, % minY, % mainHeight
             w := mainWidth*3
             Random, h, % minY, % mainHeight//2
             h += 5
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    }
    
    Gdip_ResetWorldTransform(G)
    ; If (startMode!=1)
       ; Gdip_FillRectangle(G, overBrush, 0, 0, mainWidth, mainHeight)

    If (startMode!=1 && previewMode=1)
    {
       prevBMPu := trGdip_CloneBitmap(A_ThisFunc, BMPcache)
       prevState := thisState
    } Else prevState := 0

    Gdip_DeleteBrush(pBr1)
    Gdip_DeleteBrush(pBr2)
    Gdip_DeleteBrush(pBr3)
    Gdip_DeleteBrush(pBr5)
    Gdip_DeleteGraphics(G)
    Return BMPcache
}

CalculateSweep(InputValue, Petals, w, h) {
   r:=((w+h)//2)*Sin(Petals*InputValue)
   x:=r*cos(InputValue)+w
   y:=r*sin(InputValue)+h
   return x "," y "|"
}

addJournalEntry(msg) {
    Static currentEntry := 0, maxEntries := 256, lastError, prevEntry
    If (slideShowRunning=1 && slideShowDelay<300)
       Return

    If (msg="get_last_err")
       Return lastError

    If (msg="WinTitle: " pVwinTitle) || InStr(msg, "WinTitle: " appTitle " v" appVersion) || (msg="Loading") || (slideShowRunning=1 && slideShowDelay<600) || (animGIFplaying=1)
       Return

    ; mamUsage := GetProcessMemoryUsage(QPVpid)
    ; If (A_PtrSize=8)
    ;    systemMemInfo := GlobalMemoryStatusEx()
    ; thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    ; memUsage := "Mem: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " 
    ; ToolTip, % memUsage , , , 2

    If (hasInitSpecialMode=1 || prevEntry=msg)
       Return

    fnOutputDebug("User journal: " StrReplace(msg, "`n", " | "))
    If ((InStr(msg, "error") || InStr(msg, "fail")) && !InStr(msg, "dialog box:"))
       lastError := msg

    currentEntry++
    prevEntry := msg
    QPVjournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
    If (currentEntry>maxEntries)
    {
       currentEntry := maxEntries
       QPVjournal.Pop()
    }
}

getCurrentDate() {
   FormatTime, CurrentTimeB,, H:mm:ss
   FormatTime, CurrentDateB,, ShortDate
   Return CurrentDateB ", " CurrentTimeB
}

destroyGDIPcanvas() {
    qpvCanvasHasInit := 0
    Gdi_SelectObject(glHDC, glOBM)
    If glHbitmap
       Gdi_DeleteObject(glHbitmap)
    If glHDC
       Gdi_DeleteDC(glHDC)
    If glPG
       Gdip_DeleteGraphics(glPG)

    Gdi_SelectObject(2NDglHDC, 2NDglOBM)
    If 2NDglHbitmap
       Gdi_DeleteObject(2NDglHbitmap)
    If 2NDglHDC
       Gdi_DeleteDC(2NDglHDC)
    If 2NDglPG
       Gdip_DeleteGraphics(2NDglPG)

    glHbitmap := 2NDglHbitmap := ""
    glHDC := 2NDglHDC := ""
    glPG := 2NDglPG := ""
}

createGDIPcanvas(W:=0, H:=0, forceIT:=0) {
   Critical, on
   Static prevDimensions, hasInit
   If (A_TickCount - lastMenuBarUpdated<700) && (forceIT=0)
      Return

   If (!W || !H)
      GetWinClientSize(W, H, PVhwnd, 0)

   newDimensions := "w" W "-h" H "-mbar" showMainMenuBar
   doAgain := (prevDimensions!=newDimensions) ? 1 : 0
   If (!qpvCanvasHasInit || doAgain=1 || forceIT=1)
   {
      If (hasInit=1)
         destroyGDIPcanvas()

      ; gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      imgQuality := (userimgQuality=1) ? 7 : 5
      If (minimizeMemUsage=1)
         imgQuality := ""    ; default interpolation mode

      PixelMode := (userimgQuality=1) ? 2 : 0
      smoothMode := (userimgQuality=1) ? 4 : 1
      compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1
      glHDC := Gdi_CreateCompatibleDC()
      ; Gdi_SetPolyFillMode(glHDC, 2)
      glHbitmap := Gdi_CreateDIBSection(W, H)
      glOBM := Gdi_SelectObject(glHDC, glHbitmap)
      glPG := Gdip_GraphicsFromHDC(glHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(glPG, 2)
      ; ToolTip, % W "==" H "==" glHDC "==" glHbitmap "==" glOBM "==" glPG , , , 2

      2NDglHDC := Gdi_CreateCompatibleDC()
      2NDglHbitmap := Gdi_CreateDIBSection(W, H)
      2NDglOBM := Gdi_SelectObject(2NDglHDC, 2NDglHbitmap)
      2NDglPG := Gdip_GraphicsFromHDC(2NDglHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(2NDglPG, 2)

      hasInit := 1
      prevDimensions := newDimensions
      addJournalEntry("Canvas infos: " prevDimensions " - glPG:" glPG " - glHDC:" glHDC " - glOBM:" glOBM " - glHbmp:" glHbitmap " - 2NDglPG:" 2NDglPG " - 2NDglHDC:" 2NDglHDC " - 2NDglOBM:" 2NDglOBM " - 2NDglHbmp:" 2NDglHbitmap)
      If (!glPG || !glHDC || !glHbitmap || !glOBM || !2NDglPG || !2NDglHDC || !2NDglOBM || !2NDglHbitmap)
      {
         qpvCanvasHasInit := 0
         prevDimensions := "r"
         ; MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+ window...`n`nThe program will probably malfunction or crash.
         handleFatalWinInitErrors()
      } Else
      {
         qpvCanvasHasInit := 1
         addJournalEntry("Main canvas created: " W " x " H " px.")
      }
   }
}

handleFatalWinInitErrors() {
   msgResult := msgBoxWrapper(appTitle ": FATAL ERROR", appTitle " was unable to initialize the GDI+ windows required to display images.`n`nWould you like to try initialize it again? By choosing to continue, the application may malfunction.", "&Try again|&Continue|&Exit", 1, "error")
   If InStr(msgResult, "again")
   {
      restartEntireGui()
   } Else If InStr(msgResult, "exit")
   {
      hasInitSpecialMode := 1
      ForceExitNow()
   }
}

restartEntireGui() {
   destroyGDIPcanvas()
   interfaceThread.ahkFunction("destroyAllGUIs")
   Sleep, 25
   externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarHidden "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized
   initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
   fnOutputDebug("RESTARTED extern UI HWNDs: " initGUI)
   If InStr(initGui, "|")
      handleUIhwnd(InitGui)

   createGDIPcanvas()
}

handleUIhwnd(initGui) {
   externObj := StrSplit(initGUI, "|")
   PVhwnd := externObj[1]
   hGDIinfosWin := externObj[2]
   hGDIwin := externObj[3]
   hGDIthumbsWin := externObj[4]
   hGDIselectWin := externObj[5]
   hPicOnGui1 := externObj[6]
   winGDIcreated := externObj[7]
   ThumbsWinGDIcreated := externObj[8]
   If (!PVhwnd || !hGDIinfosWin || !hGDIwin || !hGDIthumbsWin || !hGDIselectWin || !hPicOnGui1)
   {
      handleFatalWinInitErrors()
   } Else
   {
      GroupAdd, QPVwindows, ahk_id %PVhwnd%
      GroupAdd, QPVwindows, ahk_id %hGDIthumbsWin%
      GroupAdd, QPVwindows, ahk_id %hGDIwin%
      GroupAdd, QPVwindows, ahk_id %hGDIselectWin%
      GroupAdd, QPVwindows, ahk_id %hGDIinfosWin%
      updateUIctrl()
   }
}

InitGDIpStuff() {
; create pens and brushes
   pPen1 := Gdip_CreatePen("0xCCbbccbb", 3)
   pPen1d := Gdip_CreatePen("0xCCbbccbb", 3)
   ; Gdip_SetPenAlignment(pPen1d, 1)
   Gdip_SetPenDashArray(pPen1d, "1.1,1.1")
   pPen2 := Gdip_CreatePen("0xBBffccbb", imgHUDbaseUnit//9)
   pPen3 := Gdip_CreatePen("0x66334433", imgHUDbaseUnit//8)
   pPen4 := Gdip_CreatePen("0x88998899", imgHUDbaseUnit//11)
   pPen5 := Gdip_CreatePen("0x880088FF", imgHUDbaseUnit//11.5)
   pPen6 := Gdip_CreatePen("0xDD998822", imgHUDbaseUnit//6)
   pPen7 := Gdip_CreatePen("0xDDFFeeFF", imgHUDbaseUnit//6)
   Gdip_SetPenDashArray(pPen4, "0.5,0.5")
   pBrushA := Gdip_BrushCreateSolid("0x90898898")
   pBrushB := Gdip_BrushCreateSolid("0xBB898898")
   pBrushC := Gdip_BrushCreateSolid("0x77898898")
   pBrushD := Gdip_BrushCreateSolid("0xDDbbccFF")
   pBrushE := Gdip_BrushCreateSolid("0x77333333")
   pBrushF := Gdip_BrushCreateSolid("0x33667766")
   pBrushZ := Gdip_BrushCreateSolid("0xFF000000")
   ; Loop, 6
      ; r := Gdip_SetPenAlignment(pPen%A_Index%, 1)
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) "`n" WindowBgrColor , , , 2
   GDIcreateCheckersBrush(20)
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushHatchLow := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

GDIcreateCheckersBrush(size) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, coreDesiredPixFmt)
   If !pBitmap
      Return

   pBr1 := Gdip_BrushCreateSolid("0x99ffFFff")
   pBr2 := Gdip_BrushCreateSolid("0x99515151")
   pBr3 := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)

   G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   Gdip_FillRectangle(G, pBr3, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr2, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr1, 0, 0, size//2, size//2)
   Gdip_FillRectangle(G, pBr1, size//2, size//2, size//2, size//2)
   Gdip_DeleteGraphics(G)
   GDIbrushHatch := createGDIbrushPbitmap(pBitmap)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DeleteBrush(pBr1)
   Gdip_DeleteBrush(pBr2)
   Gdip_DeleteBrush(pBr3)
}

refreshWinBGRbrush() {
   If pBrushWinBGR
      Gdip_DeleteBrush(pBrushWinBGR)
   If OSDwinFadedBrushBGR
      Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   If GDIbrushWinBGR
      Gdi_DeleteObject(GDIbrushWinBGR)
   Sleep, 0
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) , , , 2
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

useHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return pBrushZ
   Else 
      Return pBrushHatchLow
}

useGdiHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return Gdi_GetStockObject(0)
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return Gdi_GetStockObject(4)
   Else 
      Return GDIbrushHatch
}

ToggleSeenIMGstatus() {
   initSeenImagesListDB()
   If (thumbsDisplaying!=1 || sqlFailedInit=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   mustRem := 0 
   imgPath := getIDimage(currentFileIndex)
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
   resultedFilesList[currentFileIndex, 3] := ""
   seenImagesDB.Exec("COMMIT TRANSACTION;")
   If retrieveSeenImageDBentry(imgPath, currentFileIndex)
      mustRem := 1 
   
   If markedSelectFile
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      countFilez := 0
      getSelectedFiles(0, 1)
      friendly := (mustRem=1) ? "UNSEEN" : "SEEN"
      showTOOLtip("Marking as " friendly markedSelectFile " images, please wait")
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      doStartLongOpDance()
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue
      
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countFilez, markedSelectFile, startOperation)
            showTOOLtip("Marking as " friendly " images, please wait" etaTime, 0, 0, countFilez / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countFilez++
         resultedFilesList[A_Index, 3] := ""
         imgPath := resultedFilesList[A_Index, 1]
         cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
         If (mustRem=1)
            deleteSQLseenEntry(imgPath, A_Index)
         Else
            recordSeenIMGdbEntry(imgPath, A_Index, 0)
      }

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         someERR := "Failed to commit changes to the SQL database`n"

      If (abandonAll=1)
         showTOOLtip(someERR "Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected images were marked as " friendly ".")
      Else
         showTOOLtip(someERR "Finished marking " groupDigits(countFilez) " images as " friendly ".")

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (abandonAll=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      If (mustRem=1)
         deleteSQLseenEntry(imgPath, currentFileIndex)
      Else
         recordSeenIMGdbEntry(imgPath, currentFileIndex, 0)

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

CleanDeadFilesSeenImagesDB(doPartial:=0, partu:=0) {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If AnyWindowOpen
     BtnCloseWindow()


   If (doPartial!="yesu")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to purge no longer existent files from the list of seen images?`n`nThis action is irreversible and may take awhile...", "&Continue|C&ancel", 2, "question")
      If !InStr(msgResult, "continue")
         Return
   }

  startOperation := A_TickCount
  showTOOLtip("Removing entries of inexistent files from the already seen images database, please wait")
  doStartLongOpDance()
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  entriesCount := entriesScanned := entriesDoneCount := 0
  RecordSet := ""
  npartu := StrReplace(partu, "\viewed-images-history-")
  npartu := StrReplace(npartu, ".sld")
  If (doPartial="yesu" && !InStr(partu, "-viewed-images-history-current-session"))
     SQL := "SELECT imgfile FROM images WHERE imgViewDate LIKE '" npartu "%';"
  Else
     SQL := "SELECT imgfile FROM images;"

  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := []
  seenImagesDB.Exec("BEGIN TRANSACTION;")
  entriesCount := RecordSet.RowCount
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      item := Trimmer(Rowu[1])
      If !FileExist(item)
      {
         deleteSQLseenEntry(item, 0)
         entriesDoneCount++
      }

      entriesScanned++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(entriesScanned, entriesCount, startOperation)
         showTOOLtip("Removing entries of inexistent files from the seen images database, please wait" etaTime "`n" groupDigits(entriesDoneCount) " entries to inexistent files removed", 0, 0, entriesScanned / entriesCount)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  RecordSet.Free()
  If !seenImagesDB.Exec("COMMIT TRANSACTION;")
     throwSQLqueryDBerror(A_ThisFunc)

  If (doPartial!="yesu")
     seenImagesDB.Exec("VACUUM main;")

  zeitOperation := A_TickCount - startOperation
  etaTime := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
  If (abandonAll=1)
     etaTime .= "`nOperation aborted. " groupDigits(entriesScanned) " / " groupDigits(entriesCount) " entries were scanned until now"

  showTOOLtip(groupDigits(entriesDoneCount) " entries of inexistent files were removed from the database" etaTime)
  SetTimer, ResetImgLoadStatus, -50
  SoundBeep, 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return entries
}

retrieveEntireSeenImagesDB(ByRef entriesCount, doSorting, applyFilter:=0) {
  entriesCount := 0
  RecordSet := ""
  filteru := Strlen(applyFilter)>1 ? " WHERE imgViewDate LIKE '" applyFilter "%'" : ""
  orderu := (doSorting=1) ? " ORDER BY imgViewDate;" : ";"
  SQL := "SELECT imgfile FROM images" filteru orderu
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := new hashtable(RecordSet.RowCount)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      If RegExMatch(Rowu[1], RegExFilesPattern)
      {
         entriesCount++
         entries[Format("{:L}", Rowu[1])] := 1
      }
  }

  RecordSet.Free()
  addJournalEntry("Recorded seen images: " entriesCount "`nRetrieved entries: " entries.Count())
  Return entries
}

deleteSQLseenEntry(imgPath, thisIndex) {
  SQLstr := "DELETE FROM images WHERE (imgfile='" imgPath "');"
  If !seenImagesDB.Exec(SQLStr)
  {
     stringA := imgPath
     seenImagesDB.EscapeStr(stringA)
     SQLstr := "DELETE FROM images WHERE (imgfile=" stringA ");"
     seenImagesDB.Exec(SQLStr)
  }

  resultedFilesList[thisIndex, 3] := 0
}

retrieveSeenImageDBentry(imgPath, thisIndex) {
  Static lastInvoked := 1

  If (!imgPath || (A_TickCount - lastInvoked<350) && (slideShowRunning!=1))
     Return 0

  If (resultedFilesList[thisIndex, 3]=1)
     Return 1
  Else If (resultedFilesList[thisIndex, 3]=0 && thumbsDisplaying=1)
     Return 0

  zu := cachedAllSessionsSeen[Format("{:L}", imgPath)]
  If (zu=1 && imgPath)
  {
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else If (thumbsDisplaying=1 && zu=0)
     Return 0
 
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  RecordSet := ""
  stringA := imgPath
  seenImagesDB.EscapeStr(stringA)
  SQL := "SELECT imgfile FROM images WHERE imgfile=" stringA " COLLATE NOCASE;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
     Return 0

  entries := 0
  Loop, % RecordSet.RowCount
  {
     Rowu := RecordSet.Rows[A_Index]
     If (Trimmer(Rowu[1])=imgPath)
        entries := "yay"
  }

  RecordSet.Free()
  If entries
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 0
     resultedFilesList[thisIndex, 3] := 0
     Return 0
  }

  lastInvoked := A_TickCount
}

recordSeenIMGdbEntry(imgPath, thisIndex, doCommits:=1) {
   Static invoked := 0
   If (resultedFilesList[thisIndex, 3]=1)
      Return

   If (doCommits=1)
      initSeenImagesListDB()

   If (sqlFailedInit=1)
      Return

   FormatTime, currDate, , yyyy-MM-dd@HH
   ; MD5name := currDate
   resultedFilesList[thisIndex, 3] := 1
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1

   SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES ('" imgPath "', '" currDate "');"
   If !seenImagesDB.Exec(SQLStr)
   {
      stringA := imgPath
      seenImagesDB.EscapeStr(stringA)
      stringB := currDate
      seenImagesDB.EscapeStr(stringB)
      ; MsgBox, % stringA "--" stringB 
      SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES (" stringA ", " stringB ");"
      seenImagesDB.Exec(SQLStr)
   }

   If (invoked>14 && doCommits=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      invoked := 0
   }

   invoked++
}

eraseSeenIMGsDB() {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If !seenImagesDB
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete the list of seen images?`n`nThis action is irreversible. The actual files will be untouched, only the list of seen images is going to be erased.", "&Erase list|&Cancel", 2, "exclamation")
   If !InStr(msgResult, "erase list")
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   seenImagesDB.CloseDB()
   FileDelete, % mainCompiledPath "\seenImagesList.db"
   Sleep, 5
   seenImagesDB := ""
   showTOOLtip("Already seen images list is now empty.`nEntries will be added only if the option`nto skip seen images is activated.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (mustRecordSeenImgs=1)
      initSeenImagesListDB()
}

initSeenImagesListDB() {
   If (sqlFailedInit=-1 || sqlFailedInit=1)
      Return

   If FileExist(mainCompiledPath "\seenImagesList.db")
      alreadyExisting := 1

   seenImagesDB := new SQLiteDB
   sqlFailedInit := seenImagesDB.hasFailedInit
   If !seenImagesDB.OpenDB(mainCompiledPath "\seenImagesList.db")
   {
      mustRecordSeenImgs := 0
      sqlFailedInit := 1
   } Else If (alreadyExisting!=1)
   {
      SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE UNIQUE ON CONFLICT IGNORE, imgViewDate TEXT, PRIMARY KEY(imgfile ASC)); CREATE INDEX imgsIndex ON images (imgfile COLLATE NOCASE);"
      If !seenImagesDB.Exec(SQL)
      {
         mustRecordSeenImgs := 0
         sqlFailedInit := 1
      } Else
      {
         sqlFailedInit := -1
         seenImagesDB.Exec("BEGIN TRANSACTION;")
      }
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      sqlFailedInit := -1
   }
}

SLDBinitSQLdb(fileNamu) {
   activeSQLdb.CloseDB()
   Sleep, 5
   activeSQLdb := new SQLiteDB
   activeSQLdb.OpenDB(fileNamu)
      ; Return -1

   SQL := "CREATE TABLE images (imgidu NUMERIC PRIMARY KEY NOT NULL, imgfile TEXT COLLATE NOCASE NOT NULL, imgfolder TEXT COLLATE NOCASE NOT NULL, fullPath TEXT AS (imgfolder||'\'||imgfile), fsize INT, kbfsize FLOAT AS (round(cast(fsize AS float)/1024,1)), fmodified INT, fcreated INT, imgwidth INT, imgheight INT, imgframes INT, imgdpi INT, imgpixfmt TEXT COLLATE NOCASE, imgwhratio FLOAT AS (round(cast(imgwidth AS float)/imgheight, 5)), imgmegapix FLOAT AS (round((cast(imgwidth AS float)*imgheight)/1000000, 5)), imgmedian FLOAT, imgavg FLOAT, imghpeak FLOAT, imghlow FLOAT, imghmode FLOAT, imghrms FLOAT, imghminu FLOAT, imghrange FLOAT, innerpixelz TEXT, outerpixelz TEXT, entireHush TEXT, pixelzHash TEXT, isDeleted INT DEFAULT 0, UNIQUE (fullPath));"
   SQL .= "CREATE TABLE imagesData (imgfile TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, imgCaption TEXT, imgAudio TEXT COLLATE NOCASE, PRIMARY KEY(imgfile ASC));"
   SQL .= "CREATE TABLE dynamicfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE staticfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE settings (paramz TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, valuez TEXT COLLATE NOCASE, PRIMARY KEY(paramz ASC, valuez ASC));"
   SQL .= "CREATE INDEX imgsIndex ON images(imgidu, imgfolder, imgfile);"
   If !activeSQLdb.Exec(SQL)
      Return activeSQLdb.ErrorMsg
}

dummy() {
  Sleep, 0
}

setImageLoading() {
  If (slideShowRunning=1 || animGIFplaying=1 || drawingShapeNow=1 || hasInitSpecialMode=1 || liveDrawingBrushTool=1)
     Return

  imageLoading := 1
  changeMcursor("busy-img")
}

ResetImgLoadStatus() {
  If (slideShowRunning=1 || animGIFplaying=1) && (imageLoading!=1 && runningLongOperation!=1)
  {
     If (imageLoading=1)
        SetTimer, ResetImgLoadStatus, -70
     Return
  }

  If !GetKeyState("LButton")
  {
     changeMcursor("normal-extra")
     runningLongOperation := 0
     mustAbandonCurrentOperations := imageLoading := 0
  } Else If (imageLoading=1)
     SetTimer, ResetImgLoadStatus, -70
}

ShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
  Static prevImgPath, lastInvoked := 1
  If (usePrevious=2)
     preventHUDelements := 0

  imgPath := StrReplace(imgPath, "||")
  If (slideShowRunning=1)
  {
     slideShowRunning := interfaceThread.ahkgetvar.slideShowRunning
     If (slideShowRunning!=1)
     {
        StopMediaPlaying(1)
        prevSlideShowStop := A_TickCount
     }
  }

  doIT := ((A_TickCount - lastInvoked<125) && (drawModeAzeit>180 && LastWasFastDisplay!=1 && prevDrawingMode=1)) || ((A_TickCount - lastInvoked<65) && (prevImgPath!=imgPath && drawModeAzeit>50)) || ((A_TickCount - lastInvoked<10) && prevDrawingMode=1) ? 1 : 0
  If (A_TickCount - prevColorAdjustZeit<90) || (animGIFplaying=1 || slideShowRunning=1)
     doIT := 0

  If (usePrevious=0 && ForceIMGload=0 && AnyWindowOpen!=10 && vpImgPanningNow=0
  && doIT=1 && !diffIMGdecX && !diffIMGdecY && thumbsDisplaying!=1)
  {
     ; ToolTip, % Exception("", -1).Line "`n" Exception("", -1).What, , , 2
     zPlitPath(imgPath, 1, OutFileName, OutDir)
     If (vpIMGrotation>0)
        zoomu := " @ " vpIMGrotation "°"
     If (IMGresizingMode=4)
        zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

     winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
     winPrefix := defineWinTitlePrefix()
     pVwinTitle := winPrefix winTitle
     setWindowTitle(pVwinTitle, 1)
     lastInvoked := A_TickCount
     dummyFastImageChangePlaceHolder(OutFileName, OutDir)
     ; SetTimer, dummyFastImageChangePlaceHolder, -15
     dummyTimerReloadThisPicture(550)
     prevImgPath := imgPath
  } Else
  {
     If (animGIFplaying=1)
        usePrevious := 0

     prevImgPath := imgPath
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount

     coreShowTheImage(imgPath, usePrevious, ForceIMGload)
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount
  }

  lastInvoked := A_TickCount
}

coreShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
   Critical, on
   Static prevImgPath, lastInvoked2 := 1, counteru
        , lastInvoked := 1, prevPicCtrl := 1

   WinGet, winStateu, MinMax, ahk_id %PVhwnd%
   If (winStateu=-1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()
      DestroyGIFuWin()
      Return
   }

   startZeitIMGload := A_TickCount
   SetTimer, ResetImgLoadStatus, Off
   ThisPrev := (ForceIMGload=1 || usePrevious=2) ? 1 : 0
   If (imgPath=prevImgPath && StrLen(prevImgPath)>3 && ThisPrev!=1)
      usePrevious := 1

   If (usePrevious=2 || ForceIMGload=1)  ; force no caching
   {
      If (ForceIMGload=1)
         prevImgPath := 1
      usePrevious := 0
   }

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"
   If (IMGresizingMode=4)
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

   winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
   If (thumbsDisplaying=1)
   {
      filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
      SetTimer, UpdateThumbsScreen, -10
      pVwinTitle := filesSelInfo "THUMBS: " winTitle
      setWindowTitle(pVwinTitle, 1)
      If (imageLoading=1)
         SetTimer, ResetImgLoadStatus, -15
      Return
   }

   If !gdiBitmap
   {
      usePrevious := 0
      ForceIMGload := 1
   }
   ; ToolTip, % AprevImgCall "`n" BprevImgCall "`n" imgPath,,,2
   If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath)) && (ForceIMGload=0) || StrLen(UserMemBMP)>1
      ignoreFileCheck := 1

   If (vpImgPanningNow=0 && usePrevious=0 && ignoreFileCheck!=1)
   {
      If !FileRexists(imgPath)
      {
         destroyGDIfileCache()
         DestroyGIFuWin()
         If (hSNDmedia && autoPlaySNDs!=1)
            StopMediaPlaying()
         If (slideShowRunning=1)
            invokeExternalSlideshowHandler()

         If (WinActive("A")=PVhwnd)
         {
            winTitle := "[*] " winTitle
            pVwinTitle := winTitle
            setWindowTitle(pVwinTitle, 1)
            showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir "\")
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }

         If (imgPath!=prevImgPath)
         {
            If (minimizeMemUsage=1)
               terminateIMGediting()

            If (A_TickCount - lastInvoked2>125) && (A_TickCount - lastInvoked>95)
            {
               SoundBeep, 300, 50
               lastInvoked2 := A_TickCount
            }
    
            If (autoRemDeadEntry=1)
               remCurrentEntry(1)
            lastInvoked := A_TickCount
            SetTimer, ResetImgLoadStatus, -15
            Return "fail"
         }
      }
   }

   If (A_TickCount - lastInvoked>85) && (A_TickCount - lastInvoked2>85)
   || (slideShowRunning=1 || animGIFplaying=1 || usePrevious=1 || oldZoomLevel || ForceIMGload=1 || diffIMGdecX || diffIMGdecY || LastWasFastDisplay=1)
   {
       lastInvoked := A_TickCount
       r2 := ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload)
       ; msgbox, % r2
       If InStr(r2, "error")
       {
          DestroyGIFuWin()
          destroyGDIfileCache()
          If (hSNDmedia && autoPlaySNDs!=1)
             StopMediaPlaying()
          If (slideShowRunning=1)
             invokeExternalSlideshowHandler()

          friendly := (A_PtrSize=4) ? "`nOr, insufficient memory." : ""
          errMsg := "ERROR: Unable to display the image: " groupDigits(currentFileIndex) "`nPossibly malformed image file format or access denied." friendly "`n" r2 "`n" OutFileName "`n" OutDir "\"
          If (WinActive("A")=PVhwnd)
          {
             showTOOLtip(errMsg)
             SetTimer, RemoveTooltip, % -msgDisplayTime
          } Else addJournalEntry(errMsg)
      
          winTitle := "[*] " winTitle
          pVwinTitle := winTitle
          setWindowTitle(pVwinTitle, 1)
          SetTimer, ResetImgLoadStatus, -15
          If (slideShowRunning!=1)
             SoundBeep, 300, 100
          Return "fail"
       } Else prevImgPath := imgPath
       lastInvoked := A_TickCount
   } Else If (vpImgPanningNow=0)
   {
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix winTitle
      setWindowTitle(pVwinTitle, 1)
      delayu := (A_TickCount - prevFastDisplay < 500) ? 110 : 325
      dummyFastImageChangePlaceHolder(OutFileName, OutDir)
      dummyTimerReloadThisPicture(delayu)
   }
   ; SetTimer, ResetImgLoadStatus, -15
   lastInvoked2 := A_TickCount
}

dummyFastImageChangePlaceHolder(OutFileName, OutDir) {
   Static lastInvoked := 1, prevImgPath
   If (A_TickCount - lastInvoked<50)
      Return

   lastInvoked := A_TickCount
   entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
   If (entireString=prevImgPath)
      Return

   prevImgPath := entireString
   CreateOSDinfoLine(entireString, 0, 0, currentFileIndex/maxFilesIndex)
   SetTimer, RemoveTooltip, -500
}

calcImgSizeForVP(modus, imgW, imgH, GuiW, GuiH, ByRef ResizedW, ByRef ResizedH) {
   PicRatio := Round(imgW/imgH, 5)
   GuiRatio := Round(GuiW/GuiH, 5)
   If (imgW <= GuiW) && (imgH <= GuiH)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
      If (ResizedH>GuiH)
      {
         ResizedH := (imgH <= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
         ResizedW := Round(ResizedH * PicRatio)
      }   

      If (modus=2)
      {
         ResizedW := imgW
         ResizedH := imgH
      }
   } Else If (PicRatio > GuiRatio)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
   } Else
   {
      ResizedH := (imgH >= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
      ResizedW := Round(ResizedH * PicRatio)
   }

   If (modus=5)
   {
      ResizedW := GuiW
      ResizedH := GuiH
   }

    ; ToolTip, % modus "=modusa" , , , 2
}

ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload) {
    Critical, on
    Static oImgW, oImgH, prevImgPath, lastTitleChange := 1
         , IDprevImgPath, tinyW, tinyH, wscale

    setImageLoading()
    If (editingSelectionNow=1 && IMGresizingMode=5)
    {
       IMGresizingMode := 1
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    }

    imgPath := StrReplace(imgPath, "||")
    setWindowTitle("Loading file | " imgPath)
    changeMcursor()
    calcScreenLimits()
    ; If (winGDIcreated!=1)
    ;   createGDIwin()
    ; o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
    extraID := ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation usrTextureBGR usrColorDepth bwDithering
    IDthisImgPath := imgPath "-" userHQraw extraID
    If (imgPath!=prevImgPath || IDthisImgPath!=IDprevImgPath || !gdiBitmap || ForceIMGload=1)
    {
       ; ToolTip, % imgPath "`n" prevImgPath , , , 2
       gdiBMPchanged := 1
       If (imgPath!=prevImgPath) && (currentFileIndex!=0)
       {
          terminateIMGediting()
          desiredFrameIndex := 0
          If (AutoDownScaleIMGs=2)
             AutoDownScaleIMGs := 1
       }

       mustReloadIMG := (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath) || (ForceIMGload=1) ? 1 : 0
       If (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath)
       {
          usePrevious := 0
          mustReloadIMG := ForceIMGload := 1
          If (currentFileIndex!=0)
             GdipCleanMain(6)
       }

       disposeCacheIMGs()
       changeMcursor()
       r1 := CloneMainBMP(imgPath, oImgW, oImgH, mustReloadIMG, hasFullReloaded)
       abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
       If (imgFxMode=3 && r1!="error" && abortImgLoad<3)
       {
          setWindowTitle("Calculating auto-color adjustments")
          AdaptiveImgLight(gdiBitmap, imgPath, oImgW, oImgH)
       }

       If (abortImgLoad>2)
       {
          o_ImgQuality := userimgQuality
          If (userimgQuality=1)
             ToggleImgQuality("lowu")
          If (desiredFrameIndex<1 && (usrColorDepth>1 || vpIMGrotation>0))
          {
             setWindowTitle("Image processing aborted")
             showTOOLtip("Image processing aborted")
             SetTimer, RemoveTooltip, % -msgDisplayTime//2
          }
       }
    }

    If (!gdiBitmap || r1="error")
    {
       If (o_ImgQuality=1)
          ToggleImgQuality("highu")
       If (AutoDownScaleIMGs=2)
          AutoDownScaleIMGs := 1

       prevImgPath := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       FadeMainWindow()
       SetTimer, ResetImgLoadStatus, -15
       r := (r1="error") ? r1 : 0
       Return r
    }

   prevImgPath := imgPath
   IDprevImgPath := imgPath "-" userHQraw extraID
   GetWinClientSize(GuiW, GuiH, PVhwnd, 0)
   imgW := oImgW
   imgH := oImgH
   decideUndoLevelsAccepted(imgW, imgH)
   If (IMGresizingMode=3) ; original [100%]
   {
      lGuiW := (GuiW>imgW) ? imgW : GuiW
      lGuiH := (GuiH>imgH) ? imgH : GuiH
      ws := Round(ResizedW / imgW * 100)
      If (ws<100)
      {
         ws := Round(((lGuiW*lGuiH) / (imgW*imgH)) * 100)
         ws .= "% visible"
      } Else If (ws>100)
      {
         ws := "100%"
      } Else ws .= "%"
      zoomLevel := 1
      ResizedW := imgW
      ResizedH := imgH
   } Else If (IMGresizingMode=4) ; custom zoom level
   {
      prevVPsize := max(prevResizedVPimgW, prevResizedVPimgH)
      If (prevVPsize>2 && gdiBMPchanged=1 && lockZoomLevel=0 && animGIFplaying!=1)
      {
         calcImgSizeForVP(1, oimgW, oimgH, prevVPsize, prevVPsize, ResizedW, ResizedH)
         zoomLevel := clampInRange(Round(ResizedW / imgW, 3), 0.01, 20)
         ResizedW := Round(oimgW * zoomLevel, 3)
         ResizedH := Round(oimgH * zoomLevel, 3)
         ws := Round(zoomLevel * 100) "%"
      } Else
      {
         ResizedW := Round(imgW * zoomLevel, 3)
         ResizedH := Round(imgH * zoomLevel, 3)
         ws := Round(zoomLevel * 100) "%"
      }
   } Else
   {
      calcImgSizeForVP(IMGresizingMode, oimgW, oimgH, GuiW, GuiH, ResizedW, ResizedH)
      zoomLevel := Round(ResizedW / imgW, 3)
      ws := Round(ResizedW / imgW * 100) "%"
   }

   ; ToolTip, % imgW ", " oImgW ", " roImgW ", " ResizedW ,,, 2
   IMGlargerViewPort := ((ResizedH-5>GuiH+1) || (ResizedW-5>GuiW+1)) ? 1 : 0
   IMGentirelylargerThanVP := ((ResizedH-5>GuiH+1) && (ResizedW-5>GuiW+1)) ? 1 : 0
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   winPrefix := defineWinTitlePrefix()
   winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "] | " OutFileName " | " OutDir "\"
   If (A_TickCount - lastTitleChange>300)
      setWindowTitle("Adapting image to viewport")

   prevResizedVPimgW := ResizedW := Round(ResizedW)
   prevResizedVPimgH := ResizedH := Round(ResizedH)
   prevMaxSelX := roImgW ? roImgW : oImgW
   prevMaxSelY := roImgH ? roImgH : oImgH
   If (hSNDsong && StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && gdiBMPchanged=1)
   {
      If RegExMatch(MCI_Status(hSNDsong), "i)^(stop|pause)")
      {
         MCI_SendString("seek " hSNDsong " to 1 wait")
         If MCI_Play(hSNDsong)
            StopMediaPlaying(1)
      }
   }

   If (editingSelectionNow=1 && relativeImgSelCoords=1 && gdiBMPchanged=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
   If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && (animGIFplaying!=1 || desiredFrameIndex=0) && slideShowDelay>950)
      GDIfadeVPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)

   changeMcursor()
   pVwinTitle := infoFilesSel infoFrames winTitle
   r := QPV_ShowImgonGui(ResizedW, ResizedH, GuiW, GuiH, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, wasPrevious)
   delayu := (A_TickCount - prevFastDisplay < 300) ? 90 : 550
   If (wasPrevious=1 && animGIFplaying!=1)
      dummyTimerReloadThisPicture(delayu)

   infoFilesSel := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
   If (totalFramesIndex>0)
      infoFrames := "["  desiredFrameIndex "/" totalFramesIndex "] "

   setWindowTitle(pVwinTitle, 1)
   lastTitleChange := A_TickCount
   If (o_ImgQuality=1)
      ToggleImgQuality("highu")

   SetTimer, ResetImgLoadStatus, -15
   Return r
}

drawinfoBox(mainWidth, mainHeight, directRefresh, Gu) {
    Static prevMsg, prevOSDfnt
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    infoFilesSel := (markedSelectFile>0) ? "`nFiles selected: " groupDigits(markedSelectFile) : ""
    If (totalFramesIndex>0 || currIMGdetails.Frames>1) && (thumbsDisplaying!=1)
    {
       thisFramesInfo := (totalFramesIndex>0) ? totalFramesIndex : currIMGdetails.Frames
       infoFrames := "`nMultiple pages: " desiredFrameIndex " / " thisFramesInfo
    }

    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If FileExist(imgPath)
    {
       QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
       fileSizu := Round(resultedFilesList[currentFileIndex, 6]/1024)
       fileSizu := (fileSizu>1023) ? Round(fileSizu/1024, 1) " MB" : fileSizu " KB"
       FileDateM := resultedFilesList[currentFileIndex, 7]
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       fileMsg := "`n" fileSizu " | " FileDateM
    } Else If (currentFileIndex!=0)
       fileMsg := "`nFile not found or access denied..."

    fileRelatedInfos := (StrLen(folderu)>3) ? folderu "\`n[ " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " ] " fileNamu fileMsg : ""
    If (thumbsDisplaying!=1)
    {
       If (vpIMGrotation>0)
          infoRotate := " @ " vpIMGrotation "°"

       infoSizing := "`nRescaling mode: " DefineImgSizing()
       If (IMGresizingMode!=5)
       {
          infoSizing .= (IMGresizingMode!=4) ? " | " Round(zoomLevel*100) "%" infoRotate : infoRotate
          If (showInfoBoxHUD=2)
             infoSizing .= "`nViewport alignment: " defineImgAlign()
       }

       infoRes := "`nResolution: " groupDigits(maxSelX) " x " groupDigits(maxSelY) " px | " Round((maxSelX*maxSelY)/1000000,2) " MPx"
       If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
          infoRes .= " | DOWNSCALED"
       If (currIMGdetails.TooLargeGDI=1)
          infoRes .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
       ; infoRes := "`nResolution (W x H): " thisW " x " thisH " px [ " Round(zoomLevel*100) "%" infoRotate " ]"
    } Else
    {
       thisFileIndex := currentFileIndex
       If (showInfoBoxHUD=2)
       {
          infoSizing := "`nThumbnails alignment: " defineImgAlign() "`nThumbnails size: " thumbsW " x " thumbsH " px | " defineThumbsAratio()
          thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
          infoSizing .= "`nThumbnails grid: " maxItemsW " x " maxItemsH " = " maxItemsPage
       }

       If (!resultedFilesList[thisFileIndex, 9] && notFound!=1)
       {
          If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
             GetCachableImgFileDetails(imgPath, thisFileIndex)
          If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
             updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
       }

       If (notFound!=1)
       {
          infoRes := "`nImage resolution: " groupDigits(resultedFilesList[thisFileIndex, 13]) " x " groupDigits(resultedFilesList[thisFileIndex, 14]) " px | " resultedFilesList[thisFileIndex, 17] " MPx"
          infoRes .= (resultedFilesList[thisFileIndex, 9]>1) ? "`nImage frames: " resultedFilesList[thisFileIndex, 9] : ""
          infoRes .= "`nImage pixel format: " resultedFilesList[thisFileIndex,15]
       }
    }

    If StrLen(UserMemBMP)>2
    {
       infoEditing := "IMAGE EDITING MODE`n"
       If (showInfoBoxHUD=2 && thumbsDisplaying!=1)
          infoEditing .= "Undo levels recorded: " currentUndoLevel " / " undoLevelsRecorded "`n"
    }

    If (showInfoBoxHUD=1)
    {
       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       If (thumbsDisplaying=1)
       {
          tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
          tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       } Else
       {
          tlbrBonusX := (hasTrans=1 && FlipImgH=0) ? ToolbarWinW : 0
          tlbrBonusY := (hasTrans=2 && FlipImgV=0) ? ToolbarWinH : 0
       }

       entireString := infoEditing fileRelatedInfos infoRes infoSizing infoFrames
       thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfntSize OSDbgrColor OSDtextColor
       If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
       {
          prevOSDfnt := thisOSDfnt
          infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
          infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, !thumbsDisplaying)
          prevMsg := entireString
       }
       trGdip_DrawImage(A_ThisFunc, Gu, infoBoxGdiCached, tlbrBonusX, tlbrBonusY)
       Return
    }

    If (thumbsDisplaying!=1)
       infoRes .= " | " currIMGdetails.dpi " DPI"

    mamUsage := GetProcessMemoryUsage(QPVpid)
    If (A_PtrSize=8)
       systemMemInfo := GlobalMemoryStatusEx()

    thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/1500063598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    totalMemoryLoad := (A_PtrSize=8) ? "/ " Round(systemMemInfo.TotalPhys/1024**3, 1) " GB" : "/ 1.5 GB"
    memUsage := "`nMemory usage: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " totalMemoryLoad " | " thisMemoryLoad "%"
    If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
       memUsage.= "`nFile matched search criteria: " thisSearchString

    sliSpeed := Round(slideShowDelay/1000, 2) " sec."
    If (slideShowRunning=1)
       infoSlider := "`nSlideshow running: " DefineSlideShowType() " @ " sliSpeed

    infoMirroring := defineIMGmirroring()
    If (editingSelectionNow=1 && thumbsDisplaying!=1)
    {
       imgSelW := groupDigits(max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2))
       imgSelH := groupDigits(max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2))
       If (relativeImgSelCoords=1)
       {
          x1 := " [ " Round(prcSelX1 * 100) "%, "
          y1 := Round(prcSelY1 * 100) "% ]"
          wP := " [ " Round((prcSelX2 - prcSelX1) * 100) "%, "
          hP := Round((prcSelY2 - prcSelY1) * 100) "% ]"
          ; moreSelInfo := "`nCoordinates relative to image size"
       }

       infoLocked := (lockSelectionAspectRatio>1) ? "`n  Locked aspect ratio: " defineSelectionAspectRatios() : "`n  Aspect ratio: " Round(imgSelW/imgSelH, 2)
       infoLocked .= (LimitSelectBoundsImg=1) ? "`n  Selection area limited to image boundaries" : ""
       infoSelection := "`n `n" DefineVPselAreaMode() " selection coordinates:`n  X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) x1 y1 "`n  W / H: " Round(imgSelW) ", " Round(imgSelH) wP hP moreSelInfo "`n  Rotation: " Round(vPselRotation, 2) "°" infoLocked
    } Else If (editingSelectionNow=1)
       infoSelection := "`nSelection area activated in image view"

    ; If (SLDtypeLoaded=2)
    infoThisSLD := "`nFiles list opened: " defineFilesListType()
    If (SLDtypeLoaded>1)
       infoThisSLD .= "`n" PathCompact(CurrentSLD, 40)

    If (usrColorDepth>1)
       infoColorDepth := "`nSimulated color depth: " defineColorDepth()

    If StrLen(filesFilter)>1
       infoFilteru := "`nFiles list filtered from " groupDigits(bckpMaxFilesIndex) " down to " groupDigits(maxFilesIndex) ".`nFilter pattern used:`n" SubStr(filesFilter, 1, 45)

    totalZeit := A_TickCount - startZeitIMGload + 2
    InfoLoadTime := "`nViewport size: " groupDigits(mainWidth) " x " groupDigits(mainHeight) " px"
    If (totalZeit>=10 && thumbsDisplaying!=1 && directRefresh=1)
    {
       InfoLoadTime .= "`nViewport refresh speed: ~" totalZeit " milisec."
       If (currIMGdetails.HasAlpha=1)
          InfoLoadTime .= " (*)"
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " | " sndMediaPos hSNDmediaDuration
       }
       infoAudio := "`nAudio file associated: " OutFileName mediaDuration statusMedia
    }

    If (animGIFplaying=1)
       infoAnim := "`nGIF animation playing at " GIFspeedDelay " ms / frame."

    If (imgFxMode>1 || usrColorDepth>1)
       infoColors := "`nColors display mode: " DefineFXmodes()

    If (thumbsDisplaying!=1)
       infoPixFmt := "`nImage pixel format: " currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat

    If (resultedFilesList[currentFileIndex, 5]=1)
       infoFaved := "`nImage in favourites list"

    If (thumbsDisplaying=1)
    {
       If (resultedFilesList[currentFileIndex, 3]=1)
          infoFaved .= "`nImage already seen"

       maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
       mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && multiCoreThumbsInitGood=1) ? 1 : 0
       friendlyCoreInfo := (mustDoMultiCore=1) ? "ACTIVATED" : "DEACTIVATED"
       memUsage .= "`nMulti-threaded mode: " friendlyCoreInfo
    }

    hasTrans := adjustCanvas2Toolbar(Gu, 0)
    entireString := infoEditing fileRelatedInfos infoFaved infoRes infoPixFmt memUsage infoSizing infoMirroring infoColors infoColorDepth infoFrames infoAnim InfoLoadTime infoThisSLD infoFilesSel infoAudio infoSlider infoFilteru infoSelection 
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
    borderSize := imgHUDbaseUnit//6
    thisTxtAlignu := (thumbsDisplaying=1) ? "Left" : 0
    txtOptions := initInPlaceTextOptions(thisGu, FontBolded, 0, 1, thisTxtAlignu, OSDFontName, OSDfntSize//1.1, "0xEE" OSDtextColor, "0xEE" OSDbgrColor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    dims := TextuToGraphics(Gu, entireString, nul, OSDFontName, "measure", 0, otherTxtObj)
    dimsFw := clampInRange(dims.w + borderSize*2, 0, mainWidth)
    dimsFh := clampInRange(dims.h + borderSize*2, 0, mainHeight)
    txtOptions.x := (FlipImgH=1 && thumbsDisplaying!=1) ? 0 : borderSize + tlbrBonusX
    txtOptions.y := (FlipImgV=1 && thumbsDisplaying!=1) ? mainHeight - dimsFh + borderSize : borderSize + tlbrBonusY
    txtOptions.w := mainWidth - borderSize
    txtOptions.h := mainHeight - borderSize
    tlbrBonusY := (hasTrans=2 && (FlipImgV=0 || thumbsDisplaying=1)) ? ToolbarWinH : 0
    Gdip_FillRectangle(Gu, OSDwinFadedBrushBGR, tlbrBonusX, tlbrBonusY, dimsFw, dimsFh)
    If (thumbsDisplaying!=1)
       Gdip_ResetWorldTransform(Gu)
    drawInPlaceTextInBox(Gu, entireString, txtOptions)
    If (thumbsDisplaying!=1)
       setMainCanvasTransform(mainWidth, mainHeight, Gu)
}

drawAnnotationBox(mainWidth, mainHeight, Gu) {
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " (" sndMediaPos hSNDmediaDuration  ")"
       }
       If mediaDuration
          infoAudio := "Audio file associated" mediaDuration statusMedia "`n"
    } ; Else If (autoPlaySNDs=1)
      ;  infoAudio := "No audio file associated.`n"


    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"

    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       Try FileRead, textFileContent, % textFile
       If StrLen(textFileContent)<1
          textFileContent := ""
    }

    entireString := infoAudio textFileContent
    If !entireString
       Return

    infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 1, usrTextAlign)
    Gdip_GetImageDimensions(infoBoxBMP, imgW, imgH)
    thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
    thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
    If (usrTextAlign="Left")
       thisPosX := 0
    Else If (usrTextAlign="Center")
       thisPosX := (scrollBarVx>0) ? scrollBarVx//2 - imgW//2 : mainWidth//2 - imgW//2

    If infoBoxBMP
       trGdip_DrawImage(A_ThisFunc, Gu, infoBoxBMP, thisPosX, thisPosY)
    infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
}

clampInRange(value, min, max, reverse:=0) {
   If (reverse=1)
   {
      If (value>max)
         value := min
      Else If (value<min)
         value := max
   } Else
   {
      If (value>max)
         value := max
      Else If (value<min)
         value := min
   }

   Return value
}

changeOSDfontSize(direction) {
  stepu := (OSDfntSize>30) ? 5 : 2
  If (direction=1)
     OSDfntSize += stepu
  Else
     OSDfntSize -= stepu

  OSDfntSize := clampInRange(OSDfntSize, 15, 350)
  INIaction(1, "OSDfntSize", "General")
  showTOOLtip("OSD font size: " OSDfntSize, A_ThisFunc, 2, OSDfntSize/350)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  calcHUDsize()
  recalculateThumbsSizes()
  interfaceThread.ahkassign("OSDfntSize", OSDfntSize)
  If (thumbsListViewMode>1 && thumbsDisplaying=1)
  {
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(25)
  } Else If (thumbsDisplaying=1)
     SetTimer, mainGdipWinThumbsGrid, -25
  Else If (CurrentSLD && maxFilesIndex>0)
     SetTimer, dummyRefreshImgSelectionWindow, -25

  If (ShowAdvToolbar=1)
     SetTimer, createGUItoolbar, -500
}

determineGDIsmallCacheSize(mainWidth, mainHeight) {
  Resized := []
  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  if (imgW*imgH>640000)
     size := 300
  Else
     size := 800

  calcIMGdimensions(imgW, imgH, size, size, ResizedW, ResizedH)

  Resized.Wsmall := ResizedW
  Resized.Hsmall := ResizedH
  Resized.Small := Round((ResizedW * ResizedH)/1000000, 2)
  Resized.Main := Round((imgW * imgH)/1000000, 2)
  Resized.Screen := Round((Floor(mainWidth*1.15) * Floor(mainHeight*1.15))/1000000, 2)
  Return Resized
}

RescaleBMPtiny(imgPath, mainWidth, mainHeight) {
  Critical, on
  Static prevImgPath
  Gdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (Strlen(gdiBitmapSmall)>3 && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBitmapSmall

  gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
  Resized := determineGDIsmallCacheSize(mainWidth, mainHeight)
  If StrLen(gdiBMPvPsize)>3 
  {
     Gdip_GetImageDimensions(gdiBMPvPsize, otherW, otherH)
     vpIMGres := Round((otherW * otherH)/1000000)
  }

  thisImgQuality := (userimgQuality=1) ? 3 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  whichBitmap := (StrLen(gdiBMPvPsize)>3 && vpIMGres>Resized.Small*1.01) ? gdiBMPvPsize : gdiBitmap
  gdiBitmapSmall := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, Resized.Wsmall, Resized.Hsmall, 0, thisImgQuality, -1)
  ; gdiBitmapSmall := Gdi_ResizeBitmap(whichBitmap, Resized.W, Resized.H, 0, 4)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBitmapSmall)>3
     Return gdiBitmapSmall
}

RescaleBMPtinyVPsize(imgPath, GuiW, GuiH) {
  Critical, on

  Static prevImgPath
  Gdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (StrLen(gdiBMPvPsize)>3 && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBMPvPsize

  gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  gdiBMPvPsize := trGdip_ResizeBitmap(A_ThisFunc, gdiBitmap, Floor(GuiW*1.15), Floor(GuiH*1.15), 0, thisImgQuality, -1)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  ; ToolTip, % gdiBitmapIDentire "`n" prevImgPath , , , 2
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBMPvPsize)>3
     Return gdiBMPvPsize
}

setGIFframesDelay() {
   GIFspeedDelay := (totalFramesIndex>75) ? 35 : 45
   If (totalFramesIndex>195)
      GIFspeedDelay := 20
   Else If (totalFramesIndex<15)
      GIFspeedDelay := 60

   If (totalFramesIndex<8)
      GIFspeedDelay := 85
}

multiPageFileManaging(oBitmap) {
   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   totalFramesIndex := Gdip_GetBitmapFramesCount(oBitmap) - 1
   If (totalFramesIndex<0 || !totalFramesIndex)
      totalFramesIndex := 0

   If (desiredFrameIndex>=totalFramesIndex)
      desiredFrameIndex := totalFramesIndex

   setGIFframesDelay()
   If (totalFramesIndex>0 && slideShowRunning=1 && SlideHowMode=1 && animGIFsSupport!=1)
      Random, desiredFrameIndex, 0, % totalFramesIndex

   If RegExMatch(rawFmt, "i)(gif|tiff)$")
      Gdip_BitmapSelectActiveFrame(oBitmap, desiredFrameIndex)
}

LoadFileWithWIA(imgPath, fastMode, noBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
   oBitmap := 0
   Try wiaImg := WIA_LoadImage(imgPath)
   If IsObject(wiaImg)
   {
      mainLoadedIMGdetails.File := imgPath
      mainLoadedIMGdetails.dpi := Round((wiaImg.HorizontalResolution + wiaImg.VerticalResolution)/2)
      mainLoadedIMGdetails.Width := wiaImg.Width
      mainLoadedIMGdetails.Height := wiaImg.Height
      mainLoadedIMGdetails.Frames := wiaImg.FrameCount
      mainLoadedIMGdetails.HasAlpha := wiaImg.IsAlphaPixelFormat
      If (wiaImg.IsAlphaPixelFormat=1)
         extraPixelFormat := "A"
      If (wiaImg.IsIndexedPixelFormat)
         extraPixelFormat .= " [INDEXED-" wiaImg.IsIndexedPixelFormat "]"
      If (wiaImg.IsExtendedPixelFormat)
         extraPixelFormat .= " [EXTENDED-" wiaImg.IsExtendedPixelFormat "]"
      mainLoadedIMGdetails.PixelFormat := wiaImg.PixelDepth "-bit RGB" extraPixelFormat
      mainLoadedIMGdetails.RawFormat := WIA_GetImageFormatID(wiaImg)
      mainLoadedIMGdetails.OpenedWith := "Windows Image Acquisition (WIA)"
      mainLoadedIMGdetails.TooLargeGDI := 0
      If (noBMP=1)
         oBitmap := 1
   } Else
   {
      addJournalEntry("Failed to load image file using WIA`n" imgPath)
      Return
   }

   If (fastMode!=1 && IsObject(wiaImg))
   {
      If (forceW && forceH)
      {
         If (imgW>forceW || imgH>forceH)
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)
      } Else
      {
         capMaxGDIbmpSize32bits()
         If (wiaImg.width*wiaImg.height>maxGDIbmpSize)
         {
            setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
            changeMcursor()
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1)
            If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
               Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
         }

         If (wiaImg.width>32500 || wiaImg.height>32500)
         {
            setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
            changeMcursor()
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, 32500, 32500, 1)
            If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
               Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
         }

         If IsObject(ScaledWiaIMG)
            mainLoadedIMGdetails.TooLargeGDI := 1
      }
   }

   If (IsObject(wiaImg) && noBMP=0)
   {
      Try PicObj := ScaledWiaIMG.Height ? WIA_GetImageBitmap(ScaledWiaIMG) : WIA_GetImageBitmap(wiaImg)

      If (PicObj.Handle)
      {
         setWindowTitle("Converting WIA image format to GDI+ bitmap")
         changeMcursor()
         If wiaImg.IsAlphaPixelFormat
            oBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObj.Handle)
         Else
            oBitmap := trGdip_CreateBitmapFromHBITMAP(PicObj.Handle)
         Gdi_DeleteObject(PicObj.Handle)
      }
   }

   wiaImg := ""
   ScaledWiaIMG := ""
   PicObj := ""
   Return oBitmap
}

LoadBitmapFromFileu(imgPath, noBPPconv:=0, forceGDIp:=0, allowCaching:=0, allowMemBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
  Static prevMD5nameA, prevMD5nameB

  GDIbmpFileConnected := 1
  totalFramesIndex := 0
  coreIMGzeitLoad := A_TickCount
  If (allowMemBMP=1 && StrLen(UserMemBMP)>2)
  {
     currIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     If (currIMGdetails.HasAlpha!=1)
        currIMGdetails.PixelFormat := StrReplace(currIMGdetails.PixelFormat, "A")

     currIMGdetails.RawFormat := Gdip_GetImageRawFormat(UserMemBMP)
     ; currIMGdetails.HasAlpha := InStr(currIMGdetails.PixelFormat, "argb") ? 1 : 0
     currIMGdetails.Frames := 1
     prevMD5nameA := prevMD5nameB := ""
     ; If (minimizeMemUsage=1)
        destroyGDIfileCache()
     Return trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
  }

  If (allowCaching=1)
  {
     fimStuff := (alwaysOpenwithFIM=1) ? 1 desiredFrameIndex totalFramesIndex : 0
     MD5name := generateThumbName(imgPath, 1)
     thisMD5name := MD5name imgPath userHQraw fimStuff cmrRAWtoneMapAlgo cmrRAWtoneMapParamA cmrRAWtoneMapParamB
     If (thisMD5name=prevMD5nameA && StrLen(GDIcacheSRCfileA)>2 && StrLen(prevMD5nameA)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileA "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileA)
        currIMGdetails := AbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileA)
     } Else If (thisMD5name=prevMD5nameB && StrLen(GDIcacheSRCfileB)>2 && StrLen(prevMD5nameB)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileB "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileB)
        currIMGdetails := BbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileB)
     }
  }

  If RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0)
  {
     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
        setWindowTitle("Loading file using the FreeImage library")

     oBitmap := LoadFimFile(imgPath, noBPPconv, 0, forceW, forceH, keepAratio)
     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
        addJournalEntry("Image loaded with FreeImage:`n" imgPath)
     GDIbmpFileConnected := 0
  } Else
  {
     changeMcursor()
     oBitmap := trGdip_CreateBitmapFromFile(imgPath)
     capMaxGDIbmpSize32bits()
     If StrLen(oBitmap)>2
     {
        pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
        Gdip_GetImageDimensions(oBitmap, imgW, imgH)
        Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
        mainLoadedIMGdetails.File := imgPath
        mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
        mainLoadedIMGdetails.Width := imgW
        mainLoadedIMGdetails.Height := imgH
        mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
        mainLoadedIMGdetails.HasAlpha := InStr(pixFmt, "argb") ? 1 : 0
        mainLoadedIMGdetails.PixelFormat := pixFmt
        mainLoadedIMGdetails.RawFormat := Gdip_GetImageRawFormat(oBitmap)
        mainLoadedIMGdetails.OpenedWith := "GDI+"
        mainLoadedIMGdetails.TooLargeGDI := 0
        ; ToolTip, % imgW "-" imgH "-" pixFmt , , , 2
        If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
           ER := Gdip_BitmapConvertFormat(oBitmap, 0x26200A, 2, 1, 0, 0, 0, 0, 0)

        If (!imgW || !imgH || ER || InStr(pixFmt, "0x"))
        {
           mustOpenWithWia := 1
        } Else If ((imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)) && (noBPPconv=0)
        {
           setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
           pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
           If (imgW*imgH>maxGDIbmpSize) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1, 3, pargbPixFmt)
           Else If (imgW>32500) || (imgH>32500) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 32500, 32500, 1, 3, pargbPixFmt)

           If StrLen(nBitmap)>3
           {
              mainLoadedIMGdetails.TooLargeGDI := 1
              oBitmap := trGdip_DisposeImage(oBitmap, 1)
              oBitmap := nBitmap
           } Else mustOpenWithWia := 1
        }
     } Else mustOpenWithWia := 1

     If (mustOpenWithWia=1 && noBPPconv=0) ; || (allowCaching=1)
     {
        loadedWith := 2
        oBitmap := trGdip_DisposeImage(oBitmap, 1)
        setWindowTitle("Loading file through WIA: " imgPath)
        oBitmap := LoadFileWithWIA(imgPath, noBPPconv, 0, forceW, forceH, keepAratio)
        GDIbmpFileConnected := 0
     }

     If StrLen(oBitmap)<4 ; || InStr(pixFmt, "0x"))
     {
        loadedWith := 3
        GDIbmpFileConnected := 0
        oBitmap := LoadFimFile(imgPath, noBPPconv, forceW, forceH, keepAratio)
     } Else If (allowMemBMP=1 && !InStr(pixFmt, "0x"))
        multiPageFileManaging(oBitmap)

     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
     {
        If (loadedWith=2)
           addJournalEntry("Image loaded with WIA:`n" imgPath)
        Else If (loadedWith=3)
           addJournalEntry("Image loaded with FreeImage:`n" imgPath)
        Else
           addJournalEntry("Image loaded with GDI+:`n" imgPath)
     }
  }

  If (allowCaching=1 && StrLen(oBitmap)>2)
  {
     If (slideShowRunning!=1) || (slideShowRunning=1 && slideShowDelay>700)
        userSeenSessionImagesArray[Format("{:L}", imgPath)] := 1

     prevMD5nameB := prevMD5nameA
     prevMD5nameA := thisMD5name
     idGDIcacheSRCfileB := idGDIcacheSRCfileA
     idGDIcacheSRCfileA := GDIbmpFileConnected MD5name imgPath
     GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
     GDIcacheSRCfileB := GDIcacheSRCfileA
     GDIcacheSRCfileA := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
     BbackupIMGdetails := AbackupIMGdetails.Clone()
     AbackupIMGdetails := mainLoadedIMGdetails.Clone()
  }

  If (allowMemBMP=1)
     currIMGdetails := mainLoadedIMGdetails.Clone()
  Return oBitmap
}

RotateBMP2exifOrientation(oBitmap) {
   exifOrientation := Gdip_GetPropertyItem(oBitmap, 0x112)
   orientation := exifOrientation.Value
   ; MsgBox, % orientation
   If (orientation=6)
      Gdip_ImageRotateFlip(oBitmap, 1)
   Else If (orientation=8)
      Gdip_ImageRotateFlip(oBitmap, 3)
   Else If (orientation=3)
      Gdip_ImageRotateFlip(oBitmap, 2)
   Else If (orientation=2)
      Gdip_ImageRotateFlip(oBitmap, 4)
   Else If (orientation=5)
      Gdip_ImageRotateFlip(oBitmap, 5)
   Else If (orientation=4)
      Gdip_ImageRotateFlip(oBitmap, 6)
   Else If (orientation=7)
      Gdip_ImageRotateFlip(oBitmap, 7)
}

capMaxGDIbmpSize32bits() {
  If (A_PtrSize=4)
  {
     mamUsage := GetProcessMemoryUsage(QPVpid)
     If !mamUsage[1]
        Return

     maxGDIbmpSize := ((2115473648 - mamUsage[1] - mamUsage[8]//2)//4)//1.9
     If (maxGDIbmpSize<10101)
        maxGDIbmpSize := 10101
  }
}

Gdip_CloneBmpPargbArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:=0, KeepPixelFormat:=0, ignoreBounds:=0, addBgr:=0) {
   thisPixFmt := !PixelFormat ? coreDesiredPixFmt : PixelFormat
   If (ignoreBounds=1 && w>0 && h>0)
   {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (isDotInRect(x, y, 0, imgW, 0, imgH) && isDotInRect(x + w, y + h, 0, imgW, 0, imgH))
       {
          simpleMode := 1
          newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)
       } Else newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, w, h, thisPixFmt)

       If (StrLen(newBitmap)>2 && simpleMode!=1)
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc "() initially invoked by " funcu, newBitmap, 3)
          If G2
          {
             r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x, y, w, h)
             If (addBgr=1)
             {
                x1 := (x<0) ? Abs(x) : 0
                y1 := (y<0) ? Abs(y) : 0
                x2 := (x+w>imgW) ? x1 + w - ((x + w) - imgW) : x1 + w
                y2 := (y+h>imgH) ? y1 + h - ((y + h) - imgH) : y1 + h
                Gdip_SetClipRect(G2, x1, y1, w, h, 4)
                ; r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x3, y3, w2, h2)
                ; ToolTip, % x1 "=" y1 "=" x2 "=" y2 "`n" w "=" h , , , 2
                trGdip_GraphicsClear(A_ThisFunc "() initially invoked by " funcu, G2, "0x01828282")
             }
          }

          Gdip_DeleteGraphics(G2)
          If (r1="fail" || !G2)
          {
             trGdip_DisposeImage(newBitmap, 1)
             newBitmap := ""
          }
       }
   } Else
     newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)

   If StrLen(newBitmap)<3
   {
      baseMsg := "Unable to create internal PARGB bitmap clone to apply operations on image... Error occured in " A_ThisFunc "() invoked by " funcu  "() for pBMP=" pBitmap ". "
      generalInternalErrorMsgBox(gdipLastError, baseMsg)
      newBitmap := ""
   }

   Return newBitmap
}

generalInternalErrorMsgBox(err, baseMsg, silentMode:=0) {
   Static forceSilent := 0

   If err
      message := "`n`n" Gdip_ErrorHandler(err, 0)

   friendly := (A_PtrSize=4) ? "`n`nPossible cause: memory limit reached." : ""
   friendly .= (A_PtrSize=4 && A_is64BitOS) ? " Please use the 64-bits edition of this application." : ""
   If (InStr(message, "out_of_memory") && maxMemUndoLevels>12012)
      maxMemUndoLevels -= 100000

   addJournalEntry(baseMsg message friendly)
   If (runningLongOperation!=1 && hasInitSpecialMode!=1 && silentMode!=1 && forceSilent!=1)
   {
      If (imgEditPanelOpened=1)
         TextInAreaLivePreview := FillAreaLivePreview := PasteInPlaceLivePreview := 0
      ; SoundBeep, 300, 100
      simpleMsgBoxWrapper(appTitle ": ERROR", baseMsg message friendly, 0, 0, "error")
      If (InStr(baseMsg, glPG) || InStr(baseMsg, 2NDglPG))
      {
         info := (debugModa=1) ? "" : "You can start QPV with /qpv-debug to view all error messages in a debug viewer."
         msgResult := msgBoxWrapper(appTitle, "It seems you are receving errors related to core viewport components. Would you like to no longer receive GDI+ error messages ?`n`nAnyhow, the application will likely continue to malfunction, but at least in silence.", 4, 0, "question")
         If (msgResult="yes")
            forceSilent := 1
      }
   }
}

CloneMainBMP(imgPath, ByRef imgW, ByRef imgH, mustReloadIMG, ByRef hasFullReloaded) {
  Critical, on
  Static prevFrame := -1, AprevImgDownScaled := 0, BprevImgDownScaled := 0, lastInvoked := 1

  totalFramesIndex := 0
  GDIbmpFileConnected := 1
  hasFullReloaded := CountGIFframes := 0
  MD5name := generateThumbName(imgPath, 1)
  o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
  o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
  thisImgCall := MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation
  If !FileRexists(imgPath) && (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath))
     thisImgCall := InStr(AprevImgCall, imgPath) ? SubStr(AprevImgCall, 2) : SubStr(BprevImgCall, 2)

  prevLastImg[2] := prevLastImg[1]
  prevLastImg[1] := [currentFileIndex, resultedFilesList[currentFileIndex, 1]]
  gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
  file2load := thumbsCacheFolder "\big-" alwaysOpenwithFIM userHQraw MD5name ".png"
  ignoreCache := (prevFrame!=desiredFrameIndex || minimizeMemUsage=1 || StrLen(UserMemBMP)>2) ? 1 : mustReloadIMG
  ; MsgBox, % imgPath "`n" AbackupIMGdetails.File "`n" BbackupIMGdetails.File "`n" CbackupIMGdetails.File
  If (SubStr(AprevImgCall, 2)=thisImgCall && StrLen(AprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := AprevImgDownScaled
     Gdip_GetImageDimensions(AprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, AprevGdiBitmap)
     addJournalEntry("Used cached GDI bitmap ID: " AprevGdiBitmap "`n" imgPath)
     gdiBitmapIDcall := AprevImgCall
     gdiBitmapIDentire := AprevImgCall gdiBitmap
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     totalFramesIndex := currIMGdetails.Frames
     Return
  } Else If (SubStr(BprevImgCall, 2)=thisImgCall && StrLen(BprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := BprevImgDownScaled
     Gdip_GetImageDimensions(BprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, BprevGdiBitmap)
     gdiBitmapIDcall := BprevImgCall
     gdiBitmapIDentire := BprevImgCall gdiBitmap
     addJournalEntry("Used cached GDI bitmap ID: " BprevGdiBitmap "`n" imgPath)
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     totalFramesIndex := currIMGdetails.Frames
     extractAmbientalTexture()
     Return
  }

  pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
  If (slideShowRunning!=1 && desiredFrameIndex<1) && (A_TickCount - lastInvoked>250)
     GdipCleanMain(6)

  interfaceThread.ahkassign("canCancelImageLoad", 1)
  changeMcursor()
  preventDownScaling := (IMGresizingMode=3) || (StrLen(UserMemBMP)>2) || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  thisImgPath := (preventDownScaling!=1 && FileExist(file2load) && AutoDownScaleIMGs=1) ? file2load : imgPath
  thisIMGisDownScaled := (thisImgPath!=imgPath && AutoDownScaleIMGs=1) ? 1 : 0
  allowCaching := !minimizeMemUsage
  If StrLen(UserMemBMP)>2
     thisIMGisDownScaled := allowCaching := 0

  oBitmap := LoadBitmapFromFileu(thisImgPath, 0, 0, allowCaching, 1)
  ; MsgBox, % obitmap
  If !oBitmap
     Return "error"

  lastInvoked := A_TickCount
  slowFileLoad := (A_TickCount - coreIMGzeitLoad > 450) ? 1 : 0
  hasFullReloaded := 1
  rawFmt := Gdip_GetImageRawFormat(oBitmap)
  rawFmt := (rawFmt="MEMORYBMP" && fimMultiPage) ? fimMultiPage : rawFmt
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (RegExMatch(rawFmt, "i)(bmp|png|tiff)$") && currIMGdetails.HasAlpha=1 && StrLen(UserMemBMP)<3)
  {
     ERR := Gdip_GetHistogram(oBitmap, 7, histoArray, 0, 0)
     If !ERR
     {
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 0, 254))
               HasAlpha := 1
        }

        currIMGdetails.HasAlpha := HasAlpha
     }
     ; ToolTip, % ERR " = " HasAlpha " = " rawFmt , , , 2
  }

  If (RegExMatch(rawFmt, "i)(gif|tiff)$") && totalFramesIndex>0)
     multiFrameImg := 1
  Else If (rawFmt="JPEG")
     RotateBMP2exifOrientation(oBitmap)

  If (rawFmt="gif" && totalFramesIndex>0)
  {
     gifLoaded := 1
     CountGIFframes := (animGIFsSupport=1) ? totalFramesIndex : 0
  }

  If (rawFmt="MEMORYBMP")
     GDIbmpFileConnected := 0

  If (AnyWindowOpen=17 && performAutoCropNow=1 && usrAutoCropGenerateSelection=0)
  {
     GDIbmpFileConnected := 0
     hasAutoCropped := 1
     setWindowTitle("Auto-cropping image")
     ; xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap)
     kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
     FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
     ; trGdip_DisposeImage(xBitmap, 1)
     If StrLen(kBitmap)>3
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        oBitmap := kBitmap
     }
  }

  Gdip_GetImageDimensions(oBitmap, imgW, imgH)
  totalIMGres := imgW + imgH
  totalScreenRes := ResolutionWidth + ResolutionHeight
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  preventDownScaling := (multiFrameImg=1) || (IMGresizingMode=3) || StrLen(UserMemBMP)>2 || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  If (hasAutoCropped!=1 && preventDownScaling!=1 && !FileExist(file2load) && AutoDownScaleIMGs=1 && totalIMGres/totalScreenRes>1.3)
  {
     setWindowTitle("Downscaling large image to viewport")
     thisImgQuality := (userimgQuality=1) ? "" : 5
     roImgW := imgW, roImgH := imgH
     calcIMGdimensions(imgW, imgH, ResolutionWidth, ResolutionHeight, newW, newH)
     imgW := newW, imgH := newH
     totalIMGres := newW + newH
     slowFileLoad := 0
     thisIMGisDownScaled := 1
     mustSaveFile := (multiFrameImg!=1 && enableThumbsCaching=1) ? 1 : 0
  } ; Else thisIMGisDownScaled := 0
  If (minimizeMemUsage=1 && rawFmt!="MEMORYBMP")
     thisImgQuality := ""

  If !newW
     newW := imgW
  If !newH
     newH := imgH

  BprevImgDownScaled := AprevImgDownScaled
  AprevImgDownScaled := thisIMGisDownScaled
  If (currIMGdetails.HasAlpha!=1 || gifLoaded=1)
     brushRequired := 1

  changeMcursor()
  If (thisIMGisDownScaled=1 || animGIFplaying=1 || gifLoaded=1 || minimizeMemUsage!=1 && rawFmt!="MEMORYBMP")
  {
     rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, newW, newH, 0, thisImgQuality, pargbPixFmt)
     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        If (mustSaveFile=1 && thisIMGisDownScaled=1)
           z := Gdip_SaveBitmapToFile(rBitmap, file2load, 90)
     } Else rBitmap := oBitmap
  } Else
  {
     If (currIMGdetails.HasAlpha=1 && rawFmt!="MEMORYBMP")
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)

     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
     } Else rBitmap := oBitmap
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && vpIMGrotation>0)
  {
     setWindowTitle("Rotating image at " vpIMGrotation "°")
     brushu := (brushRequired=1) ? pBrushWinBGR : ""
     ; nBitmap := simpleFreeImgRotate(rBitmap, vpIMGrotation)
     changeMcursor()
     nBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, rBitmap, vpIMGrotation, brushu, imgQuality, pargbPixFmt)
     If StrLen(nBitmap)>3
     {
        Gdip_GetImageDimensions(nBitmap, imgW, imgH)
        newW := imgW, newH := imgH
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     } Else vpIMGrotation := 0
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && bwDithering=1 && imgFxMode=4)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Converting image to black and white with dithering")
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)

     zBitmap := trGdip_BitmapConvertGray(rBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
     If zBitmap
     {
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := zBitmap
        E := Gdip_BitmapSetColorDepth(rBitmap, "BW", 1)
     }
  } Else If (usrColorDepth>1)
  {
     infoColorDepth := defineColorDepth()
     setWindowTitle("Converting image to " infoColorDepth)
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)
     E := Gdip_BitmapSetColorDepth(rBitmap, internalColorDepth, ColorDepthDithering)
  }

  Gdip_GetImageDimensions(rBitmap, fimgW, fimgH)
  BprevImgCall := AprevImgCall
  AprevImgCall := "a" GDIbmpFileConnected MD5name imgPath o_bwDithering o_AutoDownScaleIMGs "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  gdiBitmapIDcall := AprevImgCall
  gdiBitmapIDentire := AprevImgCall rBitmap
  gdiBitmap := rBitmap
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  extractAmbientalTexture(abortImgLoad)
  BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
  prevFrame := desiredFrameIndex
  If (allowCaching=1)
  {
     BprevGdiBitmap := AprevGdiBitmap
     AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
  }
  imgW := newW, imgH := newH
}

createGDIbrushPbitmap(pBitmap) {
    hbitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, pBitmap)
    If StrLen(hBitmap)>1
    {
       gdiBrushu := Gdi_CreatePatternBrush(hBitmap)
       Gdi_DeleteObject(hBitmap)
       Return gdiBrushu
    }
}

extractAmbientalTexture(abortImgLoad:=0) {
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (abortImgLoad<3 && usrTextureBGR=1 && IMGresizingMode!=5 && confirmTexBGR=1)
    {
       setWindowTitle("Extracting image texture for the window background")
       If gdiAmbientalTexBrush
          Gdi_DeleteObject(gdiAmbientalTexBrush)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
       TexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), 3, 3, 3, ambiTexBrushSize, ambiTexBrushSize, matrix, 0, 0, 0, imageAttribs)
       If TexBrush
       {
          klBMP := trGdip_CreateBitmap(A_ThisFunc, ambiTexBrushSize*2, ambiTexBrushSize*2)
          If klBMP
          {
             Gup := Gdip_GraphicsFromImage(klBMP)
             Gdip_FillRectangle(Gup, TexBrush, 0, 0, ambiTexBrushSize*2, ambiTexBrushSize*2)
             gdiAmbientalTexBrush := createGDIbrushPbitmap(klBMP)
             Gdip_DeleteGraphics(Gup)
             trGdip_DisposeImage(klBMP)
          }
          Gdip_DeleteBrush(TexBrush)
       }
       Gdip_DisposeEffect(pEffect)
    }

    preventScreenOff()
    OnImgFileChangeActions(0)
    If (autoPlaySNDs=1)
    {
       AutoPlayAudioFileAssociated()
       identifyAudioMediaLength()
    }
}

OnImgFileChangeActions(forceThis) {
  Static prevImgPath := ""
  imgPath := currentFileIndex "=" getIDimage(currentFileIndex)
  If (imgPath=prevImgPath && forceThis=0)
  {
     Return
  } Else
  {
     SetTimer, RemoveTooltip, -200
     If (LimitSelectBoundsImg!=1 && editingSelectionNow=1)
        correctActiveSelectionAreaViewPort()
     GIFframesPlayied := 0
     allowNextSlide := 1
     If (A_TickCount - lastGIFdestroy > 950)
        prevAnimGIFwas := ""
     If (AutoDownScaleIMGs=2)
        AutoDownScaleIMGs := 1
     If (hSNDmedia && autoPlaySNDs!=1)
        StopMediaPlaying()
     If (slideShowRunning=1) ;  && (animGIFplaying!=1 || totalFramesIndex<2))
        invokeExternalSlideshowHandler()
  }

  prevImgPath := imgPath
}

invokeExternalSlideshowHandler() {
   allowNextSlide := 1
   interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
   interfaceThread.ahkPostFunction("dummySlideshow")
}

identifyAudioMediaLength() {
   If hSNDmedia
   {
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
   } Else If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
}

IdentifyAudioFileAssociated() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
    {
       AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
       If StrLen(AudioFileu)>3 && FileExist(AudioFileu)
          Return AudioFileu
    }

    audioFile1 := OutDir "\" OutNameNoExt ".WAv"
    audioFile2 := OutDir "\" OutNameNoExt ".WMA"
    audioFile3 := OutDir "\" OutNameNoExt ".MP3"

    If FileRexists(audioFile1)
       thisSNDfile := audioFile1
    Else If FileRexists(audioFile2)
       thisSNDfile := audioFile2
    Else If FileRexists(audioFile3)
       thisSNDfile := audioFile3
    Else
       thisSNDfile := 0
    Return thisSNDfile
}

PlayAudioFileAssociatedNow() {
    If (thumbsDisplaying=1)
       Return

    ohSNDmediaFile := hSNDmediaFile
    ohSNDmedia := hSNDmedia
    StopMediaPlaying()
    If (ohSNDmediaFile && ohSNDmedia)
    {
       zPlitPath(ohSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("Media file stopped: `n" OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       identifyAudioMediaLength()
       zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       thisMsg := (E || !hSNDmedia) ? "ERROR: " E " - " hSNDmedia ". Unable to play media file: `n" : "Media file now playing: `n(" hSNDmediaDuration ") " 
       showTOOLtip(thisMsg OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime

       If (E || !hSNDmedia)
          StopMediaPlaying()
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("WARNING: No media file found to play`n" OutNameNoExt " (.WAV / .WMA / .MP3)`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

AutoPlayAudioFileAssociated() {
    Static prevAudioFile
    thisSNDfile := IdentifyAudioFileAssociated()
    If (thisSNDfile=prevAudioFile && StrLen(thisSNDfile)>3)
       Return

    StopMediaPlaying()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       milisec := MCI_Length(hSNDmedia)
       If (E || !hSNDmedia || milisec<350)
          StopMediaPlaying()
       Else
          prevAudioFile := hSNDmediaFile
    } Else prevAudioFile := ""
}

startSlidesMusicNow() {
    StopMediaPlaying(1)
    If StrLen(SlidesMusicSong)>3
    {
       hSNDsong := MCI_Open(SlidesMusicSong,,,0)
       E := MCI_Play(hSNDsong)
       milisec := MCI_Length(hSNDsong)
       ; lenghtu := MCI_ToHHMMSS(milisec)
       If (E || !hSNDsong || milisec<900)
          StopMediaPlaying(1)
    }
}

StopMediaPlaying(modus:=0) {
    If (modus=1)
    {
       If (StrLen(SlidesMusicSong)>3 && hSNDsong)
       {
          MCI_Stop(hSNDsong)
          hSNDsong := ""
       }
    } Else
    {
       If hSNDmedia
       {
          MCI_Stop(hSNDmedia)
          hSNDmediaDuration := hSNDmedia := hSNDmediaFile := ""
       }
    }
}

createHistogramBMP(whichBitmap) {
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   mpxu := Round((imgW*imgH)/1000000,2)
   If (mpxu>7.5 && StrLen(whichBitmap)>2)
      whichBMP := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, 520, 520, 1, 3, -1)
   Else
      whichBMP := whichBitmap

   If StrLen(whichBMP)<3
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram - no bitmap given")
      Return
   }

   If (showHistogram=2)
   {
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
   } Else If (showHistogram=3)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlArray, 0, 0)
   } Else If (showHistogram=4)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlArray, 0)
   } Else If (showHistogram=5)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlArray)
   } Else If (showHistogram=6)
   {
      setWindowTitle("Calculating histogram")
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlR, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlG, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlB)
      brLvlFakeArray := []
      Loop, 257
      {
          thisIndex := A_Index - 1
          thisMax := max(brLvlR[thisIndex], brLvlG[thisIndex], brLvlB[thisIndex])
          brLvlFakeArray[thisIndex] := Round(thisMax/1.25)
          ; MsgBox, % thisMax
      }
   }

   If ERR
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram... " Gdip_ErrorHandler(err, 0))
      Return
   }

   Gdip_GetImageDimensions(whichBMP, imgW, imgH)
   zr2ndMaxV := r2ndMaxV := 0
   minBrLvlV := TotalPixelz := imgW * imgH
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If (nrPixelz="")
          Continue

       stringArray .= nrPixelz "." (thisIndex+1) "`n"
       If (nrPixelz>0)
       {
          thisSum += nrPixelz
          If (thisSum>TotalPixelz//2 && medianValue="")
             medianValue := thisIndex
       }

       If (nrPixelz>1)
          stringArray3 .= (thisIndex+1) "." nrPixelz "`n"
       sumTotalBr += nrPixelz * (thisIndex+1)
       SimpleSumTotalBr += nrPixelz
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (nrPixelz<modePointV && nrPixelz>r2ndMaxV)
          r2ndMaxV := nrPixelz
       If (nrPixelz>zr2ndMaxV)
          zr2ndMaxV := nrPixelz

       If (nrPixelz<minBrLvlV && nrPixelz>2)
       {
          minBrLvlV := nrPixelz
          minBrLvlK := thisIndex
       }
   }

   Sort, stringArray, ND`n
   RstringArray := stringArray
   Sort, RstringArray, RND`n
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   avgBrLvlK := Round(sumTotalBr/TotalPixelz - 1, 1)
   thisVal := minu := maxu := 0
   Loop, 256
   {
      thisVal := brLvlArray[Round(avgBrLvlK) - A_Index]
      If (thisVal>0 && !minu)
      {
         minu := thisVal
         Break
      }
   }

   Loop, 256
   {
      thisVal := brLvlArray[A_Index + Round(avgBrLvlK)]
      If (thisVal>0 && !maxu)
      {
         maxu := thisVal
         Break
      }
   }

   avgBrLvlV := (minu + maxu)//2 ;  brLvlArray[Round(avgBrLvlK)]
   modePointK3 := ST_ReadLine(RstringArray, 2)
   modePointK3 := StrSplit(modePointK3, ".")
   modePointK4 := ST_ReadLine(RstringArray, 3)
   modePointK4 := StrSplit(modePointK4, ".")
   modePointK5 := ST_ReadLine(RstringArray, 4)
   modePointK5 := StrSplit(modePointK5, ".")
   rangeA := ST_ReadLine(stringArray3, 1)
   rangeA := StrSplit(rangeA, ".")
   rangeB := ST_ReadLine(stringArray3, "L")
   rangeB := StrSplit(rangeB, ".")
   Loop, 256
   {
       minBrLvlK2 := ST_ReadLine(stringArray, A_Index)
       minBrLvlK2 := StrSplit(minBrLvlK2, ".")
       If (minBrLvlK2[1]=0)
          Continue
       If (minBrLvlK2[2]>0)
          Break
   }

   rangeC := rangeB[1] - rangeA[1] + 1
   meanValue := SimpleSumTotalBr/rangeC
   meanValuePrc := Round(meanValue/TotalPixelz * 100)
   meanValuePrc := (meanValuePrc>0) ? " (" meanValuePrc "%) " : ""
   2ndMaxVa := (r2ndMaxV + avgBrLvlV)//2 + minBrLvlV
   2ndMaxVb := (r2ndMaxV + meanValue)//2 + minBrLvlV
   Loop, 256
   {
       lookMean := ST_ReadLine(stringArray, A_Index)
       lookMean := StrSplit(lookMean, ".")
       thisMean := lookMean[1]
       If (thisMean>meanValue)
       {
          meanValueK := Round((prevMean + lookMean[2] - 1)/2, 1)
          Break
       } prevMean := lookMean[2]
   }

   meanValueK := !meanValueK ? "" : " | Mean: " meanValueK meanValuePrc
   modePointKm := ST_ReadLine(stringArray, 2)
   modePointKm := StrSplit(modePointKm, ".")
   ; f2ndMaxV := (2ndMaxVa + 2ndMaxVb)//2 + avgBrLvlV//2
   f2ndMaxV := (histogramMode=2) ? (avgBrLvlV + (modePointK3[1] + modePointK4[1] + modePointK5[1])//3)//2 : (r2ndMaxV + zr2ndMaxV)//2    ; + modePointKm[1]//2
   If (f2ndMaxV>r2ndMaxV && histogramMode=2)
      f2ndMaxV := (r2ndMaxV + f2ndMaxV)//2
   If (histogramMode=1)
      f2ndMaxV := (avgBrLvlV + minBrLvlK2[1])//2
   ; ToolTip, % avgBrLvlV "--" minBrLvlK2[1] "--" r2ndMaxV , , , 2
   peakPrc := Round(modePointV/TotalPixelz * 100)
   peakPrc := (peakPrc>0) ? " (" peakPrc "%)" : ""
   minPrc := Round(minBrLvlK2[1]/TotalPixelz * 100)
   minPrc := (minPrc>0) ? " (" minPrc "%)" : ""
   medianPrc := Round(lookValue[2]/TotalPixelz * 100)
   medianPrc := (medianPrc>0) ? " (" medianPrc "%)" : ""
   avgPrc := Round(avgBrLvlV/TotalPixelz * 100)
   avgPrc := (avgPrc>0) ? " (" avgPrc "%)" : ""
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   TotalPixelzSpaced := groupDigits(imgW*imgH)

   infoRange := "(" defineHistogramMode() ") " defineHistogramType() " range: " rangeA[1] - 1 " - " rangeB[1] - 1 " (" rangeC ")"
   infoPeak := "`nMode: " modePointK peakPrc
   infoAvg := " | Avg: " avgBrLvlK avgPrc " | Min: " minBrLvlK2[2] - 1 minPrc
   infoMin := "`nMedian: " medianValue medianPrc meanValueK
   entireString := infoRange infoPeak infoAvg infoMin "`nTotal pixels: " TotalPixelzSpaced
   If (slideShowRunning=1)
      infoBoxBMP := trGdip_CreateBitmap(A_ThisFunc, 5, 5)
   Else
      infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.5, mainWidth//1.3, mainHeight//1.3, OSDtextColor, OSDbgrColor, 1, 0)
   ; tooltip, % "|" TotalPixelz "|" modePointV ", " 2ndMaxV ", " avgBrLvlV " || "  maxW "," maxH  ;  `n" PointsList
   Scale := (slideShowRunning=1) ? imgHUDbaseUnit/50 : imgHUDbaseUnit/40
   If (rangeC<2)
      f2ndMaxV := modePointK
   If (f2ndMaxV<250)
      f2ndMaxV := 250

   thisData := (showHistogram=6) ? brLvlFakeArray : brLvlArray
   thisOpacity := (showHistogram=6) ? "0xCC" : "0xFF"
   If (showHistogram=3)
      thisGraphColor := "0xFFFF3300"
   Else If (showHistogram=4)
      thisGraphColor := "0xFF33FF33"
   Else If (showHistogram=5)
      thisGraphColor := "0xFF3366FF"
   Else
      thisGraphColor := thisOpacity OSDtextColor

   HistogramBMP := drawHistogram(thisData, f2ndMaxV, 256, Scale, thisGraphColor, "0xEE" OSDbgrColor, imgHUDbaseUnit//3, infoBoxBMP)
   trGdip_DisposeImage(infoBoxBMP, 1)
   If (whichBMP!=whichBitmap && StrLen(whichBMP)>2)
      trGdip_DisposeImage(whichBMP, 1)
}

groupDigits(nrIn, delim:=" ") {
   If StrLen(nrin)>3
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 2)
   If StrLen(nrin)>7
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 6)
   If StrLen(nrin)>11
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 10)
   If StrLen(nrin)>15
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 14)
   Return nrIn
}

defineRelativeSelCoords(maxSelX, maxSelY) {
   prcSelX1 := imgSelX1/maxSelX
   prcSelY1 := imgSelY1/maxSelY
   prcSelX2 := imgSelX2/maxSelX
   prcSelY2 := imgSelY2/maxSelY
}

capSelectionRelativeCoords() {
   If (prcSelX1<0)
      prcSelX1 := 0
   Else If (prcSelX1>=1)
      prcSelX1 := 0.99

   If (prcSelY1<0)
      prcSelY1 := 0
   Else If (prcSelY1>=1)
      prcSelY1 := 0.99

   If (prcSelX2<0.001)
      prcSelX2 := 0.001
   Else If (prcSelX2>1)
      prcSelX2 := 1

   If (prcSelY2<0.001)
      prcSelY2 := 0.001
   Else If (prcSelY2>1)
      prcSelY2 := 1
}

calcRelativeSelCoords(whichBitmap, imgW:=0, imgH:=0) {
   If (imgSelX1=0 && imgSelY1=0 && imgSelX2=-1 && imgSelY2=-1)
      Return

   If (!imgW || !imgH)
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

   imgSelX1 := Round(prcSelX1*imgW)
   imgSelY1 := Round(prcSelY1*imgH)
   imgSelX2 := Round(prcSelX2*imgW)
   imgSelY2 := Round(prcSelY2*imgH)
   nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
   nimgSelX2 := max(imgSelX1, imgSelX2)
   nimgSelY2 := max(imgSelY1, imgSelY2)

   kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   If (kimgSelW>32500)
      nImgSelX2 := nImgSelX1 + 32500
   If (kimgSelH>32500)
      nImgSelY2 := nImgSelY1 + 32500

   If (kimgSelH*kimgSelW>23125**2)
   {
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      scaleu := (kimgSelH*kimgSelW)/(23125**2)
      nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
      nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>32500)
         nImgSelX2 := nImgSelX1 + 32500
      If (kimgSelH>32500)
         nImgSelY2 := nImgSelY1 + 32500
   }

   ImgSelX2 := nImgSelX2
   ImgSelY2 := nImgSelY2
}

AdaptiveImgLight(whichImg, imgPath, Width, Height) {
   If isWinXP
   {
      addJournalEntry("Automatic colors adjustments is deactivated on " A_OSVersion)
      Return
   }

   startZeit := A_TickCount
   If (Width=1 && Height=1)
      Gdip_GetImageDimensions(whichImg, Width, Height)

   mustRem := 0
   If ((Width//10*Height//10)>18500)
   {
      ; calcIMGdimensions(Width, Height, 900, 900, newWidth, newHeight)
      rBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichImg, 900, 900, 1, 3, -1)
      If !rBitmap
         Return -1
      Else
         mustRem := 1

      whichImg := rBitmap
   }

   Gdip_GetImageDimensions(whichImg, Width, Height)
   xCrop := Width//11
   yCrop := Height//11
   wCrop := Width - xCrop*2 + 1
   hCrop := Height - yCrop*2 + 1

   cropBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichImg, xCrop, yCrop, wCrop, hCrop)
   If !cropBMP
      Return -1

   brLvlArray := [], ArrChR := [], ArrChG := [], ArrChB := []
   rMinBrLvl := minBrLvl := 256
   modePointV := lumosAdjust := 1
   maxBrLvl := sumTotalBr := countTotalPixelz := thisBrLvl := 0
   GammosAdjust := countBrightPixelz := countMidPixelz := countDarkPixelz := 0

   ERR := Gdip_GetHistogram(cropBMP, 2, ArrChR, ArrChG, ArrChB)
   pEffect := Gdip_CreateEffect(6, 0, -99, 0)
   If !ERR
   {
      If pEffect
         rT := Gdip_BitmapApplyEffect(cropBMP, pEffect)
   
      Gdip_DisposeEffect(pEffect)
      ERR := Gdip_GetHistogram(cropBMP, 3, brLvlArray, 0, 0)
   }

   trGdip_DisposeImage(cropBMP, 1)
   If (mustRem=1)
      trGdip_DisposeImage(rBitmap, 1)

   If ERR
      Return -1

   rTotalPixelz := Width*Height
   TotalPixelz := wCrop*hCrop
   otherThreshold := (usrAdaptiveThreshold>0) ? usrAdaptiveThreshold : 2
   minMaxThreshold := Floor(rTotalPixelz*0.000015) + usrAdaptiveThreshold
   If (minMaxThreshold<1)
      minMaxThreshold := 1

   ; gather image histogram statistics
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If !nrPixelz
          Continue

       sumTotalBr += nrPixelz * thisIndex
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (thisIndex>maxBrLvl && nrPixelz>minMaxThreshold)
          maxBrLvl := thisIndex

       If (thisIndex<minBrLvl && nrPixelz>minMaxThreshold)
          minBrLvl := thisIndex

       If (thisIndex<rMinBrLvl && nrPixelz>otherThreshold)
          rMinBrLvl := thisIndex

       If (isInRange(thisIndex, 4, 40))
          countDarkPixelz += nrPixelz
       Else If (isInRange(thisIndex, 170, 253))
          countBrightPixelz += nrPixelz
       Else If (isInRange(thisIndex, 50, 165))
          countMidPixelz += nrPixelz
   }

   avgBrLvl := Round(sumTotalBr/TotalPixelz)
   Loop, 23
   {
       nrPixelz := brLvlArray[avgBrLvl - 11 + A_Index]
       If nrPixelz
          countFlatties += nrPixelz
   }

   Loop, 11
   {
       nrPixelz := brLvlArray[modePointK - 6 + A_Index]
       If nrPixelz
          countModies += nrPixelz
   }

   aMinBrLvl := (rMinBrLvl + minBrLvl)//2
   Loop, 10
   {
       nrPixelz := brLvlArray[aMinBrLvl + A_Index]
       If nrPixelz
          countLowestPx += nrPixelz
   }
   percmodePx := Round((countModies/TotalPixelz)*100, 4)
   percBrgPx := Round((countBrightPixelz/TotalPixelz) * 100, 4)
   percLowPx := Round((countLowestPx/TotalPixelz) * 100, 4)
   percDrkPx := Round((countDarkPixelz/TotalPixelz) * 100, 4)
   percMidPixu := Round((countMidPixelz/TotalPixelz) * 100, 4)
   oPercAvgPx := Round((countFlatties/TotalPixelz) * 100, 4)
   If (percmodePx<=0.00015)
      percmodePx += 0.000156
   If (percMidPixu<=0.00015)
      percMidPixu += 0.000156
   If (percBrgPx<=0.00025)
      percBrgPx += 0.000256
   If (percDrkPx<=0.001)
      percDrkPx += 0.01512
   percAvgPx := Round((oPercAvgPx + percmodePx + percMidPixu)/3, 4)
   percMidPx := 100 - percBrgPx - percDrkPx
   If (percMidPx<=0.00025)
      percMidPx += 0.000256

   ; make the image brighter if max. luminance [maxBrLvl] is less than 255
   multiplieruA := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
   If (percBrgPx>1.25)
      multiplieruA := multiplieruA - Round(percMidPx/450, 4)

   multiplieruB := 255.1/maxBrLvl + (percDrkPx/8 + (255.1 - avgBrLvl)/15 + (255.1 - modePointK)/10)/50 - percBrgPx/25 - ((percMidPixu + percMidPx)/2)/40
   multiplieru := (multiplieruA + multiplieruB)/2

   If (multiplieru<=1)
      multiplieru := 1.0002
   If (multiplieru<=1.15)
   {
      multiplieruC := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
      If (percBrgPx>1.25)
         multiplieruC := multiplieruC - Round(percMidPx/450, 4)
      multiplieru := multiplieruC/1.25
      If (multiplieru<=1)
         multiplieru := 1.0002
   }

   lumosAdjust := multiplieru
   GammosAdjust := - lumosAdjust/40 + 0.025 + ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/3.25
   realGammos := Round(1 - ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/1.25, 3)

   ; make the image darker when lacking contrast or min. luminance level [minBrLvl] is higher than 1
   darkerOffsetA := rMinBrLvl*multiplieru
   darkerOffsetA := (darkerOffsetA - 3)/105
   darkerOffsetB := (aMinBrLvl/multiplieru/(200 - percBrgPx/4) + percBrgPx/percDrkPx/avgBrLvl/300)/1.5
   darkerOffsetC := (minBrLvl/multiplieru)/250 + avgBrLvl/(600 - avgBrLvl/10)
   darkerOffset := (darkerOffsetA + darkerOffsetB)/2 - percLowPx/700
   testGammosAdjust := GammosAdjust - darkerOffset/1.1
   If (testGammosAdjust>-0.02 && aMinBrLvl>3)
      darkerOffset := darkerOffsetC/1.5
   If (darkerOffset<=0)
      darkerOffset := 0.00001

   lumosAdjust := lumosAdjust + darkerOffset
   GammosAdjust := GammosAdjust - darkerOffset/1.1

   If (autoAdjustMode=2)
   {
      lumosAdjust := multiplieru := 255.1/maxBrLvl
      GammosAdjust := - lumosAdjust/40 + 0.025
   } Else If (autoAdjustMode=3)
   {
      darkerOffset := rMinBrLvl/255
      lumosAdjust := 1 + darkerOffset*1.1
      GammosAdjust := 0 - darkerOffset*1.3
   }

   ; adjust saturation
   If (doSatAdjusts=1)
   {
      Loop, 256
      {
          thisIndex := A_Index
          nrPixR := ArrChR[thisIndex]
          nrPixG := ArrChG[thisIndex]
          nrPixB := ArrChB[thisIndex]
          If (nrPixR="" || nrPixG="" || nrPixB="")
             Continue
 
          sumTotalR += nrPixR * thisIndex
          sumTotalG += nrPixG * thisIndex
          sumTotalB += nrPixB * thisIndex
          BrLvlDifs := max(NrPixR, NrPixG, NrPixB) - min(NrPixR, NrPixG, NrPixB)
          If (BrLvlDifs<minMaxThreshold*2) || (nrPixR+nrPixB+nrPixB<minMaxThreshold*3)
             Continue
          tNrPixR += nrPixR
          tNrPixG += nrPixG
          tNrPixB += nrPixB
          tNrPixAll += max(NrPixR, NrPixG, NrPixB)
          AllBrLvlDifs += BrLvlDifs
      }
   }
   BrLvlDiffX := max(tNrPixR, tNrPixG, tNrPixB) - min(tNrPixR, tNrPixG, tNrPixB)
   PrcLvlDiffX := Round((BrLvlDiffX/tNrPixAll)*100, 4)
   PrcLvlDiffXa := Round((AllBrLvlDifs/tNrPixAll)*100, 4)

   v1a := ArrChR[maxBrLvl]
   v2a := ArrChG[maxBrLvl]
   v3a := ArrChB[maxBrLvl]
   v1b := ArrChR[maxBrLvl - 1]
   v2b := ArrChG[maxBrLvl - 1]
   v3b := ArrChB[maxBrLvl - 1]
   v1e := ArrChR[modePointK]
   v2e := ArrChG[modePointK]
   v3e := ArrChB[modePointK]
   ; hmmu := max(v1a, v2a, v3a) " -- " min(v1a, v2a, v3a) " -- " v1a "," v2a "," v3a

   BrLvlDiffA := max(v1a, v2a, v3a) - min(v1a, v2a, v3a)
   BrLvlDiffB := max(v1b, v2b, v3b) - min(v1b, v2b, v3b)
   BrLvlDiffE := max(v1e, v2e, v3e) - min(v1e, v2e, v3e)
   PrcLvlDiffA := Round((BrLvlDiffA/max(v1a, v2a, v3a))*100, 4)
   PrcLvlDiffB := Round((BrLvlDiffB/max(v1b, v2b, v3b))*100, 4)
   PrcLvlDiffE := Round((BrLvlDiffE/max(v1e, v2e, v3e))*100, 4)
   avgLvlsDiff := (PrcLvlDiffA + PrcLvlDiffB + PrcLvlDiffE)/3

   satAdjust := 1
   satLevel := (lumosAdjust - GammosAdjust - 1)/15 - percDrkPx/50
   If (satLevel<0)
      satLevel := 0
   satAdjust := 1 - satLevel
   If (satAdjust<0.5)
      satAdjust := 0.5
   Else If (PrcLvlDiffX>0.5)
      satAdjust := satAdjust - PrcLvlDiffX/50 + 0.02

   If (PrcLvlDiffX<0.2)
   {
      PrcLvlDiffX := Round((3*BrLvlDiffX/TotalPixelz)*100, 4)
      satAdjust := satAdjust + PrcLvlDiffX/40 + 0.02
   }

   If (avgLvlsDiff>95)
      satAdjust := satAdjust - (avgLvlsDiff - 95)/100 + 0.02
   Else If (avgLvlsDiff<20)
      satAdjust := satAdjust + (20 - avgLvlsDiff)/100

   If (PrcLvlDiffXa>50)
      satAdjust -= PrcLvlDiffXa/1000
   Else
      satAdjust += PrcLvlDiffXa/700

   avgBrLvlR := Round(sumTotalR/TotalPixelz)
   avgBrLvlG := Round(sumTotalG/TotalPixelz)
   avgBrLvlB := Round(sumTotalB/TotalPixelz)
   chnlDiffs := max(avgBrLvlR, avgBrLvlG, avgBrLvlB) - min(avgBrLvlR, avgBrLvlG, avgBrLvlB)
   chnlDiffs := Round((chnlDiffs/maxBrLvl)*100, 4)
   If (avgBrLvlR>240 || avgBrLvlG>240 || avgBrLvlB>240) && (avgBrLvlR!=avgBrLvlB || avgBrLvlR!=avgBrLvlG ||  avgBrLvlB!=avgBrLvlG)
      satAdjust -= 0.05

   If (satAdjust<0.86)
      satAdjust += percDrkPx/800
   If (satAdjust<0.70)
      satAdjust := 0.70

   If (satAdjust>0.8 && chnlDiffs>=20)
      satAdjust -= chnlDiffs>50 ? chnlDiffs/825 : chnlDiffs/950
   Else If (chnlDiffs<11)
      satAdjust += (100 - chnlDiffs)/950

   otherz := (avgBrLvlG + avgBrLvlB)//1.5
   rLevelu := (avgBrLvlR>otherz+5 && avgBrLvlR<100 && otherz/avgBrLvlR<0.5) ? 1 - otherz/avgBrLvlR : 0
   satAdjust -= rLevelu/11
   otherz := (avgBrLvlR + avgBrLvlB)//1.5
   gLevelu := (avgBrLvlG>otherz+5 && avgBrLvlG<100 && otherz/avgBrLvlG<0.5) ? 1 - otherz/avgBrLvlG : 0
   satAdjust -= gLevelu/11
   otherz := (avgBrLvlG + avgBrLvlR)//1.5
   bLevelu := (avgBrLvlB>otherz+5 && avgBrLvlB<100 && otherz/avgBrLvlB<0.5) ? 1 - otherz/avgBrLvlB : 0
   satAdjust -= bLevelu/11
   If (doSatAdjusts!=1)
      satAdjust := 1

   ; execTime := A_TickCount - startZeit
   ; ToolTip, % redLevelu ",avgRGB=" avgBrLvlR ", " avgBrLvlG ", " avgBrLvlB ", ChnlDiff=" chnlDiffs  ", AvgLvlDif=" avgLvlsDiff " %, diffA=" PrcLvlDiffA " %, diffE=" PrcLvlDiffE " %, diffX=" PrcLvlDiffX "/" PrcLvlDiffXa "% `nTh=" minMaxThreshold ", min=" minBrLvl "/" rMinBrLvl ", max=" maxBrLvl ", A=" avgBrLvl ", mP=" modePointK " [" modePointV " / " percmodePx "% ]"  ",`nL=" percBrgPx "%, D=" percDrkPx "%, Dl=" percLowPx "%, Mr=" percMidPx "% / Mo=" percMidPixu "%, oAvg=" oPercAvgPx "%, fAvg=" percAvgPx "%`ncL=" lumosAdjust ", cG=" GammosAdjust ", cS=" satAdjust ", T=" execTime "ms",,, 2
}

VPnavBoxWrapper(mainWidth, mainHeight, Gu) {
    Critical, on
    createVPnavBox(navBoxu, imgW, imgH, diffX, diffY, zImgW, zImgH)
    hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
    tlbrBonusX := (hasTrans=1 && (ToolbarWinH - 3 > mainHeight - imgH)) ? ToolbarWinW : 0
    thisPosX := (imageAligned=1 && thumbsDisplaying=1) ? mainWidth - imgW - imgHUDbaseUnit//3.25 : tlbrBonusX
    thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
    If navBoxu
       ERR := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, thisPosX, thisPosY)

    hasDrawnImageMap := (navBoxu && !ERR) ? 1 : 0
    If (FlipImgH=1)
       thisPosX := mainWidth - imgW
    ; ToolTip, % scrollBarVx "==" scrollBarHy , , , 2
    If (FlipImgV=1)
       thisPosY := 0 + Round(mainHeight - scrollBarHy)

    If navBoxu
       HUDobjNavBoxu := [zImgW, zImgH, thisPosX + diffX, thisPosY + diffY, imgW, imgH, thisPosX, thisPosY]

    trGdip_DisposeImage(navBoxu, 1)
}

createVPnavBox(ByRef pBitmap, ByRef imgW, ByRef imgH, ByRef posX, ByRef posY, ByRef fImgW, ByRef fImgH) {
   Static lastState := 1
   pBitmap := ""
   navBoxu := coreCreateVPnavBox()
   If StrLen(navBoxu)<3
      Return

   Gdip_GetImageDimensions(navBoxu, fImgW, fImgH)
   Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   posX := imgW//2 - fImgW//2
   posY := imgH//2 - fImgH//2

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
   If StrLen(pBitmap)<3
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   E := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, posX, posY, fImgW, fImgH)
   If (E="fail")
   {
      pBitmap := ""
      Gdip_DeleteGraphics(Gu)
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_SetClipRect(Gu, posX, posY, fImgW, fImgH, 4)
   borderu := Round(imgW*0.0099)
   Gdip_FillRectangle(Gu, pBrushE, posX - borderu, posY - borderu, fImgW + borderu*2, fImgH + borderu*2)
   Gdip_ResetClip(Gu)

   If (editingSelectionNow=1 && thumbsDisplaying!=1)
   {
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (zImgSelW<borderu*2 || zImgSelH<borderu*2)
         Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      pPath := createImgSelPath(posX + zimgSelPx, posY + zimgSelPy, zimgSelW, zimgSelH, EllipseSelectMode, vPselRotation, rotateSelBoundsKeepRatio)
      Gdip_SetClipPath(Gu, pPath, 0)
      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushA : pBrushD
      Else
         thisBrush := pBrushA

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DeletePath(pPath)
      Gdip_ResetClip(Gu)
   }

   If (thumbsDisplaying!=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      obju := createImgSelection2Win(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight, 1)
      coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushC : pBrushD
      Else
         thisBrush := pBrushC

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_SetClipRect(Gu, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH, 4)
      borderu := Round(imgW*0.006)
      Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      Gdip_ResetClip(Gu)
      Gdip_SetClipRect(Gu, borderu, borderu, imgW - borderu*2, imgH - borderu*2, 4)
      Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   }

   lastState := !lastState
   Gdip_DeleteGraphics(Gu)
   Return pBitmap
}

coreCreateVPnavBox(modus:=0) {
   Static lastCall, prevBMP
   If (modus="kill")
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   whichBitmap := useGdiBitmap()
   If (thumbsDisplaying=1)
   {
      whichBitmap := ""
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      If !FileRexists(imgPath)
         Return

      MD5name := generateThumbName(imgPath, 1, 1)
      file2save := thumbsCacheFolder "\500-" MD5name ".jpg"
      If FileExist(file2save)
      {
         whichBitmap := LoadCachableBitmapFromFile(file2save)
      } Else
      {
         changeMcursor()
         oBitmap := LoadBitmapFromFileu(imgPath)
         If StrLen(oBitmap)>1
         {
            whichBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 500, 500, 1, 7)
            trGdip_DisposeImage(oBitmap, 1)
            Gdip_SaveBitmapToFile(whichBitmap, file2save, 94)
         }
         ResetImgLoadStatus()
      }
      If StrLen(whichBitmap)>1
         whichBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(whichBitmap))
   }

   thisCall := "a" whichBitmap MD5name imgPath thumbsDisplaying gdiBitmapIDcall currentFileIndex getIDimage(currentFileIndex) currentUndoLevel undoLevelsRecorded UserMemBMP imgHUDbaseUnit OSDfntSize HUDnavBoxSize FlipImgH FlipImgV imgFxMode
   If (thisCall=lastCall)
      Return prevBMP

   If !whichBitmap
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   prevBMP := trGdip_DisposeImage(prevBMP, 1)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   Gdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
   calcIMGdimensions(rImgW, rImgH, imgW, imgH, ResizedW, ResizedH)

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If !pBitmap
   {
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }
   ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, ResizedW, ResizedH)
   posX := posY := 0
   E := trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, posX, posY, ResizedW, ResizedH)
   Gdip_DeleteGraphics(Gu)
   prevBMP := (E!="fail") ? pBitmap : ""
   lastCall := (E!="fail") ? thisCall : ""
   If (E="fail")
      pBitmap := trGdip_DisposeImage(pBitmap, 1)

   If (thumbsDisplaying=1)
      trGdip_DisposeImage(whichBitmap, 1)

   Return pBitmap
}

ImageNavBoxClickResponder() {
   Static prevState := "a"

   If (thumbsDisplaying!=1 && IMGresizingMode!=4)
   {
      IMGresizingMode := 4
      interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH)
      Return

   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1])
   mY := clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2])
   navWidth := HUDobjNavBoxu[1]
   navHeight := HUDobjNavBoxu[2]
   diffIMGdecX := diffIMGdecY := 0
   prevImgDecaX := prevImgDecaY := 0
   vpImgPanningNow := 1
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   While, (determineLClickstate()=1 || A_Index<2)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1])
      mY := clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2])
      f := (imageAligned=1) ? 0 : 0.5
      If (FlipImgV=1)
         mY := navHeight - mY
      If (FlipImgH=1)
         mX := navWidth - mX

      prcW := mX/navWidth
      prcH := mY/navHeight
      ; ToolTip, % mX "==" mY "==" navWidth "==" navHeight "==" prcW "==" prcH , , , 2
      prcW := (prcW>f) ? prcW - f : f - prcW
      prcH := (prcH>f) ? prcH - f : f - prcH
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/navWidth
      prcH := mY/navHeight
      If (prcW>f || imageAligned=1)
         decX := -decX
      If (prcH>f || imageAligned=1)
         decY := -decY

      If (decX>0 && imageAligned=1 && FlipImgH=0)
         decX := 0

      If (decY>0 && imageAligned=1 && FlipImgV=0)
         decY := 0

      limitPanningDist(decX, decY)
      diffIMGdecX := -1*(prevImgDecaX - decX) + 2
      diffIMGdecY := -1*(prevImgDecaY - decY) + 2
      thisState := "a" randomFactor decX decY diffIMGdecX diffIMGdecY currentFileIndex getIDimage(currentFileIndex) currentUndoLevel zoomLevel gdiBitmap
      If (prevState!=thisState) && (A_TickCount - thisZeit>25)
      {
         ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
         thisIndex++
         zeitSillyPrevent := A_TickCount
         IMGdecalageX := decX
         IMGdecalageY := decY
         prevImgDecaX := decX
         prevImgDecaY := decY
         thisZeit := A_TickCount
         prevState := thisState
         dummyResizeImageGDIwin()
      }
   }

   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

wrapResizeImageGDIwin() {
    startZeitIMGload := A_TickCount
    imgPath := StrReplace(getIDimage(currentFileIndex), "||")
    ResizeImageGDIwin(imgPath, 2, 0)
}

getPixelColorAvg(pBitmap, kX, kY, startToolColor, oldColor) {
   coloruA := Gdip_GetPixelColor(pBitmap, kX, kY, 1)
   coloruB := Gdip_GetPixelColor(pBitmap, kX + 2, kY + 2, 1)
   coloruD := Gdip_GetPixelColor(pBitmap, kX - 2, kY - 2, 1)
   coloruC := Gdip_GetPixelColor(pBitmap, kX + 2, kY - 2, 1)
   If (coloruA && coloruB)
      coloruZ := MixARGB(coloruA, coloruB, 0.5)
   If (coloruC && coloruD)
      coloruX := MixARGB(coloruC, coloruD, 0.5)
   If (coloruZ && coloruX)
      coloruY := MixARGB(coloruZ, coloruX, 0.5)
   Else If coloruZ
      coloruY := coloruZ
   Else If coloruX
      coloruY := coloruX
   Else
      coloruY := startToolColor

   Return coloruY
}

toggleBrushDoubleSize() {
   brushToolDoubleSize := !brushToolDoubleSize
   friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " brushToolSize " px", A_ThisFunc, 1, brushToolSize/950)
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA:, brushToolDoubleSize, % brushToolDoubleSize

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushAirMode() {
   If (BrushToolType=2 || BrushToolType=3)
      Return

   BrushToolOverDraw := !BrushToolOverDraw
   friendly := (BrushToolOverDraw=1) ? "ACTIVATED" : "DEACTIVATED"
   labelu := (BrushToolType>=6) ? "Auto-scale brush deformer: " : "Airbrush mode: "
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA:, BrushToolOverDraw, % BrushToolOverDraw

   showTOOLtip(labelu friendly moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

togglePaintingMode() {
   ; alpha mask painting, transform tool
   liveDrawingBrushTool := !liveDrawingBrushTool
   Random, OutputVar, 1, 950
   Random, OutputaVar, 1, 950
   randomu := OutputVar / OutputaVar
   If ((AnyWindowOpen=24 || AnyWindowOpen=31) && liveDrawingBrushTool=1 && StrLen(userClipBMPpaste)>2)
   {
      showTOOLtip("Please wait, activating painting mode")
      BrushToolType := 2
      PasteInPlaceAlphaMaskMode := 5
      PasteInPlaceLivePreview := PasteInPlaceAlphaChannelFile := 1
      PasteInPlaceAlphaFile := "user-painted"
      GuiControl, SettingsGUIA: Choose, PasteInPlaceAlphaMaskMode, 5
      GuiControl, SettingsGUIA: Choose, PasteInPlaceAlphaChannelFile, 1
      GuiControl, SettingsGUIA: Choose, BrushToolType, 2
      GuiControl, SettingsGUIA:, PasteInPlaceLivePreview, 1
      GuiControl, SettingsGUIA: Disable, PasteInPlaceLivePreview
      GuiControl, SettingsGUIA: Disable, btnReset
      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 1
      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaFile, ||obj|this|prev|next|first|last|user-painted||
      Gdip_GetImageDimensions(userClipBMPpaste, rImgW, rImgH)
      If StrLen(userAlphaMaskBmpPainted)<3
      {
         PasteInPlaceOpacity := PasteInPlaceAlphaMaskClrA := 128
         PasteInPlaceAlphaMaskClrB := FillAreaGradientAngle := 0
         FillAreaColorReversed := alphaMaskReplaceMode := 0
         FillAreaGradientScale := 1, CurrentPanelTab := 4
         GuiControl, SettingsGUIA:, PasteInPlaceOpacity, 128
         GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrA, 128
         GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrB, 0
         GuiControl, SettingsGUIA:, FillAreaGradientScale, 1
         GuiControl, SettingsGUIA:, FillAreaGradientAngle, 0
         GuiControl, SettingsGUIA:, FillAreaColorReversed, 0
         GuiControl, SettingsGUIA:, alphaMaskReplaceMode, 0
         GuiControl, SettingsGUIA: Choose, CurrentPanelTab, 4
         userAlphaMaskBmpPainted := trGdip_CreateBitmap(A_ThisFunc, rImgW, rimgH, "0xE200B")
         G := Gdip_GraphicsFromImage(userAlphaMaskBmpPainted)
         Gdip_GraphicsClear(G, "0xFFffFFff")
         Gdip_DeleteGraphics(G)
      }
      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
   } Else If ((AnyWindowOpen=24 || AnyWindowOpen=31) && StrLen(userClipBMPpaste)>2)
   {
      showTOOLtip("Please wait, deactivating painting mode")
      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 0
      GuiControl, SettingsGUIA: Enable, PasteInPlaceLivePreview
      GuiControl, SettingsGUIA: Enable, btnReset
      realtimePasteInPlaceAlphaMasker("kill", 2, lol)
      SetTimer, updateUIpastePanel, -300
      SetTimer, updateUIpasteInPlacebrushTool, -200
   }

   BrushToolTexture := 1
   dummyRefreshImgSelectionWindow()
   SetTimer, MouseMoveResponder, -100
}

toggleBrushTypes() {
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=1) ? 2 : 1

   mustCaptureCloneBrush := 0
   liveDrawingBrushTool := 1
   friendly := (BrushToolType=1) ? "Simple color brush" : "Soft edges color brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   If (BrushToolType=2)
      moreInfos .= "`nSoftness: " BrushToolSoftness "%"

   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDeformers() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   mustCaptureCloneBrush := 0
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=7) ? 8 : 7

   liveDrawingBrushTool := 1
   friendly := (BrushToolType=7) ? "Pinch brush" : "Bulge brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeEraser() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   BrushToolType := 4
   liveDrawingBrushTool := 1
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "Eraser brush:`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   BrushToolEraserRestore := 0
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolEraserRestore, % BrushToolEraserRestore
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
   }

   showTOOLtip(moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeFX() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   BrushToolUseSecondaryColor := 0
   friendly := "Effects brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

togglePresetsBrushes(modus, dir:=1) {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   BrushToolUseSecondaryColor := 0
   level := 0, maxu := 0
   If (modus=1)
   {
      BrushToolApplyColorFX := 0
      BrushToolBlurStrength := clampInRange(BrushToolBlurStrength + 5*dir, 3, 99, 1)
      friendly := "Effects brush`nBlur strength: " BrushToolBlurStrength "%"
      level := BrushToolBlurStrength
      maxu := 99
   } Else If (modus=2)
   {
      BrushToolApplyColorFX := 1
      BrushToolBlurStrength := 0
      friendly := "Effects brush: color adjustments"
   } Else If (modus=3)
   {
      BrushToolType := 2
      BrushToolWetness := clampInRange(BrushToolWetness + 1*dir, 2, 22, 1)
      friendly := "Soft edges brush`nWetness: " Round(BrushToolWetness/22 * 100) "%"
      level := BrushToolWetness
      maxu := 22
   } Else If (modus=4)
   {
      BrushToolWetness := 0
      BrushToolType := 2
      friendly := "Soft edges brush:"
   } Else If (modus=5)
   {
      BrushToolType := 1
      friendly := "Hard brush:"
   }

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA:, BrushToolBlurStrength, % BrushToolBlurStrength
      GuiControl, SettingsGUIA:, BrushToolWetness, % BrushToolWetness
      GuiControl, SettingsGUIA:, BrushToolApplyColorFX, % BrushToolApplyColorFX
      SetTimer, updateUIbrushTool, -150
   }

   showTOOLtip(friendly moreinfos, 0, 0, level/maxu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDrawInOutModes() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   mustCaptureCloneBrush := 0
   liveDrawingBrushTool := 1
   BrushToolOutsideSelection := clampInRange(BrushToolOutsideSelection + 1, 1, 3, 1)
   friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
   If (BrushToolOutsideSelection=3)
      friendly := "OUTSIDE"

   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA: Choose, BrushToolOutsideSelection, % BrushToolOutsideSelection

   If (editingSelectionNow!=1)
      msgu := "WARNING: The image selection area is currently not created. Press E to create or display it.`n"

   If (ShowAdvToolbar=1)
      decideIconBTNpaintBrushSelect()
   showTOOLtip(msgu "Paint " Friendly " image selection area", A_ThisFunc, 1, BrushToolOutsideSelection/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeCloner() {
   isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
   If (isAlphaPainting=1)
      Return

   If (BrushToolType=3 && liveDrawingBrushTool=1)
      BrushToolDynamicCloner := !BrushToolDynamicCloner

   BrushToolType := 3
   liveDrawingBrushTool := 1
   friendly := "Cloner brush"
   If (BrushToolDynamicCloner=1)
      friendly .= " (dynamic coords mode)"

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>2)
      moreInfos .= "`nBrush effects are enabled"

   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolDynamicCloner, % BrushToolDynamicCloner
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA: Show, uiBtnSetCloner
      GuiControl, SettingsGUIA: Enable, BrushToolDynamicCloner
   }

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyChangeBrushOpacity(dir) {
    If (dir=1)
       changeBrushOpacity(-1, 0)
    Else
       changeBrushOpacity(1, 0)
}

changeBrushOpacity(keyu, isKeyu) {
    If (isKeyu=1)
    {
       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       keyu := StrReplace(keyu, "+")
       okeyu := keyu
       keyu := StrReplace(keyu, "vk3")
       factoru := keyu ? "0." keyu : 1
       If (okeyu="vk31" && isInRange(thisOpacity, 22, 27))
          factoru := 0.05

       newOpacity := clampInRange(Round(255 * factoru), 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round(factoru*100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    } Else
    {
       newOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       If (keyu=-1)
          newOpacity += 10
       Else
          newOpacity -= 10

       newOpacity := clampInRange(newOpacity, 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round((newOpacity / 255) * 100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    }

    If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
    {
       GuiControl, SettingsGUIA:, BrushToolAopacity, % BrushToolAopacity
       GuiControl, SettingsGUIA:, BrushToolBopacity, % BrushToolBopacity
    }
    liveDrawingBrushTool := 1
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, MouseMoveResponder, -25
}

changeBrushColorPicker() {
    thisColor := (BrushToolUseSecondaryColor=1) ? "PickuBrushToolBcolor" : "PickuBrushToolAcolor"
    mustCaptureCloneBrush := 0
       ; showTOOLtip("Pick brush color")
    ; SetTimer, RemoveTooltip, % -msgDisplayTime
    obju := StartPickingColor("isGiven", 0, thisColor)
    If (ShowAdvToolbar=1)
    {
       newColor := obju[1] , oldColor := obju[2]
       updateToolColorsBasedToolbar(newColor, oldColor)
       updateTlbrColorsSwatch()
    }

    SetTimer, MouseMoveResponder, -25
    If (imgEditPanelOpened=1 && AnyWindowOpen)
       livePreviewsImageEditing()
}

changeBrushSize(dir) {
   liveDrawingBrushTool := 1
   factoru := (brushToolSize>50) ? 10 : 5
   If (dir=1)
      brushToolSize += factoru
   Else
      brushToolSize -= factoru

   mustCaptureCloneBrush := 0
   BrushToolSize := clampInRange(brushToolSize, 1, 950)
   friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " groupDigits(brushToolSize) " px", A_ThisFunc, 2, brushToolSize/950)
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA:, BrushToolSize, % BrushToolSize

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushRatioAngle(dir, what) {
   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   If (what=1)
   {
      factoru := 5
      BrushToolAspectRatio := clampInRange(BrushToolAspectRatio + factoru*dir, -100, 100, 0)
      If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
         GuiControl, SettingsGUIA:, BrushToolAspectRatio, % BrushToolAspectRatio

      showTOOLtip("Brush aspect ratio: " BrushToolAspectRatio, 0, 0, (BrushToolAspectRatio + 100)/201)
   } Else
   {
      factoru := 10
      BrushToolAutoAngle := 0
      BrushToolAngle := clampInRange(BrushToolAngle + factoru*dir, 0, 359, 0)
      If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
         GuiControl, SettingsGUIA:, BrushToolAngle, % BrushToolAngle
      showTOOLtip("Brush angle: " BrushToolAngle "° ", 0, 0, BrushToolAngle/360)
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

resetBrushAsRatio() {
   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   BrushToolAspectRatio := 0
   BrushToolAngle := 0
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      GuiControl, SettingsGUIA:, BrushToolAspectRatio, % BrushToolAspectRatio
      GuiControl, SettingsGUIA:, BrushToolAngle, % BrushToolAngle
   }

   showTOOLtip("Brush aspect ratio: RESET")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

toggleBrushMouseAngle() {
   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   BrushToolAutoAngle  := !BrushToolAutoAngle
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      GuiControl, SettingsGUIA:, BrushToolAutoAngle, % BrushToolAutoAngle
      friendly := (BrushToolAutoAngle=1) ? "Disable" : "Enable"
      GuiControl, SettingsGUIA: %friendly%, BrushToolAngle
   }

   friendly := (BrushToolAutoAngle=1) ? "Alter brush angle based on mouse movements" : "Fixed brush angle: " BrushToolAngle "° "
   showTOOLtip(friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushSoftness(dir) {
   If (BrushToolType=1)
      Return

   If (dir=1)
      BrushToolSoftness += 2
   Else
      BrushToolSoftness -= 2

   liveDrawingBrushTool := 1
   mustCaptureCloneBrush := 0
   BrushToolSoftness := clampInRange(BrushToolSoftness, 1, 99)
   showTOOLtip("Brush softness: " BrushToolSoftness "%", A_ThisFunc, 2, BrushToolSoftness/100)
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA:, BrushToolSoftness, % BrushToolSoftness
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushWetness(dir) {
   isOkay := (BrushToolType=2 || BrushToolType=7 || BrushToolType=8) ? 1 :0
   If (isOkay!=1)
      Return

   If (dir=1)
      BrushToolWetness++
   Else
      BrushToolWetness--

   liveDrawingBrushTool := 1
   BrushToolWetness := clampInRange(BrushToolWetness, 0, 22)
   friendly := (BrushToolType>6) ? "deform intensity" : "wetness"
   showTOOLtip("Brush " friendly ": " BrushToolWetness, A_ThisFunc, 2, BrushToolWetness/22)
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA:, BrushToolWetness, % BrushToolWetness
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

createGradientBrushBitmap(brushColor, grPosA, brushSize, grAngle, bAR, opacity:=0, bgr:=0) {
    Critical, on
    Static offsetX := 0, offsetY := 0, grPosB := 99, prevState, prevBrushu
    If (brushColor="kill")
    {
       prevState := ""
       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       Return
    }

    isAlphaPainting := (AnyWindowOpen=24 || AnyWindowOpen=31) && (liveDrawingBrushTool=1) ? 1 : 0
    offsetX := (isAlphaPainting=1) ? 0 : alphaMaskOffsetX
    offsetY := (isAlphaPainting=1) ? 0 : alphaMaskOffsetY
    thisColorA := opacity ? opacity brushColor : "0xFF" brushColor
    thisColorB := "0x00" brushColor
    rImgW := rImgH :=  brushSize
    ; ToolTip, % thisColorA "`n" thisColorB, , , 2
    thisAR := 1 - Abs(bAR)/105
    brImgSelW := (bAR>0) ? brushSize * thisAR : brushSize
    brImgSelH := (bAR<0) ? brushSize * thisAR : brushSize
    brimgSelPx := 0 - (brImgSelW - rImgW)//2
    brimgSelPy := 0 - (brImgSelH - rImgH)//2
    thisState := "a" bgr brImgSelW brImgSelH brimgSelPx brimgSelPy thisAR bAR brushSize thisColorA thisColorB grPosA grAngle offsetX offsetY BrushToolTexture
    If (thisState!=prevState || StrLen(prevBrushu)<3)
    {
       brushBitmap := trGdip_CreateBitmap(A_ThisFunc, brushSize, brushSize, "0xE200B")
       If !brushBitmap
          Return

       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, brushBitmap, 5)
       If (BrushToolTexture=1)
       {
          grpPath := Gdip_CreatePath()
          If grpPath
          {
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)
             If gradBrush
             {
                Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*offsetX), 0 + rImgH//2 + Round(rImgH*offsetY))
                Gdip_SetLinearGrBrushPresetBlend(gradBrush, [grPosA/100, grPosB/100], [thisColorA, thisColorB])
                Gdip_RotatePathGradientAtCenter(gradBrush, grAngle, 1)
                ; Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
             }

             Gdip_DeletePath(grpPath)
          }

          If bgr
             Gdip_GraphicsClear(Ga, bgr)
          Gdip_FillEllipse(Ga, gradBrush, 0, 0, rImgW, rImgH)
          Gdip_DeleteBrush(gradBrush)
       } Else
       {
          Gdip_GraphicsClear(Ga, thisColorA)
          pBitmap := LoadCachableBitmapFromFile(mainCompiledPath "\resources\brush-texture-" BrushToolTexture - 1 ".png")
          If pBitmap
          {
             If (grAngle>0)
             {
                pBitmap3 := trGdip_RotateBitmapAtCenter(A_ThisFunc, pBitmap, grAngle, 0, 3)
                If StrLen(pBitmap3)>2
                {
                   trGdip_DisposeImage(pBitmap, 1)
                   pBitmap := pBitmap3
                }
             }
             pBitmap2 := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, rImgW, rImgH, 0, 3)
             trGdip_DisposeImage(pBitmap, 1)
             ; QPV_BlendBitmaps(brushBitmap, pBitmap2, 2, 0)
             QPV_SetAlphaChannel(brushBitmap, pBitmap2, 0, 1, 1, 0)
             trGdip_DisposeImage(pBitmap2, 1)
          }
          ; Gdip_DrawImage(Ga, pBitmap, 0, 0, rImgW, rImgH)
       }
       If Ga
          Gdip_DeleteGraphics(Ga)
       prevState := thisState
       prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushBitmap)
    } Else If StrLen(prevBrushu)>2
       brushBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)

    Return brushBitmap
}

createClonedBrushBitmap(brushSize, brushSofty, brushAngle, thisAR, whichBitmap, offsetX:=0, offsetY:=0, doBlur:=0, noAlphaMask:=0, previewMode:=0) {
   Static noPrompting :=0, brushAlpha, prevState, prevBrushu, hasEverDefineSource := 0
   mustCaptureCloneBrush := 0
   If (brushSize="kill")
   {
      prevState := ""
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      Return
   }

   If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
   {
      prevState := ""
      hasEverDefineSource := 1
      If (brushAngle="mouse")
      {
         mX := brushSize
         mY := brushSofty
      } Else GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
      showTOOLtip("Cloner brush source set to`n" kX " / " kY)
      SoundBeep , 900, 100
      If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>1) && (noPrompting=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Cloner effects", "The cloner tool has color effects activated. Do you want to deactivate the brush cloner effects?", 4, 0, "question", "&Do not prompt me again in this session")
         noPrompting := msgResult.check
         If (msgResult.btn="Yes")
         {
            BrushToolApplyColorFX := 0
            BrushToolBlurStrength := 0
            If (AnyWindowOpen=64)
            {
               GuiControl, SettingsGUIA:, BrushToolApplyColorFX, 0
               GuiControl, SettingsGUIA:, BrushToolBlurStrength, 0
            }
         }
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      SetTimer, dummyRefreshImgSelectionWindow, -150
      Return
   }

   If (!hasEverDefineSource && previewMode=0)
   {
      msgBoxWrapper(appTitle ": WARNING", "Please define the source for the clone tool.", 0, 0, "exclamation")
      BtnSetClonerBrushSource()
      Return
   }

   tkX := tinyPrevAreaCoordX
   tkY := tinyPrevAreaCoordY
   If (BrushToolDynamicCloner=1)
   {
      tkX := tkX - offsetX
      tkY := tkY - offsetY
   }

   thisState := "a" brushSofty brushSize brushAngle BrushToolDynamicCloner thisAR offsetX offsetY tkX tkY BrushToolBlurStrength doBlur BrushToolApplyColorFX PasteInPlaceLight PasteInPlaceGamma PasteInPlaceHue PasteInPlaceSaturation noAlphaMask
   If (thisState!=prevState || !prevBrushu)
   {
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      brushu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, 1)
      If (noAlphaMask=0)
      {
         applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
         brushuAlpha := createGradientBrushBitmap("ffFFff", brushSofty, brushSize, brushAngle, thisAR, 0, "0xFF000000")
         QPV_SetAlphaChannel(brushu, brushuAlpha)
         trGdip_DisposeImage(brushuAlpha, 1)
      }
      prevState := thisState
      prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushu)
   } Else brushu := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)
   Return brushu
}

somewhatAccurateBrightnessShift(hex, lum=0.5, mode=1) {
   ; from tidbit ; thanks 
   for k, val in [substr(hex, 3, 2), substr(hex, 5, 2), substr(hex, 7, 2)] ; split the hex into an array of [##,##,##]
      val:=format("{1:d}", "0x" val) ; convert from hex, to decimal values
      , val:=round((mode=1) ? val*lum : val+lum) ; do the math
      , val:=(val<0) ? 0 : (val>255) ? 255 : val ; clamp the values between 0 and 255
      , out.=format("{1:02}", format("{1:x}", val)) ; build it again, make sure each hex thing is 2 chars long
   return out ; we're done!
}

RandomizeBrushColor(startToolColor) {
   o_startToolColor := startToolColor
   If (BrushToolRandomLight>0 && BrushToolRandomDark<1)
      zR := 1
   Else If (BrushToolRandomLight<1 && BrushToolRandomDark>0)
      zR := 6
   Else
      zR := Randomizer(1, 10, 1, 14)

   If (BrushToolRandomLight>0 && isInRange(zR, 1, 5))
   {
      gR := BrushToolRandomLight
      gR := Randomizer(0, gR, 8, 8)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFFfffFff", "0xFF" startToolColor, gRz), 5)
      ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
   }

   If (BrushToolRandomDark>0 && isInRange(zR, 5, 10))
   {
      gR := BrushToolRandomDark
      gR := Randomizer(0, gR, 8, 9)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFF000000", "0xFF" startToolColor, gRz), 5)
   }

   If (BrushToolRandomHue<1 && BrushToolRandomSat<1)
      Return startToolColor

   ; Gdip_FromARGB("0xFF" startToolColor, A, R, G, B)
   ; HSLobj := ConvertRGBtoHSL(R, G, B)
   H := HSL_Hue("0x" startToolColor)
   S := HSL_Sat("0x" startToolColor)
   L := HSL_Lum("0x" startToolColor)
   If (BrushToolRandomHue>0)
   {
      gR := BrushToolRandomHue
      gR := Randomizer(-gR, gR, 2, 10)
      H := clampInRange(H + gR, 0, 360)
   }

   If (BrushToolRandomSat>0)
   {
      gR := BrushToolRandomSat
      gR := Randomizer(-gR, gR, 2, 11)
      S := clampInRange(S*100 + gR, 0, 100)/100
   }

   startToolColor := HSL_ToRGB(H, S, L)
   startToolColor := SubStr(startToolColor, 3)
   ; ToolTip, % H "=" S "=" L "`n" R "=" G "=" B , , , 2
   Return startToolColor
}


HSL_ToRGB(hue, sat=1, lum=0.5 ) {
; Function by [VxE]. See > http://www.wikipedia.org/wiki/HSV_color_space
; HSL to/from RGB conversion functions by [VxE]. Freely avalable @ http://www.autohotkey.com/community/viewtopic.php?f=2&t=88707
; Converts a hue/sat/lum into a 24-bit RGB color code. Input: 0 <= hue <= 360, 0 <= sat <= 1, 0 <= lum <= 1. 

   Static i24 := 0xFFFFFF, i40 := 0xFFFFFF0000, hx := "0123456789ABCDEF"

; Transform the decimal inputs into 24-bit integers. Integer arithmetic is nice..
   sat := ( sat * i24 ) & i24
   lum := ( lum * i24 ) & i24
   hue := ( hue * 0xB60B60 >> 8 ) & i24 ; conveniently, 360 * 0xB60B60 = 0xFFFFFF00

; Determine the chroma value and put it in the 'sat' var since the saturation value is not used after this.
   sat := lum + Round( sat * ( i24 - Abs( i24 - lum - lum ) ) / 0x1FFFFFE )

; Calculate the base values for red and blue (green's base value is the hue)
   red := hue < 0xAAAAAA ? hue + 0x555555 : hue - 0xAAAAAA
   blu := hue < 0x555555 ? hue + 0xAAAAAA : hue - 0x555555

; Run the blue value through the cases
   If ( blu < 0x2AAAAB )
      blu := sat + 2 * ( i24 - 6 * blu ) * ( lum - sat ) / i24 >> 16
   Else If ( blu < 0x800000 )
      blu := sat >> 16
   Else If ( blu < 0xAAAAAA )
      blu := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - blu ) ) * ( lum - sat ) / i24 >> 16
   Else
      blu := 2 * lum - sat >> 16

; Run the red value through the cases
   If ( red < 0x2AAAAB )
      red := sat + 2 * ( i24 - 6 * red ) * ( lum - sat ) / i24 >> 16
   Else If ( red < 0x800000 )
      red := sat >> 16
   Else If ( red < 0xAAAAAA )
      red := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - red ) ) * ( lum - sat ) / i24 >> 16
   Else
      red := 2 * lum - sat >> 16

; Run the green value through the cases
   If ( hue < 0x2AAAAB )
      hue := sat + 2 * ( i24 - 6 * hue ) * ( lum - sat ) / i24 >> 16
   Else If ( hue < 0x800000 )
      hue := sat >> 16
   Else If ( hue < 0xAAAAAA )
      hue := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - hue ) ) * ( lum - sat ) / i24 >> 16
    Else
      hue := 2 * lum - sat >> 16

; Return the values in RGB as a hex integer
   Return "0x" SubStr( hx, ( red >> 4 ) + 1, 1 ) SubStr( hx, ( red & 15 ) + 1, 1 )
         . SubStr( hx, ( hue >> 4 ) + 1, 1 ) SubStr( hx, ( hue & 15 ) + 1, 1 )
         . SubStr( hx, ( blu >> 4 ) + 1, 1 ) SubStr( hx, ( blu & 15 ) + 1, 1 )
} ; END - HSL_ToRGB( hue, sat, lum )

HSL_Hue( RGB ) {
; Function by [VxE]. Returns the HSL hue of the input 24-bit RGB code.
; Returns a floating point value less than 360 but not less than 0.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
      Return 0 + 0.0

   Else If ( blu < grn )
      If ( red < blu )
         Return 60 * ( blu - red ) / ( grn - red ) + 120
      Else If ( grn < red )
         Return 60 * ( grn - blu ) / ( red - blu )
      Else
         Return 60 * ( blu - red ) / ( grn - blu ) + 120
   Else
      If ( red < grn )
         Return 60 * ( red - grn ) / ( blu - red ) + 240
      Else If ( blu < red )
         Return 60 * ( grn - blu ) / ( red - grn ) + ( blu = grn ? 0 : 360 )
      Else
         Return 60 * ( red - grn ) / ( blu - grn ) + 240
} ; END - HSL_Hue( RGB )

HSL_Sat( RGB ) {
; Function by [VxE]. Returns the HSL saturation of the input 24-bit RGB code.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
      Return 0 + 0.0

   Else If ( blu < grn )
      If ( red < blu )
         return ( grn - red ) / ( 255 - Abs( 255 - grn - red ) )
      Else If ( grn < red )
         return ( red - blu ) / ( 255 - Abs( 255 - red - blu ) )
      Else
         return ( grn - blu ) / ( 255 - Abs( 255 - grn - blu ) )
   Else
      If ( red < grn )
         return ( blu - red ) / ( 255 - Abs( 255 - blu - red ) )
      Else If ( blu < red )
         return ( red - grn ) / ( 255 - Abs( 255 - red - grn ) )
      Else
         return ( blu - grn ) / ( 255 - Abs( 255 - blu - grn ) )
} ; END - HSL_Sat( RGB )

HSL_Lum( RGB ) {
; Function by [VxE]. Returns the HSL lightness of the input 24 bit color.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu < grn )
      If ( red < blu )
         Return ( red + grn ) / 510
      Else If ( grn < red )
         Return ( blu + red ) / 510
      Else
         Return ( blu + grn ) / 510
   Else
      If ( red < grn )
         Return ( red + blu ) / 510
      Else If ( blu < red )
         Return ( grn + red ) / 510
      Else
         Return ( grn + blu ) / 510
} ; END - HSL_Lum( RGB )


Randomizer(minu, maxu, errMargin, idu) {
   Static prevIDs := []
   Random, OutputVar, % minu, % maxu
   ; If isInRange(OutputVar, prevIDs[idu] + errMargin, prevIDs[idu] - errMargin)
   ; {
   ;    Random, OutputVar, % minu, % maxu
   ;    If (prevIDs[idu]=OutputVar)
   ;       Random, OutputVar, % minu, % maxu
   ; }

   prevIDs[idu] := OutputVar
   Return OutputVar
}

ActPaintBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH) || (A_TickCount - lastOtherWinClose<450)
      Return

   canApplyFXa := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   canApplyFXb := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   If (BrushToolBlurStrength<3 && canApplyFXa=0 && canApplyFXb=0 && BrushToolType=5)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   randomFactor := Randomizer(-950, 950, 2, 1)
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := useGdiBitmap("yes")
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   thisUseSecondaryColor := BrushToolUseSecondaryColor
   If GetKeyState("Ctrl", "P")
      thisUseSecondaryColor := !BrushToolUseSecondaryColor

   o_startToolColor := startToolColor := (thisUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   o_startToolColor := startToolColor := RandomizeBrushColor(startToolColor)
   thisMainOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
   If (BrushToolWetness=21)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.5), 5)
      thisWetness := 20
   } Else If (BrushToolWetness=22)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.2), 5)
      thisWetness := 20
   } Else thisWetness := BrushToolWetness

   oMx := kX, oMy := kY
   thisSelectionConstrain := (editingSelectionNow=1) ? BrushToolOutsideSelection - 1 : 0
   o_brushSize := brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
   If (BrushToolType>=6 && brushSize<5)
      brushSize := 5

   If (BrushToolRandomSize>0)
   {
      gR := Ceil(brushSize * (BrushToolRandomSize/100)) + 1
      gR := Randomizer(-gR, gR, 2, 2)
      brushSize := clampInRange(brushSize + gR, brushSize//3 + 2, brushSize + Abs(gR))
   }

   thisBulgePinchFactor := (BrushToolType=6) ? BrushToolWetness*2 + 1 :  BrushToolWetness + 1
   If (BrushToolType=7)
      thisBulgePinchFactor := -BrushToolWetness - 1

   thisToolSoftness := BrushToolSoftness
   If (BrushToolRandomSoftness>0)
   {
      gR := BrushToolRandomSoftness
      gR := Randomizer(-gR, gR, 2, 3)
      thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
   }

   thisToolAngle := BrushToolAngle
   If (BrushToolRandomAngle>0)
   {
      gR := BrushToolRandomAngle
      gR := Randomizer(-gR, gR, 2, 4)
      thisToolAngle := clampInRange(BrushToolAngle + gR, 0, 180)
   }

   thisToolAspectRatio := BrushToolAspectRatio
   If (BrushToolRandomAspectRatio>0)
   {
      gR := BrushToolRandomAspectRatio
      gR := Randomizer(-gR, gR, 2, 5)
      thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
   }

   ; create base brush element / bitmap
   If (BrushToolType=3) ; cloner
      brushu := createClonedBrushBitmap(brushSize, 101 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, whichBitmap, 0, 0, 1)
   Else If (BrushToolType=4 || BrushToolType=5 || BrushToolType=7 || BrushToolType=8) ; eraser, effects, pinch and bulge brushes
      brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, 0, "0xff000000")
   Else If (BrushToolType=6) ; smudge/pinch/bulge
      brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize + thisBulgePinchFactor, thisToolAngle, thisToolAspectRatio, 0, "0xff000000")
   Else If (BrushToolType>1) ; soft edges
      brushu := createGradientBrushBitmap(startToolColor, 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
   Else ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)

   If (!brushu && BrushToolType>1)
   {
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (BrushToolType=4 && !thisSelectionConstrain) || (BrushToolType=5 && BrushToolOverDraw=0) || (BrushToolType=3 && BrushToolDynamicCloner=1)
      clonescu := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
   Gu := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisQuality,,, compositingQuality)
   If !Gu
   {
      trGdip_DisposeImage(brushu, 1)
      trGdip_DisposeImage(brushImg, 1)
      trGdip_DisposeImage(clonescu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)
      addJournalEntry("ERROR: failed to create graphics object on " whichBitmap ". Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_SetPixelOffsetMode(Gu, 2)
   If (thisSelectionConstrain)
   {
      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, vPselRotation, rotateSelBoundsKeepRatio)
      modus := (thisSelectionConstrain=1) ? 0 : 4
      Gdip_SetClipPath(Gu, ImgSelPath, modus)
   } 

   thisOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisEraseOpacity := thisOpacity
   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisEraseOpacity
   thisWet := 0.79 + (21 - thisWetness)/100
   If ((A_TickCount - lastInvoked>350) && undoLevelsRecorded<2)
      recordUndoLevelNow("init", 0)

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   dryZeit := A_TickCount
   dryRateZeit := 300 - BrushToolDryingRate**2
   thisDryRate := clampInRange(BrushToolDryingRate/4, 1, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   stepu := (isUserStepu=0) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(thisToolAngle, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0)
      stepu := 1

   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   While, (determineLClickstate()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<2)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      If (BrushToolRandomPosX>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosX/100))
         gR := Randomizer(-gR, gR, 3, 6)
         mX += gR
      }

      If (BrushToolRandomPosY>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosY/100))
         gR := Randomizer(-gR, gR, 3, 7)
         mY += gR
      }

      If (BrushToolType<3 && BrushToolWetness>0) || (BrushToolType=3 && BrushToolDynamicCloner=1)
      {
         If (BrushToolRandomSize>0)
         {
            gR := Ceil(o_brushSize * (BrushToolRandomSize/100)) + 1
            gR := Randomizer(-gR, gR, 2, 2)
            brushSize := clampInRange(o_brushSize + gR, o_brushSize//3 + 2, o_brushSize + Abs(gR))
         }

         If (BrushToolRandomSoftness>0)
         {
            gR := BrushToolRandomSoftness
            gR := Randomizer(-gR, gR, 2, 3)
            thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
         }

         If (BrushToolRandomAngle>0)
         {
            gR := BrushToolRandomAngle
            gR := Randomizer(-gR, gR, 2, 4)
            thisToolAngle := clampInRange(BrushToolAngle + gR, 0, 180)
         }

         If (BrushToolRandomAspectRatio>0)
         {
            gR := BrushToolRandomAspectRatio
            gR := Randomizer(-gR, gR, 2, 5)
            thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
         }
      }

      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
      || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
         Continue

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               smudgeX := clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               smudgeX := - clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := - Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               smudgeY := clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               smudgeY := - clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := - Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; [re]create dynamic brushes
            If (BrushToolType=6)
            {
               ; smudge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2 - smudgeX/2), Round(tkY - brushSize/2 - smudgeY/2), brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, 1)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType>=7)
            {
               ; pinch/bulge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType=5)
            {
               ; effects brush
               thisBMP := (BrushToolOverDraw=0 && clonescu) ? clonescu : whichBitmap
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
               applyPersonalizedColorsBMP(brushImg, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType=4)
            {
               ; eraser brush
               If thisSelectionConstrain
               {
                  ; ToolTip, % testuz "=" otestPos " == lola" , , , 2
                  brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
                  QPV_EraserBrush(brushImg, brushu, 0, thisEraserMode, thisEraseOpacity, 0, 0, 0)
               } Else
                  QPV_EraserBrush(whichBitmap, brushu, 0, thisEraserMode, thisEraseOpacity, tkX - brushSize/2, tkY - brushSize/2, clonescu)
               currIMGdetails.HasAlpha := 1
               ; countClicks++
            } Else If (BrushToolDynamicCloner=1 && BrushToolType=3) ; dynamic cloner mode
            {
               brushu := trGdip_DisposeImage(brushu, 1)
               brushu := createClonedBrushBitmap(brushSize, 101 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, clonescu, offX, offY, 1)
            } Else If (BrushToolWetness>0 && BrushToolType=2)
            {
               ; wet soft edges brush
               brushu := trGdip_DisposeImage(brushu, 1)
               coloruY := getPixelColorAvg(whichBitmap, kX, kY, "0xFF" o_startToolColor, startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               ; startToolColor := RandomizeBrushColor(startToolColor)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               brushu := createGradientBrushBitmap(g_startToolColor, 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
            } Else If (BrushToolWetness>0 && BrushToolType=1)
            {
               ; wet simple brush
               Gdip_DeleteBrush(gdipbrushu)
               coloruY := getPixelColorAvg(whichBitmap, kX, kY, "0xFF" o_startToolColor, startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               thisHexOpacity := Format("{1:#x}", thisOpacity)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity g_startToolColor)
            }
            ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2

            ; draw the brushes into main image [ whichBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, thisToolAspectRatio, thisToolAngle)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (BrushToolOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)
               Gdip_DeletePath(tmpPath)
            } Else If (BrushToolType=4)
            {
               If thisSelectionConstrain
               {
                  ; redraw eraser area
                  Gdip_SetClipRect(Gu, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 1)
                  Gdip_GraphicsClear(Gu)
                  Gdip_DrawImage(Gu, brushImg, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, brushSize, brushSize)
                  brushImg := trGdip_DisposeImage(brushImg, 1)
                  Gdip_ResetClip(Gu)
                  modus := (thisSelectionConstrain=1) ? 0 : 4
                  If ImgSelPath
                     Gdip_SetClipPath(Gu, ImgSelPath, modus)
               }
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>=5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               If (BrushToolType>=7)
               {
                  ; pinch/bulge brushes
                  Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor, tkY - brushSize//2 - thisBulgePinchFactor, brushSize + thisBulgePinchFactor*2, brushSize + thisBulgePinchFactor*2, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  If (thisBulgePinchFactor>3 && BrushToolType=8 && BrushToolDynamicCloner=1)
                     Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor//2, tkY - brushSize/2 - thisBulgePinchFactor/2, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, brushSize, brushSize, thisFloatOpacity)
               } Else
                  Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)

               If (BrushToolType>=5)
                  brushImg := trGdip_DisposeImage(brushImg, 1)

               If (BrushToolType>=6 && BrushToolOverDraw=1)
               {
                  ; smudge/pinch/bulge brushes
                  f := (BrushToolType=7) ? BrushToolWetness*2 + 2 : BrushToolWetness + 2
                  If (BrushToolType=6)
                     f := BrushToolWetness//2 + 2
                  brushSize -= f
                  If (brushSize>2)
                  {
                     If (BrushToolType=6)
                        brusha := Gdip_ResizeBitmap(brushu, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 3)
                     Else
                        brusha := Gdip_ResizeBitmap(brushu, brushSize, brushSize, 0, 3)
                     brushu := trGdip_DisposeImage(brushu, 1)
                     brushu := brusha
                  }
               }
            }

            ; Gdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               } Else If (BrushToolType=4 || BrushToolType=5)
               {
                  brushu := trGdip_DisposeImage(brushu, 1)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, thisHexOpacity, "0xff000000")
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || stepu<=1 && BrushToolType>5 || brushToolStepping=0 || BrushToolType>=7 || brushSize<2 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         If (thisIndex=1)
            oMx := tkX, oMy := tkY
         dummyResizeImageGDIwin()
      }
   }

   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(brushu, 1)
   trGdip_DisposeImage(brushImg, 1)
   trGdip_DisposeImage(clonescu, 1)

   ; gdipObjectsStats(1, "createGradientBrushBitmap")

   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   If (A_TickCount - lastInvoked>350)
   {
      If !UserMemBMP
         UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())
      recordUndoLevelNow(0, useGdiBitmap())
   }

   ; liveDrawingBrushTool := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
}

ActDrawAlphaMaskBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH) || (A_TickCount - lastOtherWinClose<450)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := userAlphaMaskBmpPainted
   If StrLen(whichBitmap)<3
      Return

   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   o_startToolColor := startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   pDPX := viewportDynamicOBJcoords.x,     pDPY := viewportDynamicOBJcoords.y
   pVPimgW := viewportDynamicOBJcoords.w,  pVPimgH := viewportDynamicOBJcoords.h
   MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)

   oMx := kX, oMy := kY
   brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize

   ; create base brush element / bitmap
   If (BrushToolType>1) ; soft edges
      brushu := createGradientBrushBitmap(startToolColor, 101 - BrushToolSoftness, brushSize, BrushToolAngle, BrushToolAspectRatio)
   Else ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)

   If (!brushu && BrushToolType>1)
   {
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   Gu := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisQuality)
   If !Gu
   {
      trGdip_DisposeImage(brushu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)
      addJournalEntry("ERROR: failed to create graphics object on " whichBitmap ". Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_SetPixelOffsetMode(Gu, 2)
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisEraseOpacity := thisOpacity
   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisEraseOpacity
   thisWet := 0.79 + (21 - thisWetness)/100

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   dryZeit := A_TickCount
   dryRateZeit := 300 - BrushToolDryingRate**2
   thisDryRate := clampInRange(BrushToolDryingRate/4, 1, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   stepu := (isUserStepu=0) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(BrushToolAngle, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0)
      stepu := 1

   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   While, (determineLClickstate()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<2)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
      || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
         Continue

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; draw the brushes into main image [ whichBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, BrushToolAspectRatio, BrushToolAngle)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (BrushToolOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)
               Gdip_DeletePath(tmpPath)
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>=5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
            }

            ; Gdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || brushToolStepping=0 || brushSize<2 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         If (thisIndex=1)
            oMx := tkX, oMy := tkY

         livePreviewsImageEditing()
      }
   }

   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(brushu, 1)
   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   ; liveDrawingBrushTool := 0
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
}

drawVPgridsNow(mW, mH, newW, newH, DestPosX, DestPosY, Gu) {
   Static penGrid, penGridL, lastPenState, miniPath, maxiPath, prevPathsState
   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   thisPen := thisGridThickness vpGridColor vpGridAlpha
   If (thisPen!=lastPenState)
   {
      If penGrid
         Gdip_DeletePen(penGrid)
      If penGridL
         Gdip_DeletePen(penGridL)

      Gdip_FromARGB("0xFF" vpGridColor, A, R, G, B)
      this1stOpacity := vpGridAlpha
      thisColor := Gdip_ToARGB(this1stOpacity, R, G, B)
      penGrid := Gdip_CreatePen(thisColor , thisGridThickness)

      thisColor := SubStr(MixARGB("0xFF998899", "0xFF" vpGridColor, 0.85), 5)
      Gdip_FromARGB("0xFF" thisColor, A, R, G, B)
      this1stOpacity := clampInRange(vpGridAlpha + 25, 1, 255)
      thisColor := Gdip_ToARGB(this1stOpacity, R, G, B)
      penGridL := Gdip_CreatePen(thisColor , Round(thisGridThickness*1.65))
   }

   dS := (vpGridFixedSize=1) ? vpGridSize : Ceil(vpGridSize/1.5 + (vpGridSize/5)*zoomLevel + (imgHUDbaseUnit/25)*zoomLevel)
   If (zoomLevel<0.5 && vpGridSize<15 && vpGridFixedSize=0)
      dS := dS*2
   Else If (zoomLevel>10 && vpGridFixedSize=0)
      dS := dS//2
   Else If (zoomLevel>5 && vpGridFixedSize=0)
      dS := dS//1.5

   loops := 0
   prevDPx := clampInRange(prevDestPosX, 0, mW)
   prevDPy := clampInRange(prevDestPosY, 0, mH)
   MaxLimX := (LimitSelectBoundsImg=1) ? prevDestPosX + prevResizedVPimgW : mW
   MaxLimY := (LimitSelectBoundsImg=1) ? prevDestPosY + prevResizedVPimgH : mH
   MinLimX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   MinLimY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   dY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   mW := clampInRange(dX + mW, MinLimX, MaxLimX)
   mH := clampInRange(dY + mH, MinLimY, MaxLimY)
   thisPathsState := "a" dS vpGridStepu imageAligned vpGridFixedSize mW mH prevDPx prevDPy LimitSelectBoundsImg
   If (prevPathsState!=thisPathsState)
   {
      If miniPath
         Gdip_DeletePath(miniPath)
      If maxiPath
         Gdip_DeletePath(maxiPath)

      prevPathsState := thisPathsState
      miniPath := Gdip_CreatePath()
      maxiPath := Gdip_CreatePath()
      Loop
      {
         dX += dS
         If (dX>mW)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, dX, mH)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, dX, mH)
         }
      }

      ; ToolTip, % mW "==" dS "==" thisThick "==" loops    , , , 2
      dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
      loops := prevu := 0
      Loop
      {
         dY += dS
         If (dY>mH)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, mW, dY)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, mW, dY)
         }
      }
      Gdip_ClosePathFigures(miniPath)
      Gdip_ClosePathFigures(maxiPath)
   }

   Gdip_DrawPath(Gu, penGrid, miniPath)
   Gdip_DrawPath(Gu, penGridL, maxiPath)
}

drawHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath) {
    Static prevImgPath, lastInvoked := 1
    If (preventHUDelements=1)
    {
       preventHUDelements := 0
       Return
    }

    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    pBrush := (mode=2) ? pBrushB : pBrushA
    indicWidth := 150
    lineThickns := imgHUDbaseUnit
    lineThickns2 := lineThickns//4
    If (showHistogram>1 && drawingShapeNow!=1 && mode!=2)
    {
       thisImgCall := imgPath currentFileIndex zoomLevel IMGresizingMode imgFxMode showHistogram gdiBitmap undoLevelsRecorded currentUndoLevel UserMemBMP OSDfntSize histogramMode
       thisSizingModes := (IMGresizingMode=1 || IMGresizingMode=2 || IMGresizingMode=5) || (IMGresizingMode=4 && IMGlargerViewPort!=1) ? 1 : 0
       If (imgFxMode!=1 || thisSizingModes!=1 || animGIFplaying=1 || desiredFrameIndex>0)
       {
          prevImgPath := 0
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
          If StrLen(tempBMP)>2
          {
             thisPosX := (DestPosX<0) ? 0 : DestPosX
             thisPosY := (DestPosY<0) ? 0 : DestPosY
             thisW := (newW>mainWidth) ? mainWidth : newW
             thisH := (newH>mainHeight) ? mainHeight : newH
             thisVPimg := Gdip_CloneBmpPargbArea(A_ThisFunc, tempBMP, thisPosX + 1, thisPosY + 1, thisW - 2, thisH - 2)
             createHistogramBMP(thisVPimg)
             trGdip_DisposeImage(thisVPimg, 1)
             trGdip_DisposeImage(tempBMP, 1)
          }
       } Else If (prevImgPath!=thisImgCall) && (A_TickCount - lastInvoked>50)
       {
          lastInvoked := A_TickCount
          prevImgPath := thisImgCall
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If StrLen(gdiBitmap)>3
             createHistogramBMP(gdiBitmap)
       }
    } Else prevImgCall := 0

    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
    If (showViewPortGrid=1 && slideShowRunning!=1 && imgEditPanelOpened!=1)
       drawVPgridsNow(mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, glPG)

    If (mode=2 && IMGresizingMode=4 && IMGlargerViewPort=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawRectangle(glPG, pPen1d, thisX, thisY, thisW, thisH)
    } Else If (mode=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       thisThick := imgHUDbaseUnit//11
       If (showSelectionGrid=1 || imgSelLargerViewPort=1) && (editingSelectionNow=1)
       {
          Gdip_SetPenWidth(pPen4, thisThick)
          Gdip_DrawLine(glPG, pPen4, DestPosX + newW//2 - thisThick//4, DestPosY, DestPosX + newW//2 - thisThick//4, DestPosY + newH)
          Gdip_DrawLine(glPG, pPen4, DestPosX, DestPosY + newH//2 - thisThick//4, DestPosX + newW, DestPosY + newH//2 - thisThick//4)
       }

       If (IMGentirelylargerThanVP=0)
       {
          If (borderAroundImage=1) || (editingSelectionNow=1 && LimitSelectBoundsImg=1)
             Gdip_DrawRectangle(glPG, pPen4, DestPosX - thisThick//2, DestPosY - thisThick//2, newW + thisThick, newH + thisThick)
       }
    }

; visual markers for image viewing conditions

    If (markedSelectFile || FlipImgV=1 || FlipImgH=1 || IMGlargerViewPort=1 || imgFxMode>1) && (slideShowRunning!=1)
    {
       If (FlipImgH=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - indicWidth//2, mainHeight//2 - lineThickns2//2, indicWidth, lineThickns2, lineThickns2//2)
       If (FlipImgV=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//2, lineThickns2, indicWidth, lineThickns2//2)

       If (imgFxMode>1 && mode=2)
       {
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//4, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2, 0, 180)
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//8, mainHeight//2 - indicWidth//8, indicWidth//4, indicWidth//4, 180, 360)
       }

       If (IMGlargerViewPort=1 && imgEditPanelOpened!=1)
       {
          marginErr := (mode=2) ? 12 : 25
          lineThickns2 := (imgHUDbaseUnit/3)//1.5
          If (newH>mainHeight)
          {
             If (DestPosY<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, lineThickns2//2)
             If (DestPosY>-newH+mainHeight+marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, mainHeight - lineThickns2//2, mainWidth, lineThickns2//2)
          }

          If (newW>mainWidth)
          {
             If (DestPosX<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, lineThickns2//2, mainHeight)
             If (DestPosX>-newW+mainWidth+marginErr)
                Gdip_FillRectangle(glPG, pBrush, mainWidth - lineThickns2//2, 0, lineThickns2//2, mainHeight)
          }
       }

       If (markedSelectFile && imgEditPanelOpened!=1)
       {
          sqSize := lineThickns ; (mode=2) ? lineThickns + lineThickns2 : lineThickns
          sqPosX := mainWidth - sqSize
          Gdip_FillRectangle(glPG, pBrush, sqPosX, 0, sqSize, sqSize)
          thisThick := lineThickns//9
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen1d, sqPosX, 0, sqSize, sqSize)
       }

       If resultedFilesList[currentFileIndex, 2] ; file is selected
       {
          thisThick := lineThickns//4.2 ; (mode=2) ? lineThickns//2.5 : lineThickns//4.2
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen3, 0, 0, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen1d, 0, 0, mainWidth, mainHeight)
       }
    }

; highlight usePrevious=1 mode

    lineThickns := (mode=2) ? imgHUDbaseUnit//10 : imgHUDbaseUnit//9
    If (mode=2 && imgFxMode=1)
    {
       indicWidth := (zoomLevel<1) ? Round(120 * zoomLevel) : 110
       If (indicWidth<50)
          indicWidth := 50
       Gdip_SetPenWidth(pPen2, lineThickns)
       Gdip_FillRectangle(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
       Gdip_DrawRectangle(glPG, pPen2, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
    }

; draw the scrollbar indicators

    prcVisX := mainWidth/newW
    prcVisY := mainHeight/newH
    knobW := Round(mainWidth*prcVisX)
    knobH := Round(mainHeight*prcVisY)
    If (knobH<15)
       knobH := 15
    If (knobW<15)
       knobW := 15

    Ax := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    Ax := Round(Ax*maxSelX)
    Ay := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    Ay := Round(Ay*maxSelY)
    knobX := Round((Ax/maxSelX)*mainWidth)
    knobY := Round((Ay/maxSelY)*mainHeight) 
    knobSize := imgHUDbaseUnit//3
    If (knobW<mainWidth - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, knobX, 0, knobW, knobSize)
       scrollBarHy := mainHeight - knobSize
       Gdip_FillRectangle(glPG, pBrushE, 0, scrollBarHy, mainWidth, knobSize)
       Gdip_FillRectangle(glPG, pBrushD, knobX, scrollBarHy + 5, knobW, knobSize)
    } Else scrollBarHy := 0

    If (knobH<mainHeight - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, 0, knobY, knobSize, knobH)
       scrollBarVx := mainWidth - knobSize
       Gdip_FillRectangle(glPG, pBrushE, scrollBarVx, 0, knobSize, mainHeight)
       Gdip_FillRectangle(glPG, pBrushD, scrollBarVx + 5, knobY, knobSize, knobH)
    } Else scrollBarVx := 0

; highlight number of frames and the current frame in multi-frame images [tiff and gif]

    If (totalFramesIndex>0)
    {
       bulletSize := imgHUDbaseUnit//3
       totalBulletsWidth := bulletSize * totalFramesIndex
       If (totalBulletsWidth>mainWidth)
          bulletsPerc := Round(desiredFrameIndex/totalFramesIndex, 3)
       maxBullets := Round(mainWidth/bulletSize)
       centerPos := bulletsPerc ? 0 : mainWidth//2 - totalBulletsWidth//2
       If (centerPos<0)
          centerPos := 0
       Loop, % totalFramesIndex + 1
       {
           If bulletsPerc
              whichBrush := (A_Index/maxBullets<bulletsPerc) || (desiredFrameIndex=totalFramesIndex) ? pBrushA : pBrushE
           Else
              whichBrush := (A_Index - 1 <= desiredFrameIndex) ? pBrushA : pBrushE
           Gdip_FillEllipse(glPG, whichBrush, centerPos + bulletSize * (A_Index - 1), mainHeight - bulletSize, bulletSize, bulletSize)
           If (A_index>maxBullets)
              Break
       }
    }

    If (adjustNowSel=1)
       Return

    If (showHistogram>1 && StrLen(HistogramBMP)>3 && mode!=2)
    { 
       Gdip_GetImageDimensions(HistogramBMP, imgW, imgH)
       thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
       thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
       If (FlipImgH=1 || FlipImgV=1)
       {
          tempBMP := trGdip_CloneBitmap(A_ThisFunc, HistogramBMP)
          flipBitmapAccordingToViewPort(tempBMP, 1)
          E := trGdip_DrawImage(A_ThisFunc, glPG, tempBMP, thisPosX, thisPosY)
          trGdip_DisposeImage(tempBMP, 1)
       } Else E := trGdip_DrawImage(A_ThisFunc, glPG, HistogramBMP, thisPosX, thisPosY,,,,,,, 0.9)

       If (FlipImgH=1)
          thisPosX := 0 + Round(mainWidth - scrollBarVx)
       If (FlipImgV=1)
          thisPosY := 0 + Round(mainHeight - scrollBarHy)

       HUDobjHistoBoxu[1] := imgW, HUDobjHistoBoxu[2] := imgH
       HUDobjHistoBoxu[3] := thisPosX, HUDobjHistoBoxu[4] := thisPosY
       hasDrawnHistoMap := (E="fail") ? 0 : 1
    } Else hasDrawnHistoMap := 0

    additionalHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 1)
}

snapPointsAtAngles(gmX, gmY, dulaX, dulaY, ByRef guX, ByRef guY) {
    mustSnapLiveDrawPoints := 1
    guY := gmY, guX := gmX
    zY := Abs(gmY),   zX := Abs(gmX)
    wY := Abs(dulaY), wX := Abs(dulaX)
    maxX := max(zX, wX), maxY := max(zY, wY)
    minX := min(zX, wX), minY := min(zY, wY)
    lenX := maxX - minX
    lenY := maxY - minY
    lenAvg := (lenX + lenY)//2
    thisAngle := getAngleBetweenTwoPoints(gmX, gmY, dulaX, dulaY, 2)
    ; ToolTip, % thisAngle , , , 2
    If isInRange(thisAngle, 30, 60)
    {
       guX := dulaX + lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 120, 150)
    {
       guX := dulaX - lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 210, 240)
    {
       guX := dulaX - lenAvg
       guY := dulaY + lenAvg
    } Else If isInRange(thisAngle, 300, 330)
    {
       guX := dulaX + lenAvg
       guY := dulaY + lenAvg
    } Else If (lenX>lenY)
       guY := dulaY
    Else
       guX := dulaX
}

getAngleBetweenTwoPoints(x1, y1, x2, y2, mode:=1) {
   ; function from tidbit
   ; based on http://stackoverflow.com/questions/2339487/calculate-angle-of-2-points
   ; returns 0-359.999
  angle := APIatan2(y1-y2, x1-x2)*(180/3.14159)*-1
  if (mode=2)
     angle += (angle<0) ? 360 : 0 ; or should it be 359? whatever.
  return angle
}

APIatan2(y,x) { 
   Return dllcall("msvcrt\atan2","Double",y, "Double",x, "CDECL Double")
}

drawLiveCreateShape(mainWidth, mainHeight, Gu) {
    If StrLen(HistogramBMP)>2
       HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)

    newShape := ""
    newArrayu := []
    Loop, % customShapePoints.Count()
    {
       maxPoints := A_Index
       splitu := customShapePoints[A_Index]
       xu := splitu[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
       yu := splitu[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
       newArrayu[A_Index] := [xu, yu]
       newShape .= xu "," yu "|"
    }

    SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
    PointsList := newShape
    GetMouseCoord2wind(PVhwnd, mX, mY)
    gmX := (FlipImgH=1) ? mainWidth - mX : mX
    gmY := (FlipImgV=1) ? mainHeight - mY : mY
    dontAddPoint := (mX<0 || mY<0) ? -1 : 0
    If (IMGlargerViewPort=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1))
    {
       ; handle H/V scrollbars for images larger than the viewport
       If (scrollBarHy>1) && ((mY>scrollBarHy && FlipImgV=0)
       || (mY<(mainHeight - scrollBarHy) && FlipImgV=1))
       {
          dontAddPoint := -1
       } Else If (scrollBarVx>1) && ((mX>scrollBarVx && FlipImgH=0)
       || (mX<(mainWidth - scrollBarVx) && FlipImgH=1))
       {
          dontAddPoint := -1
       }
    }

    If (GetKeyState("Space", "P") || determineLClickstate()=1)
       dontAddPoint := -1
    Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
       dontAddPoint := -1

    MouseGetPos, , , OutputVarWin
    If (OutputVarWin!=PVhwnd) || (A_TickCount - zeitSillyPrevent<100)
       dontAddPoint := -1

    If (dontAddPoint!=-1)
    {
       Loop, % newArrayu.Count()
       {
          If (A_Index=1 && drawingLiveMode=1)
             Continue

          xu := newArrayu[A_Index, 1]
          yu := newArrayu[A_Index, 2]
          If isDotInRect(gmX, gmY, xu - SelDotsSize//2, xu + SelDotsSize, yu - SelDotsSize//2, yu + SelDotsSize)
             dontAddPoint := A_Index
       }
    }

    mustSnapLiveDrawPoints := 0
    If (GetKeyState("Shift", "P") && dontAddPoint=0 && maxPoints)
    {
       snapPointsAtAngles(gmX, gmY, newArrayu[maxPoints, 1], newArrayu[maxPoints, 2], gmX, gmY)
       VPstampBMPx := gmX, VPstampBMPy := gmY
    }

    If (dontAddPoint=0)
       PointsList .= gmX "," gmY "|"
    ; ToolTip, % gmX "--" gmY , , , 2
    ; ToolTip, % tensionCurveCustomShape "=t" , , , 2
    PointsList := Trimmer(PointsList, "|")
    If (PenuDrawLive && ST_Count(PointsList, "|")<=1)
    {
       Gdip_SetPenWidth(pPen4, imgHUDbaseUnit//11)
       Gdip_DrawLines(Gu, pPen4, PointsList)
    } Else If (PenuDrawLive)
    {
       If (drawingLiveMode=1 || drawingLiveMode=3)
       {
          If (closedLineCustomShape=1)
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawClosedCurve(Gu, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawPolygon(Gu, PenuDrawLive, PointsList)
          } Else
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawCurve(Gu, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawLines(Gu, PenuDrawLive, PointsList)
          }
       } Else
       {
          If (cardinalCurveCustomShape=1)
             Gdip_FillClosedCurve(Gu, PenuDrawLive, PointsList, tensionCurveCustomShape)
          Else
             Gdip_FillPolygon(Gu, PenuDrawLive, PointsList)
       }
    }

    If (dontAddPoint!=-1 && (A_TickCount - lastZeitFileSelect>250))
    {
       Loop, % customShapePoints.Count()
       {
           xu := newArrayu[A_Index, 1]
           yu := newArrayu[A_Index, 2]
           If (A_Index=dontAddPoint)
              Gdip_FillRectangle(Gu, pBrushE, xu - SelDotsSize, yu - SelDotsSize, SelDotsSize*2, SelDotsSize*2)

           whichBrush := (A_Index=1 || A_Index=maxPoints) ? pBrushC : pBrushD
           Gdip_FillRectangle(Gu, whichBrush, xu - SelDotsSize//2, yu - SelDotsSize//2, SelDotsSize, SelDotsSize)
       }
    }
}

convertCustomShape2relativeCoords(PointsListArray) {
    If (PointsListArray.Count()<3)
       Return

    minXu := minYu := 99993234489
    maxXu := maxYu := -99993234489
    newArrayu := []
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       xu := c[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
       yu := c[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
       minXu := min(xu, minXu), minYu := min(yu, minYu)
       maxXu := max(xu, maxXu), maxYu := max(yu, maxYu)
       newArrayu[thisIndex] := [xu, yu]
    }

    MouseCoords2Image(minXu, minYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX1, imgSelY1)
    MouseCoords2Image(maxXu, maxYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX2, imgSelY2)
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    initialCustomShapeCoords := imgSelX1 "|" imgSelY1 "|" bounds.w "|" bounds.h
    INIaction(1, "initialCustomShapeCoords", "General")
    mX := maxXu - minXu
    mY := maxYu - minYu

    newShape := []
    Loop, % newArrayu.Count()
    {
       xu := (newArrayu[A_Index, 1] - minXu) / mX
       yu := (newArrayu[A_Index, 2] - minYu) / mY
       newShape[A_Index] := [xu, yu]
       ; newShapa .= xu "," yu "|"
    }

    ; ToolTip, % newShapa , , , 2
    ; SetTimer, dummyRefreshImgSelectionWindow, -150
    Return newShape
}

adjustCustomShapePositionLive(dir:=0) {
    Static lastInvoked := 1
    If (customShapePoints.Count()<3)
       Return

    stepuX := stepuY := 0
    If (Abs(dir)=1)
       stepuX := (dir=1) ? 2 : -2

    If (Abs(dir)=2)
       stepuY := (dir=2) ? 2 : -2

    If (A_TickCount - lastInvoked<400)
    {
       stepuX *= 2
       stepuY *= 2
    }

    newArrayu := []
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       xu := c[1] - stepuX
       yu := c[2] - stepuY
       newArrayu[thisIndex] := [xu, yu]
    }
    lastZeitFileSelect := A_TickCount
    If (thisIndex>2)
       customShapePoints := newArrayu.Clone()
    lastInvoked := A_TickCount
}

convertCustomShape2givenArea(PointsListArray, refX, refY, refW, refH) {
    ; drawingShapeNow := 0
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       xu := refW * c[1] + refX
       yu := refH * c[2] + refY
       If (xu="" || yu="")
          Continue

       newShape .= xu "," yu "|"
       ; newShape .= Round(xu) "," Round(yu) "|"
    }
    ; ToolTip, % newShape , , , 2
    Return Trimmer(newShape, "|")
}

convertShapePointsArrayToStr(PointsListArray) {
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       newShape .= c[1] "," c[2] "|"
    }

    Return Trimmer(newShape, "|")
}

convertShapePointsStrToArray(PointsList) {
    If !InStr(PointsList, "|")
       Return

    newShape := []
    newArrayu := new hashtable()
    Loop, Parse, PointsList, "|"
    {
       c := StrSplit(A_LoopField, ",")
       ogmX := c[1]
       ogmY := c[2]
       If (ogmX="" || ogmY="" || newArrayu[ogmX ogmY]=1)
          Continue

       thisIndex++
       newArrayu[ogmX ogmY] := 1
       newShape[thisIndex] := [ogmX, ogmY]
    }

    newArrayu := []
    If (newShape.Count()<3)
       Return
    ; ToolTip, % A_ThisFunc "=" thisIndex , , , 2
    Return newShape
}

additionalHUDelements(mode, mainWidth, mainHeight, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, directRefresh:=0) {
    Critical, on

    If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && drawingShapeNow!=1 && imgSelOutViewPort!=1)
    {
       If (vpImgPanningNow=1)
       {
          Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       } Else livePreviewsImageEditing("coords")
    }

    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
    If (dynamicLiveObjVisible=0)
       toggleLiveEditObject()

    setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
    If (drawingShapeNow=1)
       drawLiveCreateShape(mainWidth, mainHeight, 2NDglPG)
    Else If (editingSelectionNow=1 && mode=2)
       drawImgSelectionOnWindow("prev", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=1)
       drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=3)
       drawImgSelectionOnWindow("return", "-", "-", "-", mainWidth, mainHeight)

    If (AnyWindowOpen=64 && BrushToolType=3) || (AnyWindowOpen=23 && FillAreaColorMode=6) 
    || (AnyWindowOpen=44 || AnyWindowOpen=43 || AnyWindowOpen=26)
    {
       ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, prevDestPosX, prevDestPosY, SelDotsSize, outX, outY)
       Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, SelDotsSize, SelDotsSize)
       Gdip_DrawRectangle(2NDglPG, pPen1d, outX, outY, SelDotsSize, SelDotsSize)
    }

    If (showImgAnnotations=1 && !AnyWindowOpen && drawingShapeNow!=1 && currentUndoLevel<3)
       drawAnnotationBox(mainWidth, mainHeight, 2NDglPG)

    If (showInfoBoxHUD>=1 && drawingShapeNow!=1)
       drawinfoBox(mainWidth, mainHeight, directRefresh, 2NDglPG)

    If (showHUDnavIMG=1 && IMGlargerViewPort=1 && slideShowRunning!=1)
       VPnavBoxWrapper(mainWidth, mainHeight, 2NDglPG)

    Gdip_ResetWorldTransform(2NDglPG)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
}

toggleLiveEditObject(dummy:=0) {
   dynamicLiveObjVisible := !dynamicLiveObjVisible
   If (dummy="hide")
      dynamicLiveObjVisible := 1

   ;  TOOLTIP, % "l= " dynamicLiveObjVisible , , , 2
   actu := (dynamicLiveObjVisible!=1) ? "hide" : "show"
   ToggleVisibilityWindow(actu, hGDIselectwin)
   ToggleVisibilityWindow(actu, hGDIwin)
   If (actu="hide")
   {
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
      r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
   }
}

getColorMatrix() {
    Static prevMatrix, prevState

    thisState := "a" ForceNoColorMatrix AnyWindowOpen imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel chnRdecalage chnGdecalage chnBdecalage
    If (thisState=prevState)
       Return prevMatrix

    matrix := ""
    fraction := (isWinXP=1) ? 0.0001 : 0
    If (ForceNoColorMatrix=1 && AnyWindowOpen=10) || (imgFxMode=1)
       Return matrix

    If (imgFxMode=4 && bwDithering=0)       ; grayscale
       matrix := GenerateColorMatrix(2, lumosGrayAdjust, GammosGrayAdjust + fraction, , IntensityAlphaChannel)
    Else If (imgFxMode=5)  ; grayscale R
       matrix := GenerateColorMatrix(3, , , , IntensityAlphaChannel)
    Else If (imgFxMode=6)  ; grayscale G
       matrix := GenerateColorMatrix(4, , , , IntensityAlphaChannel)
    Else If (imgFxMode=7)  ; grayscale B
       matrix := GenerateColorMatrix(5, , , , IntensityAlphaChannel)
    Else If (imgFxMode=8)  ; alpha channel
       matrix := GenerateColorMatrix(7)
    Else If (imgFxMode=9)  ; negative / invert
       matrix := GenerateColorMatrix(6, , , , IntensityAlphaChannel)
    Else If (imgFxMode=10)  ; sepia
       matrix := GenerateColorMatrix(8, , , , IntensityAlphaChannel)
    Else If (imgFxMode=2 || imgFxMode=3) ; personalized
       matrix := GenerateColorMatrix(1, lumosAdjust, GammosAdjust + fraction, satAdjust, IntensityAlphaChannel, chnRdecalage, chnGdecalage, chnBdecalage)

    prevMatrix := matrix
    prevState := thisState
    Return matrix
}

decideGDIPimageFX(ByRef matrix, ByRef imageAttribs, ByRef pEffect) {
    Static thisImageAttribs, colorzFX := {1:0, 2:5, 3:6, 4:7, 5:8, 6:9, 7:11}
    matrix := imageAttribs := pEffect := ""
    matrix := getColorMatrix()
    If (thumbsDisplaying=1 && (imgFxMode=3 || imgFxMode=8))
       matrix := ""

    thisFXapplies := (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) ? 1 : 0
    mustCreateAttribs := (realGammos!=1 && imgThreshold=0 && !matrix) ? 0 : 1
    If (mustCreateAttribs=1 && ForceNoColorMatrix!=1 && imgFxMode>1)
    {
       imageAttribs := thisImageAttribs ? thisImageAttribs : Gdip_CreateImageAttributes()
       Gdip_SetImageAttributesColorMatrix(matrix, imageAttribs)
       ; Gdip_SetImageAttributesWrapMode(imageAttribs, 3)
       If (imgThreshold>0 && thisFXapplies=1)
          Gdip_SetImageAttributesThreshold(imageAttribs, imgThreshold)
       If (realGammos!=1 && thisFXapplies=1)
          Gdip_SetImageAttributesGamma(imageAttribs, realGammos)
    }

    If (isWinXP=1)
       Return "a" thisFXapplies lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust

    o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    thisZatAdjust := (imgFxMode=4 && bwDithering=0 && zatAdjust=0) ? -40 : zatAdjust
    If ((thisZatAdjust=0 && hueAdjust=0 && lummyAdjust=0) || !colorzFX[specialColorFXmode] || ForceNoColorMatrix=1)
       applyAdjusts := 0

    If (thisFXapplies=1 && applyAdjusts!=0 && o_bwDithering=0 && specialColorFXmode>1)
    {
       paramA := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXmode : hueAdjust
       paramB := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXchannel : thisZatAdjust
       If (colorzFX[specialColorFXmode]=1)
          paramB := 0

       pEffect := Gdip_CreateEffect(colorzFX[specialColorFXmode], paramA, paramB, lummyAdjust)
    }

    Return "a" paramA paramB thisFXapplies applyAdjusts o_bwDithering specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust
}

testSelectOutsideImgEntirely(pBitmap) {
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     If (nimgSelX1<0)
        nimgSelX1 := 0
     If (nimgSelY1<0)
        nimgSelY1 := 0

     If (nimgSelX2<5)
        nimgSelX2 := 1
     If (nimgSelY2<5)
        nimgSelY2 := 1

     If (nimgSelX1>imgW-5)
        nimgSelX1 := ImgW-1
     If (nimgSelY1>ImgH-5)
        nimgSelY1 := imgH-1

     If (nimgSelX2>imgW)
        nimgSelX2 := imgW
     If (nimgSelY2>imgH)
        nimgSelY2 := imgH

     isOutside := 0
     imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     If (imgSelW<3 || imgSelH<3)
        isOutside := 1

     ; If (nimgSelX1<2 && nimgSelY1<2 && nimgSelX2<5 && nimgSelY2<5)
     ;    isOutside := 1

     ; If (nimgSelX1>ImgW-5 && nimgSelY1>imgH-5 && nimgSelX2>imgW && nimgSelY2>imgH)
     ;    isOutside := 1
     Return isOutside
}

distanceBetweenTwoPoints(x1,y1,x2,y2) {
   Return Sqrt((x2 - x1)**2+(y2 - y1)**2)
}

ViewPortSelectionManageCoords(mainWidth, mainHeight, dpX, dpY, maxSelX, maxSelY, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, ByRef zImgSelX1, ByRef zImgSelY1, ByRef zImgSelX2, ByRef zImgSelY2, ByRef vPimgSelW, ByRef vPimgSelH, ByRef vPimgSelPx, ByRef vPimgSelPy) {
     If (LimitSelectBoundsImg=1)
     {
        If (imgSelX1<0)
           imgSelX1 := 0
        If (imgSelY1<0)
           imgSelY1 := 0
 
        If (imgSelX2<2)
           imgSelX2 := 2
        If (imgSelY2<2)
           imgSelY2 := 2
     }

     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     kimgSelRatio := Round(kimgSelW/kimgSelH, 2)

     If (LimitSelectBoundsImg!=1 && lockSelectionAspectRatio>1 && kimgSelRatio!=Round(desiredSelAspectRatio, 2) && desiredSelAspectRatio && !adjustingSelDotNow)
     {
        avgWH := min(kimgSelW, kimgSelH)
        nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
        nimgSelY2 := nimgSelY1 + avgWH
     }

     If (kimgSelW>32500)
        nImgSelX2 := nImgSelX1 + 32500
     If (kimgSelH>32500)
        nImgSelY2 := nImgSelY1 + 32500
     If (kimgSelH*kimgSelW>23125**2)
     {
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        scaleu := (kimgSelH*kimgSelW)/(23125**2)
        nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
        nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        If (kimgSelW>32500)
           nImgSelX2 := nImgSelX1 + 32500
        If (kimgSelH>32500)
           nImgSelY2 := nImgSelY1 + 32500
     }

     If (editingSelectionNow=1)
        defineRelativeSelCoords(maxSelX, maxSelY)

     If (LimitSelectBoundsImg=1)
        capSelectionRelativeCoords()

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)

     minSizu := SelDotsSize*2
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<minSizu)
        vPimgSelW := minSizu
     If (vPimgSelH<minSizu)
        vPimgSelH := minSizu

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)

     minMargin := 2 ; (mainWidth*0.025 + mainHeight*0.205)//2
     imgSelLargerViewPort := (vPimgSelPx<minMargin && vPimgSelPy<minMargin) && (vPimgSelPx + vPimgSelW>mainWidth - minMargin) && (vPimgSelPy + vPimgSelH>mainHeight - minMargin) ? 1 : 0
     imgSelOutViewPort := 0
     If (vPimgSelPx>mainWidth - minSizu)
     {
        vPimgSelPx := mainWidth - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy>mainHeight - minSizu)
     {
        vPimgSelPy := mainHeight - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPx + vPimgSelW<minSizu)
     {
        vPimgSelW := minSizu*2
        vPimgSelPx := -minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy + vPimgSelH<minSizu)
     {
        vPimgSelH := minSizu*2
        vPimgSelPy := -minSizu
        imgSelOutViewPort := 1
     }

     dotsSize := SelDotsSize
     selDotX := vPimgSelPx - dotsSize//2
     selDotY := vPimgSelPy - dotsSize//2
     selDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotBx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotBy := vPimgSelPy - dotsSize//2
     selDotCx := vPimgSelPx - dotsSize//2
     selDotCy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotDx := vPimgSelPx + vPimgSelW//2 - dotsSize//2
     selDotDy := vPimgSelPy + vPimgSelH//2 - dotsSize//2

     If (AnyWindowOpen=31 && PasteInPlaceToolMode=1 && imgEditPanelOpened=1)
        prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY)
}

prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY) {
     If (LimitSelectBoundsImg=1)
     {
        If (previmgSelX1<0)
           previmgSelX1 := 0
        If (previmgSelY1<0)
           previmgSelY1 := 0
 
        If (previmgSelX2<2)
           previmgSelX2 := 2
        If (previmgSelY2<2)
           previmgSelY2 := 2
     }

     nImgSelX1 := min(previmgSelX1, previmgSelX2)
     nImgSelY1 := min(previmgSelY1, previmgSelY2)
     nimgSelX2 := max(previmgSelX1, previmgSelX2)
     nimgSelY2 := max(previmgSelY1, previmgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<2)
        vPimgSelW := 2
     If (vPimgSelH<2)
        vPimgSelH := 2

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     dotsSize := SelDotsSize
     prevSelDotX := vPimgSelPx - dotsSize//2
     prevSelDotY := vPimgSelPy - dotsSize//2
     prevSelDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     prevSelDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
}

createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, ellipse, angleu:=0, keepBounds:=0, zeroTension:=0) {
   ImgSelPath := Gdip_CreatePath()
   If (ellipse=2 && ImgSelPath)
   {
      PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx, imgSelPy, imgSelW, imgSelH)
      If (FillAreaCurveTension=1 || zeroTension=1)
         Gdip_AddPathPolygon(ImgSelPath, PointsList)
      Else
         Gdip_AddPathClosedCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
   } Else If (ellipse=1)
      Gdip_AddPathEllipse(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   Else
      Gdip_AddPathRectangle(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)

   If (angleu && ImgSelPath)
      Gdip_RotatePathAtCenter(ImgSelPath, angleu, 1, 1, keepBounds)

   ; Sleep, -1
   Return ImgSelPath
}

decideLiveSelectionBasedOnWindow(ByRef angleu, ByRef okay) {
   okay := (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55 || AnyWindowOpen=64) ? 1 : 0
   angleu := (okay=1) ? VPselRotation : 0
}

drawImgSelectionOnWindow(operation, theMsg:="", colorBox:="", dotActive:="", mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0) {
     Static prevMsg, infoBoxBMP, lineThickns, infoW, infoH, pBr0, zPen
          , infoPosX, infoPosY, prevuDPx, prevuDPy, prevNewW, prevNewH

     SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
     maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
     decideLiveSelectionBasedOnWindow(angleu, isAngleu)
     ; ForceRefreshNowThumbsList()
     If (operation="return")
     {
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        operation := "active"
        newW := prevNewW, newH := prevNewH
        ; DestPosX := prevuDPx, DestPosY := prevuDPy
        DestPosX := prevDestPosX, DestPosY := prevDestPosY
        ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     }

     If !zPen
     {
        zPen := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        ; Gdip_SetPenDashArray(zPen, "0.2,0.2")
     }

     If (operation="init")
     {
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
           clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)

        If StrLen(hitTestSelectionPath)>1
        {
           Gdip_DeletePath(hitTestSelectionPath)
           hitTestSelectionPath := ""
        }

        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        ; Gdip_ResetWorldTransform(2NDglPG)
        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        InfoW := InfoH := ""
        lineThickns := imgHUDbaseUnit//9
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//13)
     } Else If (operation="prev")
     {
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns :=  imgHUDbaseUnit//10
        Gdip_SetPenWidth(pPen1, lineThickns)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//7)
        Gdip_DrawPath(2NDglPG, zPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, pPen1, ImgSelPath)

        Gdip_ResetClip(2NDglPG)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="active")
     {
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns := (editingSelectionNow!=1) ? imgHUDbaseUnit//13 : imgHUDbaseUnit//9

        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//12)
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)

        ViewPortSelectionManageCoords(mainWidth, mainHeight, DestPosX, DestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        If (showSelectionGrid=1)
           pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        whichPen := (EllipseSelectMode>0) ? zPen : pPen
        Gdip_DrawPath(2NDglPG, whichPen, ImgSelPath)
        ; If (EllipseSelectMode=1) || ((showSelectionGrid=1 || imgSelLargerViewPort=1) && (EllipseSelectMode!=1))
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (EllipseSelectMode>0 && AnyWindowOpen!=23)
           Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        thisExterior := (editingSelectionNow=1) ? pBrushE : pBrushF
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1)
           Gdip_FillRectangle(2NDglPG, pBrushF, 0, 0, mainWidth, mainHeight)

        If (liveDrawingBrushTool!=1)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (imgEditPanelOpened!=1 && showSelectionGrid=1 && liveDrawingBrushTool!=1)
           Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)

        Gdip_ResetClip(2NDglPG)
        If (showSelectionGrid=1) || (imgSelLargerViewPort=1 && liveDrawingBrushTool!=1)
        {
           If (imgSelLargerViewPort=1)
           {
              Gdip_DrawRectangle(2NDglPG, whichPen, 1, 1, mainWidth - 1, mainHeight - 1)
              Gdip_DrawRectangle(2NDglPG, pPen, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
           }
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If StrLen(hitTestSelectionPath)>1
        {
           Gdip_DeletePath(hitTestSelectionPath)
           hitTestSelectionPath := ""
        }

        If (FlipImgV=1)
           imgSelPy := mainHeight - imgSelPy - imgSelH
        If (FlipImgH=1)
           imgSelPx := mainWidth - imgSelPx - imgSelW

        whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
        If (imgSelLargerViewPort!=1 && liveDrawingBrushTool!=1)
        {
           hitTestSelectionPath := Gdip_CreatePath()
           Gdip_AddPathRectangle(hitTestSelectionPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
           ; Gdip_RotatePathAtCenter(hitTestSelectionPath, vPselRotation)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        }
        If (liveDrawingBrushTool!=1)
        {
           If (vPselRotation!=0)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
           Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }

        Gdip_DeletePath(ImgSelPath)
     } Else If (operation="live")
     {
        lineThickns := imgHUDbaseUnit/9
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevuDPx, prevuDPy, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        Gdip_SetPenWidth(pPen1d, lineThickns//2 + 1)
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1 && imgSelLargerViewPort!=1)
           Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, mainHeight)

        If (imgSelLargerViewPort!=1)
        {
           ; ToolTip, lol , , , 2
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX1 + prevDestPosX, 0, zImgSelX1 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY1 + prevDestPosY, mainWidth, zImgSelY1 + prevDestPosY)
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX2 + prevDestPosX, 0, zImgSelX2 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY2 + prevDestPosY, mainWidth, zImgSelY2 + prevDestPosY)
           Gdip_DrawRectangle(2NDglPG, pPen1d, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }
        pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        Gdip_ResetClip(2NDglPG)
        If (IMGentirelylargerThanVP!=1) ; image boundaries
           Gdip_DrawRectangle(2NDglPG, pPen4, prevuDPx, prevuDPy, prevResizedVPimgW, prevResizedVPimgH)

        If (imgSelW>125 && imgSelH>125 && minimizeMemUsage!=1 && dotActive!=10 && !InStr(theMsg, "offset"))
        {
           cornersPreview := coreCaptureImgCorners(useGdiBitmap(), 6, 100)
           Gdip_GetImageDimensions(cornersPreview, cImgW, cImgH)
           cX := imgSelPx + imgSelW//2 - cImgW//2
           cY := imgSelPy + imgSelH//2 - cImgH//2
           cX := clampInRange(cX, 0, mainWidth - cImgW)
           cY := clampInRange(cY, 0, mainHeight - cImgH)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, cornersPreview, cX, cY)
           trGdip_DisposeImage(cornersPreview, 1)
        }

        If (minimizeMemUsage!=1)
        {
            If (dotActive=10)
            {
               theMsg := SubStr(theMsg, InStr(theMsg, "rotation"))
               fScale := 0.9
            } Else fScale := 1.3

           infoBoxBMP := drawTextInBox(theMsg, OSDFontName, OSDfntSize//fScale, mainWidth//2, mainHeight//2, OSDtextColor, OSDbgrColor, 1, 1)
           colorBoxH := colorBox ? imgHUDbaseUnit//7 : 1
           Gdip_GetImageDimensions(infoBoxBMP, infoW, infoH)
           If (imgSelPy + imgSelH + 5 < mainHeight - infoH)
           {
              infoPosY := (imgSelPy + imgSelH<5) ? 5 : imgSelPy + imgSelH + 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           } Else
           {
              otherPos := 1
              infoPosY := (imgSelPy - infoH - colorBoxH <20) ? 5 : imgSelPy - infoH - colorBoxH - 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           }
 
           If (dotActive=4 || otherPos=1) && (dotActive!=3)
           {
              infoPosX := imgSelPx  + imgSelW - infoW - 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           } Else
           { 
              infoPosX := (imgSelPx<5) ? 5 : imgSelPx + 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           }
 
           If colorBox
           {
              pBr0 := Gdip_BrushCreateSolid(colorBox)
              Gdip_FillRectangle(2NDglPG, pBr0, infoPosX, infoPosY + infoH, infoW, colorBoxH)
              Gdip_DeleteBrush(pBr0)
           }
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, infoPosX, infoPosY,,,,,,, 0.8)
           infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        }

        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1 || EllipseSelectMode>0)
        {
           whichPen := (EllipseSelectMode>0) ? pPen : zPen
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }

        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        If ((EllipseSelectMode>0 || vPselRotation>0) && AnyWindowOpen!=23)
           Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If (imgSelLargerViewPort!=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        }

        If (dotActive=10)
        {
            ; Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize*2, dotsSize*2)
            Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)

        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
        {
           r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
           livePreviewsImageEditing("live-selection")
        } Else r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
     } Else If (operation="end")
     {
        InfoW := InfoH := ""
        ; Gdip_ResetWorldTransform(2NDglPG)
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        If pBr0
        {
           Gdip_DeleteBrush(pBr0)
           pBr0 := ""
        }

        Gdip_ResetWorldTransform(2NDglPG)
        SetTimer, dummyRefreshImgSelectionWindow, -25
     }

     ; If (AnyWindowOpen=44 || AnyWindowOpen=43 || AnyWindowOpen=26)
     ; {
     ;    Gdip_ResetWorldTransform(2NDglPG)
     ;    ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, DestPosX, DestPosY, dotsSize, outX, outY)
     ;    Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, dotsSize, dotsSize)
     ;    Gdip_DrawRectangle(2NDglPG, pPen1d, outX, outY, dotsSize, dotsSize)
     ; }
}

dummyRefreshImgSelectionWindow() {
     Static prevStatus, loopsOccured := 0
     If (editingSelectionNow=1 && IMGresizingMode=5)
     {
        thisu := 1
        IMGresizingMode := 1
        interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
     }

     ; ToolTip, % "l=" drawingShapeNow "==" editingSelectionNow "==" drawingLiveMode , , , 2
     If (drawingShapeNow!=1 && imgSelX2=-1 && imgSelY2=-1 && editingSelectionNow=1) || (thisu=1)
     {
        dummyTimerDelayiedImageDisplay(25)
        Return
     }

     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     If (drawingShapeNow=1)
        GetMouseCoord2wind(PVhwnd, mX, mY)

     thisState := "a" mX mY mainWidth mainHeight closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2
     If (thisState!=prevStatus) || (drawingShapeNow!=1)
     {
        loopsOccured++
        ; ToolTip, % loopsOccured "==" thisState " -- " A_TickCount , , , 2
        additionalHUDelements(3, mainWidth, mainHeight)
        prevStatus := thisState
     }
}

drawVPpartialIMGsection(brickVPx, brickVPy, brickVPw, brickVPh, DestPosX, DestPosY, newW, newH, whichBitmap, Gu, dpX, dpY, kW, kH, imageAttribs, clrMatrix, pEffect, rImgW, rImgH, thisUSRimgQuality, simpleMode:=0) {
    MouseCoords2Image(brickVPx, brickVPy, 1, DestPosX, DestPosY, newW, newH, brickIMGx, brickIMGy, whichBitmap, 0, rimgW, rimgH)
    MouseCoords2Image(brickVPx + brickVPw, brickVPy + brickVPh, 1, DestPosX, DestPosY, newW, newH, brickIMGxz, brickIMGyz, whichBitmap, 0, rimgW, rimgH)
    brickIMGw := brickIMGxz - brickIMGx
    brickIMGh := brickIMGyz - brickIMGy
    If (simpleMode=1)
       Return trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, brickVPx, brickVPy, brickVPw, brickVPh, brickIMGx, brickIMGy, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)

    ; kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, 0, 0, 1, 0)
    If (brickVPx<dpX)
    {
       brickVPw -= dpX - brickVPx
       brickVPx := dpX
    }

    If (brickVPy<dpY)
    {
       brickVPh -= dpY - brickVPy
       brickVPy := dpY
    }

    If (brickVPw + brickVPx>kW + dpX)
       brickVPw -= brickVPw + brickVPx - (kW + dpX)
    If (brickVPh + brickVPy>kH + dpY)
       brickVPh -= brickVPh + brickVPy - (kH + dpY)

    totalVPsize := Round((brickVPw * brickVPh)/1000000)
    totalIMGsize := Round((brickIMGw * brickIMGh)/1000000)

    If (brickVPw>0 && brickVPh>0) && (brickIMGw>0 && brickIMGh>0)
    {
       thisQuality := (thisUSRimgQuality=1) ? 7 : 5
       kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")
       If (kBitmap && (totalIMGsize + 2>totalVPsize) && imageAttribs)
       {
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, kBitmap, brickVPw, brickVPh, 0, thisQuality, -1)
          If zBitmap
             kBitmap := trGdip_DisposeImage(kBitmap)
       }
       aBmp := zBitmap ? zBitmap : kBitmap
       If (pEffect && aBmp)
          Gdip_BitmapApplyEffect(aBmp, pEffect)
    }

    If (zBitmap || kBitmap)
    {
       If zBitmap
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, zBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickVPw, brickVPh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(zBitmap)
       } Else
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, kBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(kBitmap)
       }
    }
    ; ToolTip, % brickVPx "=" brickVPy "`n" brickVPw "==" brickVPh , , , 2
}

QPV_ShowImgonGui(newW, newH, mainWidth, mainHeight, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, ByRef wasPrevious) {
    Critical, on
    Static IDviewPortCache, PREVtestIDvPcache, prevImgAlphaChn, prevVPcacheIMGid, lastZeitLowQuality, prevDelayu
         , prevVPcachePos, prevVPcacheZoom :=[], prevVPcacheHadpartialFX, prevVPcacheIDfx, prevNewW, prevNewH

    prevLoadedImageIndex := currentFileIndex
    createGDIPcanvas(mainWidth, mainHeight)
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath && alwaysOpenwithFIM!=1)
    {
       mustPlayAnim := 1
       prevVPcacheZoom[1] := 0
       allowVPcacheOptimizations := 0
    } Else
    {
       DestroyGIFuWin()
       gdiSmallSize := determineGDIsmallCacheSize(mainWidth, mainHeight)
       totalNewSize := Round((newW * newH)/1000000, 2)
       If (IMGresizingMode=3 || zoomLevel=1)
          mustGenerate := 0
       Else If isInRange(totalNewSize, 0, gdiSmallSize.Small + 0.09)
          mustGenerate := 2
       Else If isInRange(totalNewSize, gdiSmallSize.Small + 0.08, gdiSmallSize.Screen + 2.1)
          mustGenerate := 1
       Else
          mustGenerate := 0

       If (mustGenerate=1) ; do not resize to screen size if it is already at screen size
          mustGenerate := (gdiSmallSize.Screen + 2.1<gdiSmallSize.Main + 1) || (gdiSmallSize.Screen//3>gdiSmallSize.Main) ? 1 : 0

       If (mustGenerate=1 && minimizeMemUsage=1 && usePrevious=1)
          mustGenerate := 2

       allowVPcacheOptimizations := (userimgQuality=1) ? 1 : 0
    }

    If (minimizeMemUsage=1 && usePrevious!=1 || mustPlayAnim=1 || allowVPcacheOptimizations=0)
       mustGenerate := 0

    mustGoIntoLowQuality := 0
    thisDelayu := (vpImgPanningNow=1 || sizeChanged=1) ? 950 : 400
    If (((A_TickCount - lastZeitLowQuality<thisDelayu + prevDelayu) || (drawModeAzeit>70 && mustPlayAnim=1 && desiredFrameIndex>1) || (usePrevious=1)) && (userimgQuality=1 && usePrevious!=2 && zoomLevel!=1))
       mustGoIntoLowQuality := 1

    If (imgEditPanelOpened=1 || drawingShapeNow=1 || paintBrushToolActive=1) && (userimgQuality=1)
       mustGoIntoLowQuality := 2

    If (mustGoIntoLowQuality=1 && minimizeMemUsage!=1 && mustGenerate=0 && usePrevious!=2 && mustPlayAnim!=1 && imgFxMode>1 && vpImgPanningNow=0)
       forcedSmallSize := mustGenerate := 1

    If (liveDrawingBrushTool=1)
       whichBitmap := gdiBitmap
    Else If (mustGenerate=1) ; window size
       whichBitmap := RescaleBMPtinyVPsize(imgPath, mainWidth, mainHeight)
    Else If (mustGenerate=2) ; for QPV_ShowImgOther() ; very small
       whichBitmap := RescaleBMPtiny(imgPath, mainWidth, mainHeight)
    Else ; original image
       whichBitmap := gdiBitmap

    sizeChanged := (prevNewW!=newW || prevNewH!=newH) ? 1 : 0
    prevNewW := newW
    prevNewH := newH
    ; ToolTip, % "resized cache = " mustGenerate , , , 2
    interfaceThread.ahkassign("canCancelImageLoad", 0)
    startZeit := A_TickCount
    ; ToolTip, % oldZoomLevel "==" zoomLevel , , , 2
    oldZoomLevel := matrix := ""
    prevDrawingMode := 1
    thisVPpanningNow := vpImgPanningNow
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoordsInVP(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    If (StrLen(ViewPortBMPcache)<3 || mustPlayAnim=1)
    {
       thisVPpanningNow := diffuDestPosX := diffuDestPosY := 0
    } Else
    {
       diffuDestPosX := diffIMGdecX ? DestPosX - prevDestPosX : 0   ; has panned on X
       diffuDestPosY := diffIMGdecY ? DestPosY - prevDestPosY : 0   ; has panned on Y
       If (Abs(diffuDestPosY)>mainHeight - 1) || (Abs(diffuDestPosX)>mainWidth - 1)
       {
          thisVPpanningNow := 0
          diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       }
    }

    prevDestPosX := DestPosX
    prevDestPosY := DestPosY
    diffIMGdecX := diffIMGdecY := 0

    ; calculate in viewport coords
    errMargin := (mustPlayAnim=1) ? 0 : 5
    dpX := clampInRange(DestPosX, 0 - errMargin, mainWidth + errMargin*2)
    dpY := clampInRange(DestPosY, 0 - errMargin, mainHeight + errMargin*2)
    kW := clampInRange(newW, 0 - errMargin, mainWidth + errMargin*2)
    kH := clampInRange(newH, 0 - errMargin, mainHeight + errMargin*4)
    ; If (kH<mainHeight)
       ; ToolTip, % "kWH = mWH = newWH`nW=" kW "=" mainWidth "=" newW "`nH=" kH "=" mainHeight "=" newH , , , 2
    errMargin := Ceil(zoomLevel + 1)
    If diffuDestPosX
    {
       ; calculate the new visible rect
       AdpX := (diffuDestPosX<0) ? diffuDestPosX + mainWidth - errMargin : -errMargin*1.5
       AdpX := clampInRange(AdpX, -errMargin*1.5, mainWidth)
       AkW := Abs(diffuDestPosX) + errMargin*2
       AkW := clampInRange(AkW, 0, mainWidth + errMargin*2)
    }

    If diffuDestPosY
    {
       ; calculate the new visible rect
       AdpY := (diffuDestPosY<0) ? diffuDestPosY + mainHeight - errMargin : -errMargin
       AdpY := clampInRange(AdpY, -errMargin, mainHeight)
       AkH := Abs(diffuDestPosY) + errMargin*2
       AkH := clampInRange(AkH, 0, mainHeight + errMargin*2)
    }

    thisUSRimgQuality := userimgQuality
    allowForceIMGload := (thisVPpanningNow=1) ? ForceIMGload : 0
    thisVPcacheIMGid := "a" gdiBitmap currentFileIndex imgPath allowForceIMGload whichBitmap desiredFrameIndex currentUndoLevel UserMemBMP undoLevelsRecorded
    thisVPcachePos := "a" newW newH zoomLevel allowForceIMGload DestPosX DestPosY thisVPcacheIMGid
    prevVPcacheIDfx := decideGDIPimageFX(matrix, imageAttribs, pEffect)
    forceNoFXcaching := (thisVPcachePos=prevVPcachePos && prevVPcacheHadpartialFX=2 && thisVPpanningNow=0) ? 1 : 0
    thisThingMatrix := (IntensityAlphaChannel>1 && imgFxMode>=2 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? 1 : 0
    isAlphaMaskMode := (currIMGdetails.HasAlpha=1 && imgFxMode=8 && ForceNoColorMatrix=0) ? 1 :0 
    thisImgAlphaChn := "a" IntensityAlphaChannel thisThingMatrix isAlphaMaskMode
    Gdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
    ; ToolTip, % forceNoFXcaching "==" vpImgPanningNow , , , 2
    If (thisVPcachePos!=prevVPcachePos || forceNoFXcaching=1 || StrLen(ViewPortBMPcache)<2 || thisImgAlphaChn!=prevImgAlphaChn || liveDrawingBrushTool=1)
    {
       If (mustGoIntoLowQuality>0)
       {
          lastZeitLowQuality := A_TickCount
          lastWasLowQuality := 1
          thisUSRimgQuality := 0
          Gdip_SetInterpolationMode(glPG, 5)
       }
 
       If (thisVPcacheIMGid!=prevVPcacheIMGid && thisVPpanningNow=0 || thisImgAlphaChn!=prevImgAlphaChn)
       {
          ; if the image has changed, no cached section must be used
          forceNoFXcaching := prevVPcacheHadpartialFX := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
          prevVPcacheZoom[1] := 0
       }

       windowScreenMGPX := Ceil((mainWidth * mainHeight)/1000000)
       azW := prevVPcacheZoom[8] , azH := prevVPcacheZoom[9]
       prevIMGrectMGPX := Round((azW * azH)/1000000) - 1
       If (prevIMGrectMGPX<windowScreenMGPX//4.5 || liveDrawingBrushTool=1)        ; no need to slice and dice images when the rect we need is much smaller than the viewport
          hasPanned := thisVPpanningNow := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0

       Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
       If (mustPlayAnim!=1)
       {
          Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          If (isAlphaMaskMode=1)
          {
             Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2)
             Gdip_GraphicsClear(glPG, "0xFF000000")
          }
       } Else Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
       Gdip_ResetClip(glPG)

       ; errMargin := Ceil(zoomLevel*70) + 2
       If (currIMGdetails.HasAlpha=1 && imgFxMode!=8 && mustPlayAnim!=1)
       {
          ; draw image background - if it has an alpha channel
          hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
          Gdi_FillRegion(glHDC, hRgnB, useGdiHatchedBrush("vp"))
          Gdi_DeleteObject(hRgnB)
       }
       ; Gdip_GraphicsClear(glPG, "0xFf" WindowBgrColor)
       ; gp := Gdip_GetImagePixelFormat(ViewPortBMPcache, 2) 
       ; ToolTip, % gp , , , 2
       thisAllowed := (allowVPcacheOptimizations=1 || diffuDestPosX || diffuDestPosY) ? 1 : 0
       thisImageAttribs := (imageAttribs && ((forceNoFXcaching=0 && thisAllowed=1 && currIMGdetails.HasAlpha!=1) || (isAlphaMaskMode=1))) ? imageAttribs : 0
       clrMatrix := (thisImageAttribs=0 && IntensityAlphaChannel>1 && imgFxMode>1 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? IntensityAlphaChannel : 1
       thisPeffect := (pEffect && forceNoFXcaching=0 && thisAllowed=1 && isAlphaMaskMode!=1) ? pEffect : 0
       If diffuDestPosX
       {
          ; resize and draw the new visible rect if panned on the X axis
          errMargin := (diffuDestPosX<0) ? Ceil(zoomLevel) : zoomLevel//2
          errMargin := errMargin//4
          drawVPpartialIMGsection(AdpX - errMargin, dpY, AkW + errMargin, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin*2, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          prevVPcacheZoom[1] := 0
       }

       If diffuDestPosY
       {
          ; resize and draw the new visible rect if panned on the Y axis
          If !AdpX
             AdpX := 0

          tdpX := (diffuDestPosX<0) ? 0 : Round(AkW) + 1
          tdpW := (diffuDestPosX<0) ? tdpX - 2 : Round(AkW) + 2
          drawVPpartialIMGsection(dpX + tdpX, AdpY, kW - tdpW, AkH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          ; ToolTip, % tdpX "=" tdpW "`n" AkW "=" AkH "`n" AdpX "=" AdpY "`n" diffuDestPosX "=" diffuDestPosY, , , 2
          prevVPcacheZoom[1] := 0
       }
       ; ToolTip, % diffuDestPosX "==" diffuDestPosY , , , 2
       If (diffuDestPosX || diffuDestPosY || thisVPpanningNow=1 && allowVPcacheOptimizations=1) && ViewPortBMPcache
       {
          ; draw the cached section on image panning

          ; Gdip_SetClipRect(glPG, diffuDestPosX - errX, diffuDestPosY - errY, mainWidth, mainHeight)
          hasPanned := 1
          thisuAttribs := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisImageAttribs
          thisuAttribs := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? thisuAttribs : 0
          thisuClrMatrix := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? clrMatrix : 1
          thisuEffectu := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisPeffect
          thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisuEffectu && forceNoFXcaching=0) ? thisuEffectu : 0
          ; If (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0)
          ; {
             brickIMGx := (diffuDestPosX<0) ? Abs(diffuDestPosX) : 0
             brickIMGy := (diffuDestPosY<0) ? Abs(diffuDestPosY) : 0
             brickVPx := (diffuDestPosX<0) ? 0 : Abs(diffuDestPosX)
             brickVPy := (diffuDestPosY<0) ? 0 : Abs(diffuDestPosY)
             brickIMGw := mainWidth - Abs(diffuDestPosX)
             brickIMGh := mainHeight - Abs(diffuDestPosY)
             If (brickIMGw && brickIMGh)
                kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, ViewPortBMPcache, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")

             If kBitmap
             {
                If thisuEffectu
                   Gdip_BitmapApplyEffect(kBitmap, thisuEffectu)

                r2 := trGdip_DrawImage(A_ThisFunc, glPG, kBitmap, brickVPx, brickVPy, brickIMGw, brickIMGh, 0, 0, brickIMGw, brickIMGh, thisuClrMatrix, 2, thisuAttribs)
                kBitmap := trGdip_DisposeImage(kBitmap, 1)
             }

             ; r2 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache, diffuDestPosX, diffuDestPosY, mainWidth, mainHeight,,,,, thisuClrMatrix, 2, thisuAttribs)

          If (!diffuDestPosX && !diffuDestPosY)
          {
             Gdip_DisposeEffect(thisPeffect)
             thisImageAttribs := thisPeffect := pEffect := imageAttribs := ""
          }
          ; ToolTip, % r2 "==" diffuDestPosX "==" diffuDestPosY "`n"  brickIMGx "=" brickIMGy "`n" brickIMGw "==" brickIMGh , , , 2
       }

       If (!diffuDestPosX && !diffuDestPosY && hasPanned!=1)
       {
          ; draw and calculate the image visible rect if image was not panned
          zX := prevVPcacheZoom[2] , zY := prevVPcacheZoom[3]
          zW := prevVPcacheZoom[4] , zH := prevVPcacheZoom[5]
          sameNess := (dpX=zX && dpY=zY && zW=kW && zH=kH && prevVPcacheZoom[11]=DestPosX && prevVPcacheZoom[12]=DestPosY) ? 1 : 0
          ; ToolTip, % "l=" sameNess "`n" DestPosX "==" DestPosY "`n" prevVPcacheZoom[11] "==" prevVPcacheZoom[12] , , , 2
          If ((sameNess=1 || prevVPcacheZoom[1]>zoomLevel) && (prevIMGrectMGPX>windowScreenMGPX//2) && IMGresizingMode=4 && StrLen(ViewPortBMPcache)>2 && whichBitmap=gdiBitmap && allowVPcacheOptimizations=1)
          {
             ; on zoom out, reuse viewport cached image
             azX := prevVPcacheZoom[6] , azY := prevVPcacheZoom[7]
             ImageCoords2Window(azX, azY, DestPosX, DestPosY, 0, outXa, outYa, 0, 1)
             ImageCoords2Window(azX + azW, azY + azH, DestPosX, DestPosY, 0, outXb, outYb, 0, 1)
             errMargin := 0 ; Ceil(zoomLevel)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 3)

             thisuAttribs := (prevVPcacheHadpartialFX!=2 && thisImageAttribs && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisImageAttribs : 0
             thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisPeffect && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisPeffect : 0
             If thisuEffectu
             {
                thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
                If thisBMP
                   Gdip_BitmapApplyEffect(thisBMP, thisuEffectu)
             }
             aBmp := StrLen(thisBMP)>2 ? thisBMP : ViewPortBMPcache
             r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, outXa - errMargin, outYa - errMargin, outXb - outXa + errMargin*2, outYb - outYa + errMargin*2, zX, zY, zW, zH, clrMatrix, 2, thisuAttribs)
             thisBMP := trGdip_DisposeImage(thisBMP)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 7)

             If (prevVPcacheZoom[10]=1)
             {
                ; if the image is larger than the viewport, and user zooms out
                ; resize and draw only the newly visible image sections
                mX := 0, mY := 0
                mW := mainWidth, mH := mainHeight

                ; left side
                errMargin := (outXa>0) ? Ceil(zoomLevel) + 4 : 0
                drawVPpartialIMGsection(mX, mY, outXa + errMargin, mH + errMargin*2, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; right side
                errMargin := Ceil(zoomLevel) + 4
                tW := mW - outXb, tH := mH
                tX := mW - tW, tY := mY
                tW := (tW>0) ? tW + errMargin*2 : 0
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tW>0)
                   tX -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; top side
                tW := mW - outXa - (mW - outXb), tH := outYa
                tX := outXa, tY := mY
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; bottom side
                tW := mW - outXa - (mW - outXb)
                tH := mH - outYb
                tX := outXa, tY := outYb
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
             } 

             ; ToolTip,  % zX "==" zY "`n" zW "==" zH "`n" azX "=" azY "`n" azW "=" azH "`n" outXa "==" outYa "`n" outXb "=" outYb , , , 2
          } Else If (thisVPpanningNow=0 || allowVPcacheOptimizations=0)
          {
             ; no cached sections reused
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 3)

             thisModus := (thisPeffect || thisImageAttribs || thisUSRimgQuality=1) ? 0 : 1
             ; ToolTip, % " not cached  = " thisModus , , , 2
             drawVPpartialIMGsection(dpX, dpY, kW, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality, thisModus)
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 7)
          }
       }

       dpX := clampInRange(DestPosX, 0, mainWidth)
       dpY := clampInRange(DestPosY, 0, mainHeight)
       kW := clampInRange(newW, 0, mainWidth)
       kH := clampInRange(newH, 0, mainHeight)
       MouseCoords2Image(dpX, dpY, 0, DestPosX, DestPosY, newW, newH, sfPosX1, sfPosY1, whichBitmap, 0, rImgW, rImgH)
       MouseCoords2Image(dpX + kW, dpY + kH, 0, DestPosX, DestPosY, newW, newH, sfPosX2, sfPosY2, whichBitmap, 0, rImgW, rImgH)
       sfW := sfPosX2 - sfPosX1
       sfH := sfPosY2 - sfPosY1

       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       prevVPcachePos := thisVPcachePos
       prevVPcacheIMGid := thisVPcacheIMGid
       zl := (IMGresizingMode=4 && !AdpX && !AdpY && whichBitmap=gdiBitmap) ? zoomLevel : 0
       prevVPcacheIDfx := thisVPcacheIDfx
       prevVPcacheHadpartialFX := thisImageAttribs ? 2 : 0
       prevImgAlphaChn := thisImgAlphaChn
       prevVPcacheZoom := [zl, dpX, dpY, kW, kH, sfPosX1, sfPosY1, sfW, sfH, IMGlargerViewPort, DestPosX, DestPosY]
       If (thisPeffect && pEffect)
       {
          Gdip_DisposeEffect(pEffect)
          pEffect := ""
       }

       If (thisImageAttribs && imageAttribs)
          imageAttribs := ""

       wasVPcached := 0
    } Else
    {
       ; the entire image visible area is cached, recalculate colour effects if needed
       wasVPcached := 1
    }

    ; ToolTip, % "l=" r2 "=" kBitmap "=" ViewPortBMPcache "=" gdipLastError "=" glHbitmap , , , 2
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) && (usrTextureBGR=1 && gdiAmbientalTexBrush && IMGentirelylargerThanVP!=1) ? 1 : 0
    If (FlipImgV=1 || FlipImgH=1 || pEffect || imageAttribs || wasVPcached=1)
    {
       ; redraw viewport with the activated FX
       If (prevVPcacheHadpartialFX=2 || isAlphaMaskMode=1)
       {
          ; ToolTip, llllllol , , , 2
          imageAttribs := ""
          Gdip_DisposeEffect(pEffect)
          pEffect := ""
       }

       if (imageAttribs || pEffect)
       {
          ; ToolTip, nooooooooo , , , 2
          prevVPcacheHadpartialFX := 0
       }

       If (imageAligned=1 && wasVPcached=0 && (FlipImgV=1 || FlipImgH=1))
       {
          Gdip_SetClipRect(glPG, dpX, dpY, kW, kH)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       ; flipBitmapAccordingToViewPort(kBitmap, 1)
       setMainCanvasTransform(mainWidth, mainHeight)
       If (wasVPcached=1 && confirmTexBGR=0)
       {
          Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
          Gdip_SetClipRect(glPG, dpX, dpY, kW, kH, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       If pEffect
       {
          thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          If thisBMP
             Gdip_BitmapApplyEffect(thisBMP, pEffect, dpX, dpY, kW, kH)

          Gdip_DisposeEffect(pEffect)
       }
       aBmp := StrLen(thisBMP)>2 ? thisBMP : ViewPortBMPcache
          ; r4 := trGdip_DrawImageFX(A_ThisFunc, glPG, ViewPortBMPcache, , , dpX, dpY, kW, kH,, pEffect, imageAttribs)
       r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, dpX, dpY, kW, kH, dpX, dpY, kW, kH,,, imageAttribs)
       thisBMP := trGdip_DisposeImage(thisBMP, 1)
    } Else Gdip_ResetClip(glPG)

    If (confirmTexBGR=1)
    {
       Gdip_ResetClip(glPG)
       hRgnA := Gdi_CreateRectRegion(0, 0, mainWidth, mainHeight)
       dpX := (FlipImgH=1 && imageAligned=1) ? mainWidth - kW : dpX
       dpY := (FlipImgV=1 && imageAligned=1) ? mainHeight - kH : dpY
       hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
       Gdi_CombineRegion(hRgnA, hRgnA, hRgnB, 3)
       Gdi_FillRegion(glHDC, hRgnA, gdiAmbientalTexBrush)
       Gdi_DeleteObject(hRgnA)
       Gdi_DeleteObject(hRgnB)
    }

    ; ToolTip, % z "=" hRgnA "==" gdiAmbientalTexBrush , , , 2
    thisModus := (mustPlayAnim=0 && thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2) ? 2 : 1
    drawHUDelements(thisModus, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)
    If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && slideShowDelay>950 && StrLen(GDIfadeVPcache)>2)
       imageHasFaded := performFadeTransition(imgPath, mustPlayAnim)

    whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
    r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC)
    If (imageHasFaded=1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)

    If (mustPlayAnim=1 && !AnyWindowOpen)
    {
       setGIFframesDelay()
       autoChangeDesiredFrame("start", imgPath)
       SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
    } Else
    {
       autoChangeDesiredFrame("stop")
       If (mustRecordSeenImgs=1 && gdiBMPchanged=1 && !InStr(r, "error"))
          recordSeenIMGdbEntry(imgPath, currentFileIndex)
    }

    totalZeit := A_TickCount - startZeitIMGload
    If (thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2)
    {
       lastWasLowQuality := 1
       If (usePrevious=0)
          lastZeitLowQuality := A_TickCount
       Gdip_SetInterpolationMode(glPG, 7)
       prevDelayu := (vpImgPanningNow=1 || hasPanned=1 || totalZeit>100 && hasPanned=1 || sizeChanged=1 || forcedSmallSize=1) ? 850 : 65
       SetTimer, wrapResizeImageGDIwin, % -prevDelayu
    } Else
    {
       prevDelayu := 50
       lastWasLowQuality := (mustGoIntoLowQuality=2) ? 1 : 0
    }

    ; Gdip_ResetClip(glPG)
    thisZeit := A_TickCount - startZeit
    If (totalZeit<155)
       prevFastDisplay := A_TickCount
    Else If (usePrevious!=2)
       lastZeitLowQuality := A_TickCount

    ; prevFullIMGload := A_TickCount
    LastWasFastDisplay := (totalZeit<150 && usePrevious<2) ? 1 : 0
    drawModeAzeit := A_TickCount - startZeit
    If (hasFullReloaded=1 && imageHasFaded!=1)
    {
       fullLoadZeit := A_TickCount - startZeitIMGload
       fullLoadZeit2 := (fullLoadZeit + drawModeCzeit)//2
       drawModeCzeit := max(fullLoadZeit, fullLoadZeit2)
    }

    ; ToolTip, % fullLoadZeit ", "  thisZeit ", " totalZeit ", " drawModeCzeit "==" prevGDIvpCache ,,,2
    Return r
}

performFadeTransition(imgPath, gifAnim) {
    Static prevImgPath
    If (gifAnim=1 && prevImgPath=imgPath)
       Return 0

    setWindowTitle(pVwinTitle, 1)
    ForceRefreshNowThumbsList()
    tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    ToggleVisibilityWindow("show", hGDIthumbsWin)
    trGdip_DrawImage(A_ThisFunc, glPG, GDIfadeVPcache)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    Loop, 255
    {
        opacity := 255 - A_Index*12
        If (opacity<2)
           Break

        dummyPos := (A_OSVersion!="WIN_7") ? 0 : ""
        r2 := UpdateLayeredWindow(hGDIwin, glHDC, dummyPos, dummyPos, mainWidth, mainHeight, opacity)
        Sleep, 1
    }
    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    trGdip_DisposeImage(tempBMP, 1)
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBGRcolor)
    prevImgPath := imgPath
    Return 1
}

getCaptionStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0xC00000) ? 0 : 1
  Return r
}

getTopMopStyle(hwnd) {
  WinGet, Stylu, ExStyle, ahk_id %hwnd%
  r := (Stylu & 0x8) ? 1 : 0
  Return r
}

updateUIctrl() {
    interfaceThread.ahkassign("editingSelectionNow", editingSelectionNow)
    interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
    interfaceThread.ahkPostFunction("updateUIctrl")
}

coreselectRandomFiles(howMany, a, b) {
   newArrayu := []
   a := clampInRange(a, 1, maxFilesIndex)
   b := clampInRange(b, 1, maxFilesIndex)
   maxu := max(a, b) - min(a, b)
   If (maxu<3)
      Return

   thisHowMany := clampInRange(howMany, 1, maxu)
   Loop
   {
      Random, Randy, %a%, %b%
      newArrayu[Randy] := 1
      If (newArrayu.Count()=thisHowMany)
         Break
   }

   For Key, Value in newArrayu
      resultedFilesList[Key, 2] := 1
}

selectRandomFiles(howMany, replaceAll, modus) {
   If (replaceAll=1)
      dropFilesSelection(1)

   If (modus=1)
   {
      coreselectRandomFiles(howMany, 1, maxFilesIndex)
   } Else
   {
      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      Loop, % Ceil(maxFilesIndex / maxItemsPage)
         coreselectRandomFiles(howMany, (A_Index - 1) * maxItemsPage, A_Index * maxItemsPage)
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   dummyTimerReloadThisPicture(50)
}

PanelSelectRandomFiles() {
   Static a := 1, b := 5, dropListu := "Entire files list`f`fOn every page of thumbnails"

   fakeWinCreator(54, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Select random files: " appTitle, "Please specify how many files to select.", "&Apply|&Cancel", 1, "modify-entry", "Replace pre-existing selection", a, dropListu, "limit6 number", b)

   If InStr(msgResult.btn, "apply")
   {
      a := msgResult.check
      c := msgResult.list
      b := Trimmer(msgResult.edit)
      b := clampInRange(b, 2, maxFilesIndex - 2)
      selectRandomFiles(b, a, c)
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

selectAllFiles(dummy:=0) {
    ; Static selMode := 0
    If (maxFilesIndex<3)
       Return

    selMode := (markedSelectFile < maxFilesIndex || !markedSelectFile) ? 1 : 0
    Loop, % maxFilesIndex
        resultedFilesList[A_Index, 2] := selMode

    lastZeitFileSelect := A_TickCount
    markedSelectFile := (selMode=1) ? maxFilesIndex : 0
    interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
    interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
    SetTimer, mainGdipWinThumbsGrid, -10
}

ToggleEditImgSelection(dummy:=0) {
  Critical, on
  imgPath := getIDimage(currentFileIndex)
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  ; If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (getCaptionStyle(PVhwnd)=1)
     ToggleTitleBaruNow()

  If (editingSelectionNow=1)
     recordSelUndoLevelNow()

  editingSelectionNow := (dummy="show-edit") ? 1 : !editingSelectionNow
  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  updateUIctrl()
  If (ShowAdvToolbar=1)
     decideIconBTNselectShape()
  clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

selectEntireImage(act:=0) {
   imgPath := getIDimage(currentFileIndex)
   If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
      Return

   If (getCaptionStyle(PVhwnd)=1)
      ToggleTitleBaruNow()

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (editingSelectionNow=1)
      recordSelUndoLevelNow()

   vpr := (act="r") ? 0 : vPselRotation
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (ImgSelX2=imgW && imgSelY2=imgH
   && imgSelX1=0 && imgSelY1=0 && editingSelectionNow=1)
   {
      resetImgSelection()
      If (act="rm" && imgEditPanelOpened!=1)
         Return
   } Else
   {
      ImgSelX2 := imgW, imgSelY2 := imgH
      imgSelX1 := imgSelY1 := 0
   }

   vPselRotation := vpr
   editingSelectionNow := 1
   updateUIctrl()
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   ; SetTimer, MouseMoveResponder, -50
   SetTimer, dummyRefreshImgSelectionWindow, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

changeSelectZoom(direction) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If (direction=-1)
    {
       imgSelW -= Round(imgSelW*0.02)
       imgSelH -= Round(imgSelH*0.02)
       imgSelX1 += Round(imgSelW*0.01)
       imgSelY1 += Round(imgSelH*0.01)
    } Else
    {
       imgSelW += Round(imgSelW*0.02)
       imgSelH += Round(imgSelH*0.02)
       imgSelX1 -= Round(imgSelW*0.01)
       imgSelY1 -= Round(imgSelH*0.01)
    }

    imgSelX2 := Round(imgSelX1 + imgSelW)
    imgSelY2 := Round(imgSelY1 + imgSelH)
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustSelectionArea(direction, modus, extraUmphf:=1) {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    factoru := (zoomLevel>2) ? 1 : 2 - zoomLevel
    stepu := Round(2 * (factoru + 0.1))
    If (stepu<2)
       stepu := 2

    stepu := stepu * extraUmphf
    If (FlipImgH=1 && InStr(direction, "1"))
       direction := (direction=1) ? -1 : 1

    If (FlipImgV=1 && InStr(direction, "2"))
       direction := (direction=2) ? -2 : 2

    If (modus=1) ; reposition selection
    {
       If (direction=1)
          imgSelX1 += stepu
       Else If (direction=-1)
          imgSelX1 -= stepu
       Else If (direction=2)
          imgSelY1 += stepu
       Else If (direction=-2)
          imgSelY1 -= stepu
    } Else If (modus=2)
    {
       If (direction=1)
          imgSelX2 += stepu
       Else If (direction=-1)
          imgSelX2 -= stepu
       Else If (direction=2)
          imgSelY2 += stepu
       Else If (direction=-2)
          imgSelY2 -= stepu
    }
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustPrevPointPath(direction, modus, extraUmphf:=1) {
    Static lastInvoked := 1
    If (drawingShapeNow!=1)
       Return

    maxu := (modus=1) ? 1 : customShapePoints.Count()
    cX1 := customShapePoints[maxu, 1]
    cY1 := customShapePoints[maxu, 2]

    stepu := (A_TickCount - lastInvoked<400) ? 1 : 2
    If (direction=1)
       cX1 += stepu
    Else If (direction=-1)
       cX1 -= stepu
    Else If (direction=2)
       cY1 += stepu
    Else If (direction=-2)
       cY1 -= stepu

    customShapePoints[maxu, 1] := cX1
    customShapePoints[maxu, 2] := cY1
    lastZeitFileSelect := A_TickCount
    dummyRefreshImgSelectionWindow()
    lastInvoked := A_TickCount
}

dummyShowSelCoordsInfos() {
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)

    theRatio := "`nRatio: " Round(imgSelW/imgSelH, 2)
    theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "

    theMsg := "X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio
    showTOOLtip(theMsg, 0, 0, vPselRotation/360)
    SetTimer, RemoveTooltip, -500
}

resetImgSelection() {
  If (thumbsDisplaying=1)
     Return

  If (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  imgSelX1 := imgSelY1 := vPselRotation := 0
  imgSelX2 := imgSelY2 := -1
  editingSelectionNow := 0
  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  updateUIctrl()
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

newImgSelection() {
  IMGdecalageX := IMGdecalageY := vPselRotation := 0
  resetImgSelection()
  Sleep, -1
  ToggleEditImgSelection()
}

createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight) {
    If (imgSelX2="C" && imgSelY2="C" && useGdiBitmap())
    {
       GetMouseCoord2wind(PVhwnd, mX, mY)
       MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
       MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
       Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
       defineRelativeSelCoords(rImgW, rImgH)
    } Else If (imgSelX2=-1 && imgSelY2=-1)
    {
       obju := createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, 2)
       imgSelX1 := obju.x1, imgSelY1 := obju.y1
       imgSelX2 := obju.x2, imgSelY2 := obju.y2
    }
}

createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, factor) {
    obju := []
    x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    SelX1 := Round(x1*maxSelX)
    y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    SelY1 := Round(y1*maxSelY)
    SelX2 := Round(SelX1 + (mainWidth/factor)/zoomLevel) + 5
    SelY2 := Round(SelY1 + (mainHeight/factor)/zoomLevel) + 5
    If (SelX2>maxSelX/factor && newW<mainWidth)
       SelX2 := maxSelX//factor
    If (SelY2>maxSelY/factor && newH<mainHeight)
       SelY2 := maxSelY//factor

    obju.x1 := SelX1, obju.y1 := SelY1
    obju.x2 := SelX2, obju.y2 := SelY2
    Return obju  
}

correctActiveSelectionAreaViewPort() {
    Static prevDimensions
    If (imgSelX2=-1 && imgSelY2=-1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    theseDimensions := imgW "," imgH
    If (theseDimensions=prevDimensions)
       Return

    capSelectionRelativeCoords()
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    ; msgbox, % x1 "--" x2 "--" y1 "--" y2
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
    prevDimensions := imgW "," imgH
}

coremakeSquareSelection(imgW, imgH) {
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    avg := (imgSelW+imgSelH)//2
    avg := clampInRange(avg, 5, min(imgW, imgH))
    imgSelX2 := X1 + avg
    imgSelY2 := Y1 + avg
    prcSelX2 := imgSelX2/prevMaxSelX
    If (prcSelX2>1)
       prcSelX2 := 1

    prcSelY2 := imgSelY2/prevMaxSelY
    If (prcSelY2>1)
       prcSelY2 := 1

    Sleep, 1
    If (LimitSelectBoundsImg=1)
       dummyRefreshImgSelectionWindow()
}

makeSquareSelection() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    If (lockSelectionAspectRatio>1)
    {
       lockSelectionAspectRatio := 1
       toggleImgSelectionAspectRatio()
       Return
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    doLoops := (LimitSelectBoundsImg=1) ? 20 : 1
    Loop, % doLoops
       coremakeSquareSelection(imgW, imgH)

    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

resetSelectionRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

   vPselRotation := 0
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

MenuSelRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   VPselRotation := Round(VPselRotation) + 45
   If (VPselRotation>350)
      VPselRotation := 0

   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

flipSelectionWH() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    Gdip_GetRotatedDimensions(imgSelW, imgSelH, 90, rimgSelW, rimgSelH)
    imgSelX2 := X1 + Floor(rimgSelW)
    imgSelY2 := Y1 + Floor(rimgSelH)
    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

ImageCoords2Window(inputX, inputY, DestPosX, DestPosY, dotSize, ByRef outX, ByRef outY, rounding:=1, limitBounds:=0, givenZL:=99) {
   thisZL := givenZL!=99 ? givenZL : zoomLevel
   If (rounding=1)
   {
      outX := Round(inputX*thisZL) + DestPosX - dotSize//2
      outY := Round(inputY*thisZL) + DestPosY - dotSize//2
   } Else
   {
      outX := inputX*thisZL + DestPosX - dotSize/2
      outY := inputY*thisZL + DestPosY - dotSize/2
   }

   If (limitBounds=1)
   {
      GetWinClientSize(mW, mH, PVhwnd, 0)
      outX := clampInRange(outX, 0, mW)
      outY := clampInRange(outY, 0, mH)
   }
}

MouseCoords2Image(mX, mY, limitBounds, dPosX, dPosY, newW, newH, ByRef x, ByRef y, whichBitmap:=0, rounding:=1, imgW:=0, imgH:=0) {
    x1 := (dPosX<0) ? mX + Abs(dPosX) : mX - Abs(dPosX)
    y1 := (dPosY<0) ? mY + Abs(dPosY) : mY - Abs(dPosY)
    If (limitBounds=1)
    {
       x1 := clampInRange(x1, 0, newW)
       y1 := clampInRange(y1, 0, newH)
    }

    whichBitmap := whichBitmap ? whichBitmap : useGdiBitmap()
    If (!imgW || !imgH)
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

    prcx1 := x1/newW
    prcy1 := y1/newH
    x := (rounding=1) ? Round(imgW * prcx1) : imgW * prcx1
    y := (rounding=1) ? Round(imgH * prcy1) : imgH * prcy1
    If (limitBounds=1)
    {
       x := clampInRange(x, 0, imgW)
       y := clampInRange(y, 0, imgH)
    }
    ; ToolTip, % mX " -- " mY "`n" x " -- " y "`n" DestPosX " -- " DestPosY "`n" newW " -- " newH "`n" prcx1 " -- " prcy1, , , 2
}

updateTinyPreviewArea(DestPosX, DestPosY, newW, newH, urgent:=0) {
    Static lastInvoked := 1
    If (tinyPrevAreaCoordX="C" || tinyPrevAreaCoordY="C" || urgent=1)
    {
       GetMouseCoord2wind(hGDIwin, mX, mY)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       mX := (FlipImgH=1) ? mainWidth - mX : mX
       mY := (FlipImgV=1) ? mainHeight - mY : mY
       MouseCoords2Image(mX, mY, 1, DestPosX, DestPosY, newW, newH, x, y)
       tinyPrevAreaCoordX := x, tinyPrevAreaCoordY := y
       If (panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%

       If (urgent=1)
       {
          If (A_TickCount - lastInvoked<90)
             Return

          If (AnyWindowOpen=26)
             livePreviewBlurPanel()
          Else If (AnyWindowOpen=43)
             livePreviewIDedges()
          Else If (AnyWindowOpen=44)
             livePreviewAddNoiser()
          lastInvoked := A_TickCount
       } Else
       {
          If (AnyWindowOpen=26)
             SetTimer, livePreviewBlurPanel, -100
          Else If (AnyWindowOpen=43)
             SetTimer, livePreviewIDedges, -100
          Else If (AnyWindowOpen=44)
             SetTimer, livePreviewAddNoiser, -100
       }
    } 
}

destroyBlacked() {
  If (imageLoading=1)
  {
     SetTimer, destroyBlacked, -50
     Return
  }
  BlackedCreator(1, 1)
}

ToggleVisibilityWindow(actu, winIDu) {
   Static prevState
   thisState := actu "-" winIDu
   If (thisState=prevState)
      Return

   globalWinStates["a" winIDu] := (actu="show") ? 1 : 0
   If (actu="show")
      WinSet, Region,, ahk_id %winIDu%
   Else
      WinSet, Region, 0-0 w1 h1, ahk_id %winIDu%

   prevState := thisState
}

FadeMainWindow() {
   If (A_TickCount - scriptStartTime<5000)
      Return

   whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
   r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 125)
}

GdipCleanMain(modus:=0) {
    If (modus=2)
    {
       ; BlackedCreator(128)
       ; SetTimer, destroyBlacked, -100
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 200)
       Return
    }

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    opacity := (modus=1) ? "0xFF" : "0x50"
    If (modus=4 || modus=5 || modus=6)
    {
       ; BMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       If (modus=4)
       {
          graphPath := Gdip_CreatePath()
          x1 := mainWidth//2 - 45
          x2 := mainWidth//2 + 45
          x3 := mainWidth//2
          y1 := mainHeight//2
          y2 := mainHeight//2
          y3 := mainHeight//2 - 200
          PointsList := x1 "," y1 "|" x2 "," y2 "|" x3 "," y3
          Gdip_AddPathPolygon(graphPath, PointsList)
          Gdip_RotatePathAtCenter(graphPath, vpIMGrotation)
       }

       ; trGdip_DrawImage(A_ThisFunc, glPG, BMPcache)
       If (modus=5 || modus=6)
       {
          If (vpIMGrotation>0)
             zoomu := " @ " vpIMGrotation "°"
          zoomu := Round(zoomLevel * 100) "%" zoomu
          thisInfo := max(oldZoomLevel, zoomLevel) - min(oldZoomLevel, zoomLevel)
          If (modus=6)
             thisInfo := zoomu := "( - )"

          If thisInfo
          {
             thisFntSize := (modus!=6) ? OSDfntSize*1.25 : OSDfntSize*0.75
             infoBoxBMP := drawTextInBox(zoomu, OSDFontName, thisFntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             Gdip_GetImageDimensions(infoBoxBMP, Wi, He)
             If (modus=5)
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2)
             Else
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2,,,,,,, 0.45)
             trGdip_DisposeImage(infoBoxBMP, 1)
          } Else
          {
             imgPath := getIDimage(currentFileIndex)
             zPlitPath(imgPath, 0, OutFileName, OutDir)
             entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
             infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP)
             trGdip_DisposeImage(infoBoxBMP, 1)
             oldZoomLevel := zoomLevel
          }
       }

       If (modus=4)
       {
          thisW := thisH := 250
          Gdip_FillEllipse(glPG, pBrushE, mainWidth//2 - thisW//2, mainHeight//2 - thisH + 30, thisW, thisH)
          Gdip_FillPath(glPG, pBrushD, graphPath)
          Gdip_DeletePath(graphPath)
       }
       thisOpacity := (modus!=6) ? "0x22" : "0x33"
       Random, hu, 6, 8
       Random, ha, 6, 8
       clr := thisOpacity . ha . hu . ha . hu . ha . hu
       widthu := imgHUDbaseUnit//3
       yPen := Gdip_CreatePen(clr, widthu)
       Gdip_DrawRectangle(glPG, yPen, 0, 0, mainWidth, mainHeight)
       Gdip_DeletePen(yPen)
       whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
       r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 225)
       ; trGdip_DisposeImage(BMPcache)
    } Else 
    {
       trGdip_GraphicsClear(A_ThisFunc, glPG, opacity WindowBgrColor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    }
}

clearGivenGDIwin(funcu, Gu, DCu, hwnd) {
    trGdip_GraphicsClear(funcu "<-" A_ThisFunc, Gu, "0x00" WindowBgrColor, 1)
    Return doLayeredWinUpdate(funcu "<-" A_ThisFunc, hwnd, DCu)
}

GetCachableImgFileDetails(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, isFilter:=0) {
     If (!imgPath || !imgIndex)
     {
        fnOutputDebug(A_ThisFunc "() - wow error: " imgIndex " = " imgPath)
        Return
     }

     wasGiven := r := 0
     ; fnOutputDebug(A_ThisFunc "() - no cache: " imgIndex " = " imgPath)
     If !thumbBMP
     {
        ; mainLoadedIMGdetails := []
        If RegExMatch(imgPath, RegExFIMformPtrn)
        {
           r := LoadFimFile(imgPath, 1, 1)
        } Else
        {
           oBitmap := trGdip_CreateBitmapFromFile(imgPath)
           If StrLen(oBitmap)>2
           {
              Gdip_GetImageDimensions(oBitmap, imgW, imgH)
              If (!imgW || !imgH)
              {
                 trGdip_DisposeImage(oBitmap, 1)
                 r := LoadFileWithWIA(imgPath, 1, 1)
              }
              r := 1
              Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
              mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
              mainLoadedIMGdetails.Width := imgW
              mainLoadedIMGdetails.Height := imgH
              mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
              mainLoadedIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(oBitmap, 2)
              trGdip_DisposeImage(oBitmap, 1)
           } Else r := LoadFileWithWIA(imgPath, 1, 1)
        }

        If (r=1)
        {
           If (returnObj=1)
           {
              obju := []
              obju.w := mainLoadedIMGdetails.Width
              obju.h := mainLoadedIMGdetails.Height
              obju.pixFmt := mainLoadedIMGdetails.PixelFormat
              obju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames +1 : 1
              obju.ratio := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              obju.mgpx := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              obju.dpi := mainLoadedIMGdetails.dpi
           } Else If isFilter
           {
              bckpResultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              bckpResultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              bckpResultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              bckpResultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              bckpResultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              bckpResultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              bckpResultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           } Else
           {
              resultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              resultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              resultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              resultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              resultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              resultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              resultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           }
        } Else obju := r := 0

        ; If (returnObj!=1)
        ; {
           fileInfos := GetFileAttributesEx(imgPath)
           If (isFilter && returnObj!=1)
           {
              bckpResultedFilesList[imgIndex, 6] := fileInfos.size
              bckpResultedFilesList[imgIndex, 7] := fileInfos.wTime
              bckpResultedFilesList[imgIndex, 8] := fileInfos.cTime
           } Else If (returnObj!=1)
           {
              resultedFilesList[imgIndex, 6] := fileInfos.size
              resultedFilesList[imgIndex, 7] := fileInfos.wTime
              resultedFilesList[imgIndex, 8] := fileInfos.cTime
           }
        ; }
        ; thumbBMP := LoadBitmapFromFileu(imgPath, 1)
     } Else If StrLen(thumbBMP)>2
     {
        fileInfos := ""
        Gdip_GetImageDimensions(thumbBMP, imgW, imgH)
        Gdip_BitmapGetDPIResolution(thumbBMP, dpix, dpiy)
        If (returnObj=1)
        {
           obju := []
           obju.pixFmt := Gdip_GetImagePixelFormat(thumbBMP, 2)
           obju.dpi := Round((dpix + dpiy)/2)
           Gdip_GetImageDimensions(thumbBMP, imgW, imgH)
           obju.frames := Gdip_GetBitmapFramesCount(thumbBMP) - 1
           obju.w := imgW
           obju.h := imgH
           obju.mgpx := Round((imgW * imgH)/1000000, 2)
           obju.ratio := Round(imgW/imgH, 2)
        } Else If isFilter
        {
           bckpResultedFilesList[imgIndex, 9] := Gdip_GetBitmapFramesCount(thumbBMP)
           bckpResultedFilesList[imgIndex, 13] := imgW
           bckpResultedFilesList[imgIndex, 14] := imgH
           bckpResultedFilesList[imgIndex, 15] := Gdip_GetImagePixelFormat(thumbBMP, 2)
           bckpResultedFilesList[imgIndex, 16] := Round(imgW/imgH, 2)
           bckpResultedFilesList[imgIndex, 17] := Round((imgW * imgH)/1000000, 2)
           bckpResultedFilesList[imgIndex, 22] := Round((dpix + dpiy)/2)
        } Else
        {
           resultedFilesList[imgIndex, 9] := Gdip_GetBitmapFramesCount(thumbBMP)
           resultedFilesList[imgIndex, 13] := imgW
           resultedFilesList[imgIndex, 14] := imgH
           resultedFilesList[imgIndex, 15] := Gdip_GetImagePixelFormat(thumbBMP, 2)
           resultedFilesList[imgIndex, 16] := Round(imgW/imgH, 2)
           resultedFilesList[imgIndex, 17] := Round((imgW * imgH)/1000000, 2)
           resultedFilesList[imgIndex, 22] := Round((dpix + dpiy)/2)
        } 

        r := wasGiven := 1
     }

     If !wasGiven
        trGdip_DisposeImage(thumbBMP, 1)

     If (returnObj=1)
        Return [obju, fileInfos]

     Return r
}

MixARGB(color1, color2, t := 0.5, gamma := 1, inputFormat:="hex") {
   rgamma := 1/gamma
   a1 := (color1 >> 24) & 0xff,  r1 := (color1 >> 16) & 0xff,  g1 := (color1 >>  8) & 0xff,  b1 := (color1 >>  0) & 0xff
   a2 := (color2 >> 24) & 0xff,  r2 := (color2 >> 16) & 0xff,  g2 := (color2 >>  8) & 0xff,  b2 := (color2 >>  0) & 0xff
   
   ga1 := (a1 / 255) ** gamma,   gr1 := (r1 / 255) ** gamma,   gg1 := (g1 / 255) ** gamma,   gb1 := (b1 / 255) ** gamma
   ga2 := (a2 / 255) ** gamma,   gr2 := (r2 / 255) ** gamma,   gg2 := (g2 / 255) ** gamma,   gb2 := (b2 / 255) ** gamma
   
   ma := ga1 * (1-t) + ga2 * t,  mr := gr1 * (1-t) + gr2 * t,  mg := gg1 * (1-t) + gg2 * t,  mb := gb1 * (1-t) + gb2 * t
   mga := 255 * (ma ** rgamma),  mgr := 255 * (mr ** rgamma),  mgg := 255 * (mg ** rgamma),  mgb := 255 * (mb ** rgamma)

   thisColor := Gdip_ToARGB(mga, mgr, mgg, mgb)
   Return thisColor := Format("{1:#x}", thisColor)
}

initInPlaceTextOptions(Gu, boldu, italicu, NoWrap, thisTextAlign, face, theFntSize, txtColor, bgrColor, borderu) {
    If (FontBolded=1)
       txtStyle .= " Bold"
    If (FontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    txtOptions := []
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := txtColor
    txtOptions.Size := theFntSize
    txtOptions.Fontu := face
    txtOptions.borderSize := borderu
    txtOptions.wrapu := NoWrap
    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(Gu, fontQuality)
    Return txtOptions
}

QPV_listThumbnailsGridMode(forceMode, thisGu, thisHDC, thisHwnd) {
    Static zBru := 0
    If !zBru
       zBru := Gdip_BrushCreateSolid("0x66994433")

    If (forceMode!=1)
       setImageLoading()

    startZeit := A_TickCount
    trGdip_GraphicsClear(A_ThisFunc, thisGu, "0xFF" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    columnIndex := -1
    prevMSGdisplay := A_TickCount
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && forceMode!=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("BEGIN TRANSACTION;")

    borderSize := imgHUDbaseUnit//5
    txtOptions := initInPlaceTextOptions(thisGu, FontBolded, 0, 1, 0, OSDFontName, OSDfntSize//1.25, "0xEE" OSDtextColor, "0xFF" WindowBGRcolor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := StrReplace(resultedFilesList[thisFileIndex, 1], "||")
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        ; Gdip_FillRectangle(thisGu, pBrushWinBGR, DestPosX, DestPosY, thumbsW, thumbsH)
        If (StrLen(imgPath)>2 && (thumbsListViewMode=2 || forceMode=1))
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           entireString := fileNamu "`n" folderu "\"
           If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=3)
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           ofileSizu := Round(QPV_FileGetSizeTime(imgPath, "S", thisFileIndex) / 1024) ; kilobytes
           fileSizu := (ofileSizu>1023) ? Round(ofileSizu/1024, 1) " MB" : ofileSizu " KB"
           FileDateM := QPV_FileGetSizeTime(imgPath, "M", thisFileIndex)
           FileDateC := QPV_FileGetSizeTime(imgPath, "C", thisFileIndex)
           Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
           Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
           fileMsg := FileExist(imgPath) ? FileDateC " | " FileDateM " | " fileSizu : "Error gathering data..."
           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If (ofileSizu<2 && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=4)
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           If FileExist(imgPath)
           {
              If !resultedFilesList[thisFileIndex, 9]
              {
                 If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
                    GetCachableImgFileDetails(imgPath, thisFileIndex)

                 If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
                    updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
              }

              Width := resultedFilesList[thisFileIndex, 13]
              Height := resultedFilesList[thisFileIndex, 14]
              CountFrames := (resultedFilesList[thisFileIndex, 9]>1) ? " | " resultedFilesList[thisFileIndex, 9] " frames" : ""
              mgpx := resultedFilesList[thisFileIndex, 17] " MPx | "
              ofileSizu := Round(QPV_FileGetSizeTime(imgPath, "S", thisFileIndex) / 1024) ; kilobytes
              fileSizu := (ofileSizu>1023) ? Round(ofileSizu/1024, 1) " MB" : ofileSizu " KB"
              fileMsg := groupDigits(Width) " x " groupDigits(Height) " | " resultedFilesList[thisFileIndex, 9] CountFrames " | " fileSizu
           } Else fileMsg := "Error gathering data"

           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If ((Width<2 || Height<2 || ofileSizu<2) && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        }

        If StrLen(entireString)>2
        {
           txtOptions.x := (FlipImgH=1) ? DestPosX : DestPosX + borderSize
           txtOptions.y := DestPosY + borderSize
           txtOptions.w := thumbsW - borderSize
           txtOptions.h := thumbsH - borderSize
           drawInPlaceTextInBox(thisGu, entireString, txtOptions)
           ; Gdip_ResetClip(thisGu)
           ; trGdip_DrawImage(A_ThisFunc, thisGu, infoBoxBMP2, DestPosX, DestPosY)
           ; infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           entireString := ""
        } 

        If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
        {
           If retrieveSeenImageDBentry(imgPath, thisFileIndex)
              Gdip_DrawRectangle(thisGu, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (A_TickCount - prevMSGdisplay > 450)
        {
           prevMSGdisplay := A_TickCount
           r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
        } Else If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
    }

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("COMMIT TRANSACTION;")

    ; Gdip_DeleteBrush(zBru)
    r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    ; ToolTip, % mainEndZeit - startZeit , , , 2
    If (forceMode!=1)
    {
       prevFullIndexThumbsUpdate := startIndex
       SetTimer, ResetImgLoadStatus, -15
       prevFullThumbsUpdate := A_TickCount
    } Else prevTryThumbsUpdate := A_TickCount
}

mainGdipWinThumbsGrid(mustDestroyBrushes:=0, simpleMode:=0) {
    Critical, on
    Static pBrush1, pBrush2, pBrush3, pBrush4, pBrush5
         , brushesCreated, prevIndexu

    If (mustDestroyBrushes=1 && brushesCreated=1)
    {
       Gdip_DeleteBrush(pBrush1)
       Gdip_DeleteBrush(pBrush2)
       Gdip_DeleteBrush(pBrush3)
       Gdip_DeleteBrush(pBrush4)
       Gdip_DeleteBrush(pBrush5)
       brushesCreated := 0
       Return
    } Else If (mustDestroyBrushes=1)
       Return

    If (thumbsDisplaying!=1)
       Return

    If (brushesCreated!=1)
    {
       pBrush1 := Gdip_BrushCreateSolid("0x88999999")
       pBrush2 := Gdip_BrushCreateSolid("0x55999999")
       pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
       pBrush4 := Gdip_BrushCreateSolid("0x55404040")
       pBrush5 := Gdip_BrushCreateSolid("0x66334433")
       brushesCreated := 1
    }

    If StrLen(hitTestSelectionPath)>1
    {
       Gdip_DeletePath(hitTestSelectionPath)
       hitTestSelectionPath := ""
    }

    selectorWidth := imgHUDbaseUnit//6
    If (selectorWidth>min(thumbsW, thumbsH)*0.3)
       selectorWidth := Round(min(thumbsW, thumbsH)*0.3)

    If (simpleMode=0)
    {
       Gdip_SetPenWidth(pPen6, selectorWidth)
       Gdip_SetPenWidth(pPen1d, selectorWidth//2)
       Gdip_SetPenWidth(pPen5, selectorWidth//2)
    }

    ; hitTestSelectionPath := Gdip_CreatePath()
    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    currentDupeID := columnIndex := -1
    If (simpleMode=0)
    {
       If testIsDupesList()
       {
          isDupesList := 1
          Gdip_SetPenWidth(pPen2, imgHUDbaseUnit//9 + 1)
          currentDupeID := resultedFilesList[currentFileIndex, 23]
       }
    }

    If (startIndex=prevIndexu)
       prevIndexu := ""

    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPathSelected := resultedFilesList[thisFileIndex, 2]
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        isStringLen := StrLen(imgPath)>5 ? 1 : 0
        If (simpleMode=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           ; Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           If StrLen(imgPath)<4
              Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (simpleMode=1 && isStringLen=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX + 1, DestPosY + 1, thumbsW - 2, thumbsH - 2)
        } Else If (isStringLen=1 && simpleMode=0 && thumbsListViewMode=1)
        {
           If !FileExist(imgPath)
           {
              infoBoxBMP2 := drawTextInBox("! " thisFileIndex, OSDFontName, OSDfntSize//1.5, thumbsW, thumbsH, OSDtextColor, OSDbgrColor, 0, 0)
              trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
              infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           }
        }

        If (simpleMode=0 && isStringLen=1)
        {
           If !FileExist(imgPath)
              Gdip_FillRectangle(2NDglPG, pBrush4, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (imgPathSelected=1)
        {
           countSel++
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrush3, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (resultedFilesList[thisFileIndex, 3]=1 && highlightAlreadySeenImages=1)
           Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           ; Gdip_FillRectangle(2NDglPG, pBrush1, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen6, DestPosX, DestPosY, thumbsW, thumbsH)
           If (isStringLen=1)
           {
              ; Gdip_AddPathRectangle(hitTestSelectionPath, DestPosX, DestPosY, thumbsW, thumbsH)
              zPlitPath(imgPath, mustDrawBoxNow, fileNamu, folderu)
              If FileExist(imgPath)
              {
                 QPV_FileGetSizeTime(imgPath, "R", thisFileIndex)
                 fileSizu := Round(resultedFilesList[thisFileIndex, 6]/1024)
                 fileSizu := (fileSizu>1023) ? Round(fileSizu/1024, 1) " MB" : fileSizu " KB"
                 FileDateM := resultedFilesList[thisFileIndex, 7]
                 Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
                 fileMsg := fileSizu " | " FileDateM
              } Else fileMsg := "File access error"

              delim := (multilineStatusBar=1 || simpleMode>=1) ? "`n" : " | "
              theMsg := groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " | " fileMsg  " | " fileNamu delim folderu "\"
           }
        }

        If (resultedFilesList[thisFileIndex, 5]=1) ; is bookmarked
           Gdip_DrawRectangle(2NDglPG, pPen1d, DestPosX, DestPosY, thumbsW, thumbsH)

        If (currentDupeID=resultedFilesList[thisFileIndex, 23] && simpleMode=0)
        {
           thisu := imgHUDbaseUnit//3.5
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY, DestPosX + thumbsW, DestPosY)
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY + thumbsH, DestPosX + thumbsW, DestPosY + thumbsH)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2, DestPosY + thumbsH//2 - thisu//2, thisu, thisu)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2 + 2, DestPosY + thumbsH//2 - thisu//2 + 2, thisu, thisu)
        }

        If (thisFileIndex=EntryMarkedMoveIndex)
           Gdip_FillRectangle(2NDglPG, pBrushC, DestPosX, DestPosY, thumbsW, thumbsH)
    }

    If (countSel>markedSelectFile && countSel>1 && markedSelectFile>1)
       SetTimer, dummyRecountSelectedFiles, -100

    If (mustDrawBoxNow=1 || simpleMode>=1)
    {
       ; draw top line progress bar
       knobSize := imgHUDbaseUnit//3.5
       Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, Round(mainWidth*(currentFileIndex/maxFilesIndex)), knobSize//2)
    }

    If StrLen(filesFilter)>1
       theMsg := "[F] " theMsg

    prevIndexu := startIndex
    If markedSelectFile
    {
       Gdip_FillRectangle(2NDglPG, pBrush1, 0, 0, mainWidth, imgHUDbaseUnit//5)
       theMsg := groupDigits(markedSelectFile) " selected | " theMsg
    }

    scrollYpos := startIndex/maxFilesIndex
    scrollYpos := Round(mainHeight*scrollYpos)
    thisFileIndex := currentFileIndex
    If (thisFileIndex>maxFilesIndex - maxItemsPage)
       thisFileIndex := maxFilesIndex - maxItemsPage

    scrollHeight := (maxItemsPage/maxFilesIndex)*100
    scrollHeight := Ceil((mainHeight/100)*scrollHeight)
    If (scrollHeight<imgHUDbaseUnit//4.5)
       scrollHeight := imgHUDbaseUnit//4.5

    scrollYpos := clampInRange(scrollYpos, 1, mainHeight - imgHUDbaseUnit//4.5)
    If (StrLen(theMsg)>1)
    {
       bgrTXT := (resultedFilesList[currentFileIndex, 2]=1) ? SubStr(MixARGB("0xFF0188FF", "0xFF" WindowBgrColor, 0.65), 5) : OSDbgrColor
       If isDupesList
       {
          theMSG := "DUPE ID: " currentDupeID " | " theMSG
          mpxu := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " MPx"
          theMSG := StrReplace(theMSG, " MB |", " MB" mpxu " |")
          theMSG := StrReplace(theMSG, " KB |", " KB" mpxu " |")
       }

       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1 && (ToolbarWinH - 3 > mainHeight - ThumbsStatusBarH)) ? ToolbarWinW + 5 : 0
       tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       infoBoxBMP := drawTextInBox(theMsg, OSDFontName, Round(OSDfntSize*0.9), mainWidth, mainHeight//3, OSDtextColor, bgrTXT, 1)
       Gdip_GetImageDimensions(infoBoxBMP, ThumbsStatusBarW, ThumbsStatusBarH)
       statusPosX := -1 + tlbrBonusX
       ThumbsStatusBarW := clampInRange(ThumbsStatusBarW, 1, mainWidth - imgHUDbaseUnit//3.3)
       If tlbrBonusX
          Gdip_FillRectangle(2NDglPG, OSDwinFadedBrushBGR, 0, mainHeight - ThumbsStatusBarH, tlbrBonusX, ThumbsStatusBarH)

       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, statusPosX, mainHeight - ThumbsStatusBarH)
       If (simpleMode=0)
       {
          theMSG2 := theMSG
          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(getIDimage(currentFileIndex), thisSearchString, userSearchWhat)
             {
                Gdip_FillRectangle(2NDglPG, pBrushD, statusPosX, mainHeight - ThumbsStatusBarH, OSDfntSize//2.5+1, ThumbsStatusBarH)
                theMSG2 .= " | Matched search: " thisSearchString 
             }
          }

          If (resultedFilesList[currentFileIndex, 3]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen5, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Image already seen"
          }

          If (resultedFilesList[currentFileIndex, 5]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen1d, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Added to favourites"
          }

          If (bgrTXT!=OSDbgrColor)
             theMSG2 .= " | File selected"

          If StrLen(filesFilter)>1
             theMSG2 .= " | Files list filtered"

          interfaceThread.ahkPostFunction("UpdateUiStatusBar", theMSG2, ThumbsStatusBarH, 0, maxItemsPage)
          trGdip_DisposeImage(infoBoxBMP, 1)

          If (showInfoBoxHUD>0)
             drawinfoBox(mainWidth, mainHeight, 0, 2NDglPG)

          If (showHUDnavIMG=1 && thumbsListViewMode>1)
             VPnavBoxWrapper(mainWidth, mainHeight - ThumbsStatusBarH, 2NDglPG)
       }
    }

    lineThickns := imgHUDbaseUnit//3.25
    If (scrollHeight<mainHeight)
    {
       Gdip_FillRectangle(2NDglPG, pBrushE, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       ; Gdip_AddPathRectangle(hitTestSelectionPath, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - lineThickns + 5, scrollYpos, lineThickns, scrollHeight)
    }

    SetTimer, ResetImgLoadStatus, -25
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    If (toolTipGuiCreated=2)
    {
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       toolTipGuiCreated := 0
    }
}

dummyRecountSelectedFiles() {
   getSelectedFiles(0, 1)
}

EraseThumbsCache(dummy:=0, remCacheOldDays:=0) {
   startZeit := A_TickCount
   showTOOLtip("Emptying thumbnails cache, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countTFilez := countFilez := 0
   Loop, Files, %thumbsCacheFolder%\*.*
   {
      If !(A_LoopFileExt="tiff" || A_LoopFileExt="png" || A_LoopFileExt="jpg")
         Continue

      changeMcursor()
      timeNow := %A_Now%
      EnvSub, timeNow, %A_LoopFileTimeCreated%, Days
      mustRem := (timeNow>remCacheOldDays && dummy="daysITis") ? 1 : 0
      countTFilez++
      If (mustRem=1 || dummy!="daysITis")
      {
         FileDelete, % A_LoopFileFullPath
         If !ErrorLevel
            countFilez++
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Emptying thumbnails cache, please wait`n" countFilez " removed until now.")
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (dummy="daysITis")
   {
      moreInfo := " out of " countTFilez
      friendly := " older than " remCacheOldDays " days"
   }


   If (abandonAll=1)
      showTOOLtip("Operation aborted. Removed " countFilez " cached thumbnails until now")
   Else If (A_TickCount - startZeit>1500) || (dummy="daysITis")
      showTOOLtip("Finished removing " countFilez moreInfo " cached thumbnails" friendly)
   
   remCacheOldDays := 0
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createThumbsFolder() {
    If !FolderExist(thumbsCacheFolder)
    {
       FileCreateDir, %thumbsCacheFolder%
       If ErrorLevel
          Return "error"
    }
}

generateImgThumbCache(imgPath, newImgSize) {
    Critical, on
    r := createThumbsFolder()
    If (r="error")
       Return r

    MD5name := generateThumbName(imgPath)
    file2save := thumbsCacheFolder "\" MD5name ".jpg"
    thisImgFile := FileExist(file2save) ? file2save : imgPath
    whichLIB := (thisImgFile=file2save) ? 1 : 0
    changeMcursor()
    oBitmap := LoadBitmapFromFileu(thisImgFile, 0, whichLIB)
    If !oBitmap
       Return "error"

    Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    calcIMGdimensions(imgW, imgH, newImgSize, newImgSize, ResizedW, ResizedH)
    If (isInRange(imgW, ResizedW - 15, ResizedW + 15) && isInRange(imgH, ResizedH - 15, ResizedH + 15))
    {
       cacheUsed := 1
       ResizedW -= 50
       ResizedH -= 50
    }
    changeMcursor()
    thisImgQuality := (userimgQuality=1) ? 3 : 5
    thumbBMP := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, ResizedW, ResizedH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(oBitmap, 1)
    If (cacheUsed=1)
       Sleep, 1

    changeMcursor()
    r := Gdip_SaveBitmapToFile(thumbBMP, file2save)
    trGdip_DisposeImage(thumbBMP, 1)
}

setPriorityThread(level, handle:="A") {
  If (handle="A" || !handle)
     handle := DllCall("GetCurrentThread")
  Return DllCall("SetThreadPriority", "UPtr", handle, "Int", level)
}

ObjToString(obj) {
  if (!IsObject(obj))
    return obj
  str := "`n{"
  for key, value in obj
    str .= "`n" key ": " ObjToString(value) ","
  return str "`n}"
}

CustomObjToString(obj) {
  if (!IsObject(obj))
    return obj
;  str := "|&|"
  for key, value in obj
    str .= "?" key "|" CustomaObjToString(value)
  return str ; "|&|"
}

CustomaObjToString(obj) {
  if (!IsObject(obj))
    return obj
 ; str := "/&/"
  for key, value in obj
    str .= "<" ObjToString(value) "@"
  return str ; "/&/"
}

StrToObject(stringu) {
  newArrayu := []
  Loop, Parse, stringu, ?
  {
      If !A_LoopField
         Continue
      lineArrayu := StrSplit(A_LoopField, "|<")
      thisIndex := lineArrayu[1]
      preparedOther := StrReplace(lineArrayu[2], "@")
      otherLineArrayu := StrSplit(preparedOther, "<")
      ; MsgBox, % A_LoopField "`n" thisIndex "`n" preparedOther "`n" otherLineArrayu[1] "`n" lineArrayu[2] "`n" A_Index
      Loop, % otherLineArrayu.Count()
          newArrayu[thisIndex, A_Index] := otherLineArrayu[A_Index]
  }
  ; MsgBox, % CustomObjToString(newArrayu)
  Sleep, 50
  Return newArrayu
}

generateAllThumbsNow() {
   Static chunkSize := 1500
   If (thumbsDisplaying!=1 || maxFilesIndex<3 || !CurrentSLD)
      Return

   currentFileIndex := 1
   thumbsListViewMode := 1
   ; If (thumbnailsListMode!=1)
   ;    initAHKhThumbThreads()

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   loopTimes := Ceil(maxFilesIndex/chunkSize)
   startZeit := A_TickCount
   Loop, % loopTimes
   {
      currentFileIndex := (A_Index - 1) * chunkSize
      If !currentFileIndex
         currentFileIndex := 1

      r := QPV_ShowThumbnails("all", A_Index * chunkSize, startZeit)
      If r
         Break
   }
 
   currentFileIndex := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(90)
   SoundBeep , 900, 100
   SetTimer, ResetImgLoadStatus, -25
   RemoveTooltip()
}

QPV_ShowThumbnails(modus:=0, allStarter:=0, allStartZeit:=0) {
    Critical, on

    prevFullThumbsUpdate := A_TickCount
    mainStartZeit := A_TickCount
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    If (modus="all")
    {
       maxItemsW := maxItemsH := allStarter//2 + 1
       maxItemsPage := allStarter + 1
       ; MsgBox, % maxItemsPage
    }

    If (thumbsListViewMode>1)
    {
       QPV_listThumbnailsGridMode(0, glPG, glHDC, hGDIthumbsWin)
       Return
    }

    setImageLoading()
    If (minimizeMemUsage!=1)
    {
       thumbsBitmap := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbsBitmap, 5, 1)
       If !G2
       {
          trGdip_DisposeImage(thumbsBitmap, 1)
          thumbsBitmap := ""
          G2 := glPG
       }
    } Else G2 := glPG

    hasUpdated := rowIndex := imgsListed := 0
    maxImgSize := maxZeit := columnIndex := -1
    fnOutputDebug("Begin show " maxItemsPage " thumbs from index " startIndex)
    setPriorityThread(-2)
    DestroyGIFuWin()
    createThumbsFolder()
    Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, mainWidth + 5, mainHeight + 5)
    prevGUIupdate := A_TickCount
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    imgsListArrayThumbs := []
    lastMsg := imgsMustPaint := imgsNotCached := 0
    doStartLongOpDance()
    Loop, % maxItemsW*maxItemsH*2
    {
        If (modus="all" && maxFilesIndex>100)
        {
           If (determineTerminateOperation()=1)
           {
              fnOutputDebug("ThumbsMode. User abandoned the operation during preparations phase of generate all thumbs.")
              abandonAll := 1
              hasUpdated := 0
              Break
           }
        }

        thisFileIndex := startIndex + A_Index - 1
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH || thisFileIndex>maxFilesIndex) || (modus="all" && thisFileIndex>allStarter)
        {
           ; If (thisFileIndex>maxFilesIndex)
           ;    SoundBeep , 300, 100
           Break
        }

        If (modus="all") && (A_TickCount - lastMsg > 450)
        {
           lastMsg := A_TickCount
           showTOOLtip("Preparing to generate all thumbnails: " thisFileIndex "/" maxFilesIndex, 0, 0, thisFileIndex / maxFilesIndex)
        }

        imgPath := StrReplace(getIDimage(thisFileIndex), "||")
        thisFileDead := (StrLen(imgPath)<5 || !FileRexists(imgPath)) ? 1 : 0
        DestPosX := thumbsW//2 + thumbsW*columnIndex
        DestPosY := thumbsH//2 + thumbsH*rowIndex
        memCached := wasThumbCached := 0
        MD5name := generateThumbName(imgPath, 1, 1)
        isForceRefresh := resultedFilesList[thisFileIndex, 4]
        If (thisFileDead=1)
        {
           imgsListArrayThumbs[thisFileIndex] := ["x", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else If StrLen(imgThumbsCacheIDsArray[MD5name])>0
        {
           memCached := 1
           imgsListArrayThumbs[thisFileIndex] := ["m", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else
        {
           wasThumbCached := (isForceRefresh=1) ? 0 : checkThumbExists(MD5name, imgPath, file2load)
           fnOutputDebug("Thumb = " thisFileIndex  " cached=" wasThumbCached " original file: " imgPath " thumb file: " file2load)
           If (wasThumbCached=1)
              imgsListArrayThumbs[thisFileIndex] := ["f", 0, imgPath, file2load, DestPosX, DestPosY, MD5name]
        }

        If (currentFileIndex=thisFileIndex)
        {
           sizeSquare := thumbsSizeQuality//10
           Gdip_FillRectangle(glPG, pBrushA, DestPosX - sizeSquare//2, DestPosY - sizeSquare//2, sizeSquare, sizeSquare)
        }

        imgsMustPaint++
        If (memCached=1 || wasThumbCached=1 || thisFileDead=1) && (isForceRefresh!=1)
           Continue

        imgsNotCached++
        ; Gdip_FillRectangle(glPG, pBrushE, DestPosX - 10, DestPosY - 10, 20, 20)
        file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
        If (isForceRefresh=1)
        {
           FileDelete, % file2save
           resultedFilesList[thisFileIndex, 4] := 0
        }

        thisW := imgPath ? "w" : "x"
        imgsListArrayThumbs[thisFileIndex] := [thisW, 0, imgPath, file2save, DestPosX, DestPosY, MD5name]
        ;    fnoutputdebug("thumbs prepare " imgPath "|" thisFileIndex "|" MD5name)
    }

   limitCores := realSystemCores + 1
   filesPerCore := imgsNotCached//limitCores
   If (filesPerCore<2 && limitCores>1)
   {
      systemCores := imgsNotCached//2
      filesPerCore := imgsNotCached//systemCores
   } Else systemCores := limitCores

   maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && systemCores>1 && filesPerCore>1 && multiCoreThumbsInitGood=1) ? 1 : 0
   fnOutputDebug("ThumbsMode. Init. doMultiCore:" mustDoMultiCore ", cores:" systemCores ", filesPerCore:" filesPerCore ", imgsNotCached:" imgsNotCached ", imgsMustPaint:" imgsMustPaint)
   mamUsage := GetProcessMemoryUsage(QPVpid)
   systemMemInfo := GlobalMemoryStatusEx()
   thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
   fnOutputDebug("ThumbsMode. Memory usage: " thisMemoryLoad "%")
   If (thisMemoryLoad>70 || isWinXP=1)
   {
      fnOutputDebug("ThumbsMode. Memory usage above 70%. Multi-threaded thumbnails generation deactivated.")
      mustDoMultiCore := 0
   }

   ; how much time in miliseconds can an image take to load and not be cached
   timePerImg := 1550//imgsNotCached
   If (timePerImg<25 || modus="all")
      timePerImg := 25
   Else If (timePerImg>300)
      timePerImg := 300

   timePerImgMultiCore := (modus="all") ? 25 : timePerImg*2 + limitCores*2
   If (timePerImgMultiCore>350)
      timePerImgMultiCore := 350

   If (mustDoMultiCore=1)
   {
      fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. Cores: " limitCores)
      Loop, % limitCores
          thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
      ; fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. DONE")
   } Else limitCores := 1

   thisFileIndex := MD5name := Bindex := hasUpdated := rowIndex := imgsListed := lastMsg := 0
   imgsHavePainted := thisNonCachedImg := coreIndex := threadIndex := memCached := lapsOccured := totalLoops := 0
   lowestGiven := maxIndexu := maxImgSize := maxZeit := columnIndex := -1
   prevCoreEventZeit := A_TickCount - 2
    ; MsgBox, % filesPerCore "--" imgsMustPaint "--" imgsNotCached "--" imgsListArrayThumbs.Length()
   interfaceThread.ahkassign("alterFilesIndex", 0)
   If (abandonAll!=1)
   {
      Loop
      {
          alterFilesIndex := interfaceThread.ahkgetvar.alterFilesIndex
          If (alterFilesIndex>1 && lapsOccured>3)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation by scrolling.")
             userScrolled := 1
             Break
          }

          totalLoops++
          If (determineTerminateOperation()=1)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation.")
             abandonAll := 1
             hasUpdated := 0
             Break
          }

          ; Sleep, 0
          Bindex++
          If (Bindex>imgsMustPaint)
          {
             lapsOccured++
             Bindex := 1
          }

          thisFileIndex := startIndex + Bindex - 1
          If (mustEndLoop=1)
          {
             fnOutputDebug("ThumbsMode. Must end loop = 1. laps " lapsOccured "  -- loops " totalLoops "  -- inner " innerLoops " ")
             hasUpdated := 0
             Break
          }

          If (imgsHavePainted>=imgsMustPaint)
             mustEndLoop := 1

          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          If (cacheType="d")
             Continue

          If (cacheType="x")
          {
             fnOutputDebug("ThumbsMode. Failed to generate. " thisFileIndex " .")
             imgsListArrayThumbs[thisFileIndex, 1] := "d"
             thumbsFailures++
             imgsHavePainted++
             Continue
          }

          If (modus="all") && (A_TickCount - lastMsg > 750)
          {
             allStuffPerc := (startIndex + imgsHavePainted) / maxFilesIndex
             etaTime := ETAinfos(startIndex + imgsHavePainted, maxFilesIndex, allStartZeit)
             If (mustDoMultiCore=1)
                etaTime .= "`nUsing multi-threaded processing"

             showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " etaTime, 0, 0, allStuffPerc)
             lastMsg := A_TickCount
          }

          innerLoops++
          If (cacheType="w" && mustDoMultiCore=1)
          {
             ; Sleep, -1
             thisCoreDoneLine := ""
             thisCoreDoneArr := ""
             whichCoreBusy := imgsListArrayThumbs[thisFileIndex, 2]
             mamUsage := GetProcessMemoryUsage(QPVpid)
             systemMemInfo := GlobalMemoryStatusEx()
             thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
             If (A_TickCount - prevCoreEventZeit>69500 && innerLoops>2 && lapsOccured>2 && totalLoops>2)
             {
                fnOutputDebug("ThumbsMode. Wait time since last new core started ... exceeded.  " thisFileIndex " . Loop. Break. Now. :-) ")
                Break
             }

             If (whichCoreBusy>0)
             {
                hasThumbFailed := thumbThread%whichCoreBusy%.AHKgetvar.operationFailed
                thisCoreDoneLine := thumbThread%whichCoreBusy%.AHKgetvar.resultsList
                thisCoreDoneArr := StrSplit(thisCoreDoneLine, "|")
                waitDataCollect := thumbThread%whichCoreBusy%.AHKgetvar.waitDataCollect
                If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && thisCoreDoneArr[5]=Bindex && waitDataCollect=1)
                {
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "fim"
                   imgsListArrayThumbs[thisCoreDoneArr[3], 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "x"
                   }
                } Else If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && waitDataCollect=1)
                {
                   ; SoundBeep 
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisFileIndex := thisCoreDoneArr[3]
                   Bindex := thisCoreDoneArr[5]
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisFileIndex, 1] := "fim"
                   imgsListArrayThumbs[thisFileIndex, 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisFileIndex, 1] := "x"
                   }
                } Else Continue
             } Else
             {
                coreIndex++
                If (coreIndex>limitCores)
                   coreIndex := 1

                thisCoreDone := thumbThread%coreIndex%.AHKgetvar.operationDone
                waitDataCollect := thumbThread%coreIndex%.AHKgetvar.waitDataCollect
                hasThumbFailed := thumbThread%coreIndex%.AHKgetvar.operationFailed
                If (thisMemoryLoad<90 && thisCoreDone=1 && waitDataCollect<1 && hasThumbFailed=0)
                {
                   prevCoreEventZeit := A_TickCount
                   thumbThread%coreIndex%.ahkassign("operationDone", 0)
                   thumbThread%coreIndex%.ahkassign("waitDataCollect", 0)
                   thisPath := imgsListArrayThumbs[thisFileIndex, 3]
                   thisSavePath := imgsListArrayThumbs[thisFileIndex, 4]
                   thumbThread%coreIndex%.ahkPostFunction("MonoGenerateThumb", thisPath, thisSavePath, enableThumbsCaching, thumbsSizeQuality, timePerImgMultiCore, coreIndex, thisFileIndex, Bindex)
                   imgsListArrayThumbs[thisFileIndex, 2] := coreIndex
                   fnOutputDebug("ThumbsMode. Work assigned to thread. IMG #" thisFileIndex ". Core " coreindex " ")
                   Sleep, 1
                }
                Continue
             }
          }

          ; Sleep, 1
          changeMcursor()
          startZeit := A_TickCount
          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          fnOutputDebug("thumbs inner " thisCoreDoneLine " -- cT" cacheType " --cB" whichCoreBusy  " -- " reallyThreadsDone " -- loops infos " A_Index " -- " innerLoops " -- " lapsOccured " -- " totalLoops " -- " imgsHavePainted " -- " imgsMustPaint)
          fimCached := mustDisposeImgNow := 0
          wasCacheFile := thumbCachable := WasMemCached := hasNowMemCached := 0
          If (cacheType="w")
          {
             If (mustDoMultiCore=1)
                Continue

             ; mustDisposeImgNow := 1
             thumbCachable := 1
             imgsListArrayThumbs[thisFileIndex, 1] := "f"
             file2load := imgsListArrayThumbs[thisFileIndex, 3]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
             GetCachableImgFileDetails(file2load, thisFileIndex, oBitmap, 0, 0)
          } Else If (cacheType="m")
          {
             WasMemCached := 1
             MD5name := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]
          } Else If (cacheType="f")
          {
             wasCacheFile := 1
             file2load := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
          } Else If (cacheType="fim")
          {
             fimCached := 1
             oBitmap := imgsListArrayThumbs[thisFileIndex, 2]
             If !oBitmap
             {
                ; mustDisposeImgNow := 1
                cacheType := "f"
                wasCacheFile := 1
                fimCached := 0
                file2load := imgsListArrayThumbs[thisFileIndex, 4]
                fnOutputDebug("missing thumb cached with a FIM thread " thisFileIndex ". Trying to load file... " file2load)

                If !FileRexists(file2load)
                {
                   wasCacheFile := fimCached := 0
                   thumbCachable := 1
                   file2load := imgsListArrayThumbs[thisFileIndex, 3]
                }
                oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
             }
          }

          extendedLoops++
          imgsListArrayThumbs[thisFileIndex, 1] := "d"
          imgPath := imgsListArrayThumbs[thisFileIndex, 3]
          MD5name := imgsListArrayThumbs[thisFileIndex, 7]
          file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)

          If (!oBitmap || !FileExist(imgPath) || !imgW || !imgH)
          {
             If (WasMemCached=1)
             {
                wasThumbCached := checkThumbExists(MD5name, imgPath, file2load)
                imgsListArrayThumbs[thisFileIndex, 1] := FileExist(file2load) ? "fim" : "w"
                imgsListArrayThumbs[thisFileIndex, 2] := 0
                imgsListArrayThumbs[thisFileIndex, 4] := file2load
             } Else imgsHavePainted++

             fnOutputDebug("broken thumb: mem" WasMemCached " -- w" imgW "-- h" imgH "-- obj bmp id" oBitmap)
             Continue
          } Else imgsHavePainted++

          If (thumbCachable=1)
          {
             fnOutputDebug("must resize GDI object thumbCachable=1. " oBitmap)
             zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thumbsW, thumbsH, 1, thisImgQuality, -1)
             If zBitmap
             {
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. " oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. DONE")
                oBitmap := zBitmap
             }
          } Else If (WasMemCached!=1 && modus!="all")
          {
             fnOutputDebug("must clone GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
             zBitmap := cloneGDItoMem(A_ThisFunc, oBitmap, imgW, imgH)
             If (fimCached!=1)
             {
                fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. DONE")
             }
             If zBitmap
                oBitmap := zBitmap
          }

          thisZeit := A_TickCount - startZeit
          fnOutputDebug("MEM cached thumbs infos: " memCached " -- " hasMemThumbsCached " -- " imgThumbsCacheIDsArray[MD5name] " = " file2save)
          Gdip_GetImageDimensions(oBitmap, newW, newH)
          If (!newW || !newH)
          {
             fnOutputDebug("ThumbsMode. Faulty GDI thumbnail. File Index: " thisFileIndex ". GDI bmp: " oBitmap ".")
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             ; fnOutputDebug("ThumbsMode. Faulty GDI thumbnail object disposed.")
             Continue
          }

          If (WasMemCached!=1 && minimizeMemUsage!=1 && modus!="all")
          {
             hasNowMemCached := 1
             hasMemThumbsCached++ 
             fnOutputDebug("ThumbsMode. Memory cached GDI thumb to be disposed: " imgThumbsCacheArray[hasMemThumbsCached, 1] )
             trGdip_DisposeImage(imgThumbsCacheArray[hasMemThumbsCached, 1], 1)
             ; fnOutputDebug("ThumbsMode. A memory cached GDI thumb to be disposed... DONE")
             imgThumbsCacheIDsArray[imgThumbsCacheArray[hasMemThumbsCached, 2]] := ""
             imgThumbsCacheArray[hasMemThumbsCached] := [oBitmap, MD5name]
             imgThumbsCacheIDsArray[MD5name] := hasMemThumbsCached
             If (hasMemThumbsCached>maxMemThumbsCache)
                hasMemThumbsCached := 0
          }

          calcIMGdimensions(newW, newH, thumbsW, thumbsH, fW, fH)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosX -= (imageAligned!=5) ? thumbsW//2 : fW//2
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          DestPosY -= (imageAligned!=5) ? thumbsH//2 : fH//2
          If (fimCached!=1 && thumbCachable=1 && thisZeit>timePerImg && file2save!=file2load && enableThumbsCaching=1 && WasMemCached!=1)
          && ((newW<imgW//2) || (newH<imgH//2))
          {
             fnOutputDebug("Saving thumb for: " file2load " -- " file2save) 
             zr := Gdip_SaveBitmapToFile(oBitmap, file2save, 94)
             If zr
                fnOutputDebug("ThumbsMode. failed to save thumbnail to file: " file2save)
          }

          If (WasMemCached=1 || hasNowMemCached=1)
          {
             zBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
             oBitmap := zBitmap
          }

          If (bwDithering=1 && imgFxMode=4) || (modus="all")
          {
             nullu := ""
          } Else If (usrColorDepth>1)
          {
             fnOutputDebug("ThumbsMode. Changing thumb color depth... " oBitmap)
             E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
          }

          If (modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. (maybe) flipping thumb... " oBitmap)
             flipBitmapAccordingToViewPort(oBitmap)
             ; changeMcursor()
             hasUpdated := 0
             fnOutputDebug("ThumbsMode. Drawing image thumb: " oBitmap)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, DestPosX, DestPosY, fW - 1, fH - 1)
          }

          fnOutputDebug("ThumbsMode. Disposing GDI thumb after drawing: " oBitmap)
          oBitmap := trGdip_DisposeImage(oBitmap, 1)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && modus!="all")
          {
             If retrieveSeenImageDBentry(imgPath, thisFileIndex)
             {
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             }
          }

          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                Gdip_FillRectangle(G2, pBrushD, DestPosX - thumbsW//2, DestPosY - thumbsH//2, Ceil(thumbsW*0.05), thumbsH - 8)
          }

          If ((A_TickCount - prevGUIupdate>350) && modus!="all")
          {
             fnOutputDebug("ThumbsMode. Redraw the whole window.")
             If (minimizeMemUsage!=1 && thumbsBitmap)
                r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)
             r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
             prevGUIupdate := A_TickCount
             If (minimizeMemUsage!=1)
                hasUpdated := 1
          }
      }
   }

    If (alterFilesIndex>1 && mustEndLoop!=1 && lapsOccured>3 && modus!="all")
    {
       mustReloadThumbsList := 1
       ; mainGdipWinThumbsGrid()
       SetTimer, ForceRefreshNowThumbsList, -350
       ; Return
    } Else If (mustDoMultiCore=1 && mustEndLoop=1 && abandonAll!=1 && modus!="all")
    {
       fnOutputDebug("ThumbsMode after. Clean GDIs mess. Cores: " limitCores)
       Loop, % limitCores
           thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
       ; fnOutputDebug("Thumbnails generator after. Clean GDIs mess. DONE.")
    }

    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    setPriorityThread(0)
    If (modus!="all" && (minimizeMemUsage=1 || !thumbsBitmap))
    {
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    } Else If (modus!="all")
    {
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(thumbsBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If StrLen(zBitmap)>2
          {
             trGdip_DisposeImage(thumbsBitmap, 1)
             thumbsBitmap := zBitmap
          }
          E := Gdip_BitmapSetColorDepth(thumbsBitmap, "BW", 1)
       }
       If !isWinXP
          decideGDIPimageFX(matrix, imageAttribs, pEffect)

       fnOutputDebug("ThumbsMode end. Redraw the whole window.")
       If (pEffect || imageAttribs)
          r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, thumbsBitmap, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
       Else If (hasUpdated=0)
          r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    }

    If (minimizeMemUsage!=1 && thumbsBitmap)
       Gdip_DeleteGraphics(G2)

    trGdip_DisposeImage(thumbsBitmap, 1)
    Gdip_DisposeEffect(pEffect)
    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    prevFullThumbsUpdate := A_TickCount
    If (!userScrolled && !abandonAll && alterFilesIndex!=1)
    {
       mustReloadThumbsList := 0
       prevFullIndexThumbsUpdate := startPageIndex
    }

    If (abandonAll=1)
       lastLongOperationAbort := A_TickCount

    executingCanceableOperation := 0
    If (modus!="all")
       SetTimer, ResetImgLoadStatus, -25

    prevFullThumbsUpdate := A_TickCount
    addJournalEntry(maxItemsPage " thumbnails listed in " SecToHHMMSS((A_TickCount - mainStartZeit)/1000) ".")
    ; ToolTip, % lapsOccured "|"  totalLoops " | " innerLoops " | " extendedLoops " | " imgsNotCached "`nZeit: " A_TickCount - mainStartZeit , , , 2
    r := (r1!=0 || !r2 || abandonAll=1) ? 0 : 1
    If (modus="all")
       Return abandonAll
    Return r
}

cloneGDItoMem(funcu, pBitmap, W:=0, H:=0) {
    If !pBitmap
    {
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: no bitmap given")
       Return
    }

    If (!W || !H)
       Gdip_GetImageDimensions(pBitmap, W, H)

    newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, W, H, coreDesiredPixFmt)
    If newBitmap
    {
       thisImgQuality := 5 ; (userimgQuality=1) ? 3 : 5
       G := trGdip_GraphicsFromImage(A_ThisFunc "() invoked by " funcu, newBitmap, thisImgQuality)
       If G
          E := trGdip_DrawImage(A_ThisFunc "() invoked by " funcu, G, pBitmap, 0, 0, W, H)

       If (E="fail" || !G)
       {
          newBitmap := trGdip_DisposeImage(newBitmap, 1)
          addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create GDI+ graphics object")
       }

       Gdip_DeleteGraphics(G)
    } Else addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create bitmap")
    Return newBitmap
}

calcIMGcoordsInVP(usePrevious, mainWidth, mainHeight, newW, newH, ByRef DestPosX, ByRef DestPosY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevW := 1, prevH := 1, prevZoom := 0

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := Round((mainWidth/2 - newW/2))
    CY := Round((mainHeight/2 - newH/2))

    modus := orderu[imageAligned]
    If (thumbsDisplaying=1)
       modus := 5

    ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0) ; to-do ; make image not appear under the toolbar
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0

    ; ToolTip, % modus "=modus" , , , 2
    If (modus=1)
    {
       DestPosX := tlbrBonusX
       DestPosY := LY
    } Else If (modus=5)
    {
       DestPosX := CX + tlbrBonusX
       DestPosY := CY + tlbrBonusY
    } Else
    {
        DestPosX := tlbrBonusX
        DestPosY := tlbrBonusY
    }

    If (IMGlargerViewPort!=1)
    {
       IMGdecalageY := IMGdecalageY := 1
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (prevZoom!=zoomLevel && prevZoom!=0)
       {
          scaleu := newH/prevH
          IMGdecalageX := Round(IMGdecalageX*scaleu, 1)
          IMGdecalageY := Round(IMGdecalageY*scaleu, 1)
       } 

/*
to-do: allow free panning; this seems to be correct [mostly]
qpv_show img on gui () needs be fixed to work with this

       errMargin := 20
       factoru := (imageAligned=5) ? 2 : 1
       If (imageAligned=5)
       {
          IMGdecalageX := clampInRange(IMGdecalageX, -mainWidth//2 + errMargin, mainWidth//2 - errMargin)
          IMGdecalageY := clampInRange(IMGdecalageY, -mainHeight//2 + errMargin, mainHeight//2 - errMargin)
       } Else
       {
          IMGdecalageX := clampInRange(IMGdecalageX, -newW + errMargin, mainWidth - errMargin)
          IMGdecalageY := clampInRange(IMGdecalageY, -newH + errMargin, mainHeight - errMargin)
       }

       ; IMGdecalageY := clampInRange(IMGdecalageY, 0 - LY//factoru, LY//factoru)
       DestPosX := clampInRange(DestPosX + Round(IMGdecalageX), -newW + errMargin, mainWidth - errMargin)
       DestPosY := clampInRange(DestPosY + Round(IMGdecalageY), -newH + errMargin, mainHeight - errMargin)
ToolTip, % IMGdecalageX "=" IMGdecalageY "`n" DestPosX "=" DestPosY , , , 2
*/

       factoru := (imageAligned=5) ? 2 : 1
       If (IMGdecalageX<LX//factoru) && (newW>mainWidth)
          IMGdecalageX := LX//factoru
       If (IMGdecalageY<LY//factoru) && (newH>mainHeight)
          IMGdecalageY := LY//factoru

       If (newW - 2 > mainWidth)
          DestPosX := DestPosX + Round(IMGdecalageX)
       Else
          IMGdecalageX := 0

       If (newH - 2 > mainHeight)
          DestPosY := DestPosY + Round(IMGdecalageY)
       Else
          IMGdecalageY := 0

       If (DestPosX>0 && newW>mainWidth)
       {
          DestPosX := 0
          IMGdecalageX := (imageAligned=5) ? - LX//2 : 0
       }

       If (DestPosY>0 && newH>mainHeight)
       {
          DestPosY := 0
          IMGdecalageY := (imageAligned=5) ? - LY//2 : 0
       }
    }

    prevW := newW
    prevH := newH
    prevZoom := zoomLevel
}

saveMainWinPos() {
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   mainWinPos := winX "|" winY
   IniAction(1, "mainWinPos", "General")
}

writeMainWindowPos() {
   Static prevInfos
   If determineLClickstate()
   {
      SetTimer, writeMainWindowPos, -300
      Return
   }

   thisWinHwnd := (thumbsDisplaying=1) ? hGDIthumbsWin : hGDIwin
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   WinGetPos,,, winWidth, winHeight, ahk_id %thisWinHwnd%
   WinGetPos,,, win2Width, win2Height, ahk_id %PVhwnd%
   If (winX && winY && winWidth && winHeight)
   {
      mainWinPos := winX "|" winY
      mainWinSize := winWidth "|" winHeight
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
      thisInfos := win2Width "z" win2Height "z" mainWinSize "z" mainWinPos "z" mainWinMaximized
      If (prevInfos!=thisInfos)
      {
         prevInfos := thisInfos
         IniAction(1, "mainWinPos", "General")
         IniAction(1, "mainWinSize", "General")
         IniAction(1, "mainWinMaximized", "General")
         SetTimer, writeMainWindowPos, -300
      }
   }
}

GDIupdaterResize(eventu:=0) {
   If (A_TickCount - scriptStartTime<950)
      Return

   If (drawingShapeNow=1)
      stopDrawingShape()
   If (toolTipGuiCreated=1)
      RemoveTooltip()
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   If (eventu=2)
   {
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      IniAction(1, "mainWinMaximized", "General")
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
   } Else If (eventu!=1)
      SetTimer, writeMainWindowPos, -350

   SetTimer, dummyTimerReloadThisPicture, Off
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   DestroyGIFuWin()
   resetSlideshowTimer(0)
   imgPath := getIDimage(currentFileIndex)
   If StrLen(UserMemBMP)>2
      thisClippyIMG := 1

   If (!imgPath || !maxFilesIndex || PrevGuiSizeEvent=1 || !CurrentSLD) && (thisClippyIMG!=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      If (A_OSVersion="WIN_7" || isWinXP=1)
         GDIwindowsPosCorrections()

      ForceRefreshNowThumbsList()
      If (A_TickCount - lastWinDrag<350)
         Return

      If (thumbsDisplaying=1) && (!maxFilesIndex || !CurrentSLD)
         ToggleVisibilityWindow("hide", hGDIthumbsWin)
      Else
         FadeMainWindow()

      Return
   }

   If (maxFilesIndex>0 && PrevGuiSizeEvent!=1 && thumbsDisplaying!=1) && (A_TickCount - scriptStartTime>500) || (thisClippyIMG=1)
   {
      preventHUDelements := 1
      fnOutputDebug("Resize window event - image view mode. ")
      delayu := (A_TickCount - lastWinDrag<450) ? 450 : 15
      filterDelayiedImageDisplay()
      ; dummyTimerDelayiedImageDisplay(delayu)
      dummyTimerReloadThisPicture(150)
      ForceRefreshNowThumbsList()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      fnOutputDebug("Resize window event - thumbs mode.")
      recalculateThumbsSizes()
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      ; WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight% , ahk_id %hGDIthumbsWin%
      delayu := (A_TickCount - lastWinDrag<450) ? 550 : 325
      SetTimer, RefreshThumbsList, % -delayu
   }

   If (A_OSVersion="WIN_7" || isWinXP=1)
      GDIwindowsPosCorrections()
}

ToggleViewModeTouch() {
   zoomLevel := IMGdecalageY := IMGdecalageX := 1
   If (IMGresizingMode=1)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   } Else
   {
      IMGresizingMode := 0
      ToggleImageSizingMode()
   }
}

JEE_ClientToScreen(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ClientToScreen", "Ptr", hWnd, "Ptr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}


ReloadDynamicFolderz(fileNamu) {
    showTOOLtip("Refreshing files list, please wait")
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    listu := coreLoadDynaFolders(fileNamu)
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue
       Else
          r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }
}

coreLoadDynaFolders(fileNamu) {
    FileRead, tehFileVar, %fileNamu%
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(DF[0-9].*\=[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
          listu .= SubStr(line, InStr(line, "=")+1) "`n"
    }
 
    DynamicFoldersList := StrReplace(DynamicFoldersList, "|hexists|")
    listu .= "`n" Trimmer(DynamicFoldersList) "`n"
    changeMcursor()
    Sort, listu, UD`n
    listu := cleanDynamicFoldersList(listu)
    DynamicFoldersList := listu
    Return listu
}

cleanDynamicFoldersList(listu) {
    newArrayu := []
    thisIndex := 0
    Loop, Parse, listu, `n
    {
       If (!InStr(A_LoopField, "|") && A_LoopField)
       {
          thisIndex++
          newArrayu[thisIndex] := A_LoopField
       }
    }

    For Key, Value in newArrayu
    {
       If !Value
          Continue
       listu := StrReplace(listu, "`n|" Value "\", "`n")
       ; MsgBox, % value
       listu := StrReplace(listu, "`n|" Value, "`n")
       listu := StrReplace(listu, "`n" Value "\", "`n")
    }

    newListu := ""
    Loop, Parse, listu, `n
    {
       If RegExMatch(A_LoopField, "^(.?.\:\\.)")
          newListu .= A_LoopField "`n"
    }

    newArrayu := ""
    Return newListu
}

compareFoldersList(mainFoldersListu, foldersListu) {
   obju := []
   stuffAdded := 0
   Loop, Parse, foldersListu,`n
   {
       linea := Trimmer(A_LoopField)
       If StrLen(linea)<4
          Continue

       skipThis := 0
       Loop, Parse, mainFoldersListu, `n
       {
           line := Trimmer(A_LoopField)
           If StrLen(line)<4
              Continue

           If (line=linea)
              skipThis := 1
       }

       If (skipThis=1)
          Continue

       obju.newEntries .= linea "`n"
   }

   mainFoldersListu .= "`n" obju.newEntries
   Sort, mainFoldersListu, UD`n
   obju.newListu := mainFoldersListu

   Return obju
}

RegenerateEntireList() {
    If (AnyWindowOpen>0)
       BtnCloseWindow()

    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       retrieveFavesAsList()
       Return
    } Else If InStr(CurrentSLD, "\viewed-images-history-")
       Return

    If askAboutFileSave(" and the files list will be reloaded")
       Return

    thisIndex := currentFileIndex
    newStaticFoldersListCache := []
    startOperation := A_TickCount
    showTOOLtip("Preparing to refresh the files list, please wait")
    listu := getDynamicFoldersList()
    If StrLen(listu)<4
    {
       showTOOLtip("WARNING: No list of dynamic folders found")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    mustOpenStartFolder := ""
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    renewCurrentFilesList()
    mustGenerateStaticFolders := (SLDtypeLoaded=3) ? 0 : 1
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    countFolders := ST_Count(listu, "`n") + 1
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       isPipe := InStr(line, "|") ? 1 : 0
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue

       If (SLDtypeLoaded=3)
       {
          getMaxRowIDsqlDB()
          thisR := SQLescapeStr(fileTest, 1)
          thisR := (isPipe=1) ? thisR : thisR "%"
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          activeSQLdb.Exec(SQLstr)
       }

       r := GetFilesList(line "\*", A_Index / countFolders, 0, 0)
       If (SLDtypeLoaded=3)
          maxFilesIndex := getTotalIMGsSQLdb("WHERE isDeleted=0")

       If (r="abandoned")
          Break
    }

    If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, "i)(.\.sldb)$"))
    {
       If (r="abandoned")
       {
          showTOOLtip("Operation aborted: regenerate files list. The files list is unchanged.`nReopening now the database, please wait")
          activeSQLdb.Exec("ROLLBACK TRANSACTION;")
          Sleep, 250
       } Else
       {
          showTOOLtip("Finalising database operations, please wait", 0, 0, 1/5)
          SQLdeleteEntriesMarked()
          showTOOLtip("Finalising database operations, please wait", 0, 0, 2/5)
          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)

          showTOOLtip("Regenerating main folders list, please wait", 0, 0, 3/5)
          recreateDynaFoldersSQLdbList(listu)
          showTOOLtip("Regenerating secondary folders list, please wait", 0, 0, 4/5)
          SQLdbGenerateStaticFolders()
          saveSlideSettingsInDB()
          etaTime := "Elapsed time to regenerate files list, database mode: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
          addJournalEntry(etaTime)
       }

       OpenSLD(CurrentSLD, 1)
       Return
    }

    thisFolder := StrReplace(CurrentSLD, "|")
    If (SLDtypeLoaded=1 && FolderExist(thisFolder))
       watchFolderDetails := getFolderDetails(thisFolder)

    GenerateRandyList()
    SoundBeep, % (r="abandoned" && SLDtypeLoaded!=3) ? 300 : 900, 100
    currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
    If (maxFilesIndex<1)
    {
       friendly := (SLDtypeLoaded=1 && FolderExist(thisFolder)) ? "No image files found in the folder:`n" thisFolder "\`n`n" : "Error refreshing files list... found nothing.`n`n"
       FadeMainWindow()
       msgBoxWrapper(appTitle ": WARNING", friendly "No indexed files found, please open a file or folder.", 0, 0, "info")
       resetMainWin2Welcome()
    } Else dummyTimerDelayiedImageDisplay(50)

    etaTime := "Elapsed time to regenerate files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " groupDigits(maxFilesIndex)
    addJournalEntry(etaTime)
}

throwSQLqueryDBerror(funcu) {
   SetTimer, ResetImgLoadStatus, -150
   showDelayedTooltip("ERROR: " funcu "() failed to query or commit changes the SQL database`n" activeSQLdb.ErrorMsg)
   SoundBeep, 300, 100
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
}

getMaxRowIDsqlDB() {
  SQL := "SELECT max(imgidu) FROM images;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         sqlDBrowID := Rowu[1] + 1 ; Rowu[2] Rowu[3]
  }

  RecordSet.Free()
  Return sqlDBrowID
}

getTotalIMGsSQLdb(morus:="") {
  SQL := "SELECT COUNT(*) FROM images " morus ";"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         value := Rowu[1]
  }

  RecordSet.Free()
  Return value
}

OpenSLDBdataBase(fileNamu, importMode:=0) {
  activeSQLdb.CloseDB()
  activeSQLdb := new SQLiteDB
  If !activeSQLdb.OpenDB(fileNamu)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  startOperation := A_TickCount
  If (MustLoadSLDprefs=1 && importMode!=1)
  {
     SlidesMusicSong := ""
     IniSLDBreadAll() ; read slideshow settings
  } Else If (importMode!=1)
  {
     ; IniSLDBreadAll("prevFilesSortMode")
     ; IniSLDBreadAll("reverseOrderOnSort")
     SlidesMusicSong := ""
     IniSLDBreadAll("autoPlaySlidesAudio")
     IniSLDBreadAll("SlidesMusicSong")
  }

  RecordSet := ""
  sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
  reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
 
  startOperation := A_TickCount
  SQL := "SELECT imgidu, imgfolder||'\'||imgfile FROM images" ; reorder
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  If (importMode!=1)
  {
     SLDcacheFilesList := 1
     resultedFilesList := []
     maxFilesIndex := 0
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1] := Rowu[2]
         If (importMode!=1)
            resultedFilesList[maxFilesIndex, 12] := Rowu[1]
      }
  }

  RecordSet.Free()
  getMaxRowIDsqlDB()
  If (importMode!=1)
     DynamicFoldersList := ""

  SQL := "SELECT imgfolder FROM dynamicfolders;"
  activeSQLdb.GetTable(SQL, RecordSet)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
         DynamicFoldersList .= Rowu[1] "`n"
  }

  RecordSet.Free()
  etaTime := "Elapsed time to open SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
  addJournalEntry(etaTime)
  If (A_TickCount - startOperation>7000) && (maxFilesIndex>2)
     SoundBeep , 900, 100

  If (importMode=1)
     activeSQLdb.CloseDB()

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

SQLdbRetrieveGivenFolder(pathu, isRecursive) {
   rec := (isRecursive=1) ? "%" : ""
   pathu := SQLescapeStr(pathu, 1)
   SQL := "SELECT imgidu, fullPath FROM images WHERE imgfolder LIKE '%" pathu rec "' ESCAPE '>'" ; reorder
   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   Loop, % RecordSet.RowCount
   {
       Rowu := RecordSet.Rows[A_Index]
       If Rowu[2]
       {
          maxFilesIndex++
          resultedFilesList[maxFilesIndex, 1] := Rowu[2]
          If (importMode!=1)
             resultedFilesList[maxFilesIndex, 12] := Rowu[1]
       }
   }
 
   RecordSet.Free()
}

filterDupeResultsByHdist(threshold, mustConvertHash) {
   doStartLongOpDance()
   showTOOLtip("Preparing list for Hamming distance calculations, please wait")
   groupies := []
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
          showTOOLtip("Preparing list for Hamming distance calculations, please wait" etaTime, 0, 0, A_index/maxFilesIndex)
          prevMSGdisplay := A_TickCount
       }

       grpIDu := resultedFilesList[A_Index, 23]
       If grpIDu
       {
          grpIDv%grpIDu%++
          hash := (mustConvertHash=1) ? ConvertBase(2, 16, resultedFilesList[A_Index, 28]) : resultedFilesList[A_Index, 28]
          groupies[grpIDu, grpIDv%grpIDu%] := [A_Index, hash]
          ; groupies[grpID] := [A_Index, hash, grpIDv%grpIDu%]
       }
   }

   If (abandonAll=1)
      Return

   ; prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := groupies.Count()
   rtotalLoops := 0
   For Key, Value in groupies
         rtotalLoops += Value.Count()

   ; MsgBox, % "groups=" totalLoops

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   thisLoop := 0
   For Key, Value in groupies
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(thisLoop, rtotalLoops, startOperation)
          showTOOLtip("Calculating Hamming distance between image pairs`nImage groups: " A_Index " / " groupDigits(totalLoops) etaTime, 0, 0, thisLoop/rtotalLoops)
          prevMSGdisplay := A_TickCount
       }

       thisLoop += value.Count()
       If corefilterDupeResultsByHdist(value, threshold, thisLoop, rtotalLoops)
       {
          abandonAll := 1
          Break
       }
   }

   groupies := []
   If (abandonAll=1)
      Return
 
   showTOOLtip("Finishing the duplicate images filtered list, please wait")
   finalArray := degroupMonoGroups(resultedFilesList)
   maxFilesIndex := finalArray.Count()
   resultedFilesList := []
   resultedFilesList := finalArray.Clone()
   changeHdistLevelCached("kill")
   ResetImgLoadStatus()
}

degroupMonoGroups(givenArray, oldMap:=0) {
   groupies := []
   listuGroupies := "|"
   Loop, % givenArray.Count()
   {
       grpIDu := givenArray[A_Index, 23]
       If grpIDu
       {
          grpIDv%grpIDu%++
          If (grpIDv%grpIDu%>1)
             groupies[grpIDu] := 1

          listuGroupies .= grpIDu "z" A_Index "|"
       }
   }

   listuGroupies := Trimmer(listuGroupies, "|")
   Sort, listuGroupies, D|
   newIndex := 0
   newArrayu := []
   newMappingList := []
   ; ToolTip, % listuGroupies , , , 2
   Loop, Parse, listuGroupies, |
   {
       If A_LoopField
       {
          zu := StrSplit(A_LoopField, "z")
          If groupies[zu[1]]
          {
             newIndex++
             newArrayu[newIndex] := givenArray[zu[2]]
             newArrayu[newIndex, 28] := ""
             If (hasHamDistCached=1 && IsObject(oldMap))
                newMappingList[newIndex] := oldMap[zu[2]]
          }
       }
   }

   If (hasHamDistCached=1 && IsObject(oldMap) && newIndex>1)
   {
      filteredMap2mainList := []
      filteredMap2mainList := newMappingList.Clone()
   }
 
   Return newArrayu
}

calculateNCR2(n){
; n (objects)
; r (sample size) [default r=2]
; formula: n! / ( r! * (n-r)! )

   initQPVmainDLL()
   func2exec := (A_PtrSize=8) ? "dumbcalculateNCR" : "_dumbcalculateNCR@4"
   z := DllCall("qpvmain.dll\" func2exec, "int", n, "uint")
   ; ToolTip, % z "=l=" n , , , 2
   Return z
}

changeHdistLevelCached(modus, newLvlA:=0, newLvlB:=0) {
   Static cachedListu := []
   If (modus="kill")
   {
      hasHamDistCached := 0
      bckpResultedFilesList := []
      filteredMap2mainList := []
      Return -1
   }

   ; mustRenew := (newLvl=userFindDupesHamDistLvl && resultedFilesList.Count() != cachedListu.Count()) ? 1 : 0
   If (bckpResultedFilesList.Count()<3) ; || mustRenew=1)
   {
      hasHamDistCached := 1
      If markedSelectFile
         dropFilesSelection()

      bckpResultedFilesList := []
      bckpResultedFilesList := resultedFilesList.Clone()
      bckpMaxFilesIndex := maxFilesIndex
   }

   newArrayu := []
   thisString := StrReplace(Trimmer(UserHamDistStringFilter), "||", "|")
   thisString := Trimmer(thisString, "|")
   thisFilter := processSearchIndexString(thisString)
   isStrFilter := StrLen(thisString)>1 ? 1 : 0
   newMappingList := []
   Loop, % bckpResultedFilesList.Count()
   {
       grpIDu := bckpResultedFilesList[A_Index, 23]
       imgPath := bckpResultedFilesList[A_Index, 1]
       If (grpIDu && imgPath && !InStr(imgPath, "||"))
       {
          posu := InStr(grpIDu, "_", 0, 0) + 1
          lvl := SubStr(grpIDu, posu)
          If isInRange(lvl, newLvlA, newLvlB)
          {
             If (isStrFilter=1)
             {
                If !coreSearchIndex(imgPath, thisFilter, 1, UserHamDistStringInvert)
                   Continue
             }

             newIndex++
             newArrayu[newIndex] := bckpResultedFilesList[A_Index]
             newArrayu[newIndex, 2] := 0
             newMappingList[newIndex] := A_Index
          }
       }
   }

   If (UserHamDistCacheFilterMonoGroups=1 && newIndex>1)
   {
      hasThis := 1
      hasHamDistCached := 1
      finalArray := degroupMonoGroups(newArrayu, newMappingList)
      newIndex := finalArray.Count()
      newArrayu := []
      newArrayu := finalArray.Clone()
   }

   ; ToolTip, % lvl "=" newLvlA "=" newLvlB "=" newIndex , , , 2
   If (newIndex>1)
   {
      If !hasThis
      {
         filteredMap2mainList := []
         filteredMap2mainList := newMappingList.Clone()
      }

      hasHamDistCached := 1
      ForceRefreshNowThumbsList()
      maxFilesIndex := newIndex
      resultedFilesList := []
      resultedFilesList := newArrayu.Clone()
      lastZeitFileSelect := A_TickCount
      ; dropFilesSelection(1)
      SetTimer, RandomPicture, -350
      Return 1
   } Else Return 0
}

corefilterDupeResultsByHdist(dupeIDsArray, threshold, grupu, totalgroups) {
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   totalLoops := dupeIDsArray.Count()
   VarSetCapacity(HbigArray, 8 * totalLoops + 1)
   VarSetCapacity(IDsbigArray, 8 * totalLoops + 1)
   combinations := (totalLoops>10101) ? totalLoops*15 : calculateNCR2(totalLoops)
   ; one cannot allocate too much memory; so I chose to cap the number of possible dupe results

   VarSetCapacity(resultsArrayA, 4 * combinations + 1) ; Lpair
   VarSetCapacity(resultsArrayB, 4 * combinations + 1) ; Rpair
   VarSetCapacity(resultsArrayC, 4 * combinations + 1) ; hamming distance
   etaTime := ""
   ; ToolTip, % totalLoops "==" combinations , , , 2
   Loop, % totalLoops
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, totalLoops, startOperation)
          showTOOLtip("Hamming distance image duplicates group " groupDigits(grupu) " preparations" etaTime, 0, 0, A_Index/totalLoops)
          prevMSGdisplay := A_TickCount
       }

       offset := (A_Index-1) * 8
       hash := "0x" dupeIDsArray[A_Index, 2]
       NumPut(hash, HbigArray, offset, "uint64")

       offset := (A_Index-1) * 4
       idu := dupeIDsArray[A_Index, 1]
       NumPut(idu, IDsbigArray, offset, "uint")
       ; stringu .= A_Index "|" idu "=" hash "`n"
       ; msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have. " stringu, 4, 0, "question")
       ; If (msgResult="Yes")
       ;    Break
   }

   If (abandonAll=1)
   {
      IDsbigArray := ""
      HbigArray := ""
      resultsArrayA := ""
      resultsArrayB := ""
      resultsArrayC := ""
      Return 1
   }

   If etaTime
      showTOOLtip("Calculating Hamming distance between " groupDigits(totalLoops) " images`n" groupDigits(grupu) " / " groupDigits(totalgroups) "`nPlease wait", 0, 0, grupu/totalgroups)

   ; initQPVmainDLL()
   prevMSGdisplay := A_TickCount
   totalResults := DllCall("qpvmain.dll\hammingDistanceOverArray", "UPtr", &HbigArray, "UPtr", &IDsbigArray, "int", totalLoops, "UPtr", &resultsArrayA, "UPtr", &resultsArrayB, "UPtr", &resultsArrayC, "Int", threshold + 1, "int", combinations - 1)

   If etaTime
      prevMSGdisplay := A_TickCount

   startOperation := A_TickCount
   newArrayu := []
   Loop, % totalResults
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(A_Index, totalResults, startOperation)
          showTOOLtip("Integrating Hamming distance results for specific group of found image duplicates" etaTime, 0, 0, A_Index/totalResults)
          prevMSGdisplay := A_TickCount
       }

       idRa := NumGet(resultsArrayA, 4 * (A_Index - 1), "uInt")
       If (idRa<0)
          idRa := Abs(idRa)

       idRb := NumGet(resultsArrayB, 4 * (A_Index - 1), "uInt")
       If (idRb<0)
          idRb := Abs(idRb)

       idRc := NumGet(resultsArrayC, 4 * (A_Index - 1), "uInt")
       If idRa
          newArrayu[idRa] := idRa "_" idRc
       If idRb
          newArrayu[idRb] := idRa "_" idRc

       ; stringu .= idRa "=" idRb "|" idRc "`n"
   }

   Loop, % totalLoops
   {
       idu := dupeIDsArray[A_Index, 1]
       If !newArrayu[idu]
          resultedFilesList[idu, 23] := ""
       Else
          resultedFilesList[idu, 23] .= "_" newArrayu[idu]
   }

   IDsbigArray := ""
   HbigArray := ""
   resultsArrayA := ""
   resultsArrayB := ""
   resultsArrayC := ""
}

retrieveDupesByProperties(theseCols, fsCmp, SortCriterion:=0) {
   Static prevMode, notFloatsRegEX := "i)(fcreated|fmodified|fsize|imgfile|innerpixelz|outerpixelz|imgwidth|imgheight|imgframes|imgdpi|imgpixfmt|pixelzHash)"

   If SortCriterion
      mode := prevMode

   If RegExMatch(theseCols, "i)(innerpixelz|outerpixelz|pixelzHash)")
      thisNOTnullCol := "innerpixelz"
   Else If RegExMatch(theseCols, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms)")
      thisNOTnullCol := "imgmedian"
   Else If RegExMatch(theseCols, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      thisNOTnullCol := "imgwidth"
   Else If RegExMatch(theseCols, "i)(fcreated|fmodified|fsize)")
      thisNOTnullCol := "fsize"
   Else
      thisNOTnullCol := "imgfile"
   ; ToolTip, % theseCols "`n" thisNOTnullCol , , , 2

   showTOOLtip("Identifying image duplicates, please wait")
   collectSQLFileInfosNow(thisNOTnullCol, 0, 1, 0, 0)
   If InStr(theseCols, "pixelzHash")
      generateSQLimagesExtraHash()

   If (InStr(theseCols, "innerpixelz") && userFindDupesFilterHamDist=1)
   {
      hashuStrA := "innerpixelz"
      If InStr(theseCols, "outerpixelz")
         hashuStrB := "outerpixelz"
      theseCols := StrReplace(theseCols, hashuStrA)
      theseCols := StrReplace(theseCols, hashuStrB)
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
   }

   prevMode := theseCols
   innerTrimL := hashInnerTrimLeft + 1
   innerTrimR := 36 - hashInnerTrimRight - hashInnerTrimLeft
   outerTrimL := hashOuterTrimLeft + 1
   outerTrimR := 28 - hashOuterTrimRight - hashOuterTrimLeft
   simpleTrimL := (hashSimpleTrimLeft=0) ? 1 : hashSimpleTrimLeft + 4
   simpleTrimR := 36 - hashSimpleTrimRight - hashSimpleTrimLeft
   mustDoSubStr := 0
   If ((innerTrimL!=1 || innerTrimR!=36) && InStr(theseCols, "innerp"))
   || ((outerTrimL!=1 || outerTrimR!=28) && InStr(theseCols, "outerp"))
   || ((simpleTrimL!=1 || simpleTrimR!=36)  && InStr(theseCols, "pixelzH"))
      mustDoSubStr := 1

   orderCol := "a.imgmegapix,a.fsize"
   ONlist := "ON ("
   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

      If (InStr(A_LoopField, "inner") && mustDoSubStr=1)
         ONlist .= " AND substr(a.innerpixelz," innerTrimL "," innerTrimR ") = b.innerpixelz"
      Else If (InStr(A_LoopField, "outer") && mustDoSubStr=1)
         ONlist .= " AND substr(a.outerpixelz," outerTrimL "," outerTrimR ") = b.outerpixelz"
      Else If (InStr(A_LoopField, "hash") && mustDoSubStr=1)
         ONlist .= " AND substr(a.pixelzHash," simpleTrimL "," simpleTrimR ") = b.pixelzHash"
      Else If A_LoopField
         ONlist .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " AND Round(a." A_LoopField "," findDupesPrecision ") = b." A_LoopField : " AND a." A_LoopField " = b." A_LoopField
   }

   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

      If (InStr(A_LoopField, "pixelz") && mustDoSubStr=1)
      {
         If InStr(A_LoopField, "inner")
         {
            newCols .= " substr(innerpixelz," innerTrimL "," innerTrimR "),"
            selectuCols .= " substr(innerpixelz," innerTrimL "," innerTrimR ") AS innerpixelz,"
         } Else If InStr(A_LoopField, "outer")
         {
            newCols .= " substr(outerpixelz," outerTrimL "," outerTrimR "),"
            selectuCols .= " substr(outerpixelz," outerTrimL "," outerTrimR ") AS outerpixelz,"
         } Else If InStr(A_LoopField, "hash")
         {
            newCols .= " substr(pixelzHash," simpleTrimL "," simpleTrimR "),"
            selectuCols .= " substr(pixelzHash," simpleTrimL "," simpleTrimR ") AS pixelzHash,"
         }
      } Else
      {
         newCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ")," : A_LoopField ","
         selectuCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ") AS " A_LoopField "," : A_LoopField ","
      }
   }

   mustConvertHash := 0
   theseCols := Trimmer(newCols, ",")
   selectuCols := Trimmer(selectuCols, ",")
   includeHash := (userFindDupesFilterHamDist=1) ? ", entireHush" : ""
   If (userFindDupesFilterHamDist=1 && (hashuStrA || hashuStrB))
   {
      If (hashuStrA && hashuStrB)
         includeHash := ", " hashuStrA "||" hashuStrB
      Else
         includeHash := hashuStrA ? ", " hashuStrA : ", " hashuStrB
      mustConvertHash := 1
   }

   doStartLongOpDance()
   startOperation := A_TickCount
   SQLstr := "SELECT imgidu, fullPath, a.imgmegapix, a.fsize, b.groupID" includeHash " FROM images AS a`n"
   SQLstr .= " JOIN (SELECT " selectuCols ", ROWID AS groupID`n"
   SQLstr .= " FROM images WHERE " thisNOTnullCol " IS NOT NULL`n"
   SQLstr .= " GROUP BY " theseCols " HAVING count(*)>1) AS b`n"
   SQLstr .= StrReplace(ONlist, "ON ( AND ", "ON (") ") "
   SQLstr .= StrLen(SortCriterion)>1 ? "ORDER BY a." SortCriterion ";" : "ORDER BY b.groupID," orderCol ";"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      userFindDupesFilterHamDist := 0
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   addJournalEntry("SQL query used to identify the dupes:`n" SQLstr)
   If (determineTerminateOperation()=1)
      abandonAll := 1

   If (RecordSet.RowCount<2 || abandonAll=1)
   {
      RecordSet.Free()
      If (abandonAll=1)
         showTOOLtip("Operation aborted by user")
      Else
         showTOOLtip("Found no image duplicates")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -150
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   }

   showTOOLtip("Found " groupDigits(RecordSet.RowCount) " duplicate images`nGenerating the files list, please wait")
   If !filesFilter
      bckpMaxFilesIndex := maxFilesIndex   

   backupArray := resultedFilesList.Clone()
   backupFilter := filesFilter
   renewCurrentFilesList()
   groupies := []
   thisString := StrReplace(dupesStringFilter, "||", "|")
   thisString := Trimmer(Trimmer(thisString), "|")
   If thisString
      givenRegEx := processSearchIndexString(thisString)

   Loop, % RecordSet.RowCount
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         If (toBeExcludedIndexes[Rowu[1]]=1)
            Continue

         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1] := Rowu[2]
         resultedFilesList[maxFilesIndex, 12] := Rowu[1]
         resultedFilesList[maxFilesIndex, 17] := Rowu[3]
         resultedFilesList[maxFilesIndex, 6] := Rowu[4]
         resultedFilesList[maxFilesIndex, 23] := Rowu[5]
         If includeHash
            resultedFilesList[maxFilesIndex, 28] := Rowu[6]

         If givenRegEx
         {
            If coreSearchIndex(Rowu[2], givenRegEx, 2, userFilterStringIsNot)
               groupies[Rowu[5]] := 1
         } Else groupies[Rowu[5]] := 1
      }
   }

   thisCounter := 0
   If givenRegEx
   {
      ; filter results
      newArrayu := []
      Loop, % maxFilesIndex
      {
         grpID := resultedFilesList[A_Index, 23]
         If groupies[grpID]
         {
            thisCounter++
            newArrayu[thisCounter] := resultedFilesList[A_Index]
         }
      }
      maxFilesIndex := thisCounter
      resultedFilesList := []
      resultedFilesList := newArrayu.Clone()
   }

   RecordSet.Free()
   If (userFindDupesFilterHamDist=1 && maxFilesIndex>6 && includeHash)
      filterDupeResultsByHdist(userFindDupesHamDistLvl, mustConvertHash)

   userFilterInvertThis := userFilterDoString := 0
   currentFileIndex := userFilterProperty := 1
   filesFilter := "SQL:query:" StrReplace(SubStr(SQLstr, Round(InStr(SQLstr, "JOIN (")), InStr(SQLstr, " ORDER BY") - InStr(SQLstr, "JOIN (")), "`n", A_Space)
   ; ToolTip, % filesFilter , , , 2
   etaTime := "Elapsed time to identify possible image duplicates: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   SetTimer, ResetImgLoadStatus, -100
   If (maxFilesIndex<2)
   {
      maxFilesIndex := backupArray.Count()
      filesFilter := backupFilter
      resultedFilesList := []
      resultedFilesList := backupArray.Clone()
      backupArray := ""
      showTOOLtip("Found no image duplicates after filtering the duplicates list")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   } Else
      SoundBeep , 900, 100

   ; SetTimer, RemoveTooltip, % -msgDisplayTime
   backupArray := ""
   showDelayedTooltip("Found " groupDigits(groupies.Count()) " groups of duplicate images`nTotal images: " groupDigits(maxFilesIndex))
   dummyTimerDelayiedImageDisplay(90)
   ; RandomPicture()
}

keepSelectedDupeInGroup() {
   thisGrpID := resultedFilesList[currentFileIndex, 23]
   If !thisGrpID
      Return

   desiredImgID := currentFileIndex
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (grpID=thisGrpID)
      {
         osel := resultedFilesList[A_Index, 2] ? 1 : 0
         nsel := (desiredImgID!=A_Index) ? 1 : 0
         resultedFilesList[A_Index, 2] := nsel
         If (nsel!=osel && nsel=1)
            markedSelectFile++
         Else If (nsel!=osel && nsel=0)
            markedSelectFile--
      }
   }

   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(90)
}

autoSelectDupesInGroups(mode, givenRegEx:=0) {
   ; dropFilesSelection(1)
   theArray := []
   ; ToolTip, % mode "==" givenRegEx , , , 2
   Loop, % maxFilesIndex
   {
      If (grpID := resultedFilesList[A_Index, 23])
      {
         countPerGroup%grpID%++
         fs := resultedFilesList[A_Index, 6]
         mgpx := Round(resultedFilesList[A_Index, 17], 3)
         If (fs>theArray[grpID, 1, 1])
            theArray[grpID, 1] := [fs, A_Index]
         If (fs<theArray[grpID, 3, 1] || !theArray[grpID, 3, 1])
            theArray[grpID, 3] := [fs, A_Index]

         If (mgpx>theArray[grpID, 2, 1])
            theArray[grpID, 2] := [mgpx, A_Index]
         If (mgpx<theArray[grpID, 4, 1] || !theArray[grpID, 4, 1])
            theArray[grpID, 4] := [mgpx, A_Index]
      }
   }

   indexu := 0
   rescanIDs := []
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (mode=1) ; Automatic
      {
         If (grpID && countPerGroup%grpID%>1)
         {
            mgpxMax := theArray[grpID, 2, 1]
            mgpxMin := theArray[grpID, 4, 1]
            ; Sleep, 100
            ; ToolTip, % mgpxMin "==" mgpxMax , , , 2
            If (mgpxMin=mgpxMax)
            {
               fsMax := Round(theArray[grpID, 1, 1]/1024, 1)
               fsMin := Round(theArray[grpID, 3, 1]/1024, 1)
               If (fsMin=fsMax && givenRegEx)
               {
                  imgPath := resultedFilesList[A_Index, 1]
                  r := coreSearchIndex(imgPath, givenRegEx, 2)
                  resultedFilesList[A_Index, 2] := r ? 0 : 1
                  If !rescanIDs[grpID, 1]
                  {
                     indexu++
                     rescanIDs[grpID, 1] := r ? 0 : 1
                  }

                  If (rescanIDs[grpID, 2]!=0)
                     rescanIDs[grpID, 2] := r ? 0 : 1
               } Else
               {
                  thisIndex := theArray[grpID, 1, 2] ; max file size
                  resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               }
            } Else
            {
               thisIndex := theArray[grpID, 2, 2] ; max res
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
            }
         } Else resultedFilesList[A_Index, 2] := 0
      } Else
      {
         ; mode=3 - megapixels
         ; mode=2 - fsize
         If (grpID && countPerGroup%grpID%>1)
         {
            fsMax := (mode=2) ? Round(theArray[grpID, 1, 1]/1024, 1) : theArray[grpID, 2, 1]
            fsMin := (mode=2) ? Round(theArray[grpID, 3, 1]/1024, 1) : theArray[grpID, 4, 1]
            If (fsMin=fsMax && givenRegEx)
            {
               imgPath := resultedFilesList[A_Index, 1]
               r := coreSearchIndex(imgPath, givenRegEx, 2)
               resultedFilesList[A_Index, 2] := r ? 0 : 1
               If !rescanIDs[grpID, 1]
               {
                  indexu++
                  rescanIDs[grpID, 1] := r ? 0 : 1
               }

               If (rescanIDs[grpID, 2]!=0)
                  rescanIDs[grpID, 2] := r ? 0 : 1
            } Else
            {
               thisIndex := (mode=2) ? theArray[grpID, 1, 2] : theArray[grpID, 2, 2]
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
            }
         } Else resultedFilesList[A_Index, 2] := 0
      }
   }

   If (indexu>0 && givenRegEx)
   {
      ; ensure that all or none are selected within a group after regex
      Loop, % maxFilesIndex
      {
         grpID := resultedFilesList[A_Index, 23]
         If (grpID && countPerGroup%grpID%>1)
         {
            If (rescanIDs[grpID, 1]=0)
            {
               rescanIDs[grpID, 1] := 1
               resultedFilesList[A_Index, 2] := 1
            }

            If (rescanIDs[grpID, 2]=1)
            {
               rescanIDs[grpID, 2] := 0
               resultedFilesList[A_Index, 2] := 0
            }
         }
      }
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)
}

sldGenerateFilesList(readThisFile, doFilesCheck, mustRemQuotes, doOptionals:=1) {
    startZeit := A_TickCount
    FileRead, tehFileVar, %readThisFile%
    If (mustRemQuotes=1)
    {
       tehFileVar := StrReplace(tehFileVar, """-")
       tehFileVar := StrReplace(tehFileVar, """")
    }

    doStartLongOpDance()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If InStr(line, "|")
       {
          RecursiveFlag := "|"
          line := StrReplace(line, "|")
       } Else RecursiveFlag := ""

       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (doFilesCheck=1)
          {
             If !FileRexists(line)
                Continue
          }

          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [line]
          ; tempu .= Chr(34) line Chr(34) "`n"
       } Else If RegExMatch(line, "i)^(.\:\\.)") ; RegExMatch(line, "i)^(.\:\\.).*(\\)$")
       {
          line := Trimmer(line, "\")
          If FolderExist(line)
          {
             DynamicFoldersList .= "`n" RecursiveFlag line "`n"
             GetFilesList(RecursiveFlag line "\*")
          }
       }
    }

    ; Clipboard := tempu
    etaTime := "Elapsed time to open TXT files list: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
    If (A_TickCount - startZeit>7000) && (maxFilesIndex>2 && abandonAll!=1)
       SoundBeep, 900, 100

    executingCanceableOperation := 0
    SetTimer, ResetImgLoadStatus, -50
    If (doOptionals=1)
    {
       If (abandonAll=1)
          showDelayedTooltip("Operation aborted. The files list is now empty.")
       Else If (maxFilesIndex<1)
          showDelayedTooltip("Found no files or folders in the SLD`nThe files list is now empty.")

       If (abandonAll=1 || maxFilesIndex<1)
       {
          lastLongOperationAbort := A_TickCount
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SoundBeep, 300, 100
          Return "abandoned"
       }
    }
}

filterCoreString(stringu, behave, thisFilter, doExactFolderMatch:=0) {
  If (doExactFolderMatch=1)
  {
     zPlitPath(stringu, 1, OutFileName, OutDir)
     r := RegExMatch(OutDir "\", "i)^(" thisFilter "\\)$")
  } Else r := RegExMatch(stringu, "i)(" thisFilter ")")
  z := r ? 1 : 0
  Return (behave=2) ? !z : z
}

GetFilesList(strDir, progressInfo:=0, doCommits:=1, factCheck:=1) {
  showTOOLtip("Loading files from`n" strDir "`n", 0, 0, progressInfo)
  If InStr(strDir, "|")
  {
     doRecursive := ""
     strDir := StrReplace(strDir, "|")
  } Else doRecursive := "R"

  abandonAll := thisCounter := addedNow := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  prevDisplay := A_TickCount
  doStartLongOpDance()
  If (SLDtypeLoaded=3)
  {
     newArrayu := []
     If (doCommits=1)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            thisCounter++
            newArrayu[thisCounter] := [A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" strDir "`nFound " groupDigits(thisCounter) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     Loop, % thisCounter
     {
         If (determineTerminateOperation()=1 || abandonAll=1)
         {
            abandonAll := 1
            Break
         }

         erru := addSQLdbEntry(newArrayu[A_Index, 1], newArrayu[A_Index, 2], newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5], 0, factCheck)
         If !erru
         {
            addedNow++
            If (factCheck!=0)
            {
               maxFilesIndex++
               fullPath := newArrayu[A_Index, 2] "\" newArrayu[A_Index, 1]
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5]]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, thisCounter, startOperation)
            showTOOLtip("Inserting records into the database for`n" strDir etaTime, 0, 0, A_Index / thisCounter)
            prevMSGdisplay := A_TickCount
         }

     }

     If (doCommits=1)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           throwSQLqueryDBerror(A_ThisFunc)
     }
  } Else
  {
     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            If (SLDtypeLoaded=3) ; SQLite database 
               erru := addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)

            If !erru
            {
               addedNow++
               maxFilesIndex++
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               If (SLDtypeLoaded=3)
                  resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" strDir "`nFound " groupDigits(addedNow) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
  }

  currentFilesListModified := 1
  executingCanceableOperation := 0
  SetTimer, ResetImgLoadStatus, -50
  If (abandonAll=1)
  {
     showTOOLtip("Files list loading aborted")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "abandoned"
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return loadedFirst
}

getIDimage(imgID) {
    Return resultedFilesList[imgID, 1]
}

IDshowImage(imgID, opentehFile:=0) {
    Static prevIMGid, prevImgPath, lastInvoked := 1
    imgPath := getIDimage(imgID)
    If StrLen(imgPath)<4
    {
       addJournalEntry("Index entry error: incorrect file path:`n" imgPath " [ " imgID " ]")
       If (A_TickCount - lastInvoked>1050)
          SoundBeep, 300, 90
       lastInvoked := A_TickCount
       Return 0
    }

    isPipe := InStr(imgPath, "||")
    imgPath := StrReplace(imgPath, "||")
    If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath) || StrLen(UserMemBMP)>2 || thumbsDisplaying=1)
       ignoreFileCheck := 1

    If (ignoreFileCheck!=1 && skipDeadFiles=1)
    {
       If (!FileRexists(imgPath) && opentehFile!=250 && imgPath!=prevImgPath)
       {
          If (autoRemDeadEntry=1 && imgID=currentFileIndex)
             remCurrentEntry(1)
          Return 0
       }
    }

    If (AnyWindowOpen!=10 && resetImageViewOnChange=1 && thumbsDisplaying!=1)
    {
       newIMGid := generateThumbName(imgPath, 1)
       If (prevIMGid!=newIMGid)
       {
          prevIMGid := newIMGid
          usrColorDepth := imgFxMode := 1
          vpIMGrotation := FlipImgH := FlipImgV := 0
       }
    }

    prevImgPath := (opentehFile=0 || opentehFile=2) ? imgPath : 0
    If (opentehFile=2)
       ShowTheImage(imgPath, 2)  ; prevent down-scaled display
    Else If (opentehFile=3)
       ShowTheImage(imgPath, 2, 1)  ; force image reload
    Else
       ShowTheImage(imgPath)
    Return 1
}

PreventKeyPressBeep() {
   IfEqual,A_Gui,1,Return 0 ; prevent keystrokes for GUI 1 only
}

doSuspendu(act) {
  If (act=1)
     Suspend, On
  Else
     Suspend, Off
}

trimArray(arr) {
; Hash O(n) - function by errorseven from:
; https://stackoverflow.com/questions/46432447/how-do-i-remove-duplicates-from-an-autohotkey-array
    hash := {}
    newArr := []
    thisCounter := 0
    For k, v in arr
    {
        z := "z" StringToASC(v)
        If (hash[z]!=1)
        {
           thisCounter++
           hash[z] := 1
           newArr[thisCounter] := v
        }
    }
    Return newArr
}

ReverseListNow() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (askAboutFileSave(" and the files list will be reversed") || maxFilesIndex<3)
       Return

    showTOOLtip("Reversing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := reverseArray(resultedFilesList)
    If StrLen(filesFilter)>1
       filteredMap2mainList := reverseArray(filteredMap2mainList)

    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    CurrentSLD := backCurrentSLD
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

RandomizeListNow() {
    If StrLen(filesFilter)>1
    {
       msgResult := msgBoxWrapper(appTitle ": Randomize files list", "You currently have a files list filter applied. To randomize the list, it will be deactivated.", 4, 0, "question")
       If InStr(msgResult, "yes")
       {
          markedSelectFile := 0
          showTOOLtip("Deactivating the files list filter, please wait")
          remFilesListFilter("simple")
          Sleep, 10
          RemoveTooltip()
       } Else Return
    }

    If askAboutFileSave(" and the files list will be randomized")
       Return

    showTOOLtip("Randomizing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := Random_ShuffleArray(resultedFilesList)
    CurrentSLD := backCurrentSLD
    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

Random_ShuffleArray(Array) {
; function from "Facade Functional Programming Suite"
; by Shambles, from https://github.com/Shambles-Dev/AutoHotkey-Facade
; modified by Marius Șucan
; This is the Fisher–Yates shuffle algorithm.

    Result := Array.Clone()
    maxArray := Array.Count()
    Loop, % maxArray - 1
    {
        Random, J, % A_Index, % maxArray
        Temp            := Result[A_Index]
        Result[A_Index] := Result[J]
        Result[J]       := Temp
    }

    Return Result
}

reverseArray(a) {
; function inspired by RHCP from https://autohotkey.com/board/topic/97722-some-array-functions/

    aStorage := []
    maxIndexu := a.Count()
    Loop, % maxIndexu
        aStorage[A_Index] := a[maxIndexu - A_Index + 1]

    Return aStorage
}

coreResizeIMG(imgPath, newW, newH, file2save, goFX, toClippy, rotateAngle, soloMode:=1, imgW:=0, imgH:=0, batchMode:=0) {
    Static rr := "error"
    If (soloMode=1)
    {
       oBitmap := LoadBitmapFromFileu(imgPath)
       If StrLen(oBitmap)>2
       {
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)
          rawFmt := Gdip_GetImageRawFormat(oBitmap)
          If (rawFmt="JPEG")
             RotateBMP2exifOrientation(oBitmap)

          If (!newW || !newH)
             mustDoRotateCoord := 1

          If !newW
             newW := imgW
          If !newH
             newH := imgH
          If (rotateAngle>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1 && mustDoRotateCoord=1)
             Gdip_GetRotatedDimensions(newW, newH, rotateAngle, newW, newH)
       } Else Return rr
    } Else oBitmap := soloMode

    If !oBitmap
       Return rr

    If (ResizeApplyEffects=1 || goFX=1)
    {
       mustDoBw := (bwDithering=1 && imgFxMode=4) ? 1 : 0
       If (imgFxMode=3 && toClippy!=1)
          AdaptiveImgLight(oBitmap, imgPath, 1, 1)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
    }

    ; to-do - if pargb - always??
    oPixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (toClippy=1)
       oPixFmt := (currIMGdetails.HasAlpha=1) ? "32-PARGB" : "24-RGB"

    brushRequired := !InStr(oPixFmt, "argb") ? 1 : 0
    pixFmt := (must24bits=1) ? "0x21808" : "0x26200A"     ; 24-RGB  //  32-ARGB
    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    If (editingSelectionNow=1 && ResizeCropAfterRotation=1 && ResizeWithCrop=1 && rotateAngle>0)
    {
       oBitmap := coreRotateBMP(oBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    }

    If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1 && soloMode=1)
       calcRelativeSelCoords(oBitmap, imgW, imgH)

    If (editingSelectionNow=1 && (goFX=1 || ResizeWithCrop=1))
    {
       calcImgSelection2bmp(0, imgW, imgH, newW, newH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       imgSelW := Round(imgW), imgSelH := Round(imgH)
       imgSelPx := 0, imgSelPy := 0

       zImgSelW := Round(newW), zImgSelH := Round(newH)
       zImgSelPx := 0, zImgSelPy := 0
    }

    thumbBMP := trGdip_CreateBitmap(A_ThisFunc, zImgSelW, zImgSelH, pixFmt)
    If warnUserFatalBitmapError(thumbBMP, A_ThisFunc)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Gdip_DisposeEffect(pEffect)
       Return rr
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbBMP, thisImgQuality, 4, 2)
    If !G2
    {
       trGdip_DisposeImage(oBitmap, 1)
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DisposeEffect(pEffect)
       Return rr
    }

    If (brushRequired=1) || (!RegExMatch(file2save, saveAlphaTypesRegEX) && toClippy!=1)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0xFf" WindowBgrColor)
       ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, imgW + 4, imgH + 4)

    If (goFX=1 || ResizeApplyEffects=1)
    {
       setMainCanvasTransform(zImgSelW, zImgSelH, G2)
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(oBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If zBitmap
          {
             trGdip_DisposeImage(oBitmap, 1)
             oBitmap := zBitmap
          }

          E := Gdip_BitmapSetColorDepth(oBitmap, "BW", 1)
       } Else If (usrColorDepth>1)
          E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
 
       If pEffect
          Gdip_BitmapApplyEffect(oBitmap, pEffect)
    }

    changeMcursor()
    E := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, 0, 0, zImgSelW, zImgSelH, imgSelPx, imgSelPy, imgSelW, imgSelH,, 2, imageAttribs)
    trGdip_DisposeImage(oBitmap, 1)
    If (E="fail")
    {
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DeleteGraphics(G2)
       Gdip_DisposeEffect(pEffect)
       Return rr
    }

    Sleep, 0
    If (editingSelectionNow=1 && ResizeCropAfterRotation=0 && ResizeWithCrop=1 && rotateAngle>0) || (rotateAngle>0 && editingSelectionNow!=1) || (rotateAngle>0 && ResizeWithCrop!=1)
       thumbBMP := coreRotateBMP(thumbBMP, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)

    If (toClippy!=1 && FileExist(file2save))
       Try FileSetAttrib, -R, %file2save%

    Sleep, 0
    changeMcursor()
    If StrLen(thumbBMP)>3
    {
       If (toClippy=1)
       {
          hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, thumbBMP)
          r := hBitmap ? Gdip_SetBitmapToClipboard(thumbBMP, hBitmap) : addJournalEntry("get_last_err")
       } Else
          r := Gdip_SaveBitmapToFile(thumbBMP, file2save, userJpegQuality)

       If (toClippy!=1) && (r=-2 || r=-1)
          r := SaveFIMfile(file2save, thumbBMP)
    } Else r := "err"

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeEffect(pEffect)
    trGdip_DisposeImage(thumbBMP, 1)
    Return r
}

coreRotateBMP(whichBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}

    confirmSimpleRotation := (rotateAngle=0 || rotateAngle=90 || rotateAngle=180 || rotateAngle=270) ? 1 : 0
    If (confirmSimpleRotation=1)
    {
       imgFoperation := (rotateAngle=90) ? 1 : 0
       imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
       imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
       ; If (goFX=1 || ResizeApplyEffects=1)
       ;    imgFoperation := imgOrientOpt["i" imgFoperation FlipImgH FlipImgV]
       If (imgFoperation>0)
          Gdip_ImageRotateFlip(whichBitmap, imgFoperation)
       thumbBMP := whichBitmap
    } Else
    {
       whichBrush := (brushRequired=1) ? pBrushWinBGR : ""
       zBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, rotateAngle, whichBrush, thisImgQuality, pixFmt)
       If StrLen(zBitmap)>2
       {
          trGdip_DisposeImage(whichBitmap, 1)
          thumbBMP := zBitmap
       } Else thumbBMP := zBitmap
       ; If (goFX=1 || ResizeApplyEffects=1) && (ResizeCropAfterRotation=1)
       ;    flipBitmapAccordingToViewPort(thumbBMP, 1)
    }
    Return thumbBMP
}

flipBitmapAccordingToViewPort(whichBitmap, ignoreThis:=0) {
   imgOp := (FlipImgH=1) ? 4 : 0
   imgOp := (FlipImgV=1) ? 6 : imgOp
   imgOp := (FlipImgV=1 && FlipImgH=1) || (vpIMGrotation=180 && ignoreThis=0) ? 2 : imgOp
   If (imgOp>0 && whichBitmap)
      Gdip_ImageRotateFlip(whichBitmap, imgOp)
   Return whichBitmap
}

calcImgSelection2bmp(boundLess, imgW, imgH, newW, newH, ByRef imgSelPx, ByRef imgSelPy, ByRef imgSelW, ByRef imgSelH, ByRef zImgSelPx, ByRef zImgSelPy, ByRef zImgSelW, ByRef zImgSelH, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, usePrevious:=0, givenRotation:=0, givenCoords:=0) {
   If (usePrevious=1)
   {
      nImgSelX1 := min(prevImgSelX1, prevImgSelX2)
      nImgSelY1 := min(prevImgSelY1, prevImgSelY2)
      nImgSelX2 := max(prevImgSelX1, prevImgSelX2)
      nImgSelY2 := max(prevImgSelY1, prevImgSelY2)
   } Else
   {
      nImgSelX1 := min(imgSelX1, imgSelX2)
      nImgSelY1 := min(imgSelY1, imgSelY2)
      nImgSelX2 := max(imgSelX1, imgSelX2)
      nImgSelY2 := max(imgSelY1, imgSelY2)
   }

   If InStr(givenCoords, "|")
   {
      givenCoordsObj := StrSplit(givenCoords, "|")
      nImgSelX1 := min(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY1 := min(givenCoordsObj[2], givenCoordsObj[4])
      nImgSelX2 := max(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY2 := max(givenCoordsObj[2], givenCoordsObj[4])
   }

   If (boundLess=-1)
   {
      initialboundLess := boundLess
      boundLess := (A_PtrSize=4) ? 0 : 1
   }

   If (boundLess!=1)
   {
      If (nImgSelX1<0)
         nImgSelX1 := 0
      If (nImgSelY1<0)
         nImgSelY1 := 0

      If (nImgSelX2>imgW)
         nImgSelX2 := imgW
      If (nImgSelY2>imgH)
         nImgSelY2 := imgH
   }

   imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   imgSelPx := min(nImgSelX1, nImgSelX2)
   imgSelPy := min(nImgSelY1, nImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(imgSelW, imgSelH, givenRotation, rimgSelW, rimgSelH)
      imgSelPx := imgSelPx - (rimgSelW - imgSelW)//2
      imgSelPy := imgSelPy - (rimgSelH - imgSelH)//2
      imgSelW := rimgSelW
      imgSelH := rimgSelH
      If (imgSelPx<1)
         imgSelPx := 0
      If (imgSelPy<1)
         imgSelPy := 0
      If (imgSelPx + imgSelW>imgW)
         imgSelW := imgW - imgSelPx
      If (imgSelPy + imgSelH>imgH)
         imgSelH := imgH - imgSelPy
   }

   If (imgSelW<2)
   {
      imgSelW := 2
      imgSelPx := (imgSelPx>=2) ? imgSelPx - 2 : 0
      nImgSelX2 := imgSelPx + imgSelW
   }

   If (imgSelH<2)
   {
      imgSelH := 2
      imgSelPy := (imgSelPy>=2) ? imgSelPy - 2 : 0
      nImgSelY2 := imgSelPy + imgSelH
   }

   nImgSelX1 := imgSelPx
   nImgSelY1 := imgSelPy

   zLv := newH/imgH
   zLh := newW/imgW
   zImgSelX1 := Floor(nImgSelX1*zLh)
   zImgSelY1 := Floor(nImgSelY1*zLv)
   zImgSelX2 := Floor(nImgSelX2*zLh)
   zImgSelY2 := Floor(nImgSelY2*zLv)
   If (boundLess!=1)
   {
      If (zImgSelX2>newW)
         zImgSelX2 := newW
      If (zImgSelY2>newH)
         zImgSelY2 := newH
   }

   zImgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   zImgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   zImgSelPx := min(zImgSelX1, zImgSelX2)
   zImgSelPy := min(zImgSelY1, zImgSelY2)

   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(zimgSelW, zimgSelH, givenRotation, zrimgSelW, zrimgSelH)
      zimgSelPx := zimgSelPx - (zrimgSelW - zimgSelW)//2
      zimgSelPy := zimgSelPy - (zrimgSelH - zimgSelH)//2
      zimgSelW := zrimgSelW
      zimgSelH := zrimgSelH
      If (zimgSelPx<1)
         zimgSelPx := 0
      If (zimgSelPy<1)
         zimgSelPy := 0
      If (zimgSelPx + zimgSelW>newW)
         zimgSelW := newW - zimgSelPx
      If (zimgSelPy + zimgSelH>newH)
         zimgSelH := newH - zimgSelPy
   }

   If (zImgSelW<2)
   {
      zImgSelW := 2
      zImgSelPx := (zImgSelPx>=2) ? zImgSelPx - 2 : 0
   }

   If (zImgSelH<2)
   {
      zImgSelH := 2
      zImgSelPy := (zImgSelPy>=2) ? zImgSelPy - 2 : 0
   }

   If (initialboundLess=-1 && boundLess=0)
   {
      capSelectionRelativeCoords()
      imgSelX1 := X1, imgSelY1 := Y1
      imgSelX2 := X2, imgSelY2 := Y2
      SetTimer, dummyRefreshImgSelectionWindow, -100
   }
}

ResizePanelHelpBoxInfo() {
    msgBoxWrapper(appTitle ": HELP", "In «Advanced mode» there is limited support for color depths other than 24 and 32 bits. All images will be converted to 24 bits per pixel. If the alpha channel is present, the resulted file will be in 32 bits, if the format allows. When saving images in formats that do not support an alpha channel, the window background color is used.`n`nUse «Simple mode» to better preserve color depths or work with images larger than 530 MPx or than 32500 px [if the given file format allows it]. This mode supports 1-, 8-, 24-, 32-, 16- (UINT16), 48- (RGB16), 64- (RGBA16), 32- (FLOAT), 96- (RGBF) and 128- (RGBAF) bits images. High-dynamic range formats supported: .EXR, .HDR, .JXR, .HDP, .PFM and .TIFF.`n`nPlease also note, while there is full support for multi-frames/paged images [for GIFs and TIFFs only] in the viewport... on file (re)save or format conversion, only the first frame will be preserved.", -1, 0, 0)
}

OpenGitHub() {
  Static thisURL := "https://github.com/marius-sucan/Quick-Picto-Viewer"
  Try Run, % thisURL
  Catch wasError
        Sleep, 1

  If wasError
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the URL:`n" %thisURL%, 0, 0, "error")
}

drawViewportHelpMap() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (editingSelectionNow=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//9
       Penuha := Gdip_CreatePen("0xEE445544", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)
       dotsSize := SelDotsSize
       thisW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
       thisH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
       thisX := min(selDotX, selDotAx) + dotsSize//2
       thisY := min(selDotY, selDotAy) + dotsSize//2

       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX, thisY, thisW, thisH)
       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image selected area", thisFntSize thisStylu , "Arial", thisW, thisH)
       thisFntSize := "Bold cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" OSDfntSize*2 " y" OSDfntSize*2
       ERR := Gdip_TextToGraphics(2NDglPG, "Current selection type: " DefineVPselAreaMode() ".`n `nDouble click on its edges to open a menu option.`n `nDouble click outside to drop the selection.`n `nCtrl + Wheel Up/Down to zoom in/out anywhere.", thisFntSize thisStylu , "Arial", mainWidth - OSDfntSize*2, mainHeight - OSDfntSize*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       toolTipGuiCreated := 2
    } Else If (TouchScreenMode=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//10
       Penuha := Gdip_CreatePen("0x99334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)

       calculateTouchMargins(thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(2NDglPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)
       Gdip_DrawRectangle(2NDglPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image panning area.`n`nDouble click in this area to change how the image is adapted to the viewport.`n`nShift + Left-click to create a new selection area.`n`nOne-finger swipe gestures allowed when nothing to pan - outside this rectangle they are always allowed.`n`nCtrl + Wheel Up/Down to zoom in/out anywhere", thisFntSize thisStylu , "Arial", thisW, thisH)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.9)
       thisStylu := " x" thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom in", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x" thisX " y" thisY + thisH
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom out", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x1 y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       thisStylu := " x" thisW + thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Next`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       toolTipGuiCreated := 2
    }
}

ShowContextualHelp() {
   If (drawingShapeNow=1)
   {
      msgu := "Current context: drawing a freeform shape.`nTo abandon, press Escape or Right-Click."
   } Else
   {
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         BtnHelpTransform()
      WinGetTitle, OutputVar , ahk_id %hSetWinGui%
      If (imgEditPanelOpened=1)
         moreInfo := "`nLive image editing tool"

      OutputVar := StrReplace(OutputVar, ": " appTitle)
      msgu := "Current tool: " OutputVar moreInfo
   }

   showTOOLtip(msgu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

AboutWindow() {
    Global LViewOthers, listViewFilteru
    thisBtnHeight := createSettingsGUI(1, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    Gui, -DPIScale
    Gui, Font, s19 Bold, Arial, -wrap
    Gui, Add, Picture, x+10 y+10 w150 Section h-1 +0x3 gOpenGitHub, qpv-icon.ico
    Gui, Add, Text, x+20 y15, %appTitle% v%appVersion%
    Gui, Font, s10 Bold, Arial, -wrap
    Gui, Add, Link, y+5 wp, Developed by <a href="http://marius.sucan.ro/">Marius Șucan</a>.
    Gui, Font
    Gui, Add, Link, y+10 wp, Based on the prototype image viewer by <a href="http://sites.google.com/site/littlescripting/">SBC</a> from October 2010 published on <a href="https://autohotkey.com/board/topic/58226-ahk-picture-viewer/">AHK forums</a>.
    lstWid := 450
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(1, "appVersion", "General")
    If wasInitFIMlib
       thisVersion := " v" FreeImage_GetVersion()

    compiled := (A_IsCompiled=1) ? "Compiled. " : "Uncompiled. "
    compiled .= (A_PtrSize=8) ? "x64. " : "x32. "
    Gui, +DPIScale
    Gui, Font, Bold
    Gui, Add, Text, xs+15 y+25 w%txtWid%, Current version: v%appVersion% from %vReleaseDate%. Internal AHK-H version: %A_AhkVersion%. %compiled%OS: %A_OSVersion%.
    Gui, Font, Normal
    Gui, Add, Text, y+10 w%txtWid%, Dedicated to people with really large image collections and slideshow needs :-).
    Gui, Add, Text, y+10 w%txtWid%, This application contains code from various entities. You can find more details in the source code.
    Gui, Add, Text, y+10 w%txtWid%, QPV uses GDI+ [Windows APIs] to display images and FreeImage%thisVersion% to load exotic file formats. FreeImage is licensed under the GNU General Public License, v2.0 (GPLv2) or v3.0 (GPLv3), and the FreeImage Public License (FIPL)

    Gui, Add, Link, y+10 w%txtWid%, To keep the development going, <a href="https://www.paypal.me/MariusSucan/10">please donate</a> or <a href="mailto:marius.sucan@gmail.com?subject=%appTitle% v%appVersion%">send me feedback</a>.
    Gui, Add, Link, y+10 w%txtWid%, New and previous versions are available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.

    Gui, Add, Button, xs+15 y+20 h%thisBtnHeight% w%btnWid% gBtnHelpWin, &Help
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp gcheckForUpdatesNow, &Check for updates
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "About " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
}

BtnHelpWin() {
   BtnCloseWindow()
   HelpWindow()
}

HelpWindow(dummy:=0) {
    Global LViewOthers, listViewFilteru
    If (AnyWindowOpen || drawingShapeNow=1)
    {
       ShowContextualHelp()
       Return
    }

    thisBtnHeight := createSettingsGUI(61, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    lstWid := 450
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    drawViewportHelpMap()
    tabu := (dummy="cmdu") ? 3 : 2
    Gui, Add, Tab3, x15 y15 Choose%tabu%, General|Keyboard shortcuts|Command line
    Gui, Tab, 1 ; general
    cmdHelp := appTitle " is made to gracefully manage large image libraries, e.g., a million images, or more. It is made to help organize and view such libraries. It is also developed having in mind keyboard users by providing many keyboard shortcuts or menu accelerators. A particular atention is paid through-out development to the needs of people with poor eye-sight. To this end, users can activate large UI fonts, adjust the zoom level for texts (Ctrl + -/+) in the viewport, and right-click on menu items or panel controls to display larger their associated texts."
    cmdHelp .= "`n`nKey concepts in QPV to know about:`n`nThe files list.`nThe files list is an index, a list of records pointing to files on the disk. "
    cmdHelp .= "When users open a folder, a files list index is automatically generated and one can add more files, from elsewhere, to this index. "
    cmdHelp .= "Given that it is just an index, the files added are not inserted (or pasted) into the initially opened folder. "
    cmdHelp .= "The files list index can be saved and reopened in later sessions. QPV allows users to save the files list in two formats: plain-text and as a SQLite database. For more details, see the Help provided in the Save panel (Ctrl+Shift+S)."
    cmdHelp .= "`n`nThe viewport`nIn QPV, unlike in other image viewers, there is a clear distinction between how images are displayed on the screen and the pixel/image data. QPV allows users to alter the viewing conditions without affecting the images themselves. The color adjustments, image rotation and flip options (available in the ""Viewport adjustments"" panel), are applied in real-time for each image when loaded, before displaying it on screen. There are distinct options and tools in QPV to edit and adjust images or to apply the viewport conditions. QPV will seamlessly apply the viewport viewing conditions onto the image itself when users choose to save the image or when image editing tools are used."
    cmdHelp .= "`n`nBy using QPV, people can observe that many similar tools are provided, which may achieve the exact same thing. QPV was thought like this, to allow users perform basic tasks by different means, because each mean is suited for specific use-case scenarios."

    Gui, Add, Edit, x+15 y+15 w%lstWid% r13 ReadOnly, %cmdHelp%

    Gui, Tab, 2 ; keyboard 
    Gui, Add, ListView, x+15 y+15 w%lstWid% r10 Grid vLViewOthers, Keys|Action|Context|Opens
    Gui, Add, Combobox, xp y+10 wp gfilterListViewKbdsAbout +hwndhEditField vlistViewFilteru, \Files list|\Image view|\Image selection area|\Live editing|\Folder tree|\Painting mode|\Freeform drawing|\Anywhere|\Panel|\Menu

    cmdHelp := "QPV can be invoked with command line arguments. Examples:`n`n1. Open a folder:`nqpv.exe ""fd=C:\example folder\tempus""`n`nAdd a pipe ""|"" after equal ""="" to NOT have images loaded recursively."
    cmdHelp .= "`n`n2. Call an internal function:`nqpv.exe call_ToggleThumbsMode() ""fd=C:\folder\tempus""`n`nThis will index all the images in the given folder and switch to thumbnails mode.`n`nOnly functions that need no parameters can be invoked. If multiple call_ are used, only the last valid one will be considered."
    cmdHelp .= "`n`nTo learn what functions you can call, check the Journal window in QPV. It names functions when opening panels or when errors occur. You can also enable debug mode, to gather more intel, or study the source code."
    cmdHelp .= "`n`n3. Specify user settings:`n`nqpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 ""C:\folder\this-image.png""`n"
    cmdHelp .= "`nYou can find available user settings in the quick-picto-viewer.ini file or by right-clicking on controls in the panels.`n`nYou can pass up to 950 arguments`n`nPass /qpv-debug argument to have QPV send debug information to a Win32 Debug Viewer.`n`nIf one .SLD file or one folder is passed as argument, any other image file passed as argument is ignored."

    Gui, Tab, 3 ; 
    Gui, Add, Edit, x+15 y+15 w%lstWid% r13 ReadOnly, %cmdHelp%

    Gui, Tab
    Gui, Add, Button, xs+15 y+8 h%thisBtnHeight% w%btnWid% gBtnAboutWin, &About
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp gPanelQuickSearchMenuOptions, &Search
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Text, x+5 hp +0x200, QPV v%appVersion%

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Help " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
}

BtnAboutWin() {
   BtnCloseWindow()
   AboutWindow()
}

PopulateAboutKbdShortcutsList(listFilter:=0) {
    EM_SETCUEBANNER(hEditField, "Filter keyboard shortcuts list", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
 
    FileRead, fileData, % mainCompiledPath "\resources\help-keyboard-shortcuts.txt"
    startOperation := A_TickCount
    Loop, Parse, fileData, `n, `r
    {
        If (StrLen(A_LoopField)<5) || (listFilter && !InStr(A_LoopField, listFilter))
           Continue

        countThese++
        lineArru := StrSplit(A_LoopField, "|")
        LV_Add(A_Index, lineArru[1], lineArru[2], lineArru[3], lineArru[4])
    }

    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

filterListViewKbdsAbout() {
   GuiControlGet, listViewFilteru
   If (SubStr(listViewFilteru, 1, 1)="\" && StrLen(listViewFilteru)>3) 
      listViewFilteru := StrReplace(listViewFilteru, "\", "|")

   PopulateAboutKbdShortcutsList(listViewFilteru)
}

BtnChangeSatPlus() {
  ChangeSaturation(1)
}

BtnChangeSatMin() {
  ChangeSaturation(-1)
}

BtnChangeLumPlus() {
  ChangeLumos(1)
}

BtnChangeLumMin() {
  ChangeLumos(-1)
}

BtnChangeGammPlus() {
  ChangeGammos(1)
}

BtnChangeGammMin() {
  ChangeGammos(-1)
}

PanelsCheckFileExists() {
   If (currentFileIndex=0)
      Return 0

   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   } Else Return 1
}

PanelResolutionSorting() {
   If AnyWindowOpen
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(20, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose resolution sort mode: " appTitle, "Each file will be read to identify the image resolution, in pixels.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Histogram|&Cancel", 1, "image-file", "&Reverse order", 0, "Resolution (MPx)`f`fImage width`fImage height`fAspect ratio (W/H)`fImage DPI`fPages / frames", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortImageProperties(msgResult.list)
   } Else If InStr(msgResult.btn, "histogram")
      PanelHistogramSorting()
}

PanelHistogramSorting() {
   Static hasAskedSort := 0
   If AnyWindowOpen
      Return

   If warnXPhistoSort()
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(45, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose image histogram sort mode: " appTitle, "Each image file will be read to extract its histogram data.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Resolution|&Cancel", 1, "image-file", "&Reverse order", 0, "Average`f`fMedian`fPeak range`fMinimum range`f`Range`fMode`fMinimum`fRoot-mean square", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      good2go := 0
      If !hasAskedSort
      {
         msgResultu := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its histogram main points.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
         If InStr(msgResultu, "yes")
            hasAskedSort := 1
      } Else good2go := 1
      If (good2go!=1 && hasAskedSort=0)
         Return

      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortHistogram(msgResult.list)
   } Else If InStr(msgResult.btn, "resolution")
      PanelResolutionSorting()
}

testIsDupesList() {
   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
      Return 1
   Else
      Return 0
}

PanelFindDupes() {
    Global userFindDupesSelectAllDummy := 0
    userFindDupesSelectAllDummy := 0
    Static hasOpened
    If !hasOpened
    {
       Global UIcheckimgfile := 0, UIcheckfcreated := 0, UIcheckfmodified := 0, UIcheckfsize := 0, UIcheckkbfsize := 0, UIcheckimgpixfmt := 0, UIcheckimgwidth := 0, UIcheckimgheight := 0, UIcheckimgmegapix := 0, UIcheckimgwhratio := 0, UIcheckimgframes := 0, UIcheckimghpeak := 0, UIcheckimghlow := 0
            , UIcheckimghrange := 0, UIcheckimgavg := 0, UIcheckimgmedian := 0, UIcheckimghrms := 0, UIcheckimghmode := 0, UIcheckimghminu := 0, editFE
       hasOpened := 1
    }

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (SLDtypeLoaded!=3)
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "The files list is currently not saved as a SQLite database. Would you like to save it in the specified format?", "&Yes|&Remove duplicate entries|&Cancel", 2, "question")
       If (msgResult="Yes")
          PanelSaveSlideShowu()
       Else If InStr(msgResult, "remove")
          cleanDeadFilesList("noFilesCheck")
       Return
    }

    thisBtnHeight := createSettingsGUI(49, A_ThisFunc, 1)
    btnWid := 100
    txtWid := 350
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 175
       Gui, Font, s%LargeUIfontValue%
    }

    If (A_PtrSize!=8)
       userFindDupesFilterHamDist := 0

    col := (PrefsLargeFonts=1) ? 285 : 190
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, General|Image fingerprints
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gBTNchangeDupesPreset AltSubmit Choose%userFindDupePresets% vuserFindDupePresets, Image content fingerprint (dHash 8x8)|Image histogram data|Image resolution and file size|Image histogram, resolution and file size|Identical file names|Identical file names and file sizes|Custom mode
    Gui, Add, Checkbox, xs y+7 w%col% -wrap gUIfindDupesChecksu Checked%UIcheckimgfile% vUIcheckimgfile, File name and its extension
    Gui, Add, Checkbox, x+7 gBTNselectAllFindDupesProperties Checked%userFindDupesSelectAllDummy% vuserFindDupesSelectAllDummy, &Select all
    Gui, Add, Text, x+3 vbtnFldr, Precision:
    Gui, Add, Edit, x+2 w50 number -multi limit1 veditF5, % findDupesPrecision
    Gui, Add, UpDown, vfindDupesPrecision Range1-5, % findDupesPrecision
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfcreated% vUIcheckfcreated, Date created
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckfmodified% vUIcheckfmodified, Date modified
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfsize% vUIcheckfsize, Size (bytes)
    Gui, Add, Checkbox, X+7 gUIfindDupesChecksu Checked%UIcheckkbfsize% vUIcheckkbfsize, Size (kilobytes)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimgpixfmt% vUIcheckimgpixfmt, Image pixel format
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgframes% vUIcheckimgframes, Frames / pages
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgwidth% vUIcheckimgwidth, Width
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgheight% vUIcheckimgheight, Height
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmegapix% vUIcheckimgmegapix, Megapixels
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgwhratio% vUIcheckimgwhratio, Aspect ratio (W/H)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimghpeak% vUIcheckimghpeak, Histogram maximum (range)
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghlow% vUIcheckimghlow, Histogram minimum (range)
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghrange% vUIcheckimghrange, Histogram total range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgavg% vUIcheckimgavg, Histogram average
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmedian% vUIcheckimgmedian, Histogram median
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghrms% vUIcheckimghrms, Histogram root-mean square
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghmode% vUIcheckimghmode, Histogram mode
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghminu% vUIcheckimghminu, Histogram minimum

    fingWid := (PrefsLargeFonts=1) ? 170 : 100
    fingEdt := (PrefsLargeFonts=1) ? 70 : 50
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 w%txtWid% Section vbtnFldr6, Image fingerprints are image 8x8 distance hashes. Below you can configure what sections of the image hashes to compare. The blue dots in the preview area highlight the areas of the images that will be compared. The less the 8x8 grid is complete, the more false-positives may be identified.
    Gui, -DPIScale
    Gui, Add, Text, xp y+15 Section w122 h122 +0x1000 +0xE +hwndhCropCornersPic, Image hashing preview
    Gui, +DPIScale
    Gui, Add, Checkbox, x+10 yp w%fingWid% Section gBTNchangeDupesPreset Checked%UIcheckinnerpixelz% vUIcheckinnerpixelz, Inner area
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF11, % hashInnerTrimLeft
    Gui, Add, UpDown, vhashInnerTrimLeft gBTNchangeDupesPreset Range0-9, % hashInnerTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF6, % hashInnerTrimRight
    Gui, Add, UpDown, vhashInnerTrimRight gBTNchangeDupesPreset Range0-9, % hashInnerTrimRight
    Gui, Add, Checkbox, xs y+7 w%fingWid% gBTNchangeDupesPreset Checked%UIcheckouterpixelz% vUIcheckouterpixelz, Borders
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF7, % hashOuterTrimLeft
    Gui, Add, UpDown, vhashOuterTrimLeft gBTNchangeDupesPreset Range0-9, % hashOuterTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF8, % hashOuterTrimRight
    Gui, Add, UpDown, vhashOuterTrimRight gBTNchangeDupesPreset Range0-9, % hashOuterTrimRight
    Gui, Add, Checkbox, xs y+7 w%fingWid% gBTNchangeDupesPreset Checked%UIcheckpixelzHash% vUIcheckpixelzHash, Simplified
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF9, % hashSimpleTrimLeft
    Gui, Add, UpDown, vhashSimpleTrimLeft gBTNchangeDupesPreset Range0-9, % hashSimpleTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF10, % hashSimpleTrimRight
    Gui, Add, UpDown, vhashSimpleTrimRight gBTNchangeDupesPreset Range0-9, % hashSimpleTrimRight
    Gui, Add, Text, xm+15 y+14 Section, Filter the results with given string - applies to folder paths:
    Gui, Add, Edit, xp+15 y+7 wp-30 -multi limit12345 vdupesStringFilter , % dupesStringFilter
    Gui, Add, Checkbox, xp y+7 Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain it
    Gui, Add, Checkbox, x+35 Checked%excludePreviousDupesFromList% vexcludePreviousDupesFromList, E&xclude current list
    Gui, Add, Checkbox, xs y+15 gBTNchangeDupesPreset Checked%userFindDupesFilterHamDist% vuserFindDupesFilterHamDist, Filter results by Hamming distance threshold:
    Gui, Add, Edit, x+2 w60 number -multi limit2 veditFE, % userFindDupesHamDistLvl
    Gui, Add, UpDown, vuserFindDupesHamDistLvl Range1-15, % userFindDupesHamDistLvl

    Gui, Tab
    Gui, Add, Button, xm+15 y+20 h%thisBtnHeight% w%btnWid% Default gBTNfindDupesNow, &Find duplicates
    If testIsDupesList()
       Gui, Add, Button, x+5 hp wp gBTNautoselectDupes, &Auto-select dupes
    Else
       Gui, Add, Button, x+5 hp wp gBtnCollectHistoInfos, Collect files &data
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNhelpFindDupes, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Find image duplicates: " appTitle)
    SetTimer, BTNchangeDupesPreset, -300
}

updateUIimageHashPreview() {
    Static uiboxSize := 122, dotu := 12
    If (AnyWindowOpen!=49)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, UIcheckpixelzHash
    GuiControlGet, UIcheckinnerpixelz
    GuiControlGet, UIcheckouterpixelz
    GuiControlGet, hashInnerTrimLeft
    GuiControlGet, hashInnerTrimRight
    GuiControlGet, hashOuterTrimLeft
    GuiControlGet, hashOuterTrimRight
    GuiControlGet, hashSimpleTrimLeft
    GuiControlGet, hashSimpleTrimRight
    GuiControlGet, userFindDupePresets
    GuiControlGet, userFindDupesHamDistLvl
    GuiControlGet, userFindDupesFilterHamDist

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    innerTrimL := hashInnerTrimLeft + 1
    innerTrimR := 36 - hashInnerTrimRight - hashInnerTrimLeft
    outerTrimL := hashOuterTrimLeft + 1
    outerTrimR := 28 - hashOuterTrimRight - hashOuterTrimLeft
    simpleTrimL := hashSimpleTrimLeft*2 + 1
    simpleTrimR := 64 - hashSimpleTrimRight*2 - hashSimpleTrimLeft*2
    opacityBr := (hashSimpleTrimLeft>0) ? "0x77" : "0xAA"

    red := Gdip_BrushCreateSolid(opacityBr "22FFAA")
    Gdip_GetImageDimensions(cornersBMP, imgW, imgH)
    If (UIcheckpixelzHash=1 || UIcheckinnerpixelz=1 || UIcheckouterpixelz=1) && (userFindDupePresets=7) || (userFindDupesFilterHamDist=1)
    {
       Gdip_FillRectangle(G, pBrushZ, 0, 0, imgW, imgH)
    } Else
    {
       Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
       Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
    }

    Loop, 8
    {
       If (userFindDupePresets!=7)
          Continue

       pY := A_Index - 1
       Loop, 8
       {
          pX := A_Index - 1
          allLoops++
          If (pY=0 || pY=7 || pX=0 || pX=7)
          {
             outLoops++
             If (userFindDupesFilterHamDist=1)
                Gdip_FillEllipse(G, pBrushC, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)

             If (isInRange(outLoops, outerTrimL, outerTrimR + outerTrimL - 1) && UIcheckouterpixelz=1)
                Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
   
             If (isInRange(outLoops, 1, 28 - hashSimpleTrimRight*2) && UIcheckpixelzHash=1)
                Gdip_FillEllipse(G, red, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
          } Else
          {
             inLoops++
             If (userFindDupesFilterHamDist=1)
                Gdip_FillEllipse(G, pBrushC, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)

             If (isInRange(inLoops, innerTrimL, innerTrimR + innerTrimL - 1) && UIcheckinnerpixelz=1)
                Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)

             If (!isInRange(inLoops, 0, simpleTrimL - 3) && UIcheckpixelzHash=1)
                Gdip_FillEllipse(G, red, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
          }
       }
    }

    Gdip_DeleteBrush(red)
    Gdip_DeleteGraphics(G)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    UIfindDupesChecksu()
    ; BTNchangeDupesPreset()
    Return er
}

BTNautoselectDupes() {
   BtnCloseWindow()
   PanelAutoSelectDupes()
}

UIfindDupesChecksu() {
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
}

BTNchangeDupesPreset() {
   If (AnyWindowOpen=49)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, userFindDupePresets
   actu := (userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   actu2 := (userFindDupePresets=5 || userFindDupePresets=6) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
   GuiControl, % actu, userFindDupesSelectAllDummy
   GuiControl, % actu, btnFldr6
   GuiControl, % actu2, findDupesPrecision
   GuiControl, % actu2, editF5
   GuiControl, % actu2, btnFldr
   UIfindDupesCheckboxes(actu)
   If (A_PtrSize!=8)
      GuiControl, SettingsGUIA: Disable, userFindDupesFilterHamDist
}

BTNselectAllFindDupesProperties() {
   GuiControlGet, userFindDupesSelectAllDummy
   UIfindDupesCheckboxes("SettingsGUIA:", userFindDupesSelectAllDummy)
}

UIfindDupesCheckboxes(hactu, v:="") {
   If (AnyWindowOpen=49)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControl, % hactu, UIcheckimgfile, %v%
   GuiControl, % hactu, UIcheckfcreated, %v%
   GuiControl, % hactu, UIcheckfmodified, %v%
   GuiControl, % hactu, UIcheckfsize, %v%
   GuiControl, % hactu, UIcheckkbfsize, %v%
   GuiControl, % hactu, UIcheckimgpixfmt, %v%
   GuiControl, % hactu, UIcheckimgwidth, %v%
   GuiControl, % hactu, UIcheckimgheight, %v%
   GuiControl, % hactu, UIcheckimgmegapix, %v%
   GuiControl, % hactu, UIcheckimgwhratio, %v%
   GuiControl, % hactu, UIcheckimgframes, %v%
   GuiControl, % hactu, UIcheckimghpeak, %v%
   GuiControl, % hactu, UIcheckimghlow, %v%
   GuiControl, % hactu, UIcheckimghrange, %v%
   GuiControl, % hactu, UIcheckimgavg, %v%
   GuiControl, % hactu, UIcheckimgmedian, %v%
   GuiControl, % hactu, UIcheckimghrms, %v%
   GuiControl, % hactu, UIcheckimghmode, %v%
   GuiControl, % hactu, UIcheckimghminu, %v%
   GuiControl, % hactu, UIcheckinnerpixelz, %v%
   GuiControl, % hactu, UIcheckouterpixelz, %v%
   GuiControl, % hactu, UIcheckpixelzHash, %v%

   GuiControlGet, UIcheckpixelzHash
   GuiControlGet, UIcheckinnerpixelz
   GuiControlGet, UIcheckouterpixelz
   GuiControlGet, userFindDupePresets
   GuiControlGet, userFindDupesFilterHamDist
   actu := (UIcheckinnerpixelz=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashInnerTrimLeft
   GuiControl, % actu, hashInnerTrimRight
   GuiControl, % actu, editF11
   GuiControl, % actu, editF6
   actu := (UIcheckouterpixelz=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashOuterTrimLeft
   GuiControl, % actu, hashOuterTrimRight
   GuiControl, % actu, editF7
   GuiControl, % actu, editF8
   actu := (UIcheckpixelzHash=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashSimpleTrimLeft
   GuiControl, % actu, hashSimpleTrimRight
   GuiControl, % actu, editF9
   GuiControl, % actu, editF10
   If InStr(hactu, "able")
      updateUIimageHashPreview()

   actu := (userFindDupesFilterHamDist=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userFindDupesHamDistLvl
   GuiControl, % actu, editFE
}


BTNfindDupesNow() {
   columnus := ""
   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, hashInnerTrimLeft
   GuiControlGet, hashInnerTrimRight
   GuiControlGet, hashOuterTrimLeft
   GuiControlGet, hashOuterTrimRight
   GuiControlGet, hashSimpleTrimLeft
   GuiControlGet, hashSimpleTrimRight
   GuiControlGet, dupesStringFilter
   GuiControlGet, userFilterStringIsNot
   GuiControlGet, excludePreviousDupesFromList
   GuiControlGet, userFindDupesHamDistLvl
   GuiControlGet, userFindDupesFilterHamDist

   If GuiCtrlGet("UIcheckimgfile")
      columnus .= "imgfile,"

   If GuiCtrlGet("UIcheckfcreated")
      columnus .= "fcreated,"

   If GuiCtrlGet("UIcheckfmodified")
      columnus .= "fmodified,"

   If GuiCtrlGet("UIcheckfsize")
   {
      columnus .= "fsize,"
   } Else 
   {
      If GuiCtrlGet("UIcheckkbfsize")
         columnus .= "kbfsize,"
   }

   If GuiCtrlGet("UIcheckimgpixfmt")
      columnus .= "imgpixfmt,"

   If GuiCtrlGet("UIcheckimgwidth")
      columnus .= "imgwidth,"

   If GuiCtrlGet("UIcheckimgheight")
      columnus .= "imgheight,"

   If GuiCtrlGet("UIcheckimgmegapix")
      columnus .= "imgmegapix,"

   If GuiCtrlGet("UIcheckimgwhratio")
      columnus .= "imgwhratio,"

   If GuiCtrlGet("UIcheckimgframes")
      columnus .= "imgframes,"

   If GuiCtrlGet("UIcheckimghpeak")
      columnus .= "imghpeak,"

   If GuiCtrlGet("UIcheckimghlow")
      columnus .= "imghlow,"

   If GuiCtrlGet("UIcheckimghrange")
      columnus .= "imghrange,"

   If GuiCtrlGet("UIcheckimgavg")
      columnus .= "imgavg,"

   If GuiCtrlGet("UIcheckimgmedian")
      columnus .= "imgmedian,"

   If GuiCtrlGet("UIcheckimghrms")
      columnus .= "imghrms,"

   If GuiCtrlGet("UIcheckimghmode")
      columnus .= "imghmode,"

   If GuiCtrlGet("UIcheckimghminu")
      columnus .= "imghminu,"

   If GuiCtrlGet("UIcheckinnerpixelz")
      columnus .= "innerpixelz,"

   If GuiCtrlGet("UIcheckouterpixelz")
      columnus .= "outerpixelz,"

   If GuiCtrlGet("UIcheckpixelzHash")
      columnus .= "pixelzHash,"

   GuiControlGet, userFindDupePresets
   If (userFindDupePresets=1)
   {
      hashInnerTrimLeft := 1
      hashInnerTrimRight := 1
      hashOuterTrimLeft := 1
      hashOuterTrimRight := 1
      columnus := "innerpixelz,outerpixelz,imgframes,imgwhratio"
   } Else If (userFindDupePresets=2)
      columnus := "imgavg,imghpeak,imgmedian,imghlow,imghrange,imghmode,imgframes,imgwhratio"
   Else If (userFindDupePresets=3)
      columnus := "fsize,imgmegapix,imgwhratio,imgframes"
   Else If (userFindDupePresets=4)
      columnus := "kbfsize,imgframes,imgmegapix,imgwhratio,imgavg,imghpeak,imgmedian,imghlow"
   Else If (userFindDupePresets=5)
      columnus := "imgfile,imgframes"
   Else If (userFindDupePresets=6)
      columnus := "fsize,imgfile,imgframes"

   ; Gui, SettingsGUIA: Submit, NoHide
   ; ToolTip, % userFindDupePresets "==" columnus , , , 2
   columnus := Trimmer(columnus, ",")
   If (InStr(columnus, "innerpixelz") && userFindDupesFilterHamDist=1)
   {
      theseCols := StrReplace(columnus, "innerpixelz")
      theseCols := StrReplace(theseCols, "outerpixelz")
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
   } Else theseCols := columnus

   If StrLen(theseCols)<3
   {
      showTOOLtip("WARNING: No properties selected by which to identify duplicates.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   toBeExcludedIndexes := []
   If (excludePreviousDupesFromList=1)
   {
      Loop, % maxFilesIndex
         toBeExcludedIndexes[resultedFilesList[A_Index, 12]] := 1
   }

   retrieveDupesByProperties(columnus, 0)
}

BTNhelpFindDupes() {
   friendly := (A_PtrSize=8) ? "For the Hamming distance, a low threshold means stricter matching. Increase it for looser matches." : "Hamming distance filtering is not available on the 32 bits edition of QPV."
   msgBoxWrapper(appTitle ": HELP", "This panel offers you the possibility to identify duplicate images based on the collected file and image properties, fingerprints and histogram data points.`n`nPlease choose based on what criteria to identify the possible duplicates. The more properties you select the stricter the criteria for identifying image duplicates will be.`n`nPrecision factor does not apply for file names, size in bytes, file dates and image width, height, frames and pixel format properties.`n`nThe functionality provided in this panel relies on collected data, please ensure you allow " appTitle " to scan the files.`n`nFor optimal results activate aspect ratio, precision 3 and variations on the options in the fingerprints tab.`n`n" friendly, -1, 0, 0)
}

GuiCtrlGet(varu) {
   GuiControlGet, %varu%
   x := %varu%
   Return x
}

PanelPurgeCachedSQLdata() {
   If (AnyWindowOpen=49)
   {
      reOpenIT := 1
      BtnCloseWindow()
   }

   If (AnyWindowOpen || SLDtypeLoaded!=3)
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(46, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Purge cached data: " appTitle, "Please choose what kind of cached data to erase from the files list database.", "&Purge|C&ancel", 1, "trash", 0, 0, "File details`f`fImage properties`fImage histograms`fAll`fAll (selected files only)", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "purge")
   {
      extraFilter := extractSQLqueryFromFilter()
      If extraFilter
         msgInfos := "`n`nThe purge will occur only for the files matching the current files list filter. To purge all the cached data, deactivate current filter."
 
      msgResultu := msgBoxWrapper(appTitle ": Purge cached data", "Please confirm you want to purge selected cached data from the database.`n`nThis data is used for sorting the files list much faster, identify image duplicates or to generate files list statistics." msgInfos, 4, 0, "question")
      If !InStr(msgResultu, "yes")
         Return

      If (msgResult.list=1)
         corePurgeCachedSQLdata("attributes")
      Else If (msgResult.list=2)
         corePurgeCachedSQLdata("resolution")
      Else If (msgResult.list=3)
         corePurgeCachedSQLdata("histogram")
      Else If (msgResult.list=4)
         corePurgeCachedSQLdata("all")
      Else If (msgResult.list=5)
         PurgeCachedDataSelectedFiles()
   }

   If (reOpenIT=1)
      PanelWrapperFilesStats()
}

corePurgeCachedSQLdata(mode) {
   setImageLoading()
   extraFilter := extractSQLqueryFromFilter()
   wherePart := extraFilter ? extraFilter " AND " : "WHERE"
   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   showTOOLtip("Purging cached data from the database, please wait" friendly)
   If (mode="attributes" || mode="all")
      SQLstr .= "UPDATE images SET fsize = NULL, fmodified = NULL, fcreated = NULL " wherePart " fsize IS NOT NULL; "
   If (mode="resolution" || mode="all")
      SQLstr .= "UPDATE images SET imgdpi = NULL, imgwidth = NULL, imgheight = NULL, imgframes = NULL, imgpixfmt = NULL " wherePart " imgwidth IS NOT NULL; "
   If (mode="histogram" || mode="all")
      SQLstr .= "UPDATE images SET imgavg = NULL, imgmedian = NULL, imghpeak = NULL, imghlow = NULL, imghminu = NULL, imghmode = NULL, imghrms = NULL, imghrange = NULL, pixelzHash = NULL, outerpixelz = NULL, innerpixelz = NULL " wherePart " imgavg IS NOT NULL;"

   If !activeSQLdb.Exec(SQLStr)
   {
      showTOOLtip("Failed to purge the cached data from the database:`n" activeSQLdb.ErrorMsg)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep 300, 100
   } Else SoundBeep 900, 100

   SetTimer, RemoveTooltip, -350
   SetTimer, ResetImgLoadStatus, -250
}

PurgeCachedDataSelectedFiles() {
   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      showTOOLtip("WARNING: No files are currently selected to perform given operation")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   If markedSelectFile
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         r := selectivePurgeCachedSQLdata(resultedFilesList[A_Index,12])
         If r
            failedFiles++
         Else
            countFiles++

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(countTFiles, markedSelectFile, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

            showTOOLtip("Purging cached data for selected image files, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }
      }
   }

   If failedFiles
      someErrors := "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned. Files processed: " groupDigits(countFiles) " out of " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for the selected files: " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 900, 100
   }
  
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

selectivePurgeCachedSQLdata(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET innerpixelz = NULL, outerpixelz = NULL, pixelzHash = NULL, imgavg = NULL, imgmedian = NULL, imghmode = NULL, imghrms = NULL, imghminu = NULL, imghrange = NULL, imghpeak = NULL, imghlow = NULL, imgwidth = NULL, imgheight = NULL, imgframes = NULL, imgpixfmt = NULL, imgdpi = NULL, fsize = NULL, fmodified = NULL, fcreated = NULL WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=1)
         Return "fail"
      Else
         addJournalEntry("Failed to purge the cached data in the database for given index: " dbIndex "`n" activeSQLdb.ErrorMsg)
   }
}

PanelJpegPerformOperation() {
    Global mainBtnACT

    If !PanelsCheckFileExists()
       Return

    filesElected := getSelectedFiles(0, 1)
    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    thisBtnHeight := createSettingsGUI(12, A_ThisFunc)
    btnWid := 110
    txtWid := slideWid := 280

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1)
       jpegDoCrop := 0

    Gui, Add, Text, x15 y15 Section, Please choose a JPEG lossless operation...
    Gui, Add, DropDownList, y+10 Section w%txtWid% AltSubmit Choose%jpegDesiredOperation% vjpegDesiredOperation, None|Flip Horizontally|Flip Vertically|Transpose|Transverse|Rotate 90°|Rotate 180°|Rotate -90° [270°]
    Gui, Add, Checkbox, y+10 Checked%jpegDoCrop% vjpegDoCrop, Crop image(s) to selected area (irreversible)
    If (filesElected>1)
       Gui, Add, Text, y+20, %filesElected% files are selected.
    If (editingSelectionNow!=1)
       GuiControl, Disable, jpegDoCrop

    If (filesElected<2)
    {
       If (thumbsDisplaying!=1)
       {
          Gui, Add, Button, xs y+10 h%thisBtnHeight% w%btnWid% gBTNautoCropRealtime, &Auto-crop selection
          Gui, Add, Button, x+5 hp w%btnWid% gPanelImgAutoCrop, &Configure auto-crop
       }
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnPerformJpegOp vmainBtnACT, &Perform operation
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnPerformJpegOp, &Perform operation
 
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "JPEG lossless operations: " appTitle)
}

BtnPerformJpegOp(dummy:=0) {
    Static lastInvoked := 1
    If (dummy!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, jpegDesiredOperation
       GuiControlGet, jpegDoCrop
       GuiControlGet, mainBtnACT
    }

    If (A_TickCount - lastInvoked < 150) || (jpegDesiredOperation=1 && jpegDoCrop=0)
    {
       showTOOLtip("WARNING: No operations selected to perform")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

    lastInvoked := A_TickCount
    ForceRefreshNowThumbsList()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchJpegLLoperations()
       Return
    } Else If (currIMGdetails.HasAlpha!=1)
    {
       destroyGDIfileCache()
       r := coreJpegLossLessAction(imgPath, jpegDesiredOperation, jpegDoCrop)
    }

    If (dummy!="extern")
    {
       GuiControl, SettingsGUIA: Disable, mainBtnACT
       SetTimer, reactivateMainBtnACT, -800
    }

    If r
    {
       resultedFilesList[currentFileIndex, 4] := 1
       FlipImgV := FlipImgH := vpIMGrotation := 0
       If (SLDtypeLoaded=3)
          selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])
       showTOOLtip("JPEG operation completed succesfully")
       RefreshImageFile()
    } Else
    {
       SoundBeep, 300, 100
       If (dummy!="extern")
          msgBoxWrapper(appTitle ": ERROR", "The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.", 0, 0, "error")
       Else
          showTOOLtip("ERROR: The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.")
    }

    lastInvoked := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

reactivatemainBtnACT() {
    If (AnyWindowOpen=12 || AnyWindowOpen=18 || AnyWindowOpen=17)
    {
       If (imageLoading=1)
          SetTimer, reactivatemainBtnACT, -600
       Else
          GuiControl, SettingsGUIA: Enable, mainBtnACT
    }
}

batchJpegLLoperations() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && jpegDoCrop=1) || (filesElected>150)
   {
      msgInfos := (jpegDoCrop=1) ? "`n`nThe crop operation IS irreversible!" : ""
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to perform the JPEG transformations on the selected files? There are currently " filesElected " selected files. " msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
 
   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing JPEG lossless operations on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   failedFiles := countFilez := countTFilez := 0

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>3) ? 1 : 0
   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresJpegLL(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("File format conversion: failed to initialize multi-threaded processing")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      If (InStr(file2rem, "||") || !file2rem)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      If !RegExMatch(file2rem, "i)(.\.(jpeg|jpg|jpe))$")
      {
         skippedFiles++
         Continue
      }

      r := coreJpegLossLessAction(file2rem, jpegDesiredOperation, jpegDoCrop)
      If r
      {
         resultedFilesList[thisFileIndex, 4] := 1
         countFilez++
      } Else failedFiles++
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors := "`nFor " groupDigits(failedFiles) " files, the operations failed"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(countFilez " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreJpegLossLessAction(imgPath, jpegOperation, mustCrop) {
    FileGetTime, originalMtime, % imgPath, M
    FileGetTime, originalCtime, % imgPath, C
    FileSetAttrib, -R, %imgPath%
    Sleep, 1
    changeMcursor()
    If (mustCrop=1 && editingSelectionNow=1) || (mustCrop=1 && hasInitSpecialMode=1)
    {
       r1 := GetImgFileDimension(imgPath, imgW, imgH)
       If (relativeImgSelCoords=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       r := FreeImage_JPEGTransformCombined(imgPath, imgPath, jpegOperation - 1, X1, Y1, X2, Y2)
    } Else
    {
       Sleep, -1
       r := FreeImage_JPEGTransform(imgPath, imgPath, jpegOperation - 1)
    }

    If originalMtime
    {
       Sleep, 0
       FileSetTime, % originalMtime, % imgPath, M
       FileSetTime, % originalCtime, % imgPath, C
    }
    Return r
}

toggleImgEditPanelWindow(dummy:="") {
   Static Width := 0, Height := 0, lastInvoked := A_TickCount
   If (AnyWindowOpen!=10 && imgEditPanelOpened!=1 && dummy!="forced") || (A_TickCount - lastInvoked<350)
      Return

   ; WinGetPos, , , nWidth, nHeight, ahk_id %hSetWinGui%
   thisHeight := imgHUDbaseUnit//4 + 2
   thisWidth := imgHUDbaseUnit//2 + 2
   ; If (Width<nWidth-5) || (Height<nHeigh-5)
   ;    panelWinCollapsed := 1

   If (panelWinCollapsed=0)
   {
      Gui, SettingsGUIA: Show, NoActivate w%thisWidth% h%thisHeight%
      Gui, SettingsGUIA: -SysMenu
      WinActivate, ahk_id %PVhwnd%
      WinSet, Transparent, 190, ahk_id %hSetWinGui%
      WinSet, Style, -0xC00000, ahk_id %hSetWinGui% ; WS_CAPTION
      ; WinGetPos, , , Width, Height, ahk_id %hSetWinGui%
      ; WinSet, Disable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 1
   } Else 
   {
      mustCaptureCloneBrush := 0
      WinSet, Transparent, 255, ahk_id %hSetWinGui%
      WinSet, Style, +0xC00000, ahk_id %hSetWinGui% ; WS_CAPTION
      Gui, SettingsGUIA: Show, AutoSize
      Gui, SettingsGUIA: +SysMenu
      ; WinSet, Enable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 0
   }
   lastInvoked := A_TickCount
   interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
}

PanelColorsAdjusterWindow() {
    Global sliderBright, sliderContrst, sliderSatu, realTimePreview, infolummyAdjust
         , infoBright, infoContrst, infoSatu, BtnLumPlus, BtnLumMin, BtnFlipH, infoZatAdjust, UIvpImgAlignCenter
         , BtnGammPlus, BtnGammMin, BtnSatPlus, BtnSatMin, ResizeModeDL, BtnFlipV, infohueAdjust
         , infoRGBchnls, RGBcbList := "-3.0|-2.0|-1.5|-1.0|-0.9|-0.8|-0.7|-0.6|-0.5|-0.4|-0.3|-0.2|-0.1|0.0|0.1|0.2|0.3|0.4|0.5|0.6|0.7|0.8|0.9|1.0|1.5|2.0|3.0"
         , infoRealGammos, infoThreshold, UIimgThreshold, UIrealGammos, infoImgRotation

    If (thumbsDisplaying=1 || StrLen(gdiBitmap)<4 || openingPanelNow=1)
       Return

    openingPanelNow := 1
    setImageLoading()
    showTOOLtip("Opening colors adjustments panel, please wait")
    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(10, A_ThisFunc)
    ForceNoColorMatrix := 0
    If (usrColorDepth=0)
       usrColorDepth := 1

    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    UIimgThreshold := imgThreshold*100
    UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Color matrix|More adjustments|Other options
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|Auto-adjusted colors|Grayscale|Red channel|Green channel|Blue channel|Alpha channel|Inverted colors|Sepia
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%autoAdjustMode% vAutoAdjustMode, Adaptive mixed mode|Increase brightness|Increase contrast
    Gui, Add, ComboBox, x+1 w90 gColorPanelTriggerImageUpdate vusrAdaptiveThreshold, -2000|-100|-50|-2|1|2|50|1000|2000|%usrAdaptiveThreshold%||
    Gui, Add, Checkbox, xs y+2 w%txtWid% gColorPanelTriggerImageUpdate Checked%doSatAdjusts% vdoSatAdjusts, Auto-adjust image saturation level
    Gui, Add, Checkbox, x+5 w90 gColorPanelTriggerImageUpdate Checked%bwDithering% vbwDithering, B/W
    Gui, Add, Text, xs y+8 w%txtWid% gBtnResetBrightness vinfoBright, Brightness: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderBright Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeLumPlus vBtnLumPlus, +
    Gui, Add, Button, x+1 hp wp gBtnChangeLumMin vBtnLumMin, -
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetContrast vinfoContrst, Contrast: ----
    Gui, Add, Slider, y+1 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderContrst Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeGammPlus vBtnGammPlus, -
    Gui, Add, Button, x+1 hp wp gBtnChangeGammMin vBtnGammMin, +
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetSaturation vinfoSatu, Saturation: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderSatu Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatPlus vBtnSatPlus, +
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatMin vBtnSatMin, -
    Gui, Add, Text, xs y+2 w%slide2Wid% gBtnResetRealGamma vinfoRealGammos, Gamma: ----
    Gui, Add, Text, x+5 w%slide2Wid% gBtnResetThreshold vinfoThreshold, Threshold: ----
    Gui, Add, Slider, xs y+2 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIrealGammos Range1-500, % UIrealGammos
    Gui, Add, Slider, x+5 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIimgThreshold Range0-100, % UIimgThreshold
    ; Gui, Add, Checkbox, xs y+15 gColorPanelTriggerImageUpdate Checked%realTimePreview% vrealTimePreview, Update image in real time
    Gui, Add, Text, xs y+8 gBtnResetCHNdec vinfoRGBchnls, RGBA channels balance:
    Gui, Add, ComboBox, x+5 w65 gColorPanelTriggerImageUpdate vchnRdecalage, %RGBcbList%|%chnRdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnGdecalage, %RGBcbList%|%chnGdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnBdecalage, %RGBcbList%|%chnBdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vIntensityAlphaChannel, 1|2|3|4|5|6|7|8|9|10|15|20|25|30|%IntensityAlphaChannel%||

    slide3wid := slide2wid - 42
    Gui, Tab, 2 ; more
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%specialColorFXmode% vspecialColorFXmode, None|Brightness / Contrast|Hue / Saturation / Lightness|Levels adjust|Color tint|Colors balance|Color curve per channel
    Gui, Add, DropDownList, xs y+2 w%slide3Wid% gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXmode% vuiColorCurveFXmode, Brightness (density)|Contrast|Highlights|Shadows|Mid-tones|White saturation|Black saturation
    Gui, Add, DropDownList, x+2 wp gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXchannel% vuiColorCurveFXchannel, Red|Green|Blue|Apply on all channels

    Gui, Add, Text, xs y+10 w%slideWid% gBtnResetHue vinfohueAdjust, Hue: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vhueAdjust Range-300-300, % hueAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetVibrance vinfoZatAdjust, Vibrance: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vzatAdjust Range-300-300, % zatAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetLummy vinfolummyAdjust, Lightness: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vlummyAdjust Range-300-300, % lummyAdjust

    Gui, Tab, 3 ; others
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%IMGresizingMode% vIMGresizingMode, Adapt all images into view|Adapt only large images into view|Fixed to original resolution (100`%)|Custom zoom level|Stretched to window dimensions
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, Centered
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    Gui, Add, Text, xs y+10 w%slide2Wid% gBtnResetRotation vinfoImgRotation, Image rotation: ----
    Gui, Add, Slider, xs y+10 ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vvpIMGrotation Range0-360, % Round(vpIMGrotation)
    Gui, Add, Text, xs y+10 h%thisBtnHeight% +0x200, Flip viewport:
    Gui, Add, Checkbox, x+10 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgV% vFlipImgV, vertically
    Gui, Add, Checkbox, x+5 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgH% vFlipImgH, horizontally
    Gui, Add, Text, xs y+10, Display histogram:
    Gui, Add, DropDownList, x+10 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%showHistogram% vshowHistogram, None|Luminance|Red|Green|Blue|All mixed
    Gui, Add, DropDownList, x+6 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%histogramMode% vhistogramMode, Lows|Balanced|Peaks
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%userimgQuality% vuserimgQuality, High quality image resampling
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%usrTextureBGR% vusrTextureBGR, Auto-generated ambiental textured viewport background
    Gui, Add, Checkbox, xs y+10 gToggleAutoResetImageView Checked%resetImageViewOnChange% vresetImageViewOnChange, Reset all image adjustments on image file change
    ; Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%showHistogram% vshowHistogram, Display the image luminance histogram
    Gui, Add, Text, xs y+10, TIP: right click on the viewport for more options.

    Gui, Tab
    Gui, Add, Button, xs-10 y+15 h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>
    Gui, Add, Button, x+5 hp wp gtoggleImgEditPanelWindow, ▲
    ; Gui, Add, Button, x+5 hp w%btnWid% gCopyImage2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gBtnSaveIMGadjustPanel, &Save or copy
    Gui, Add, Button, x+5 hp wp-25 gBtnResetImageView, &Reset all
    ; Gui, Add, Button, x+5 hp w80 Default gBtnCloseWindow, C&lose
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust viewport image view: " appTitle, winPos)
    Sleep, 1
    updatePanelColorsInfo()
    updatePanelColorSliderz()
    SetTimer, resetOpeningPanel, -300
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
}

resetOpeningPanel() {
    openingPanelNow := 0
}

BtnResetBrightness() {
  lumosAdjust := lumosGrayAdjust := 1
  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.000
  GuiControl, SettingsGUIA:, sliderBright, 1
  INIaction(1, "lumosAdjust", "General")
  INIaction(1, "lumosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetContrast() {
  GammosAdjust := GammosGrayAdjust := 0
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, sliderContrst, 0
  INIaction(1, "GammosAdjust", "General")
  INIaction(1, "GammosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetSaturation() {
  satAdjust := 1
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, sliderSatu, 0
  INIaction(1, "satAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetVibrance() {
  zatAdjust := 0
  GuiControl, SettingsGUIA:, infoZatAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  INIaction(1, "zatAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetLummy() {
  lummyAdjust := 0
  GuiControl, SettingsGUIA:, infoLummyAdjust, 0
  GuiControl, SettingsGUIA:, lummyAdjust, 0
  INIaction(1, "lummyAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetHue() {
  thisValue := (specialColorFXmode=4) ? 100 : 0
  hueAdjust := thisValue
  GuiControl, SettingsGUIA:, infohueAdjust, % thisValue
  GuiControl, SettingsGUIA:, hueAdjust, % thisValue
  INIaction(1, "hueAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRealGamma() {
  realGammos := 1
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.000 
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  INIaction(1, "realGammos", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetThreshold() {
  imgThreshold := 0
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  INIaction(1, "imgThreshold", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetCHNdec() {
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  IntensityAlphaChannel := 1
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 5
  INIaction(1, "chnRdecalage", "General")
  INIaction(1, "chnGdecalage", "General")
  INIaction(1, "chnBdecalage", "General")
  INIaction(1, "IntensityAlphaChannel", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRotation() {
  If (vpIMGrotation=0)
     Return

  vpIMGrotation := 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, infoImgRotation, Image rotation: 0°
  GuiControl, SettingsGUIA: Enable, usrTextureBGR
  INIaction(1, "vpIMGrotation", "General")
  RefreshImageFile()
}

BtnSaveIMGadjustPanel() {
   ForceNoColorMatrix := 0
   CloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   PanelSaveImg()
}

BtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  NextPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

BtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  PreviousPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

updatePanelColorSliderz() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   ; GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   If (imgFxMode=1 || imgFxMode=2 || imgFxMode=3)
   {
      infoSliderBright := (lumosAdjust>1) ? Floor((lumosAdjust - 1)/14*100) : - Floor((1 - lumosAdjust)*100)
      infoSliderContrst := (GammosAdjust<0) ? Floor(Abs(GammosAdjust)/15*100) : - Floor((Abs(GammosAdjust))*100)
      infoSliderSatu := (satAdjust>1) ? Floor((satAdjust - 1)/2*100) : - Floor((1 - satAdjust)*100)
      UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
      GuiControl, SettingsGUIA:, sliderSatu, % infoSliderSatu 
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, UIrealGammos, % UIrealGammos
   } Else If (imgFxMode=4)
   {
      infoSliderBright := (lumosGrayAdjust>1) ? Floor((lumosGrayAdjust - 1)/14*100) :  - Floor((1 - lumosGrayAdjust)*100)
      infoSliderContrst := (GammosGrayAdjust<0) ? Floor(Abs(GammosGrayAdjust)/15*100) : - Floor((Abs(GammosGrayAdjust))*100)
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, sliderSatu, 0
   }

   GuiControl, SettingsGUIA:, UIvpImgAlignCenter, % (imageAligned=5) ? 1 : 0
   lastInvoked := A_TickCount
}

updatePanelColorsInfo() {
   Static colorzFXinfoz := 0, colorzFXminz := 0, colorzFXmaxz := 0
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   If !IsObject(colorzFXinfoz)
   {
      colorzFXinfoz := []
      colorzFXinfoz[1] := ["-", "-", "-"]
      colorzFXinfoz[2] := ["Brightness", "Contrast", "-"]
      colorzFXinfoz[3] := ["Hue", "Saturation", "Lightness"]
      colorzFXinfoz[4] := ["Highlights", "Midtones", "Shadows"]
      colorzFXinfoz[5] := ["Hue", "Amount", "-"]
      colorzFXinfoz[6] := ["Cyan / Red", "Magenta / Green", "Yellow / Blue"]
      colorzFXinfoz[7] := ["-", "-", "Amount"]
      colorzFXminz := []
      colorzFXminz[1] := [-300, -300, -300]
      colorzFXminz[2] := [-255, -100, -300]
      colorzFXminz[3] := [-180, -100, -100]
      colorzFXminz[4] := [0, -100, 0]
      colorzFXminz[5] := [-180, 0, -300]
      colorzFXminz[6] := [-100, -100, -100]
      colorzFXminz[7] := [-300, -300, -100]
      colorzFXmaxz := []
      colorzFXmaxz[1] := [300, 300, 300]
      colorzFXmaxz[2] := [255, 100, 300]
      colorzFXmaxz[3] := [180, 100, 100]
      colorzFXmaxz[4] := [100, 100, 100]
      colorzFXmaxz[5] := [180, 100, 300]
      colorzFXmaxz[6] := [100, 100, 100]
      colorzFXmaxz[7] := [300, 300, 100]
   }

   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, imgFxMode, SettingsGUIA:, imgFxMode
   GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   thisMinA := colorzFXminz[specialColorFXmode, 1]
   thisMinB := colorzFXminz[specialColorFXmode, 2]
   thisMinC := colorzFXminz[specialColorFXmode, 3]
   thisMaxA := colorzFXmaxz[specialColorFXmode, 1]
   thisMaxB := colorzFXmaxz[specialColorFXmode, 2]
   thisMaxC := colorzFXmaxz[specialColorFXmode, 3]
   If (specialColorFXmode=7 && uiColorCurveFXmode=1)
   {
      thisMaxC := 255
      thisMinC := -255
   } Else If (specialColorFXmode=7 && uiColorCurveFXmode>=6)
   {
      thisMaxC := 255
      thisMinC := 0
   }

   GuiControl, SettingsGUIA: +Range%thisMinA%-%thisMaxA%, hueAdjust
   GuiControl, SettingsGUIA: +Range%thisMinB%-%thisMaxB%, zatAdjust
   GuiControl, SettingsGUIA: +Range%thisMinC%-%thisMaxC%, lummyAdjust

   infolumosAdjust := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   infoGammosAdjust := (imgFxMode=4) ? Round(GammosGrayAdjust, 3) : Round(GammosAdjust, 3)
   infoSatAdjust := Round(satAdjust, 3)
   infoZoom := Round(zoomLevel*100)
   GuiControl, SettingsGUIA:, infoBright, % "Brightness: " infolumosAdjust
   GuiControl, SettingsGUIA:, infoContrst, % "Contrast: " infoGammosAdjust
   GuiControl, SettingsGUIA:, infoSatu, % "Saturation: " infoSatAdjust
   GuiControl, SettingsGUIA:, infoRealGammos, % "Gamma: " realGammos
   GuiControl, SettingsGUIA:, infoThreshold, % "Threshold: " imgThreshold
   GuiControl, SettingsGUIA:, infoImgRotation, % "Image rotation: " vpIMGrotation "° "

   GuiControl, SettingsGUIA:, infohueAdjust, % colorzFXinfoz[specialColorFXmode, 1] ": " hueAdjust
   GuiControl, SettingsGUIA:, infoZatAdjust, % colorzFXinfoz[specialColorFXmode, 2] ": " zatAdjust
   GuiControl, SettingsGUIA:, infoLummyAdjust, % colorzFXinfoz[specialColorFXmode, 3] ": " lummyAdjust

   If (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270)
      GuiControl, SettingsGUIA: Enable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Disable, usrTextureBGR

   If (usrColorDepth>1)
      GuiControl, SettingsGUIA: Enable, ColorDepthDithering
   Else
      GuiControl, SettingsGUIA: Disable, ColorDepthDithering

   act := (IMGresizingMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   act := (imgFxMode=2) || (imgFxMode=4 && o_bwDithering=0) || (imgFxMode=9) || (imgFxMode=10) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRealGammos
   GuiControl, % act, UIrealGammos

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Enable, usrTextureBGR

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, UIvpImgAlignCenter
   Else
      GuiControl, SettingsGUIA: Enable, UIvpImgAlignCenter

   If (imgFxMode=2)
   {
      GuiControl, SettingsGUIA: Enable, sliderSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Enable, BtnSatPlus
      GuiControl, SettingsGUIA: Enable, BtnSatMin
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Enable, infoSatu
   } Else If (imgFxMode=4 && o_bwDithering=0)
   {
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoBright
      GuiControl, SettingsGUIA: Disable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, BtnLumPlus
      GuiControl, SettingsGUIA: Disable, BtnLumMin
      GuiControl, SettingsGUIA: Disable, BtnGammPlus
      GuiControl, SettingsGUIA: Disable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Disable, sliderBright
      GuiControl, SettingsGUIA: Disable, sliderContrst
   }

   If (imgFxMode=4)
      GuiControl, SettingsGUIA: Enable, bwDithering
   Else
      GuiControl, SettingsGUIA: Disable, bwDithering

   act := (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) && (o_bwDithering=0) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, zatAdjust
   GuiControl, % act, infoZatAdjust
   GuiControl, % act, hueAdjust
   GuiControl, % act, infohueAdjust
   GuiControl, % act, lummyAdjust
   GuiControl, % act, infoLummyAdjust
   GuiControl, % act, specialColorFXmode
   GuiControl, % act, UIimgThreshold
   GuiControl, % act, infoThreshold
   act := (imgFxMode=1 || imgFxMode=8) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % act, IntensityAlphaChannel
   canEnableThese := InStr(act, "enable") ? 1 : 0

   act := (specialColorFXmode=7 && canEnableThese=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, uiColorCurveFXmode
   GuiControl, % act, uiColorCurveFXchannel

   act := (imgFxMode=2 || imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRGBchnls
   GuiControl, % act, chnRdecalage
   GuiControl, % act, chnGdecalage
   GuiControl, % act, chnBdecalage

   act := (imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, autoAdjustMode
   GuiControl, % act, usrAdaptiveThreshold
   GuiControl, % act, doSatAdjusts

   If (colorzFXinfoz[specialColorFXmode, 1]="-")
   {
      GuiControl, SettingsGUIA: Disable, infohueAdjust
      GuiControl, SettingsGUIA: Disable, hueAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infohueAdjust
      GuiControl, SettingsGUIA: Enable, hueAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 2]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoZatAdjust
      GuiControl, SettingsGUIA: Disable, zatAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoZatAdjust
      GuiControl, SettingsGUIA: Enable, zatAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 3]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoLummyAdjust
      GuiControl, SettingsGUIA: Disable, lummyAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoLummyAdjust
      GuiControl, SettingsGUIA: Enable, lummyAdjust
   }

   lastInvoked := A_TickCount
}

btnResetImageView() {
  ; GuiControlGet, realTimePreview
   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

  ForceNoColorMatrix := 0
  GuiControl, SettingsGUIA: Choose, imgFxMode, 1
  GuiControl, SettingsGUIA: Choose, usrColorDepth, 1
  GuiControl, SettingsGUIA: Choose, usrAdaptiveThreshold, 5
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 5
  GuiControl, SettingsGUIA: Choose, IMGresizingMode, 1
  GuiControl, SettingsGUIA: Choose, specialColorFXmode, 1
  GuiControl, SettingsGUIA:, bwDithering, 0
  ColorDepthDithering := usrColorDepth := IMGresizingMode := imgFxMode := satAdjust := lumosAdjust := lumosGrayAdjust := specialColorFXmode := IntensityAlphaChannel := 1
  vpIMGrotation := zatAdjust := hueAdjust := GammosAdjust := GammosGrayAdjust := 0
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  updatePanelColorsInfo()
  UIrealGammos := 200
  realGammos := usrAdaptiveThreshold := infoBright := infoSatu := 1
  bwDithering := infoContrst := sliderSatu := sliderBright := sliderContrst := 0
  FlipImgV := FlipImgH := usrTextureBGR := vpIMGrotation := UIimgThreshold := imgThreshold := 0

  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.009
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0.00
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.00
  GuiControl, SettingsGUIA:, hueAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  GuiControl, SettingsGUIA:, sliderSatu, 0
  GuiControl, SettingsGUIA:, sliderBright, 0
  GuiControl, SettingsGUIA:, sliderContrst, 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, usrTextureBGR, 0
  GuiControl, SettingsGUIA:, FlipImgV, 0
  GuiControl, SettingsGUIA:, FlipImgH, 0
  GuiControl, SettingsGUIA:, ColorDepthDithering, 1
  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  defineColorDepth()
  SetTimer, WriteSettingsColorAdjustments, -90
  dummyTimerDelayiedImageDisplay(50)
}

ColorPanelTriggerImageUpdate(dummy:=0) {
   Critical, On
   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, imgFxMode
   GuiControlGet, usrAdaptiveThreshold
   GuiControlGet, doSatAdjusts
   GuiControlGet, autoAdjustMode
   GuiControlGet, showHistogram
   GuiControlGet, sliderBright
   GuiControlGet, sliderContrst
   GuiControlGet, sliderSatu
   GuiControlGet, bwDithering
   GuiControlGet, UIvpImgAlignCenter
   GuiControlGet, FlipImgV
   GuiControlGet, FlipImgH
   GuiControlGet, chnRdecalage
   GuiControlGet, chnGdecalage
   GuiControlGet, chnBdecalage
   GuiControlGet, IntensityAlphaChannel
   GuiControlGet, zatAdjust
   GuiControlGet, hueAdjust
   GuiControlGet, lummyAdjust
   GuiControlGet, uiColorCurveFXchannel
   GuiControlGet, uiColorCurveFXmode
   GuiControlGet, specialColorFXmode
   GuiControlGet, UIimgThreshold
   GuiControlGet, UIrealGammos
   GuiControlGet, userimgQuality
   GuiControlGet, vpIMGrotation
   GuiControlGet, usrTextureBGR
   GuiControlGet, usrColorDepth
   GuiControlGet, ColorDepthDithering
   GuiControlGet, histogramMode

   ; GuiControlGet, realTimePreview
   If (dummy!="ignore-zoom")
   {
      GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
      imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   }

   defineColorDepth()
   ForceNoColorMatrix := 0
   If (vpIMGrotation=1 || vpIMGrotation>358)
      vpIMGrotation := 0

   imgThreshold := Round(UIimgThreshold/100, 3)
   If (imgFxMode!=3 && imgFxMode!=1)
      realGammos := (UIrealGammos>200) ? Round((UIrealGammos*3 - 500)/100, 3) : Round(UIrealGammos/200, 3)

   If (imgFxMode=2)
   {
      lumosAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
      satAdjust := (sliderSatu>0) ? 0.02*sliderSatu + 1 : 0.01*Abs(sliderSatu + 100)
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosGrayAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
   }

   If (imgFxMode=3)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
      updatePanelColorSliderz()
   }

   If (imgFxMode!=4)
   {
      GuiControl, SettingsGUIA:, bwDithering, 0
      bwDithering := 0
   }

   If (prevvpIMGrotation!=vpIMGrotation)
   {
      mustReloadIMG := 1
      prevvpIMGrotation := vpIMGrotation
   }

   updatePanelColorsInfo()
   filterDelayiedImageDisplay()
   SetTimer, WriteSettingsColorAdjustments, -150
}

PanelFileFormatConverter() {
    Global btnFldr, IDbtnConvert, editF5
    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(15, A_ThisFunc)
    btnWid := 110
    txtWid := 280
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    initFIMGmodule()
    ReadSettingsFormatConvert()
    Gui, Add, Text, x15 y15 Section, Destination format:
    Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    Gui, Add, Text, xs y+10, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 AltSubmit gTglOverwriteFiles Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Checkbox, xs y+10 gTglKeepOriginals Checked%OnConvertKeepOriginals% vOnConvertKeepOriginals, &Keep original file[s]
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder:
    Gui, Add, Edit, xp+10 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to convert: %filesElected%.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w90 gBTNconvertNow Default vIDbtnConvert, &Convert
    Gui, Add, Button, x+5 hp wp gBTNconvertHelp, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file format conversion: " appTitle)
}

BTNconvertHelp() {
    msgBoxWrapper(appTitle ": HELP", "File format conversion relies primarly on the FreeImage library.`n`nOn conversion, images will be converted to 24 bits or 32 bits.`n`nFailures can occur if the images are very large (above 250 MPx) and the destination format does not allow such large images, if there is insufficient system memory or... if file access is denied when attempting to write files.`n`nQuality option applies for JPG, JP2, J2K, JXR and WEBP file formats.", -1, 0, 0)
}

TglKeepOriginals() {
    GuiControlGet, OnConvertKeepOriginals
    INIaction(1, "OnConvertKeepOriginals", "General")
}

TglOverwriteFiles() {
    GuiControlGet, userActionConflictingFile
    INIaction(1, "userActionConflictingFile", "General")
}

TglDesiredSaveFormat() {
    GuiControlGet, userDesireWriteFMT
    INIaction(1, "userDesireWriteFMT", "General")
}

BTNconvertNow() {
   If (AnyWindowOpen=15)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, ResizeDestFolder
   GuiControlGet, OnConvertKeepOriginals
   GuiControlGet, userActionConflictingFile
   GuiControlGet, userDesireWriteFMT
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality

   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
      Return
   }

   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "OnConvertKeepOriginals", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userActionConflictingFile", "General")
   INIaction(1, "userDesireWriteFMT", "General")
   If (markedSelectFile>1)
   {
      CloseWindow()
      batchConvert2format()
   } Else convert2format()
}

PanelAdjustImageCanvasSize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    thisBtnHeight := createSettingsGUI(28, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "ResizeKeepAratio", "General", 1)
    INIaction(0, "ResizeInPercentage", "General", 1)
    INIaction(0, "adjustCanvasCentered", "General", 1)
    INIaction(0, "adjustCanvasMode", "General", 1)
    INIaction(0, "adjustCanvasNoBgr", "General", 1)
    INIaction(0, "FillAreaColor", "General", 3)
    INIaction(0, "FillAreaOpacity", "General", 2, 1, 255)
    If (ShowAdvToolbar=1)
    {
       FillAreaColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       FillAreaOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
    }

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    r1 := Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If r1
    {
       CloseWindow()
       SoundBeep, 300, 100
       showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Edit, x15 y15 w1 r1 limit7 -multi -wrap, -
    Gui, Add, Text, xs y+10, Set new canvas dimensions (W x H):
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15, Resulted dimensions and background color:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % oImgW
    Gui, Add, Edit, x+5 wp r1 Disabled -wrap vResultEditHeight, % oImgH
    Gui, Add, ListView, x+5 wp hp %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, ComboBox, x+5 wp vFillAreaOpacity, 25|50|75|100|150|200|255|%FillAreaOpacity%||
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P

    Gui, Add, Checkbox, xs y+10 hp Checked%adjustCanvasNoBgr% vadjustCanvasNoBgr gupdateUIadjustCanvasPanel, Transparent background 
    Gui, Add, Checkbox, xs y+10 Section hp Checked%adjustCanvasMode% vadjustCanvasMode gupdateUIadjustCanvasPanel, Add margins to current image dimensions:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddTop, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddLeft, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddCenter, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddRight, 0

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddBottom, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNadjustCanvasAction Default, &Adjust canvas
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image canvas size: " appTitle)
    updateUIadjustCanvasPanel()
}

EditCanvasMargins() {
   If (AnyWindowOpen=28)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, userAddTop
   GuiControlGet, userAddBottom
   GuiControlGet, userAddCenter
   GuiControlGet, userAddLeft
   GuiControlGet, userAddRight
   If (!userAddTop || userAddTop<0)
      userAddTop := 0
   If (!userAddBottom || userAddBottom<0)
      userAddBottom := 0
   If (!userAddCenter || userAddCenter<0)
      userAddCenter := 0
   If (!userAddLeft || userAddLeft<0)
      userAddLeft := 0
   If (!userAddRight || userAddRight<0)
      userAddRight := 0

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   thisWidth := oImgW + userAddLeft + userAddRight + userAddCenter
   thisHeight := oImgH + userAddTop + userAddBottom + userAddCenter
   GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
   GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
}

updateUIadjustCanvasPanel() {
    If (AnyWindowOpen=28)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode

    If (adjustCanvasMode=1)
    {
       EditCanvasMargins()
       GuiControl, SettingsGUIA: Disable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
       GuiControl, SettingsGUIA: Disable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Disable, userEditHeight
       GuiControl, SettingsGUIA: Disable, userEditWidth
       GuiControl, SettingsGUIA: Enable, userAddCenter
       GuiControl, SettingsGUIA: Enable, userAddTop
       GuiControl, SettingsGUIA: Enable, userAddBottom
       GuiControl, SettingsGUIA: Enable, userAddLeft
       GuiControl, SettingsGUIA: Enable, userAddRight
    } Else
    {
       EditResizeWidth()
       GuiControl, SettingsGUIA: Disable, userAddCenter
       GuiControl, SettingsGUIA: Disable, userAddTop
       GuiControl, SettingsGUIA: Disable, userAddBottom
       GuiControl, SettingsGUIA: Disable, userAddLeft
       GuiControl, SettingsGUIA: Disable, userAddRight
       GuiControl, SettingsGUIA: Enable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
       GuiControl, SettingsGUIA: Enable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Enable, userEditHeight
       GuiControl, SettingsGUIA: Enable, userEditWidth
    }

    If (adjustCanvasNoBgr=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
    }

    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
}

BTNadjustCanvasAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, FillAreaOpacity
    GuiControlGet, userAddTop
    GuiControlGet, userAddBottom
    GuiControlGet, userAddCenter
    GuiControlGet, userAddLeft
    GuiControlGet, userAddRight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResultEditWidth

    If (!userAddTop || userAddTop<0)
       userAddTop := 0
    If (!userAddBottom || userAddBottom<0)
       userAddBottom := 0
    If (!userAddCenter || userAddCenter<0)
       userAddCenter := 0
    If (!userAddLeft || userAddLeft<0)
       userAddLeft := 0
    If (!userAddRight || userAddRight<0)
       userAddRight := 0

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If (ResultEditWidth=oImgW && ResultEditHeight=oImgH)
    {
       showTOOLtip("WARNING: The new dimension is equal with the initial one")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    If (ResultEditWidth*ResultEditHeight>maxGDIbmpSize) || (ResultEditWidth>32500) || (ResultEditHeight>32500)
    {
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "ResizeKeepAratio", "General")
    INIaction(1, "ResizeInPercentage", "General")
    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasCentered", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
    INIaction(1, "FillAreaColor", "General")
    FillAreaOpacity := Trimmer(FillAreaOpacity)
    FillAreaOpacity := StrReplace(FillAreaOpacity, "%")
    FillAreaOpacity := StrReplace(FillAreaOpacity, A_Space)
    If !isNumber(FillAreaOpacity)
       FillAreaOpacity := 255

    clampInRange(FillAreaOpacity, 5, 255)
    INIaction(1, "FillAreaOpacity", "General")
  
    CloseWindow()
    ToggleEditImgSelection("show-edit")
    ChangeImageCanvasSize(ResultEditWidth, ResultEditHeight, userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter, 0)
}

PanelResizeImageWindow() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight, btnFldr, editF5

    ToolTip, Please wait...
    filesElected := getSelectedFiles(0, 1)
    multipleFilesMode := (filesElected>1) ? 1 : 0
    If (multipleFilesMode=0 && !PanelsCheckFileExists())
    {
       ToolTip
       Return
    }

    thisBtnHeight := createSettingsGUI(4, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsImageProcessing()
    img2resizePath := getIDimage(currentFileIndex)
    If (multipleFilesMode=0)
    {
       zPlitPath(img2resizePath, 0, fileNamu, folderu)
       r1 := GetImgFileDimension(img2resizePath, oImgW, oImgH)
       FileGetSize, fileSizu, % img2resizePath, K
       If !r1
       {
          BtnCloseWindow()
          showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
          SoundBeep, 300, 100
          img2resizePath := ""
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    } Else
    {
       oImgW := ResolutionWidth
       oImgH := ResolutionHeight
    }

    initFIMGmodule()
    If (editingSelectionNow!=1)
       ResizeWithCrop := 0

    If (resetImageViewOnChange=1)
       ResizeApplyEffects := 0

    Gui, Add, Tab3, , General|File(s) destination
    Gui, Tab, 1
    If (multipleFilesMode=1)
    {
       Gui, Add, Text, x+15 y+15 Section, Resize image to (W x H)
    } Else
    {
       Gui, Add, Text, x+15 y+15 Section, Original image dimensions:
       Gui, Add, Text, xs+15 y+5, %oImgW% x %oImgH% pixels. %fileSizu% kilobytes.
       Gui, Add, Text, xs y+10, Resize image to (W x H)
    }

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp +0x1000 gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    If (multipleFilesMode!=1)
       Gui, Add, Text, xs y+15, Result (W x H) in pixels
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % (multipleFilesMode=1) ? "--" : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 Disabled -wrap vResultEditHeight, % (multipleFilesMode=1) ? "--" : oImgH
    thisRotation := (vpIMGrotation=0) ? ResizeRotationUser : vpIMGrotation
    otherRotation := (vpIMGrotation=thisRotation) ? ResizeRotationUser : vpIMGrotation
    Gui, Add, ComboBox, x+5 wp+30 gTglRszRotation vResizeRotationUser, Rotate: 0°|45°|90°|135°|180°|225°|270°|315°|%thisRotation%°||%otherRotation%°
    Gui, Add, Checkbox, xs y+10 hp +0x1000 gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp +0x1000 gTglRszQualityHigh Checked%ResizeQualityHigh% vResizeQualityHigh, High quality resampling
    Gui, Add, Checkbox, xs y+10 gTglRszCropping Checked%ResizeWithCrop% vResizeWithCrop, Crop image(s) to the viewport selection
    Gui, Add, Checkbox, xp+10 y+10 gTglRszCropping Checked%ResizeCropAfterRotation% vResizeCropAfterRotation, Perform image crop after image rotation (as in the viewport)
    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply color adjustments and image mirroring`nactivated in the main window

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15, If no destination folder is chosen,`nthe original files may be overwritten.
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the following folder
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 , On file name conflicts
    Gui, Add, DropDownList, x+5 w150 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    If (multipleFilesMode=1)
    {
       Gui, Add, DropDownList, xs y+10 w%txtWid% gTglRszUnsprtFrmt AltSubmit Choose%userUnsprtWriteFMT% vuserUnsprtWriteFMT, Skip files in unsupported write formats|Try to preserve file formats, convert unsupported to...|Convert all the files to...
       Gui, Add, DropDownList, xs y+5 w85 AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }

    If (resetImageViewOnChange=1)
       GuiControl, Disable, ResizeApplyEffects

    If (editingSelectionNow!=1)
    {
       GuiControl, Disable, ResizeWithCrop
       GuiControl, Disable, ResizeCropAfterRotation
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Tab
    If (multipleFilesMode=1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs-15 y+10, %filesElected% files are selected for processing.`nMulti-threaded processing not yet implemented.
       Gui, Font, Normal
       Gui, Add, Button, xp y+10 h%thisBtnHeight% w%btnWid% Default gBTNsaveResizedIMG, &Process images
       Gui, Add, Button, x+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       If (userUnsprtWriteFMT=1)
          GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
    } Else
    {
       Gui, Add, Button, xs-15 y+20 h%thisBtnHeight% w%btnWid% gBtnCopy2ClipResizedIMG, &Copy to clipboard
       Gui, Add, Button, x+5 hp wp Default gBTNsaveResizedIMG, &Save image as...
       Gui, Add, Button, xs-15 y+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }
    ToolTip
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / rotate / crop image(s): " appTitle)
}

BtnInvokePanelSimpleResizeRotate() {
   BtnCloseWindow()
   Sleep, 25
   PanelSimpleResizeRotate("forced")
}

BTNchangeResizeDestFolder() {
   If (AnyWindowOpen=4)
      EditResizeWidth()

   SelectImg := openFoldersDialogWrapper("S2", ResizeDestFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   } Else
   {
      GuiControl, SettingsGUIA:, ResizeDestFolder, % OutDir
      ResizeDestFolder := OutDir
      INIaction(1, "ResizeDestFolder", "General")
   }
}

setForceRefreshThumbsFilesIndex(onlySelected) {
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1 && onlySelected=1)
         Continue

      resultedFilesList[A_Index, 4] := 1
   }
   ForceRefreshNowThumbsList()
}

batchIMGresizer(desiredW, desiredH, isPercntg, dontAsk:=0) {
   cleanResizeUserOptionsVars()
   If (!desiredH || !desiredW
   || desiredW<1 || desiredH<1)
   || ((desiredW<5 || desiredH<5) && (isPercntg!=1))
   {
      showTOOLtip("WARNING: Incorrect dimensions given")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (dontAsk!="yes")
   {
      If (filesElected>100)
      {
         overwriteWarning := (ResizeUseDestDir!=1) ? "`n`nWARNING: All the original files will be overwritten!" : "`n`nThe files will be saved in " ResizeDestFolder "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to process multiple images in one go. There are " filesElected " selected files for this operation. " overwriteWarning, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      } Else Return
   }

   BtnCloseWindow()
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   startOperation := A_TickCount
   CurrentSLD := ""
   thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
   If (ResizeKeepAratio=1 && isPercntg=1)
      desiredW := desiredH

   showTOOLtip("Processing " filesElected " images, please wait")
   prevMSGdisplay := A_TickCount
   countTFilez := countFilez := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   failedFiles := countFilez := skippedFiles := 0
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      countTFilez++
      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (!FileExist(imgPath) || !imgPath) || (!RegExMatch(imgPath, saveTypesRegEX) && userUnsprtWriteFMT=1)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) "files were skipped"

         showTOOLtip("Processing images, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      fOutDir := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      If (userUnsprtWriteFMT=3)
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else If (userUnsprtWriteFMT=2 && !RegExMatch(imgPath, saveTypesRegEX))
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else
         destImgPath := fOutDir "\" OutFileName

      If (userUnsprtWriteFMT!=1 || ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      oBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(oBitmap)<3
      {
         failedFiles++
         Continue
      }

      Gdip_GetImageDimensions(oBitmap, imgW, imgH)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, ResizeKeepAratio, newW, newH)
      If (z=-1 || z=1)
      {
         failedFiles++
         trGdip_DisposeImage(oBitmap, 1)
         Continue
      }

      r := coreResizeIMG(imgPath, newW, newH, destImgPath, 0, 0, ResizeRotationUser, oBitmap, imgW, imgH, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (editingSelectionNow=1 && relativeImgSelCoords=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

WriteSettingsResizePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "ResizeApplyEffects", "General")
  INIaction(1, "ResizeCropAfterRotation", "General")
  INIaction(1, "ResizeInPercentage", "General")
  INIaction(1, "ResizeKeepAratio", "General")
  INIaction(1, "ResizeRotationUser", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeWithCrop", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

WriteSettingsResizeSimplePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "SimpleOperationsFlipV", "General")
  INIaction(1, "SimpleOperationsFlipH", "General")
  INIaction(1, "SimpleOperationsDoCrop", "General")
  INIaction(1, "SimpleOperationsRotateAngle", "General")
  INIaction(1, "SimpleOperationsScaleXimgFactor", "General")
  INIaction(1, "SimpleOperationsScaleYimgFactor", "General")
  INIaction(1, "ResizeMustPerform", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, isKeepRatio, ByRef newW, ByRef newH) {
   r := 0
   If (isPercntg=1)
   {
      newW := Round((imgW/100)*desiredW)
      newH := Round((imgH/100)*desiredH)
      If (newW<10 && newH<10)
         r := -1
   } Else If (isKeepRatio=1)
   {
      calcIMGdimensions(imgW, imgH, desiredW, desiredH, newW, newH)
      If (newW<10 && newH<10)
         r := -1
   } Else
   {
      newW := desiredW
      newH := desiredH
   }

   If (newW*newH>536848912) || (newW>32100) || (newH>32100)
      r := 1
   Return r
}

filesListApplyColors() {
    Static prevFXmode := "n"

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through mode")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && imgFxMode>1)
   {
      If (filesElected>200)
      {
         msgResult := msgBoxWrapper(appTitle ": Apply colors", "All the images in supported writing formats will be processed accordingly to the color adjustments of the viewport. The original files will be overwritten. Do you want to continue?", 4, 0, "question")
         If !InStr(msgResult, "yes")
            Return
      }

      ResizeMustPerform := ResizeUseDestDir := 0
      ResizeInPercentage := ResizeApplyEffects := 1
      userActionConflictingFile := userUnsprtWriteFMT := 1
      ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
      ResultEditWidth := ResultEditHeight := 100
      WriteSettingsResizePanel()
      batchIMGresizer(100, 100, ResizeInPercentage, "yes")
   } Else
   {
      imgPath := resultedFilesList[currentFileIndex, 1]
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !RegExMatch(imgPath, saveTypesRegEX)
      {
         showTOOLtip("ERROR: Image file is in an unsupported write format")
         SoundBeep, 300, 100
      } Else
      {
         destroyGDIfileCache()
         ResizeMustPerform := ResizeUseDestDir := 0
         ResizeInPercentage := ResizeApplyEffects := 1
         userActionConflictingFile := userUnsprtWriteFMT := 1
         ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
         ResultEditWidth := ResultEditHeight := 100
         ; WriteSettingsResizePanel()
         GetImgFileDimension(imgPath, imgW, imgH, 0)
         r := coreResizeIMG(imgPath, imgW, imgH, imgPath, 1, 0, 0, 1, imgW, imgH)
         If r
         {
            SoundBeep, 300, 100
            showTOOLtip("ERROR: Unable to save imagel file - unknown error:`n" OutFileName "`n" OutDir "\")
         } Else
         {
            resultedFilesList[currentFileIndex, 4] := 1
            If (SLDtypeLoaded=3)
               selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

            showTOOLtip("Viewport colour effects applied on the image:`n" OutFileName "`n" OutDir "\")
         }
      }
   }

   imgFxMode := 1
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

filesListFlipHimage() {
   coreQuickImageFilesListActions(2)
}

filesListFlipVimage() {
   coreQuickImageFilesListActions(3)
}

filesListFlipRotatePlus() {
   coreQuickImageFilesListActions(6)
}

filesListFlipRotateMinus() {
   coreQuickImageFilesListActions(8)
}

coreQuickImageFilesListActions(actu) {
   initFIMGmodule()
   countNotJpegs := firstu := 0
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1)
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         imgPath := resultedFilesList[A_Index, 1]
         If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && imgPath)
         {
            countNotJpegs++
            If !firstu
               firstu := A_Index
         }
         If (countNotJpegs>3)
            Break
      }
   }

   imgPath := resultedFilesList[currentFileIndex, 1]
   If (RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && countNotJpegs<2)
   {
      hasExec := 1
      jpegDesiredOperation := actu
      jpegDoCrop := 0
      BtnPerformJpegOp("extern")
   }

   If (countNotJpegs=1 && firstu)
   {
      hasExec := 0
      currentFileIndex := firstu
   }

   If (hasExec!=1)
   {
      ResizeMustPerform := 0 
      SimpleOperationsFlipV := (actu=3) ? 1 : 0
      SimpleOperationsFlipH := (actu=2) ? 1 : 0
      SimpleOperationsDoCrop := 0
      SimpleOperationsRotateAngle := 1
      If (actu=6)  ; 90 degrees rotation
         SimpleOperationsRotateAngle := 2
      Else If (actu=8) ; -90 degrees rotation 
         SimpleOperationsRotateAngle := 4

      SimpleOperationsScaleXimgFactor := 100
      SimpleOperationsScaleYimgFactor := 100
      ResizeQualityHigh := ResizeInPercentage := 1
      ResizeUseDestDir := 0
      cleanResizeUserOptionsVars()
      BtnPerformSimpleProcessing("no-prompt", "extern")
   }
}

BTNsaveResizedIMG() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResultEditWidth
    GuiControlGet, ResultEditHeight
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResizeApplyEffects
    GuiControlGet, ResizeCropAfterRotation
    GuiControlGet, ResizeDestFolder
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, ResizeQualityHigh
    GuiControlGet, ResizeRotationUser
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeWithCrop
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    EditResizeWidth()
    cleanResizeUserOptionsVars()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, userUnsprtWriteFMT
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
       If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
          Return
       }

       WriteSettingsResizePanel()
       If (ResizeUseDestDir=1)
          INIaction(1, "ResizeDestFolder", "General")

       batchIMGresizer(userEditWidth, userEditHeight, ResizeInPercentage)
       Return
    }

   If (!ResultEditHeight || !ResultEditWidth
   || ResultEditWidth<5 || ResultEditHeight<5)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   }

   If (ResultEditWidth*ResultEditHeight>536848912) || (ResultEditWidth>32100) || (ResultEditHeight>32100)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutFileNameNoExt, fileEXT)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : OutDir "\" OutFileNameNoExt
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." fileEXT)
           defFMTindex := A_Index
   }

   file2save := openFileDialogWrapper("S", "PathMustExist", startPath, "Save processed image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      zPlitPath(file2save, 0, OutFileName, OutDir)
      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      GetImgFileDimension(img2resizePath, imgW, imgH, 0)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
      If (z=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
         Return
      } Else If (z=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceed the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
         Return
      }

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      SetTimer, WriteSettingsResizePanel, -90
      r := coreResizeIMG(img2resizePath, newW, newH, file2save, 0, 0, ResizeRotationUser, 1, imgW, imgH)
      If r
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... Unknown error.`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         Return
      }

      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      SoundBeep, 900, 100
      showTOOLtip("Processed image saved`n" OutFileName "`n`n" OutDir "\")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnCopy2ClipResizedIMG() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResultEditWidth
   GuiControlGet, ResultEditHeight
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeQualityHigh
   GuiControlGet, ResizeApplyEffects
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation

   EditResizeWidth()
   cleanResizeUserOptionsVars()

   GetImgFileDimension(img2resizePath, imgW, imgH, 0)
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
      Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

   z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
   If (z=-1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   } Else If (z=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   showTOOLtip("Processing image, please wait")
   r := coreResizeIMG(img2resizePath, newW, newH, "--", 0, 1, ResizeRotationUser, 1, imgW, imgH)
   SoundBeep, % r ? 300 : 900, 100
   ToolTip
   If !r
      showTOOLtip("Processed image copied to clipboard")
   Else 
      msgBoxWrapper(appTitle ": ERROR", "Unable to copy the processed image to the clipboard.`nError code: " r, 0, 0, "error")

   SetTimer, RemoveTooltip, % -msgDisplayTime//3
   SetTimer, ResetImgLoadStatus, -150
}

EditResizeWidth() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeRotationUser
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser
   
   If (A_TickCount - lastEditRHChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRWChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditHeight, % Round(userEditWidth)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditWidth<1 || !userEditWidth)
      userEditWidth := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRWChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      calcIMGdimensions(oImgW, oImgH, thisWidth, 90000*oImgH, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newH/oimgH)*100) : newH
      GuiControl, SettingsGUIA:, userEditHeight, % Round(newValue)

      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

EditResizeHeight() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser

   If (A_TickCount - lastEditRWChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRHChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditWidth, % Round(userEditHeight)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditHeight<1 || !userEditHeight)
      userEditHeight := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRHChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      calcIMGdimensions(oImgW, oImgH, 90000*oImgW, thisHeight, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newW/oimgW)*100) : newW
      GuiControl, SettingsGUIA:, userEditWidth, % Round(newValue)
      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

TglRszInPercentage() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
   If (AnyWindowOpen!=18)
   {
      filesElected := getSelectedFiles()
      If (filesElected>1)
      {
         oImgW := ResolutionWidth
         oImgH := ResolutionHeight
      } Else If (AnyWindowOpen=28)
      {
         whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
         Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
      } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

      GuiControl, SettingsGUIA:, userEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, userEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
      If (filesElected<2)
         EditResizeWidth()
   }

   INIaction(1, "ResizeInPercentage", "General")
}

TglRszKeepAratio() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, ResizeKeepAratio
   If (!markedSelectFile || ResizeKeepAratio=1 && ResizeInPercentage=1)
      EditResizeWidth()

   INIaction(1, "ResizeKeepAratio", "General")
}

TglRszUnsprtFrmt() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userUnsprtWriteFMT
   GuiControlGet, userDesireWriteFMT
   If (userUnsprtWriteFMT>1)
      GuiControl, SettingsGUIA: Enable, userDesireWriteFMT
   Else
      GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
   INIaction(1, "userDesireWriteFMT", "General")
}

cleanResizeUserOptionsVars() {
    ResizeRotationUser := StrReplace(ResizeRotationUser, ":")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "°")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "rotate")
    ResizeRotationUser := Trimmer(ResizeRotationUser)

    If (SimpleOperationsRotateAngle=2)
       simpleOpRotationAngle := 90
    Else If (SimpleOperationsRotateAngle=3)
       simpleOpRotationAngle := 180
    Else If (SimpleOperationsRotateAngle=4)
       simpleOpRotationAngle := 270
    Else
       simpleOpRotationAngle := 0
}

TglRszRotation() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeWithCrop
   cleanResizeUserOptionsVars()
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation

   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeRotationUser", "General")
}

TglRszCropping() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation
   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeCropAfterRotation", "General")
}

TglRszDestFoldr() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeUseDestDir
   If !ResizeUseDestDir
   {
      GuiControl, SettingsGUIA: Disable, btnFldr
      GuiControl, SettingsGUIA: Disable, ResizeDestFolder
   } Else
   {
      GuiControl, SettingsGUIA: Enable, btnFldr
      GuiControl, SettingsGUIA: Enable, ResizeDestFolder
   }
   INIaction(1, "ResizeUseDestDir", "General")
}

TglRszQualityHigh() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeQualityHigh
   INIaction(1, "ResizeQualityHigh", "General")
}

TglRszApplyEffects() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeApplyEffects
   INIaction(1, "ResizeApplyEffects", "General")
   If (ResizeApplyEffects=1)
   {
      infoMirroring := defineIMGmirroring()
      If (usrColorDepth>1)
         infoColorDepth := "`nSimulated color depth: " defineColorDepth()
      If (imgFxMode>1)
         infoColors := "`nColors display mode: " DefineFXmodes() " [" currIMGdetails.PixelFormat "]"
 
      entireString := infoMirroring infoColors infoColorDepth infoRenderOpaque
      entireString := (entireString) ?  "Effects currently activated: " entireString : "No effects currently activated."
      msgBoxWrapper(appTitle, entireString, 0, 0, "info")
   }
}

invokePanelStaticFoldersContextMenu() {
   Try Menu, PanelStaticMenu, Delete
   Sleep, 2

   Menu, PanelStaticMenu, Add, &Rescan folder`tF5, BTNupdateSelectedStaticFolder
   Menu, PanelStaticMenu, Add, &Erase indexed files`tDelete, BTNremFilesStaticFolder
   Menu, PanelStaticMenu, Add, &Open folder in Explorer`tF4, BTNopenDynaFolder
   Menu, PanelStaticMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelStaticMenu, Add, &Ignore date change, BTNignoreSelFolder
   If (SLDtypeLoaded!=3)
      Menu, PanelStaticMenu, Add, Rename inde&x entry`tF2, PanelRenameStaticFolder
   Menu, PanelStaticMenu, Add, &Filter list to selected folder`tF3, MenuFilterListSelectedFolder
   Menu, PanelStaticMenu, Add,
   Menu, PanelStaticMenu, Add, &Copy entire list, BTNcopyAllStaticFolderPaths
   Menu, PanelStaticMenu, Add, &View list as a folders tree, BTNshowStaticFoldersInTreeView
   showThisMenu("PanelStaticMenu")
}

invokePanelDynaFoldersContextMenu() {
   Try Menu, PanelDynaMenu, Delete
   Sleep, 2

   Menu, PanelDynaMenu, Add, &Rescan folder`tF5, BTNrescanDynaFolder
   Menu, PanelDynaMenu, Add, &Remove from the list`tDelete, BTNremDynaSelFolder
   Menu, PanelDynaMenu, Add, Rename inde&x entry`tF2, PanelRenameStaticFolder
   Menu, PanelDynaMenu, Add, &Open folder in Explorer`tF4, BTNopenDynaFolder
   Menu, PanelDynaMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelDynaMenu, Add, &Toggle recursive folder scan, InvertRecurseDynaFolder
   Menu, PanelDynaMenu, Add, &Filter list to selected folder`tF3, MenuFilterListSelectedFolder
   Menu, PanelDynaMenu, Add
   Menu, PanelDynaMenu, Add, &View list as a folders tree, BTNshowDynamicFoldersInTreeView
   showThisMenu("PanelDynaMenu")
}

PanelStaticFolderzManager() {
    Global LViewOthers, listViewFilteru
    If !(RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
       Return

    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(2, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? 140 : 95
    btnWid3 := (PrefsLargeFonts=1) ? 95 : 55
    btnWid4 := (PrefsLargeFonts=1) ? 160 : 90
    CountFilesFolderzList := 0
    widthu := (SLDtypeLoaded=3) ? "w1" : ""
    Gui, Add, Text, x15 y15, This folders list was generated based on the indexed files.
    Gui, Add, ListView, xp y+10 w%lstWid% -multi AltSubmit gFolderzFilterListBTN r12 Grid vLViewOthers +hwndhLVmainu, #|Date|(?)|Folder path|Files
    Gui, Add, Edit, xs y+10 wp-50 -multi -wantTab gUIfilterListViewStaticFoldersList +hwndhEditField vStaticlistViewFilteru, % staticlistViewFilteru
    Gui, Add, Button, x+1 hp w50 gBTNhelpStaticFolderz, [ ? ]
    Gui, Add, Checkbox, xs y+10 gToggleRecursiveStaticRescan vRecursiveStaticRescan Checked%RecursiveStaticRescan%, &Perform recursive (in sub-folders) rescan

    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid2% gBTNupdateSelectedStaticFolder, &Rescan folder
    Gui, Add, Button, x+5 hp w%btnWid% gSQLdbGenerateStaticFolders , I&gnore all changes
    Gui, Add, Button, x+5 hp wp+40 gRegenerateEntireList, R&egenerate entire index
    Gui, Add, Button, x+5 hp w70 ginvokePanelStaticFoldersContextMenu, &More

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Cached folders list updater: " appTitle)
    Sleep, 25
    If (SLDtypeLoaded=3)
       PopulateStaticSQLfolderzList(staticlistViewFilteru)
    Else
       PopulateStaticFolderzList(staticlistViewFilteru)
}

PanelReviewSelectedFiles() {
    Global LViewOthers

    getSelectedFiles(0, 1)
    If !markedSelectFile
    {
       showTOOLtip("WARNING: There are no selected files to review.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (markedSelectFile>50101)
    {
       msgResult := msgBoxWrapper(appTitle ": Review selected files", "You have selected " groupDigits(markedSelectFile) " files.`nIt may take a lot of time to populate the panel with so many files.`n`nDo you want to open the panel?`n`nYou can abort the process by clicking outside the panel.", 4, 0, "question")
       If (msgResult!="Yes")
          Return
    }

    thisBtnHeight := createSettingsGUI(60, A_ThisFunc)
    btnWid := 65
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    edithu := lstWid - btnWid - 35
    Gui, Add, ListView, x15 y15 w%lstWid% AltSubmit Count%markedSelectFile% gBTNreviewPaneLV r12 Grid vLViewOthers +hwndhLVmainu, S|Complete path|#|Dupe ID
    Gui, Add, Edit, xs y+10 w%edithu% -multi -wantTab +hwndhEditField vlistViewReviewFilteru, % listViewReviewFilteru
    Gui, Add, Button, x+1 hp w%btnWid% gUIfilterReviewPanelList Default, &Apply
    Gui, Add, Button, x+1 hp w35 gUIfilterEraseReviewPanelList, &X
    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid% gBTNreviewApplySelection, &Select
    Gui, Add, Button, x+5 hp wp gBTNreviewRemSelection , &Deselect
    Gui, Add, Button, x+5 hp wp gBTNreviewDropFilesSelection, &None
    Gui, Add, Button, x+5 hp wp gBTNrefreshReviewPanel , &Refresh
    Gui, Add, Button, x+5 hp wp gBTNreviewCopyPanel , &Copy
    Gui, Add, Button, x+5 hp wp gBtnReviewSelClose, C&lose
    Gui, Add, Text, xs y+10 vinfoLine +0x200, Listing items`, please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Review selected files: " appTitle)
    Sleep, 25
    reviewSelectedIndexes := []
    Loop, % maxFilesIndex
    {
        If resultedFilesList[A_Index, 2]
        {
           thisCounter++
           reviewSelectedIndexes[thisCounter] := A_Index
        }
    }

    PopulateReviewSelectedFiles()
}

BtnReviewSelClose() {
   reviewSelectedIndexes := []
   BtnCloseWindow()
}

BTNreviewDropFilesSelection() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := 0
   GuiControlGet, listViewReviewFilteru
   modus := markedSelectFile ? 0 : 1
   If listViewReviewFilteru
   {
      LV_GetText(thisFileIndex, RowNumber + 1, 3)
      modus := resultedFilesList[thisFileIndex, 2] ? 0 : 1
      ; ToolTip, % thisFileIndex "===" isSelected "===" modus , , , 2
   }

   modusa := !modus ? "_" : "S"
   Loop
   {
       RowNumber++
       LV_GetText(thisFileIndex, RowNumber, 3)
       If !thisFileIndex
          Break

       resultedFilesList[thisFileIndex, 2] := modus
       LV_Modify(RowNumber, , modusa)
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   dummyTimerDelayiedImageDisplay(50)
}

BTNreviewApplySelection() {
   BTNreviewToggleSelection(1)
}


BTNreviewRemSelection() {
   BTNreviewToggleSelection(0)
}

BTNreviewCopyPanel() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := 0
   listu := ""
   Loop
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(imgPath, RowNumber, 2)
       listu .= imgPath "`n"
    }

    Try Clipboard := listu
    Catch wasError

    If wasError
    {
       showTOOLtip("Failed to copy file paths to clipboard")
       SoundBeep , 300, 100
    } Else
       showTOOLtip("File paths copied to clipboard")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNreviewToggleSelection(modus:=0) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := 0
   Loop
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(thisFileIndex, RowNumber, 3)
       oSel := resultedFilesList[thisFileIndex, 2]
       sel := (modus>1) ? !oSel : modus
       resultedFilesList[thisFileIndex, 2] := sel
       ; sel := (oSel && !sel) ? 0 : 1
       If (oSel=sel)
          Continue
 
       If sel
       {
          LV_Modify(RowNumber, , "S")
          markedSelectFile++
       } Else
       {
          LV_Modify(RowNumber, , "_")
          markedSelectFile--
       }
   }

   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(50)
}

UIfilterEraseReviewPanelList() {
   listViewReviewFilteru := ""
   GuiControl, SettingsGUIA:, listViewReviewFilteru, 
   PopulateReviewSelectedFiles()
}

BTNreviewPaneLV(a, b, c) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
   indexu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
   folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
   grpID := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
   ; ToolTip, % indexu "==" folderu , , , 2
   If (b="K" && c=32) ; Space
   {
      BTNreviewToggleSelection(2)
      Return
   } Else If (b="K" && c=113) ; F2
   {
      BtnCloseWindow()
      currentFileIndex := indexu
      PanelRenameThisFile()
      Return
   } Else If (b="K" && c=116) ; F5
   {
      BTNrefreshReviewPanel()
      Return
   } Else If (b!="DoubleClick")
      Return

   BtnCloseWindow()
   currentFileIndex := indexu
   dummyTimerDelayiedImageDisplay(50)
}

BTNrefreshReviewPanel() {
   BtnCloseWindow()
   PanelReviewSelectedFiles()
}

UIfilterReviewPanelList() {
   SetTimer, PopulateReviewSelectedFiles, -50
}

PopulateReviewSelectedFiles() {
    If (AnyWindowOpen!=60)
       Return

    doStartLongOpDance()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    GuiControlGet, listViewReviewFilteru
    GuiControl, SettingsGUIA:, infoLine, Listing items`, please wait...

    thisString := StrReplace(Trimmer(listViewReviewFilteru), "||", "|")
    thisString := Trimmer(thisString, "|")
    thisFilter := processSearchIndexString(thisString)
    isStrFilter := StrLen(thisString)>1 ? 1 : 0
    EM_SETCUEBANNER(hEditField, "Populating the list view - please wait", 0)
    totalSelected := reviewSelectedIndexes.Count()
    listedEntries := 0
    Loop, % totalSelected
    {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        thisIndex := reviewSelectedIndexes[A_Index]
        If (isStrFilter=1)
        {
           If !coreSearchIndex(resultedFilesList[thisIndex, 1], thisFilter, 1, 0)
              Continue
        }

        isSelected := resultedFilesList[thisIndex, 2] ? "S" : "_"
        listedEntries++
        LV_Add(A_Index, isSelected, resultedFilesList[thisIndex, 1], thisIndex, resultedFilesList[thisIndex, 23])
        If (A_Index=5)
        {
           Loop, 4
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }

    LV_ModifyCol(3, "Integer")
    LV_ModifyCol(4, "Integer")
    SetTimer, ResetImgLoadStatus, -100
    listedEntries := groupDigits(listedEntries)
    EM_SETCUEBANNER(hEditField, "Filter files list", 0)
    GuiControl, SettingsGUIA:, infoLine, Entries listed: %listedEntries%
    Loop, 4
        LV_ModifyCol(A_Index, "AutoHdr Left")
}

BTNhelpStaticFolderz() {
   msgBoxWrapper(appTitle ": HELP", "Please select the folder you want updated.`nFolders marked with (*) are changed since the last scan, based on folder modified date. Right-click on listed entries for more options.`n`nWhen you choose to «remove file entries», the files indexed pertaining to the selected folder will be removed ONLY from the index, NOT from the disk.", -1, 0, 0)
}

EM_SETCUEBANNER(handle, string, option := true) {
; ===============================================================================================================================
; Message ..................:  EM_SETCUEBANNER
; Minimum supported client .:  Windows Vista
; Minimum supported server .:  Windows Server 2003
; Links ....................:  https://docs.microsoft.com/en-us/windows/win32/controls/em-setcuebanner
; Description ..............:  Sets the textual cue, or tip, that is displayed by the edit control to prompt the user for information.
; Options ..................:  True  -> if the cue banner should show even when the edit control has focus
;                              False -> if the cue banner disappears when the user clicks in the control
; ===============================================================================================================================
   static ECM_FIRST       := 0x1500 
        , EM_SETCUEBANNER := ECM_FIRST + 1
   if (DllCall("user32\SendMessage", "ptr", handle, "uint", EM_SETCUEBANNER, "int", option, "str", string, "int"))
      return true
   return false
}

PanelDynamicFolderzWindow(dummy:=0) {
    Static LViewDynas
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(3, A_ThisFunc)
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    Gui, Add, Text, x15 y15, This folders list is used to generate the files list index.
    Gui, Add, ListView, y+10 w%lstWid% gFolderzFilterListBTN -multi r12 Grid AltSubmit vLViewDynas +hwndhLVmainu, #|(?)|Folder path

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    btnWid3 := (PrefsLargeFonts=1) ? 120 : 90
    If (dummy="reopen")
    {
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gPanelSaveSlideShowu, &Back
       Gui, Add, Button, x+5 hp wp gBTNaddNewFolder2list, &Add
    } Else
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gBTNaddNewFolder2list, &Add
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNremDynaSelFolder, &Remove
    Gui, Add, Button, x+5 hp wp+30 gRegenerateEntireList, R&escan all
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNcopyDynaFoldersList, &Copy list
    Gui, Add, Button, x+5 hp wp+5 gBTNpasteDynaFoldersList, &Paste list
    Gui, Add, Button, x+5 hp wp+5 ginvokePanelDynaFoldersContextMenu, &More
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage folders list: " appTitle)
    Sleep, 25
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    PopulateDynamicFolderzList()
}

ToggleCountFilesFoldersList() {
  GuiControlGet, CountFilesFolderzList
  If (AnyWindowOpen=3)
     PanelDynamicFolderzWindow()
  Else If (AnyWindowOpen=2)
     PanelStaticFolderzManager()
}

ToggleRecursiveStaticRescan() {
    GuiControlGet, RecursiveStaticRescan
}

BTNaddNewFolder2list() {
    BtnCloseWindow()
    Sleep, 10
    r := addNewFolder2list()
    Sleep, 10
    SetTimer, PanelDynamicFolderzWindow, -50
}

BTNignoreSelFolder(dummy:=0) {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    If (dummy="update-all")
       RowNumber := 1

    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
    }

    BtnCloseWindow()
    doAll := (dummy="update-all") ? 1 : 0
    updateCachedStaticFolders(folderu, 1, doAll)
    showTOOLtip("Folders list information updated")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    Sleep, 50
    PanelStaticFolderzManager()
}

BTNcopyStaticFolderPath() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=2) ? 4 : 3
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return
    
    Try Clipboard := folderu
    Catch wasError

    If wasError
    {
       showTOOLtip("Failed to copy path to clipboard:`n" folderu)
       SoundBeep , 300, 100
    } Else
       showTOOLtip("Folder path copied to clipboard:`n" folderu)

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcopyAllStaticFolderPaths() {
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Loop, % countStaticFolders
          finalListu .= arrayList[A_Index, 1] "`n"

    Try Clipboard := finalListu
    Catch wasError

    If wasError
    {
       showTOOLtip("Failed to copy folder paths to clipboard")
       SoundBeep , 300, 100
    } Else
       showTOOLtip("Folder paths copied to clipboard")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNshowStaticFoldersInTreeView() {
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Loop, % countStaticFolders
          finalListu .= arrayList[A_Index, 1] "`n"

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", finalListu)
}

BTNshowDynamicFoldersInTreeView() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        fileTest := StrReplace(Trimmer(A_LoopField), "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= fileTest "`n"
    }
    If !newFoldersList
       Return

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", newFoldersList)
}

BTNremFilesStaticFolder() {
    Gui, SettingsGUIA: Default
    GuiControlGet, RecursiveStaticRescan
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (RecursiveStaticRescan=1)
       friendly := "(and its sub-folders)"

    recursive := (RecursiveStaticRescan=1) ? "" : "|"
    msgResult := msgBoxWrapper(appTitle ": Remove files associated to static folder", "Please confirm that you want to remove the files from the index/list pertaining to the static folder " friendly " selected:`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       BtnCloseWindow()
       Sleep, 10
       r := coreRemFilesStaticFolder(folderu, recursive)
       Sleep, 10
       If r
          PanelStaticFolderzManager()
    } Else Return
}

coreRemFilesStaticFolder(folderu, recursive) {
    remFilesFromList(recursive folderu)
    If (maxFilesIndex>0)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
       RandomPicture()
       Return 1
    } Else
    {
       handleEmptyFilesList(CurrentSLD)
       Return 0
    }
}

BTNcopyDynaFoldersList() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    ResetImgLoadStatus()
    If !newFoldersList
       Return

    Try Clipboard := newFoldersList
    Catch wasError

    If !wasError
    {
       showTOOLtip("Dynamic folders list copied to clipboard")
    } Else
    {
       showTOOLtip("Failed to copy to clipboard the dynamic folders list")
       SoundBeep , 300, 100
    }

    SetTimer, RemoveTooltip, % msgDisplayTime
}

BTNpasteDynaFoldersList() {
    BtnCloseWindow()
    Sleep, 50
    foldersListu := getDynamicFoldersList()
    foldersListu .= SubStr(Clipboard, 1, 50432)
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    mustOpenStartFolder := ""
    Sort, newFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(newFoldersList)
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(DynamicFoldersList)

    currentFilesListModified := 1
    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

BTNremDynaSelFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 50
    mustOpenStartFolder := ""
    foldersListu := getDynamicFoldersList()
    currentFilesListModified := 1
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    msgResult := msgBoxWrapper(appTitle ": Remove dynamic folder", "Would you like to remove the files from the index/list pertaining to the removed dynamic folder as well ?`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       remFilesFromList(folderu)
       If (maxFilesIndex>0)
       {
          GenerateRandyList()
          SoundBeep, 900, 100
          RandomPicture()
       } Else 
       {
          handleEmptyFilesList(CurrentSLD)
          Return
       }
    }

    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

LV_EX_GetNextItem(HLV, nRow, lParam:=0x0001) {
; Description ..: Get the next item in the target ListView.
; Parameters ...: HLV  - External ListView hwnd
; ..............: nRow   - Row where to start the search for the next item (0-based index).
; ..............: lParam - Status of the searched item. Common statuses are:
; ..............:          LVNI_ALL         - 0x0000
; ..............:          LVNI_FOCUSED     - 0x0001
; ..............:          LVNI_SELECTED    - 0x0002
; ..............:          LVNI_CUT         - 0x0004
; ..............:          LVNI_DROPHILITED - 0x0008
; Info .........: LVM_GETNEXTITEM - http://msdn.microsoft.com/en-us/library/windows/desktop/bb761057%28v=vs.85%29.aspx
; Return .......: Item content as a string.

    ; LVM_GETNEXTITEM = LVM_FIRST (0x1000) + 12 = 0x100C.
    SendMessage, 0x100C, %nRow%, %lParam%,, % "ahk_id " HLV
    Return ErrorLevel
}

LV_EX_GetItemsCount(HLV, ByRef rows, ByRef cols) {
    ; LVM_GETITEMCOUNT = LVM_FIRST (0x1000) + 4 = 0x1004.
    SendMessage, 0x1004, 0, 0,, % "ahk_id " hlv
    rows := ErrorLevel

    ; LVM_GETHEADER = LVM_FIRST (0x1000) + 31 = 0x101F.
    SendMessage, 0x101F, 0, 0,, % "ahk_id " hlv
    hhdr := ErrorLevel

    ; HDM_GETITEMCOUNT = HDM_FIRST (0x1200) + 0 = 0x1200.
    SendMessage, 0x1200, 0, 0,, % "ahk_id " hhdr
    cols := ErrorLevel
}

LV_EX_LVITEM(ByRef LVITEM, Mask := 0, Row := 1, Col := 1) {
   Static LVITEMSize := 48 + (A_PtrSize * 3)
   VarSetCapacity(LVITEM, LVITEMSize, 0)
   NumPut(Mask, LVITEM, 0, "UInt"), NumPut(Row - 1, LVITEM, 4, "Int"), NumPut(Col - 1, LVITEM, 8, "Int")
}

LV_EX_GetSubItemText(HLV, Row, Column := 1, MaxChars := 1024) {
; function by «just me»
; found on https://github.com/AHK-just-me/

   ; LVM_GETITEMTEXT -> http://msdn.microsoft.com/en-us/library/bb761055(v=vs.85).aspx
   Static LVM_GETITEMTEXT := A_IsUnicode ? 0x1073 : 0x102D ; LVM_GETITEMTEXTW : LVM_GETITEMTEXTA
   Static OffText := 16 + A_PtrSize
   Static OffTextMax := OffText + A_PtrSize
   VarSetCapacity(ItemText, MaxChars << !!A_IsUnicode, 0)
   LV_EX_LVITEM(LVITEM, , Row, Column)
   NumPut(&ItemText, LVITEM, OffText, "Ptr")
   NumPut(MaxChars, LVITEM, OffTextMax, "Int")
   SendMessage, % LVM_GETITEMTEXT, % (Row - 1), % &LVITEM, , % "ahk_id " . HLV
   VarSetCapacity(ItemText, -1)
   Return ItemText
}

BTNopenDynaFolder() {
    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    colNum := (AnyWindowOpen=3) ? 3 : 4
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1) ; LV_GetNext(0, "F")
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    ; LV_GetText(folderu, RowNumber, colNum)
    ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    folderu := StrReplace(folderu, "|")
    Try Run, "%folderu%"
    Catch wasError
          Sleep, 1

    If wasError
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
}

FolderzFilterListBTN(a:=0, b:=0, c:=0) {
    If !AnyWindowOpen
       Return

    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, % whichLV
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=3) ? 3 : 4
    indexu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum - 3)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    files := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum + 1)

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (b="k" && c=113) ; F2
    {
       PanelRenameStaticFolder()
       Return
    } Else If (b="k" && c=115) ; F4
    {
       BTNopenDynaFolder()
       Return
    } Else If (b="k" && c=45 && whichLV="LViewDynas") ; Insert
    {
       BTNaddNewFolder2list()
       Return
    } Else If (b="k" && c=114) ; F3
    {
       MenuFilterListSelectedFolder()
       Return
    } Else If (b="k" && c=32) ; Space
    {
       If (whichLV="LViewDynas")
          invokePanelDynaFoldersContextMenu()
       Else
          invokePanelStaticFoldersContextMenu()
       Return
    } Else If (b="k" && c=116) ; F5
    {
       If (whichLV="LViewDynas")
          BTNrescanDynaFolder()
       Else
          BTNupdateSelectedStaticFolder()
       Return
    } Else If (b="K" && (c=119 || c=46)) ; F8
    {
       If (whichLV="LViewDynas")
          BTNremDynaSelFolder()
       Else
          BTNremFilesStaticFolder()
       Return
    }

    If ((A_GuiEvent="Normal" || A_GuiEvent="K") && files="" && whichLV="LViewOthers")
    {
       countedFiles := 0
       ; startZeit := A_TickCount
       Loop, % maxFilesIndex
       {
          imgPath := resultedFilesList[A_Index, 1]
          If InStr(imgPath, folderu)
             zPlitPath(imgPath, 1, OutFileName, OutDir)
          Else
             OutDir := ""
          ; If QPV_InStr(imgPath, folderu)
          If (OutDir=folderu)
             countedFiles++
       }
       ; ToolTip, % A_TickCount - startZeit , , , 2
       newStaticFoldersListCache[indexu, 3] := countedFiles
       LV_Modify(RowNumber + 1, "Col" colNum+1, countedFiles)
       LV_ModifyCol(colNum + 1, "AutoHdr Left")
       Return
    }

    If (b="DoubleClick" || a="menu-mode")
    {
       uiFilterListDynaFolder(folderu, AnyWindowOpen)
       Return
    }
}

uiFilterListDynaFolder(folderu, modus) {
    ; doExactMatch := (AnyWindowOpen=3) ? 0 : 1
    BtnCloseWindow()
    folderu := Trimmer(StrReplace(folderu, "|"))
    If (modus=3) ; full path recursive
    {
       userFilterStringPos := 2
       userFilterWhat := 1
       UsrEditFilter := folderu "\"
    } Else
    {
       userFilterStringPos := 3
       userFilterWhat := 2
       UsrEditFilter := folderu
    }

    userFilterProperty := userFilterDoString := 1
    userFilterInvertThis := userFilterStringIsNot := 0
    thisFilter := updateUIFiltersPanel("external")
    coreEnableFiltru(thisFilter)
    dummyTimerDelayiedImageDisplay(50)
}

MenuFilterListSelectedFolder() {
   FolderzFilterListBTN("menu-mode")
}

InvertRecurseDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    foldersListu := "`n" getDynamicFoldersList() "`n"

    isPipe := InStr(folderu, "|") ? 1 : 0
    folderuz := StrReplace(folderu, "|")
    newfolderu := (isPipe!=1) ? "`n|" folderuz "`n" : "`n" folderuz "`n"
    newFoldersList := StrReplace(foldersListu, "`n" folderu "`n", newFolderu)
    Sort, newFoldersList, UD`n
    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    ; ToolTip, % newFoldersList , , , 2
    Sleep, 15
    PanelDynamicFolderzWindow()
    Sleep, 15
    showTOOLtip("You need to rescan folder for the effect to take place")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNrescanDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    ; msgbox, % folderu
    mustOpenStartFolder := ""
    z := wrapperAddNewFolderToList(folderu, 1)
    ; modus := InStr(folderu, "|") ? 1 : 0
    If (mustGenerateStaticFolders=0 && z!="null" && RegExMatch(CurrentSLD, sldsPattern))
       updateCachedStaticFolders(folderu, 0)

    Sleep, 150
    PanelDynamicFolderzWindow()
}

updateCachedStaticFolders(mainFolderu, onlyMainFolder, updateAllDates:=0) {
   thisIndex := 0
   showTOOLtip("Updating static folders list")
   arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
   Loop, % countStaticFolders
         foldersListu .= "Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n"

   FileGetTime, dirDate, % mainFolderu, M
   newEntry := dirDate "*&*" mainFolderu "`n"

   If (onlyMainFolder!=1)
   {
      Loop, Files, %mainFolderu%\*, RD
      {
          FileGetTime, dirDate, %A_LoopFileFullPath%, M
          MoreNewFileFolders .= dirDate "*&*" A_LoopFileFullPath "`n"
          ; Tooltip, % MoreNewFileFolders
      }
   }

   Loop, Parse, foldersListu, `n
   {
       lineArru := StrSplit(A_LoopField, "*&*")
       folderu := lineArru[2], oldDateu := lineArru[1]
       If !FolderExist(folderu) || (folderu=mainFolderu) || InStr(MoreNewFileFolders, "*&*" folderu "`n")
          Continue

       oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
       If (updateAllDates=1)
          FileGetTime, oldDateu, % folderu, M
       newFoldersList .= oldDateu "*&*" folderu "`n"
   }

   FinalStaticFoldersList := newFoldersList "`n" MoreNewFileFolders "`n" newEntry
   Sort, FinalStaticFoldersList, U D`n
   If (SLDtypeLoaded=3)
   {
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      activeSQLdb.Exec("DELETE FROM staticfolders;")
      Loop, Parse, FinalStaticFoldersList, `n
      {
          If StrLen(A_LoopField)>2
             lineArru := StrSplit(A_LoopField, "*&*")
          Else
             Continue

          folderu := lineArru[2]
          oldDateu := lineArru[1]
          addStaticFolderSQLdb(folderu, oldDateu, 0)
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      Return
   }

   thisIndex := 0
   newStaticFoldersListCache := []
   Loop, Parse, FinalStaticFoldersList, `n
   {
        If StrLen(A_LoopField)<5
           Continue

        thisIndex++
        lineArru := StrSplit(A_LoopField, "*&*")
        newStaticFoldersListCache[thisIndex] := [lineArru[2], lineArru[1]]
   }
}

remFilesFromList(SelectedDir, silentus:=0, forReal:=1) {
    If (silentus=0)
       showTOOLtip("Removing files from the list pertaining to`n" SelectedDir "\")

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    oldMaxy := maxFilesIndex
    isPipe := InStr(SelectedDir, "|") ? 1 : 0
    SelectedDir := StrReplace(SelectedDir, "|")
    newArrayu := []
    Loop, % maxFilesIndex + 1
    {
        r := getIDimage(A_Index)
        If (InStr(r, "||") || !r)
           Continue

        If !isPipe
        {
           If InStr(r, SelectedDir "\")
              Continue
        } Else If (isPipe=1)
        {
           rT := StrReplace(r, SelectedDir "\")
           If !InStr(rT, "\")
              Continue
        }

        countFiles++
        newArrayu[countFiles] := resultedFilesList[A_Index]
        If (resultedFilesList[A_Index, 2]=1)
           selectedFiles++
    }

    If (SLDtypeLoaded=3)
    {
       thisR := SQLescapeStr(SelectedDir, 1)
       thisR := (isPipe=1) ? thisR : thisR "%"
       If (forReal=1)
       {
          activeSQLdb.Exec("BEGIN TRANSACTION;")
          SQLstr := "DELETE FROM images WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLStr)
          {
             stringA:= thisR
             activeSQLdb.EscapeStr(stringA)
             SQLstr := "DELETE FROM images WHERE imgfolder LIKE " stringA " ESCAPE '>';"
             activeSQLdb.Exec(SQLStr)
          }

          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)
       } Else
       {
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLstr)
             throwSQLqueryDBerror(A_ThisFunc)
       }
    }

    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    filesRemoved := oldMaxy - maxFilesIndex
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If (filesRemoved<1)
       filesRemoved := 0
    Else
       currentFilesListModified := 1

    CurrentSLD := backCurrentSLD
    If (silentus=0)
       showTOOLtip("Finished removing " filesRemoved " files from the list")

    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelRenameStaticFolder() {
    ; Global newFileName, idFolder, remFilesFromFolder, doRemRecursively
    ; GuiControlGet, RecursiveStaticRescan
    winOpen := AnyWindowOpen
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=2) ? 4 : 3 ; 2 = static panel ; 3 = dynamic panel
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded=2 && AnyWindowOpen=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
   }

   Sleep, 15
   folderu := StrReplace(folderu, "|")
   msgResult := msgBoxWrapper("Rename static folder entry: " appTitle, "Please type the new folder path. The records in the index pertaining to this folder, will automatically be updated to reflect the change.", "&Rename folder entry|C&ancel", 1, "modify-entry", 0, 1, 0, "limit9050 w850", folderu)
   If InStr(msgResult.btn, "Rename")
   {
      remFilesFromFolder := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      newFileName := StrReplace(newFileName, "/", "\")
      newFileName := StrReplace(newFileName, "|")
      newFileName := Trimmer(newFileName, "\")
      newFileName := RegExReplace(newFileName, "\\{2,}", "\")
      If (!newFileName || newFileName=folderu)
         Return

      If (!RegExMatch(newFileName, "i)^(.\:\\.)") || !newFileName)
      {
         showTOOLtip("WARNING: Incorrect folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If !FolderExist(newFileName)
      {
         showTOOLtip("WARNING: Inexistent folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      BtnCloseWindow()
      ; If (remFilesFromFolder=1)
      ;    coreRemFilesStaticFolder(folderu, recursive)

      newName := newFileName
      If (winOpen=2)
      {
         showTOOLtip("Updating static folders list")
         If (SLDtypeLoaded=3)
         {
            Sleep, 25
         } Else
         {
            arrayList := LoadStaticFoldersCached(CurrentSLD, totalStaticFolders, 1)
            Loop, % totalStaticFolders
            {
               If (arrayList[A_Index, 1]=folderu)
                  arrayList[A_Index, 1] := newName
               Else
                  arrayList[A_Index, 1] := StrReplace(arrayList[A_Index, 1], folderu "\", newName "\")
            }

            newStaticFoldersListCache := []
            newStaticFoldersListCache := arrayList.Clone()
         }
      } Else
      {
         finalListu := ""
         foldersListu := getDynamicFoldersList()
         Loop, Parse, foldersListu,`n,`r
         {
            line := StrReplace(A_LoopField, "|")
            If (line=folderu)
               finalListu .= StrReplace(A_LoopField, folderu, newName) "`n"
            Else
               finalListu .= StrReplace(A_LoopField, folderu "\", newName "\") "`n"
         }

         DynamicFoldersList := cleanDynamicFoldersList(finalListu)
         If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(DynamicFoldersList)
      }

      currentFilesListModified := 1
      msgResult := msgBoxWrapper(appTitle ": Update files list", "You have renamed a folder entry. Would you like to perform a search and replace in the files list to update the corresponding records?", 4, 0, "question")
      If (msgResult="Yes")
         SearchAndReplaceThroughIndex(folderu "\", newName "\", 0, 1)

      SetTimer, RemoveTooltip, % -msgDisplayTime
      ; MsgBox, % firstPart "`n" newName "`n" indexSelected
      If (winOpen=2)
         PanelStaticFolderzManager()
      Else
         PanelDynamicFolderzWindow()
    }
}

SearchAndReplaceThroughIndex(what, replacer, silentus:=0, folderMode:=0) {
    If (silentus=0)
       showTOOLtip("Performing search and replace in the files list index:`n" what "`n" replacer)

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    changeMcursor()
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    newArrayu := []
    totalAffected := 0
    If (SLDtypeLoaded=3)
    {
       whatESC := SQLescapeStr(what)
       replacerESC := SQLescapeStr(replacer)
       ; activeSQLdb.EscapeStr(what)
       ; activeSQLdb.EscapeStr(replacer)
       activeSQLdb.Exec("BEGIN TRANSACTION;")
       If (folderMode=1)
          SQLstr := "UPDATE images SET imgfolder='" Trimmer(replacerESC, "\") "' WHERE imgfolder='" Trimmer(whatESC, "\") "';"

       startOperation := A_TickCount
       prevMSGdisplay := A_TickCount
       If (activeSQLdb.Exec(SQLStr) || folderMode!=1)
       {
          If (folderMode=1)
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '" Trimmer(SQLescapeStr(what, 1), "\") "\%' ESCAPE '>';"
          Else
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '%" SQLescapeStr(what, 1) "%' ESCAPE '>';"

          If !activeSQLdb.GetTable(SQLstr, RecordSet)
             errorOccured := activeSQLdb.ErrorMsg

          changeMcursor()
          totalFiles := RecordSet.RowCount
          Loop, % RecordSet.RowCount
          {
              changeMcursor()
              Row := RecordSet.Rows[A_Index]
              If (A_TickCount - prevMSGdisplay>1500)
              {
                 etaTime := ETAinfos(A_Index, totalFiles, startOperation)
                 showTOOLtip("Performing search and replace in the files list index" etaTime, 0, 0, A_Index/totalFiles)
                 prevMSGdisplay := A_TickCount
              }

              If Row[2]
              {
                 newFolderName := StrReplace(Row[2], what, replacer)
                 SQLstr := "UPDATE images SET imgfolder='" SQLescapeStr(newFolderName) "' WHERE imgidu='" Row[1] "';"
                 If !activeSQLdb.Exec(SQLstr)
                    failedFiles++
              }
          }
          RecordSet.Free()
       } Else errorOccured := activeSQLdb.ErrorMsg

       showTOOLtip("Finishing search and replace in the files list, please wait")
       activeSQLdb.Exec("COMMIT TRANSACTION;")
    }

    If !errorOccured
    {
       Loop, % maxFilesIndex + 1
       {
           r := getIDimage(A_Index)
           If (InStr(r, "||") || !r)
              Continue

           countFiles++
           newArrayu[countFiles] := resultedFilesList[A_Index]
           newArrayu[countFiles, 1] := StrReplace(newArrayu[countFiles, 1], what, replacer, affected)
           totalAffected += affected
           If (resultedFilesList[A_Index, 2]=1)
              selectedFiles++
       }
    }

    ;  E:\Trash-100\meta\poze\soft\_older-selection\001 (6).jpg
    currentFilesListModified := 1
    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If errorOccured
    {
       showTOOLtip("Failed to update the files list database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the files list`n"
       showTOOLtip(someErrors "Finished updating the files list`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }
    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

SearchAndReplaceSeenDB(what, replacer) {
    initSeenImagesListDB()
    If (sqlFailedInit=1)
    {
       showTOOLtip("Failed to initialize database of seen images")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    startOperation := A_TickCount
    showTOOLtip("Performing search and replace in the seen database list:`n" what "`n" replacer)
    changeMcursor()
    whatESC := what
    replacerESC := replacer
    seenImagesDB.EscapeStr(whatESC)
    seenImagesDB.EscapeStr(replacerESC)
    seenImagesDB.Exec("BEGIN TRANSACTION;")
    SQLstr := "SELECT ROWID, imgfile FROM images WHERE imgfile LIKE '%" Trimmer(SQLescapeStr(what, 1)) "%' ESCAPE '>';"
    If !seenImagesDB.GetTable(SQLstr, RecordSet)
       errorOccured := seenImagesDB.ErrorMsg

    totalAffected := failedFiles := 0
    totalFiles := RecordSet.RowCount
    If !errorOccured
    {
       Loop, % RecordSet.RowCount
       {
           changeMcursor()
           Row := RecordSet.Rows[A_Index]
           If (A_TickCount - prevMSGdisplay>1500)
           {
              etaTime := ETAinfos(A_Index, totalFiles, startOperation)
              showTOOLtip("Performing search and replace in the seen database list" etaTime, 0, 0, A_Index/totalFiles)
              prevMSGdisplay := A_TickCount
           }

           If Row[2]
           {
              newFolderName := StrReplace(Row[2], what, replacer)
              SQLstr := "UPDATE images SET imgfile='" SQLescapeStr(newFolderName) "' WHERE ROWID='" Row[1] "';"
              If !seenImagesDB.Exec(SQLstr)
                 failedFiles++
              Else
                 totalAffected++
           }
       }
       RecordSet.Free()
    }

    k := seenImagesDB.Exec("COMMIT TRANSACTION;")
    If (errorOccured || !k)
    {
       showTOOLtip("Failed to update the seen images database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the seen images database`n"
       showTOOLtip(someErrors "Finished updating the seen images database`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }

    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

BTNupdateSelectedStaticFolder() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    }

    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }

    If (RecursiveStaticRescan!=1)
       isNotRecursive := "|"

    BtnCloseWindow()
    Sleep, 5
    modus := isNotRecursive ? 1 : 0
    wrapperAddNewFolderToList(isNotRecursive folderu, !modus)
    updateCachedStaticFolders(folderu, modus)
    Sleep, 5
    SetTimer, RemoveTooltip, % -msgDisplayTime
    PanelStaticFolderzManager()
}

UIfilterListViewStaticFoldersList() {
   SetTimer, UIfilterListViewStaticFoldersList, -400
}

UIfilterListViewStaticFolderzList() {
   If (AnyWindowOpen!=2)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, staticlistViewFilteru
   If (imageLoading=1)
      Return

   If (SLDtypeLoaded=3)
      PopulateStaticSQLfolderzList(staticlistViewFilteru)
   Else
      PopulateStaticFolderzList(staticlistViewFilteru)
}

PopulateStaticSQLfolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    Tooltip, Gathering folders list - please wait
    EM_SETCUEBANNER(hEditField, "Gathering folders list - please wait", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")

    RecordSet := ""
    SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    arrayList := []
    fCountThese := countThese := 0
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        ; If (Row[1] && Row[2])
        ; {
           fCountThese++
           arrayList[fCountThese] := [Rowu[1], Rowu[2]]
        ; }
    }

    RecordSet.Free()
    foldersDatesArray := []
    SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        foldersDatesArray[CalcStringHash(Rowu[1], 0x8003)] := [Rowu[2], Rowu[1]]
    }

    RecordSet.Free()
    doStartLongOpDance()
    startOperation := A_TickCount
    Loop, % fCountThese
    {
        folderu := Trimmer(arrayList[A_Index, 1])
        If (StrLen(folderu)<5) || (listFilter && !InStr(folderu, listFilter))
           Continue

        countThese++
        hashu := CalcStringHash(folderu, 0x8003)
        oldDateu := foldersDatesArray[hashu, 1]
        foldersDatesArray[hashu] := "done"
        FileGetTime, dirDate, % folderu, M
        statusu := (dirDate!=oldDateu) ? "(*)" : "_"
        dirDate := oldDateu
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 2]

        LV_Add(A_Index, A_Index, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           ; msgbox, % folderu "`n" countFiles
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }

    EM_SETCUEBANNER(hEditField, "Filter folders list", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

PopulateStaticFolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 0)
    startOperation := A_TickCount
    setImageLoading()
    Tooltip, Preparing folders list - please wait.
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
    If (CountFilesFolderzList=1)
       dropFilesSelection(1)

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    doStartLongOpDance()
    startOperation := A_TickCount
    thisIndex := foldersCount := 0

    Tooltip, Listing folders now - please wait...
    Loop, % countStaticFolders
    {
        thisIndex := A_Index
        folderu := arrayList[A_Index, 1]
        If (StrLen(folderu)<2) || (listFilter && !InStr(folderu, listFilter))
           Continue

        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           CountFilesFolderzList := 0
           Break
        }

        oldDateu := arrayList[A_Index, 2]
        FileGetTime, dirDateO, % folderu, M
        statusu := (dirDateO!=oldDateu) ? "(*)" : "_"
        dirDate := SubStr(dirDateO, 1, StrLen(dirDate)-2)
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 3] ; countedFilesArray[countThese] ; : "-"

        LV_Add(A_Index, thisIndex, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 

    EM_SETCUEBANNER(hEditField, "Filter folders list", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    If (CountFilesFolderzList=1)
    {
       SoundBeep, 900, 100
       CountFilesFolderzList := 0
       GuiControl, SettingsGUIA:, CountFilesFolderzList, 0
    }
    Tooltip
}

StrPutVar(string, ByRef var, encoding) {
    ; Ensure capacity.
    ; StrPut returns char count, but VarSetCapacity needs bytes.
    VarSetCapacity(var, StrPut(string, encoding) * ((encoding="utf-16"||encoding="cp1200") ? 2 : 1))
    ; Copy or convert the string.
    return StrPut(string, &var, encoding)
}

PopulateDynamicFolderzList() {
    listu := getDynamicFoldersList()
    Gui, SettingsGUIA: ListView, LViewDynas
    Loop, Parse, listu, `n
    {
        line := Trimmer(A_LoopField)
        If (StrLen(line)<3)
           Continue

        counteru++
        statusu := InStr(line, "|") ? "_" : "[R]"
        LV_Add(A_Index, counteru, statusu, line)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    ResetImgLoadStatus()
}

CloseWindow(forceIT:=0, cleanCaches:=1) {
    Critical, on
    If (toolTipGuiCreated=2)
       SetTimer, RemoveTooltip, -9500

    mustCaptureCloneBrush := 0
    fnOutputDebug("Close window: " prevOpenedWindow[1] "---" prevOpenedWindow[2])
    If (isNowFakeWinOpen=1 && AnyWindowOpen)
    {
       isNowFakeWinOpen := AnyWindowOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
       SetTimer, CloseMsgBox2Win, Delete
       SetTimer, WatchMsgBox2Win, Delete
       MsgBox2Result := "win_closed"
       MsgBox2InputHook.Stop()
       Gui, WinMsgBox: Destroy
       MsgBox2hwnd := ""
       Sleep, 25
       Return
    }

    If (forceIT!="yes")
    {
       If (A_TickCount - lastLongOperationAbort < 1000)
          Return
    }

    Sleep, 5
    If (imgEditPanelOpened!=1)
       ResetImgLoadStatus()

    If (AnyWindowOpen>0 && imgEditPanelOpened=1)
       Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%

    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("AnyWindowOpen", 0)
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    liveDrawingBrushTool := isNowFakeWinOpen := ForceNoColorMatrix := 0
    interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
    DestroyGIFuWin()
    Gui, SettingsGUIA: Destroy
    WinActivate, ahk_id %PVhwnd%
    interfaceThread.ahkassign("imgEditPanelOpened", 0)
    If globalhFIFimg
    {
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }

    If (imgEditPanelOpened=1)
    {
       ; coreDesiredPixFmt := StrLen(UserMemBMP)>2 ? "0x26200A" : "0xE200B" ; 32-ARGB // 32-PARGB
       If (AnyWindowOpen=64)
          clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)

       If (AnyWindowOpen=23 && editingSelectionNow=1)
       {
          If (FillAreaShape<=2)
             EllipseSelectMode := 0
          Else If (FillAreaShape=3)
             EllipseSelectMode := 1
          Else If (FillAreaShape=7)
             EllipseSelectMode := 2
       }

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
       ToggleVisibilityWindow("hide", hGDIthumbsWin)
       Gdip_GraphicsClear(2NDglPG, "0xff" WindowBGRcolor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)
       editingSelectionNow := prevOpenedWindow[4]
       dummyTimerDelayiedImageDisplay(90)
       TriggerMenuBarUpdate()
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       livePreviewInsertTextinArea("kill")
       If (cleanCaches!=0)
       {
          corePasteInPlaceActNow("kill")
          coreFillSelectedArea("kill")
          livePreviewDesaturateArea("kill")
       }
       ; If (AnyWindowOpen=64)
       ; SetTimer, dummyRefreshImgSelectionWindow, -200
    }
    If !testIsDupesList()
       toBeExcludedIndexes := []

    imgEditPanelOpened := AnyWindowOpen := 0
    createGUItoolbar()
    If (ShowAdvToolbar=1)
       decideIconBTNmainTooler()
}

adjustCanvas2Toolbar(Gu, applyTransform) {
    If (ShowAdvToolbar!=1 || slideShowRunning=1)
       Return 0

    hasTrans := 0
    JEE_ScreenToClient(PVhwnd, UserToolbarX, UserToolbarY, thisX, thisY)
    positionOk := (isInRange(thisX, -2, 10) && isInRange(thisY, -2, 10)) ? 1 : 0
    If (positionOk=1 && (TLBRverticalAlign=1 || TLBRtwoColumns=1))
    {
       hasTrans := 1
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, ToolbarWinW, 0)
    } Else If (positionOk=1 && TLBRverticalAlign=0)
    {
       hasTrans := 2
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, 0, ToolbarWinH)
    }
    Return hasTrans
}

CreateOSDinfoLine(msg:=0, killWin:=0, forceDarker:=0, perc:=0, funcu:=0, typeFuncu:=0) {
    ; Critical, On
    Static prevMsg, preventKill, lastInvoked := 1

    If (TouchScreenMode=1)
    {
       hudBTNfuncu := funcu
       hudBTNtypeFuncu := typeFuncu
    } Else hudBTNtypeFuncu := hudBTNfuncu := 0

    If (killWin=1 || StrLen(msg)<3)
    {
       If (A_TickCount - lastInvoked<msgDisplayTime + 900) && (preventKill=1)
       || (A_TickCount - lastInvoked<350) && (killWin=1 && slideShowRunning!=1)
       {
          SetTimer, RemoveTooltip, -400
          Return
       }

       toolTipGuiCreated := 0
       interfaceThread.ahkassign("toolTipGuiCreated", 0)
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       preventKill := 0
       Return
    }

    If (A_TickCount - lastInvoked<95) && (forceDarker!=1)
    {
       SetTimer, dummyPrevShowToolTip, -200
       Return
    }

    If (A_TickCount - lastInvoked<msgDisplayTime - 300) && (preventKill=1 && prevMsg!=msg && runningLongOperation!=1)
       msgBoxWrapper(appTitle ": ERROR", prevMsg, 0, 0, "error")

    addJournalEntry("OSD: " msg)
    If (!CurrentSLD && currentFileIndex!=0) || (forceDarker=1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x66" WindowBgrColor, 1)
    Else
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)

    preventKill := 0
    If RegExMatch(msg, "i)^(error|failed)")
    {
       preventKill := 1
       uBrushA := Gdip_BrushCreateSolid("0xEEFF2200")
    } Else If RegExMatch(msg, "i)^(WARNING|operation aborted)")
       uBrushA := Gdip_BrushCreateSolid("0xEEFFDE21")

    knobSize := imgHUDbaseUnit//3.5
    posXu := uBrushA ? knobSize : 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    BoxBMP := drawTextInBox(msg, OSDFontName, OSDfntSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0)
    If !BoxBMP
    {
       Gdip_DeleteBrush(uBrushA)
       Return
    }

    hasTrans := adjustCanvas2Toolbar(2NDglPG, 1)
    posYu := perc ? knobSize//2 : 0
    Gdip_GetImageDimensions(BoxBMP, imgW, imgH)
    If (hudBTNfuncu && hudBTNtypeFuncu=2)
       Gdip_FillRectangle(2NDglPG, pBrushF, imgW, 0, mainWidth - imgW, imgHUDbaseUnit*1.12)

    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
    trGdip_DrawImage(A_ThisFunc, 2NDglPG, BoxBMP, posXu, posYu, imgW, imgH)
    hudBTNheightFuncu := imgH + posYu + tlbrBonusY
    hudBTNwidthFuncu := imgW + posXu + tlbrBonusX

    If uBrushA
    {
       Gdip_FillRectangle(2NDglPG, uBrushA, 0, posYu, knobSize, imgH)
       Gdip_FillRectangle(2NDglPG, uBrushA, imgW + posXu, posYu, knobSize, imgH)
    }

    If perc
    {
       percW := Round(mainWidth*perc)
       Gdip_FillRectangle(2NDglPG, pBrushE, percW, 0, mainWidth - percW + 1, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushB, 0, knobSize//2, mainWidth, 3)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, percW, knobSize//2)
    }

    If (hudBTNfuncu && hudBTNtypeFuncu=1)
    {
       Gdip_FillRectangle(2NDglPG, pBrushD, posXu, posYu, knobSize//2, imgH)
    } Else If (hudBTNfuncu && hudBTNtypeFuncu=2)
    {
       Gdip_FillRectangle(2NDglPG, pBrushA, mainWidth - knobSize//2, posYu, knobSize//2, imgHUDbaseUnit*1.12 - knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushA, posXu, posYu, knobSize//2, imgHUDbaseUnit*1.12 - knobSize//2)
    }

    If hasTrans
       Gdip_ResetWorldTransform(2NDglPG)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
    trGdip_DisposeImage(BoxBMP, 1)
    Gdip_DeleteBrush(uBrushA)
    toolTipGuiCreated := 1
    prevMsg := msg
    If (prevMsg!=msg)
       lastInvoked := A_TickCount

    lastOSDtooltipInvoked := A_TickCount
    If (forceDarker!=1)
       interfaceThread.ahkassign("toolTipGuiCreated", 1)
}

BlackedCreator(thisOpacity, killWin:=0) {
    Critical, On
    Static lastInvoked := 1
    If (killWin=1)
    {
       Gui, BlackGuia: Destroy
       Return
    }

    If (A_TickCount - lastInvoked<250)
       Return

    lastInvoked := A_TickCount
    Gui, BlackGuia: Destroy
    Sleep, 5
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Gui, BlackGuia: -DPIScale -Caption +Owner%PVhwnd% +ToolWindow +E0x80000 +E0x20 +hwndhGuiBlack
    Gui, BlackGuia: Color, c%OSDbgrColor%
    Gui, BlackGuia: Margin, 0, 0
    Gui, BlackGuia: Add, Text,+0x80 c%OSDtextColor% w%mainWidth% h%mainHeight% gRemoveTooltip, %msg%
    JEE_ClientToScreen(hPicOnGui1, 1, 1, GuiX, GuiY)
    WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBlack%
    WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight%, ahk_id %hGuiBlack%
    ; GuiX := GuiY := 0
    Gui, BlackGuia: Show, NoActivate AutoSize x%GuiX% y%GuiY%, GuiBlackedWin
    ; SetParentID(PVhwnd, hGuiBlack)
}

DestroyGIFuWin() {
    If (slideShowRunning=1 || animGIFplaying=1)
       SetTimer, ResetImgLoadStatus, -15

    autoChangeDesiredFrame("stop")
}

; =================================================================================================
; Function......: GetModuleFileNameEx
; DLL...........: Kernel32.dll / Psapi.dll
; Library.......: Kernel32.lib / Psapi.lib
; U/ANSI........: GetModuleFileNameExW (Unicode) and GetModuleFileNameExA (ANSI)
; Author........: jNizM
; Modified......:
; Links.........: http://msdn.microsoft.com/en-us/library/windows/desktop/ms683198(v=vs.85).aspx
; =================================================================================================

GetModuleFileNameEx(PID) {
; found on: https://autohotkey.com/board/topic/109557-processid-a-scriptfullpath/

    hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x001F0FFF, "UInt", 0, "UInt", PID)
    If (ErrorLevel || hProcess = 0)
       Return
    Static lpFilename, nSize := 260, int := VarSetCapacity(lpFilename, nSize, 0)
    DllCall("Psapi.dll\GetModuleFileNameEx", "Ptr", hProcess, "Ptr", 0, "Str", lpFilename, "UInt", nSize)
    DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
    Return lpFilename
}

GetCurrentProcessId() {
    Return DllCall("Kernel32.dll\GetCurrentProcessId")
}

Fnt_GetListOfFonts() {
; function stripped down from Font Library 3.0 by jballi
; from https://autohotkey.com/boards/viewtopic.php?t=4379

    Static Dummy65612414
          ,HWND_DESKTOP := 0   ;-- Device constants
          ,LF_FACESIZE  := 32  ;-- In TCHARS - LOGFONT constants

    ;-- Initialize and populate LOGFONT structure
    Fnt_EnumFontFamExProc_List := ""
    p_CharSet := 1
    p_Flags := 0x800
    VarSetCapacity(LOGFONT,A_IsUnicode ? 92:60,0)
    NumPut(p_CharSet,LOGFONT,23,"UChar")                ;-- lfCharSet

    ;-- Enumerate fonts
    EFFEP := RegisterCallback("Fnt_EnumFontFamExProc","F")
    hDC := Gdi_GetDC(HWND_DESKTOP)
    DllCall("gdi32\EnumFontFamiliesExW"
       ,"Ptr", hDC                                      ;-- hdc
       ,"Ptr", &LOGFONT                                 ;-- lpLogfont
       ,"Ptr", EFFEP                                    ;-- lpEnumFontFamExProc
       ,"Ptr", p_Flags                                  ;-- lParam
       ,"UInt", 0)                                      ;-- dwFlags (must be 0)

    DllCall("user32\ReleaseDC","Ptr",HWND_DESKTOP,"Ptr",hDC)
    DllCall("GlobalFree", "Ptr", EFFEP)
    Return Fnt_EnumFontFamExProc_List
}

Fnt_EnumFontFamExProc(lpelfe,lpntme,FontType,p_Flags) {
    Fnt_EnumFontFamExProc_List := 0
    Static Dummy62479817
          ,LF_FACESIZE := 32     ;-- In TCHARS - LOGFONT constants

    l_FaceName := StrGet(lpelfe+28,LF_FACESIZE)
    FontList.Push(l_FaceName)    ;-- Append the font name to the list
    Return 1                     ;-- Continue enumeration
}

ST_Insert(insert,input,pos=1) {
  Length := StrLen(input)
  ((pos > 0) ? (pos2 := pos - 1) : (((pos = 0) ? (pos2 := StrLen(input),Length := 0) : (pos2 := pos))))
  output := SubStr(input, 1, pos2) . insert . SubStr(input, pos, Length)
  If (StrLen(output) > StrLen(input) + StrLen(insert))
     ((Abs(pos) <= StrLen(input)/2) ? (output := SubStr(output, 1, pos2 - 1) . SubStr(output, pos + 1, StrLen(input)))
     : (output := SubStr(output, 1, pos2 - StrLen(insert) - 2) . SubStr(output, pos - StrLen(insert), StrLen(input))))
  Return output
}

SetVolume(val:=100, r:="") {
; Function by Drugwash
  v := Round(val*655.35)
  vr := r="" ? v : Round(r*655.35)
  Try DllCall("winmm\waveOutSetVolume", "UInt", 0, "UInt", (v|vr<<16))
}

initCompiled(mode) {
   fullPath2exe := GetModuleFileNameEx(QPVpid)
   If (mode=1)
   {
      zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
      mainCompiledExe := OutFileName
      mainCompiledPath := OutDir
      thumbsCacheFolder := OutDir "\thumbs-cache"
      mainSettingsFile := OutDir "\" mainSettingsFile
      mainRecentsFile := OutDir "\" mainRecentsFile
      mainFavesFile := OutDir "\" mainFavesFile
      miniFavesFile := OutDir "\" miniFavesFile
   } Else
   {
      mainCompiledPath := A_ScriptDir
      unCompiledExePath := Chr(34) fullPath2exe Chr(34) A_Space Chr(34) A_ScriptFullPath Chr(34)
   }
}

RunAdminMode() {
  If !A_IsAdmin
  {
      Try {
         If A_IsCompiled
            Run *RunAs "%fullPath2exe%" /restart
         Else
            Run *RunAs "%A_AhkPath%" /restart "%A_ScriptFullPath%"

         ExitApp
      }
  }
}

FileAssociate(Label,Ext,Cmd,Icon:="", batchMode:=0) {
  Static q := Chr(34)
  ; by Ħakito: https://autohotkey.com/boards/viewtopic.php?f=6&t=55638 
  ; modified by Marius Șucan to AHK v1.1
  ; Weeds out faulty extensions, which must start with a period, and contain more than 1 character
  IF (SubStr(Ext,1,1)!="." || StrLen(Ext)<=1)
     Return 0

  ; Weeds out faulty labels such as ".exe" which is an extension and not a label
  IF (SubStr(Label,1,1)=".")
     Return 0

  If Label
     RegRead, CheckLabel, HKEY_CLASSES_ROOT\%Label%, FriendlyTypeName

  ; Do not allow the modification of some important registry labels
  iF (Cmd!="" && CheckLabel)
     Return 0

  regFile := "Windows Registry Editor Version 5.00`n`n"
  ; Note that "HKEY_CLASSES_ROOT" actually writes to "HKEY_LOCAL_MACHINE\SOFTWARE\Classes"
  ; If the command is just a simple path, then convert it into a proper run command
  iF (SubStr(Cmd,2,2)=":\" && FileExist(Cmd))
     Cmd := q Cmd q A_Space q "%1" q
  Else
     Return 0

  Cmd := StrReplace(Cmd, "\", "\\")
  Cmd := StrReplace(Cmd, """", "\""")
  typeInfo := "`n""ContentType""=" q "image/" Ext q "`n""PerceivedType""=" q "image" q "`n"
  regFile .= "[HKEY_CLASSES_ROOT\" Ext "]`n@=" q Label q typeInfo
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "]`n@=" q Label q "`n"
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "\Shell\Open\Command]`n@=" q Cmd q "`n"

  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Ext "]`n@=" q Label q typeInfo
  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Label "]`n@=" q Label q "`n"
  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Label "\Shell\Open\Command]`n@=" q Cmd q "`n"

  regFile .= "`n[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\UserChoice]`n""ProgId""=" q Label q "`n"
  regFile .= "`n[-HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\OpenWithProgids]`n"
  regFile .= "`n[-HKEY_CLASSES_ROOT\" Ext "\OpenWithProgids]`n`n"

  ; If Icon
  ;    regFile .= "`n[HKEY_CLASSES_ROOT\" QPVslideshow "\DefaultIcon]`n@=" Icon "`n`n"
  If !FolderExist(mainCompiledPath "\regFiles")
  {
     FileCreateDir, %mainCompiledPath%\regFiles
     If ErrorLevel
        Return 0

     Sleep, 1
  }

  iExt := StrReplace(Ext, ".")
  FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
  Sleep, 1
  FileAppend, % regFile, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg, UTF-16
  If ErrorLevel
     Return 0

  runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegFormat" iExt ".reg" q "`n"
  If !InStr("|WIN_7|WIN_8|WIN_8.1|WIN_VISTA|WIN_2003|WIN_XP|WIN_2000|", "|" A_OSVersion "|")
     runTarget .= q mainCompiledPath "\SetUserFTA.exe" q A_Space Ext A_Space Label "`n"

  FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
  If ErrorLevel
     Return 0

  If (batchMode!=1)
  {
     Sleep, 1
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 1
     FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
     FileDelete, %mainCompiledPath%\regFiles\runThis.bat
  }

  Return 1
}


; ==================================================================================================================================
; function by «just me», source https://www.autohotkey.com/boards/viewtopic.php?t=18081
;
; Creates an 'open with' menu for the passed file.
; Parameters:
;     FilePath    -  Fully qualified path of a single file.
;     Recommended -  Show only recommended apps (True/False).
;                    Default: True
;     ShowMenu    -  Immediately show the menu (True/False).
;                    Default: False
;     MenuName    -  The name of the menu.
;                    Default: OpenWithMenu
;     Others      -  Name of the submenu holding not recommended apps (if Recommended has been set to False).
;                    Default: Others
; Return values:
;     On success the function returns the menu's name unless ShowMenu has been set to True.
;     If the menu couldn't be created, the function returns False.
; Remarks:
;     Requires AHK 1.1.23.07+ and Win Vista+!!!
;     The function registers itself as the menu handler.
; Credits:
;     Based on code by querty12 -> autohotkey.com/boards/viewtopic.php?p=86709#p86709.
;     I hadn't even heard anything about the related API functions before.
; MSDN:
;     SHAssocEnumHandlers -> msdn.microsoft.com/en-us/library/bb762109%28v=vs.85%29.aspx
;     SHCreateItemFromParsingName -> msdn.microsoft.com/en-us/library/bb762134%28v=vs.85%29.aspx
; ==================================================================================================================================
CreateOpenWithMenu(FilePath, Recommended := 1, ShowMenu := 0, MenuName := "OpenWithMenu", Others := "Others") {
   Static RecommendedHandlers := []
        , OtherHandlers := []
        , HandlerID := A_TickCount
        , HandlerFunc := 0
        , ThisMenuName := ""
        , ThisOthers := ""
   ; -------------------------------------------------------------------------------------------------------------------------------
   Static IID_IShellItem := 0, BHID_DataObject := 0, IID_IDataObject := 0
        , Init := VarSetCapacity(IID_IShellItem, 16, 0) . VarSetCapacity(BHID_DataObject, 16, 0)
          . VarSetCapacity(IID_IDataObject, 16, 0)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}", "Ptr", &BHID_DataObject)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{0000010e-0000-0000-C000-000000000046}", "Ptr", &IID_IDataObject)
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; Handler call
   If (Recommended = HandlerID) {
      AssocHandlers := A_ThisMenu = ThisMenuName ? RecommendedHandlers : OtherHandlers
      If (AssocHandler := AssocHandlers[A_ThisMenuItemPos]) && FileExist(FilePath) {
         AssocHandlerInvoke := NumGet(NumGet(AssocHandler + 0, "UPtr"), A_PtrSize * 8, "UPtr")
         If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", FilePath, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", Item) {
            BindToHandler := NumGet(NumGet(Item + 0, "UPtr"), A_PtrSize * 3, "UPtr")
            If !DllCall(BindToHandler, "Ptr", Item, "Ptr", 0, "Ptr", &BHID_DataObject, "Ptr", &IID_IDataObject, "PtrP", DataObj) {
               DllCall(AssocHandlerInvoke, "Ptr", AssocHandler, "Ptr", DataObj)
               ObjRelease(DataObj)
            }
            ObjRelease(Item)
         }
      }
      Try Menu, %ThisMenuName%, DeleteAll
      For Each, AssocHandler In RecommendedHandlers
         ObjRelease(AssocHandler)
      For Each, AssocHandler In OtherHandlers
         ObjRelease(AssocHandler)
      RecommendedHandlers := []
      OtherHandlers := []
      Return
   }
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; User call
   If !FileExist(FilePath)
      Return 0

   ThisMenuName := MenuName
   ThisOthers := Others
   SplitPath, FilePath, , , Ext
   For Each, AssocHandler In RecommendedHandlers
      ObjRelease(AssocHandler)
   For Each, AssocHandler In OtherHandlers
      ObjRelease(AssocHandler)
   RecommendedHandlers:= []
   OtherHandlers:= []
   Try Menu, %ThisMenuName%, DeleteAll
   Try Menu, %ThisOthers%, DeleteAll
   ; Try to get the default association
   Size := VarSetCapacity(FriendlyName, 520, 0) // 2
   DllCall("Shlwapi.dll\AssocQueryString", "UInt", 0, "UInt", 4, "Str", "." . Ext, "Ptr", 0, "Str", FriendlyName, "UIntP", Size)
   HandlerID := A_TickCount
   HandlerFunc := Func(A_ThisFunc).Bind(FilePath, HandlerID)
   Filter := !!Recommended ; ASSOC_FILTER_NONE = 0, ASSOC_FILTER_RECOMMENDED = 1
   ; Enumerate the apps and build the menu
   If DllCall("Shell32.dll\SHAssocEnumHandlers", "WStr", "." . Ext, "UInt", Filter, "PtrP", EnumHandler)
      Return 0

   EnumHandlerNext := NumGet(NumGet(EnumHandler + 0, "UPtr"), A_PtrSize * 3, "UPtr")
   While (!DllCall(EnumHandlerNext, "Ptr", EnumHandler, "UInt", 1, "PtrP", AssocHandler, "UIntP", Fetched) && Fetched)
   {
      VTBL := NumGet(AssocHandler + 0, "UPtr")
      AssocHandlerGetUIName := NumGet(VTBL + 0, A_PtrSize * 4, "UPtr")
      AssocHandlerGetIconLocation := NumGet(VTBL + 0, A_PtrSize * 5, "UPtr")
      AssocHandlerIsRecommended := NumGet(VTBL + 0, A_PtrSize * 6, "UPtr")
      UIName := ""
      If !DllCall(AssocHandlerGetUIName, "Ptr", AssocHandler, "PtrP", StrPtr, "UInt")
      {
         UIName := StrGet(StrPtr, "UTF-16")
         DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
      } Else UIName := AssocHandler

      If (UIName!="")
      {
         If !DllCall(AssocHandlerGetIconLocation, "Ptr", AssocHandler, "PtrP", StrPtr, "IntP", IconIndex := 0, "UInt")
         {
            IconPath := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         If (SubStr(IconPath, 1, 1) = "@")
         {
            VarSetCapacity(Resource, 4096, 0)
            If !DllCall("Shlwapi.dll\SHLoadIndirectString", "WStr", IconPath, "Ptr", &Resource, "UInt", 2048, "PtrP", 0)
               IconPath := StrGet(&Resource, "UTF-16")
         }
         ItemName := StrReplace(UIName, "&", "&&")
         If (Recommended || !DllCall(AssocHandlerIsRecommended, "Ptr", AssocHandler, "UInt"))
         {
            If (UIName=FriendlyName)
            {
               If RecommendedHandlers.Count()
               {
                  Menu, %ThisMenuName%, Insert, 1&, %ItemName%, % HandlerFunc
                  RecommendedHandlers.InsertAt(1, AssocHandler)
               } Else
               {
                  Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
                  RecommendedHandlers.Push(AssocHandler)
               }
         ;      Menu, %ThisMenuName%, Default, %ItemName%
            } Else
            {
               Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
               RecommendedHandlers.Push(AssocHandler)
            }
            Try Menu, %ThisMenuName%, Icon, %ItemName%, %IconPath%, %IconIndex%
         } Else
         {
            Menu, %ThisOthers%, Add, %ItemName%, % HandlerFunc
            OtherHandlers.Push(AssocHandler)
            Try Menu, %ThisOthers%, Icon, %ItemName%, %IconPath%, %IconIndex%
         }
      } Else ObjRelease(AssocHandler)
   }

   ObjRelease(EnumHandler)
   ; All done
   If !RecommendedHandlers.Count() && !OtherHandlers.Count()
      Return 0

   If OtherHandlers.Count()
      Menu, %ThisMenuName%, Add, %ThisOthers%, :%ThisOthers%

   If (ShowMenu=1)
      Menu, %ThisMenuName%, Show
   Else
      Return ThisMenuName
}

invokeSHopenWith() {
; function by zcooler
; source:  https://www.autohotkey.com/boards/viewtopic.php?t=17850

  ; msdn.microsoft.com/en-us/library/windows/desktop/bb762234(v=vs.85).aspx
  ; OAIF_ALLOW_REGISTRATION   0x00000001 - Enable the "always use this program" checkbox. If not passed, it will be disabled.
  ; OAIF_REGISTER_EXT         0x00000002 - Do the registration after the user hits the OK button.
  ; OAIF_EXEC                 0x00000004 - Execute file after registering.
  OAIF := {ALLOW_REGISTRATION: 0x00000001, REGISTER_EXT: 0x00000002, EXEC: 0x00000004}
  imgPath := getIDimage(currentFileIndex)
  VarSetCapacity(OPENASINFO, A_PtrSize * 3, 0)
  NumPut(&imgPath, OPENASINFO, 0, "Ptr")
  NumPut(0x04, OPENASINFO, A_PtrSize * 2, "UInt")
  DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", 0, "Ptr", &OPENASINFO)
}

ReadSettingsAutoCropPanel() {
    IniAction(0, "AutoCropAdaptiveMode", "General", 1)
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "UIcropThreshold", "General", 2, 0, 99)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "usrAutoCropColorTolerance", "General", 2, 0, 255)
    IniAction(0, "usrAutoCropDeviation", "General", 2, -50, 50)
    IniAction(0, "usrAutoCropDeviationPixels", "General", 1)
    IniAction(0, "usrAutoCropDeviationSnap", "General", 1)
    IniAction(0, "usrAutoCropGenerateSelection", "General", 1)
}

PanelImgAutoCrop() {
    Global UIcropThreshold, btnFldr, infoCropTolerance, infoCropThreshold, infoCropDeviation, mainBtnACT, editF5
    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    If (vpIMGrotation>0)
    {
       vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    }

    thisBtnHeight := createSettingsGUI(17, A_ThisFunc)
    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 220

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       slide2Wid := slide2Wid + 75
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsAutoCropPanel()
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    filesElected := getSelectedFiles(0, 1)
    UIcropThreshold := Round(usrAutoCropImgThreshold * 100)
    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       usrAutoCropGenerateSelection := 1

    Gui, Add, Text, x15 y15 Section, Please adjust the following parameters for best results.
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    Gui, Add, Text, x+1 yp, Image corners preview
    Gui, -DPIScale
    Gui, Add, Text, xp+1 y+1 w220 h220 +0xE gTglAutoCropBorderzSize +hwndhCropCornersPic, -
    Gui, +DPIScale
    Gui, Add, Slider, xs yp+1 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropColorTolerance Range0-254, % usrAutoCropColorTolerance
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropThreshold, Image threshold: %UIcropThreshold%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vUIcropThreshold Range0-99, % UIcropThreshold
    Gui, Add, Text, xs y+8 w%slide2Wid% gresetAutoCropDeviation vinfoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropDeviation Range-50-50, %usrAutoCropDeviation%

    Gui, Add, Checkbox, y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropDeviationSnap% vusrAutoCropDeviationSnap, Snap to original image edges
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%usrAutoCropDeviationPixels% vusrAutoCropDeviationPixels, Deviation factor in pixels
    Gui, Add, Checkbox, xs y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropGenerateSelection% vusrAutoCropGenerateSelection, Generate an image selection
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%AutoCropAdaptiveMode% vAutoCropAdaptiveMode, Adaptive color variations
 
    thisW := (filesElected>1) ? "" : "w1"
    thisH := (filesElected>1) ? "" : "h1"
    thisY := (filesElected>1) ? "+20" : "p-20"
    Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr %thisW% %thisH% Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder: 
    Gui, Add, Edit, xp+10 y+5 wp %thisH% r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 %thisW% %thisH% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 %thisW% %thisH%, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 %thisW% %thisH% gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10 %thisW% %thisH%, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 %thisH% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       GuiControl, Disable, usrAutoCropGenerateSelection

    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to process: %filesElected%.`nMulti-threaded processing not yet implemented.`nFiles in unsupported write formats will be skipped.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y%thisY% h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>

    If (filesElected>1)
    {
       Gui, Add, Button, x+5 hp w%btnWid% Default gBTNautoCropRealtime vmainBtnACT, &Viewport preview
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Process files...
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    } Else
    {
       Gui, Add, Button, x+5 hp w90 Default gBTNautoCropRealtime vmainBtnACT, &Apply
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Save image
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    }

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Automatic image crop: " appTitle, winPos)
    Sleep, 1
    captureImgCorners(useGdiBitmap())
    ResetImgLoadStatus()
}

resetAutoCropDeviation() {
    GuiControl, SettingsGUIA:, usrAutoCropDeviation, 0
    UpdateAutoCropParams()
}

UpdateAutoCropParams() {
    GuiControlGet, UIcropThreshold
    GuiControlGet, usrAutoCropColorTolerance
    GuiControlGet, usrAutoCropGenerateSelection
    GuiControlGet, usrAutoCropDeviation
    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeDestFolder
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    usrAutoCropImgThreshold := UIcropThreshold/100
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    GuiControl, SettingsGUIA:, infoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    GuiControl, SettingsGUIA:, infoCropThreshold, Image threshold: %UIcropThreshold%
    GuiControl, SettingsGUIA:, infoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    SetTimer, WriteSettingsAutoCropPanel, -200
}

WriteSettingsAutoCropPanel() {
   INIaction(1, "ResizeUseDestDir", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "AutoCropAdaptiveMode", "General")
   INIaction(1, "usrAutoCropDeviationPixels", "General")
   INIaction(1, "usrAutoCropDeviationSnap", "General")
   INIaction(1, "usrAutoCropDeviation", "General")
   INIaction(1, "usrAutoCropGenerateSelection", "General")
   INIaction(1, "usrAutoCropColorTolerance", "General")
   INIaction(1, "UIcropThreshold", "General")
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "userActionConflictingFile", "General")
}

TglAutoCropBorderzSize() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 900) && (AutoCropBordersSize!=5)
       AutoCropBordersSize := 5
    Else
       AutoCropBordersSize := (AutoCropBordersSize=15) ? 30 : 15
    captureImgCorners(useGdiBitmap())
    lastInvoked := A_TickCount
}

captureImgCorners(whichBmp) {
   If !whichBmp
      Return

   cornersBMP2 := coreCaptureImgCorners(whichBmp)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP2)
   SetImage(hCropCornersPic, hBitmap)
   trGdip_DisposeImage(cornersBMP2, 1)
   Gdi_DeleteObject(hBitmap)
}

coreCaptureImgCorners(whichBmp, thisSize:=0, thisBoxSize:=0) {
    boxSize := (thisBoxSize=0) ? 220 : thisBoxSize
    realSize := (thisSize=0) ? AutoCropBordersSize : thisSize
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, boxSize, boxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return

    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    If (editingSelectionNow=1)
    {
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       X1 := Y1 := 0
       X2 := ImgSelW := imgW
       Y2 := ImgSelH := imgH
    }

    Loop, 3
    {
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, boxSize//2, boxSize//2, X1, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, 0, boxSize//2, boxSize//2, X2 - realSize, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, boxSize//2, boxSize//2, boxSize//2, X1, Y2 - realSize, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, boxSize//2, boxSize//2, boxSize//2, X2 - realSize, Y2 - realSize, realSize, realSize)
    }

    Static borderSize := 8
    Gdip_DeleteGraphics(G)
    cornersBMP2 := trGdip_CreateBitmap(A_ThisFunc, boxSize+borderSize, boxSize+borderSize, coreDesiredPixFmt)
    If cornersBMP2
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP2, 3)
       If G2
       {
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, cornersBMP, borderSize//2, borderSize//2)
       }
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(cornersBMP, 1)
    Return cornersBMP2
}

AutoCropAction(zBitmap, varTolerance, threshold, silentMode:=0, forceNoSel:=0) {
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 0", 0, 0, 0.001)

   aBitmap := trGdip_BitmapConvertGray(zBitmap)
   If !aBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   Gdip_GetImageDimensions(aBitmap, Width, Height)
   pBitmap := trGdip_ResizeBitmap(A_ThisFunc, aBitmap, Width//2, Height//2, 0)
   trGdip_DisposeImage(aBitmap, 1)
   If !pBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   ; pBitmap := aBitmap
   alphaUniform := Gdip_TestBitmapUniformity(pBitmap, 3, maxLevelIndex, maxLevelPixels)
   If (alphaUniform=1)
   {
      If (silentMode=0)
      {
         showTOOLtip("The image seems to be uniformly colored")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   selCoords := CoreAutoCropAlgo(pBitmap, varTolerance, threshold)
   trGdip_DisposeImage(pBitmap, 1)
   If (selCoords="error")
   {
      SoundBeep, 300, 100
      showTOOLtip("Auto-crop processing aborted by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   selCoords := StrSplit(selCoords, ",")
   X1 := selCoords[1], Y1 := selCoords[2]
   X2 := selCoords[3], Y2 := selCoords[4]

   If (silentMode=0)
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
   }

   If (usrAutoCropGenerateSelection=0 || forceNoSel=1)
   {
      newW := X2 - X1
      newH := Y2 - Y1
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, X1, Y1, newW, newH)
      return kBitmap
   } Else
   {
      vPselRotation := EllipseSelectMode := 0
      ImgSelX1 := X1, ImgSelY1 := Y1
      ImgSelX2 := X2, ImgSelY2 := Y2
      defineRelativeSelCoords(Width, Height)
   }
}

CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode:=0) {
   If !pBitmap
   {
      addJournalEntry(A_ThisFunc "(): no bitmap given for auto-cropping")
      Return "error"
   }

   interfaceThread.ahkassign("canCancelImageLoad", 1)
   Gdip_GetImageDimensions(pBitmap, Width, Height)
   maxThresholdHitsW := Round(Width*threshold) + 1
   If (maxThresholdHitsW>Width//2)
      maxThresholdHitsW := Width//2

   maxThresholdHitsH := Round(Height*threshold) + 1
   If (maxThresholdHitsH>Height//2)
      maxThresholdHitsH := Height//2

   If (threshold=0)
      maxThresholdHitsW := maxThresholdHitsH := 1

   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E1
      Return "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 1 - Y1", 0, 0, 0.1)

   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := abortImgLoad := 0
   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
     ;  sleep, 10
      ;    ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW " [" varTolerance "]" "`n" firstR1 ", " primeR1a ", " primeR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.2, R1 + varTolerance//1.2) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y1
      {
         Y1 := y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 2 - X1", 0, 0, 0.3)

   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X1
      {
         X1 := x - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 3 - Y2", 0, 0, 0.5)

   Gdip_UnlockBits(pBitmap, BitmapData1)
   Gdip_ImageRotateFlip(pBitmap, 2)
   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := 0
   E2 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E2
      Return "error"

   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y2
      {
         Y2 := Height - y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 4 - X2", 0, 0, 0.8)
   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X2
      {
         X2 := Width - x - 1
         Break
      }
   }

   deviationW := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Width/100)*usrAutoCropDeviation)
   deviationH := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Height/100)*usrAutoCropDeviation)
   If (usrAutoCropDeviationSnap=1 && X1>2) || (usrAutoCropDeviationSnap=0)
      X1 -= deviationW
   If (usrAutoCropDeviationSnap=1 && Y1>2) || (usrAutoCropDeviationSnap=0)
      Y1 -= deviationH
   If (usrAutoCropDeviationSnap=1 && X2<Width-3) || (usrAutoCropDeviationSnap=0)
      X2 += deviationW
   If (usrAutoCropDeviationSnap=1 && Y2<Height-3) || (usrAutoCropDeviationSnap=0)
      Y2 += deviationH

   ; ToolTip, % X1 "," Y1 "--" X2 "," Y2 "`n" maxThresholdHitsW "--" maxThresholdHitsH "--" firstR1, , , 2
   If (X1="" || X1>Width - 2)
      X1 := Width - 3
   If (Y1="" || Y1>Height - 2)
      Y1 := Height - 3
   If (X2="" || X2<3)
      X2 := 3
   If (Y2="" || Y2<3)
      Y2 := 3

   X2 := X2*2, Y2 := Y2*2
   X1 := X1*2, Y1 := Y1*2
   If (X2 < X1 - 2)
      X2 := X1 + 2
   If (Y2 < Y1 - 2)
      Y2 := Y1 + 2

   selCoords := x1 "," y1 "," x2 "," y2
   Gdip_UnlockBits(pBitmap, BitmapData1)
   If (abortImgLoad>1)
      selCoords := "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nDONE", 0, 0, 0.99)
   interfaceThread.ahkassign("canCancelImageLoad", 0)
   Return selCoords
}

BTNsaveAutoCroppedFile() {
    UpdateAutoCropParams()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchAutoCropFiles()
       Return
    }

   BTNautoCropRealtime()
   BtnCloseWindow()
   PanelSaveImg()
}

coreAutoCropFileProcessing(imgPath, file2save, silentMode) {
    oBitmap := LoadBitmapFromFileu(imgPath)
    If !oBitmap
       Return -3

    Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold, silentMode, 1)
    trGdip_DisposeImage(oBitmap, 1)
    If !kBitmap
       Return -1

    Gdip_GetImageDimensions(kBitmap, imgW, imgH)
    If (imgW>oImgW-1) && (imgH>oImgH-1)
       Return -2

    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, 90)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    Return r
}

batchAutoCropFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to crop " filesElected " files? The auto-crop algorithm may take some time to finish going through all of them. Hold ESC to abandon it."
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"

      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."

      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing image auto-crop on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         If failedFiles
            someErrors := "`nErrors occured for " failedFiles "files..."
         If skippedFiles
            someErrors .= "`n" skippedFiles "files were skipped"

         showTOOLtip("Performing image auto-crop on " countTFilez "/" filesElected " files, please wait..." someErrors, 0, 0, (countTFilez + skippedFiles)/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (!RegExMatch(imgPath, saveTypesRegEX) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         destImgPath := ResizeDestFolder "\" OutFileName
      } Else destImgPath := imgPath

      If (ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      countTFilez++
      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreAutoCropFileProcessing(imgPath, destImgPath, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " failedFiles "files..."
   If skippedFiles
      someErrors .= "`n" skippedFiles "files were skipped"
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip(countFilez " out of " countTFilez " selected images were automatically cropped" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNautoCropRealtime() {
  Static wasAutoCropped := 0

  lockSelectionAspectRatio := 1
  defineSelectionAspectRatios()
  GuiControl, SettingsGUIA: Disable, mainBtnACT
  SetTimer, reactivateMainBtnACT, -350
  If (AnyWindowOpen=17)
     UpdateAutoCropParams()
  Else If (AnyWindowOpen=12)
     usrAutoCropGenerateSelection := 1

  If (usrAutoCropGenerateSelection=0)
  {
     editingSelectionNow := 0
     wasAutoCropped := performAutoCropNow := 1
     updateUIctrl()
     RefreshImageFile()
     MouseMoveResponder()
  } Else
  {
     resultu := getIDimage(currentFileIndex)
     If FileExist(resultu)
     {
        thumbBMP := LoadBitmapFromFileu(resultu)
        FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
        If thumbBMP
        {
           AutoCropAction(thumbBMP, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
           trGdip_DisposeImage(thumbBMP, 1)
        }

        editingSelectionNow := performAutoCropNow := 1
        If (wasAutoCropped=0)
           dummyTimerDelayiedImageDisplay(50)
        Else
           RefreshImageFile()
     }
  }

  If (AnyWindowOpen=17)
  {
     captureImgCorners(useGdiBitmap())
  } Else If (editingSelectionNow=1 && AnyWindowOpen=12)
  {
     GuiControl, SettingsGUIA: Enable, jpegDoCrop
     GuiControl, SettingsGUIA: , jpegDoCrop, 1
  }
}

coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   Try wiaImg := WIA_LoadImage(imgPath)
   If !IsObject(wiaImg)
   {
      addJournalEntry("Failed to load and process image file using WIA`n" imgPath)
      Return 0
   }

   imgW := wiaImg.Width, imgH := wiaImg.Height
   If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
   {
      If (relativeImgSelCoords=1 && editingSelectionNow=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      wiaImg := WIA_CropImage(wiaImg, X1, Y1, X2, Y2)
   }

   If (rotateAngle!=0 && isNumber(rotateAngle))
      wiaImg := WIA_RotateImage(wiaImg, rotateAngle)

   If (SimpleOperationsFlipH=1)
      wiaImg := Wia_FlipImage(wiaImg, "Horizontal")
   If (SimpleOperationsFlipV=1)
      wiaImg := Wia_FlipImage(wiaImg, "Vertical")

   imgW := wiaImg.Width, imgH := wiaImg.Height
   thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
   thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
   changeMcursor()
   If (IsObject(wiaImg) && ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
      Try wiaImg := WIA_ScaleImage(wiaImg, thisW, thisH, 0)

    If (FileExist(file2save) && IsObject(wiaImg))
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    If IsObject(wiaImg)
       r := WIA_SaveImage(wiaImg, file2save)
    Else r := 0

    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       r := 0
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

   wiaImg := ""
   Return !r
}

coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}
    oBitmap := trGdip_CreateBitmapFromFile(imgPath)
    If StrLen(oBitmap)>2
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
       If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
          ER := Gdip_BitmapConvertFormat(oBitmap, 0x26200A, 2, 1, 0, 0, 0, 0, 0)
    } Else mustOpenWithWia := 1

    capMaxGDIbmpSize32bits()
    If (imgW<1) || (imgH<1) || InStr(pixFmt, "0x") || ER || (imgW*imgH>maxGDIbmpSize - 10) || (imgW>32100) || (imgH>32100)
       mustOpenWithWia := 1

    If (mustOpenWithWia=1)
    {
       addJournalEntry("Failed to load and process image file using GDI+`n" imgPath)
       trGdip_DisposeImage(oBitmap, 1)
       r := coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
       Return r
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords(oBitmap, imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    imgFoperation := (rotateAngle=90) ? 1 : 0
    imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
    imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
    imgFoperation := imgOrientOpt["i" imgFoperation SimpleOperationsFlipH SimpleOperationsFlipV]
    If (imgFoperation>0)
       flipErr := Gdip_ImageRotateFlip(oBitmap, imgFoperation)

    If flipErr
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       resizeFilter := (ResizeQualityHigh=1) ? 7 : 5
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thisW, thisH, 0, resizeFilter, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If StrLen(oBitmap)>2
    {
       tempFileExists := "r"
       If FileExist(file2save)
       {
          Try FileSetAttrib, -R, % file2save
          Sleep, 0
          FileMove, % file2save, % file2save "-tmp"
          If !ErrorLevel
             tempFileExists := 1
          Sleep, 0
       }

       r := Gdip_SaveBitmapToFile(oBitmap, file2save, 90)
       If (r=-2 || r=-1)
          r := SaveFIMfile(file2save, oBitmap)

       If (r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
       {
          FileDelete, % file2save
          Sleep, 0
          FileMove, % file2save "-tmp", % file2save
       } Else If (tempFileExists=1)
          FileDelete, % file2save "-tmp"

       trGdip_DisposeImage(oBitmap, 1)
    } Else r := 1

    Return r
}

coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
  maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
  If (RegExMatch(imgPath, RegExFIMformPtrn) || (RegExMatch(imgPath, "i)(.\.(png|tiff|tif))$") && (maxLimitReached!=1 && wasInitFIMlib=1)))
     r := coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Else
     r := coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Return r
}

coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Sleep, 0
    loadArgs := 0
    GFT := FreeImage_GetFileType(imgPath)
    If (GFT=34)
       loadArgs := (userHQraw=1) ? 0 : 5
    Else If (GFT=2)
       loadArgs := 8

    hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
    If !hFIFimgA
    {
       addJournalEntry("Failed to load and process image file using FreeImage library`n" imgPath)
       Return "err"
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       hFIFimgB := FreeImage_Copy(hFIFimgA, X1, Y1, X2, Y2)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (rotateAngle>0)
    {
       changeMcursor()
       hFIFimgB := FreeImage_Rotate(hFIFimgA, rotateAngle)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, resizeFilter)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    saveArg := 0
    If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
       saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
    Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
       saveArg := clampInRange(Round(userJpegQuality), 1, 100)

    changeMcursor()
    r := FreeImage_Save(hFIFimgA, file2save, saveArg)

    FreeImage_UnLoad(hFIFimgA)
    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

PanelSimpleResizeRotate(modus:="") {
    Global mainBtnACT, btnFldr, editF5
    If !PanelsCheckFileExists()
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    imgPath := getIDimage(currentFileIndex)
    filesElected := getSelectedFiles(0, 1)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (!filesElected && !RegExMatch(imgPath, thisRegEX) && modus!="forced")
    {
       CloseWindow()
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(18, A_ThisFunc)
    ReadSettingsImageProcessing()
    btnWid := 100
    txtWid := slideWid := 280
    If (editingSelectionNow!=1)
       SimpleOperationsDoCrop := 0

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    Gui, Add, Text, x15 y15 Section, Rotate / flip:
    Gui, Add, DropDownList, x+5 w100 AltSubmit Choose%SimpleOperationsRotateAngle% vSimpleOperationsRotateAngle, 0°|90°|180°|-90° [270°]
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Vertical
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleXimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleXimgFactor%||
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleYimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleYimgFactor%||
    Gui, Add, Checkbox, xs y+10 gTglRszMustPerformResize Checked%ResizeMustPerform% vResizeMustPerform, Perform image resizing (W x H):
    Gui, Add, Edit, xs+15 y+5 w100 r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 wp r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsDoCrop% vSimpleOperationsDoCrop, Crop image(s) to selected area in viewport
    Gui, Add, Checkbox, xs y+10 Checked%ResizeQualityHigh% vResizeQualityHigh, High quality image resampling
    Gui, Add, Checkbox, xs y+15 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs+15 y+7 , In destination folder, on file name conflicts
    Gui, Add, DropDownList, x+5 w140 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite

    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    If (editingSelectionNow!=1)
       GuiControl, Disable, SimpleOperationsDoCrop

    If (filesElected>1)
    {
       msgFriendly := filesElected " files are selected for processing."
       Gui, Font, Bold
       Gui, Add, Text, xs y+20 w%txtWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.
    }

    If (filesElected<2)
    {
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       ; Gui, Add, Button, x+5 hp w%btnWid%  gBtnSaveNowSimpleProcessing , &Save image
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnSaveAsSimpleProcessing vmainBtnACT, &Save image as...
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% wp Default gBtnPerformSimpleProcessing, &Perform operations on the files

    Gui, Add, Button, xs y+5 h%thisBtnHeight% w%btnWid% gBtnInvokePanelResizeImageWindow, &Advanced mode
    Gui, Add, Button, x+5 hp w80 gResizePanelHelpBoxInfo, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / crop / rotate image [simple mode]: " appTitle)
    ResetImgLoadStatus()
    SetTimer, TglRszMustPerformResize, -300
}

BtnInvokePanelResizeImageWindow() {
   BtnCloseWindow()
   Sleep, 10
   PanelResizeImageWindow()
}

BtnSaveAsSimpleProcessing() {
    BtnPerformSimpleProcessing()
}

BtnSaveNowSimpleProcessing() {
    BtnPerformSimpleProcessing("no-prompt")
}

TglRszMustPerformResize() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
    If (ResizeMustPerform!=1)
    {
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
    } Else
    {
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
    }
}

BtnPerformSimpleProcessing(dummy:=0, contextu:="") {
    If (contextu!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
       GuiControlGet, SimpleOperationsFlipV, SettingsGUIA:, SimpleOperationsFlipV
       GuiControlGet, SimpleOperationsFlipH, SettingsGUIA:, SimpleOperationsFlipH
       GuiControlGet, SimpleOperationsDoCrop, SettingsGUIA:, SimpleOperationsDoCrop
       GuiControlGet, SimpleOperationsRotateAngle, SettingsGUIA:, SimpleOperationsRotateAngle
       GuiControlGet, SimpleOperationsScaleXimgFactor, SettingsGUIA:, SimpleOperationsScaleXimgFactor
       GuiControlGet, SimpleOperationsScaleYimgFactor, SettingsGUIA:, SimpleOperationsScaleYimgFactor
       GuiControlGet, ResizeQualityHigh, SettingsGUIA:, ResizeQualityHigh
       GuiControlGet, ResizeDestFolder, SettingsGUIA:, ResizeDestFolder
       GuiControlGet, ResizeUseDestDir, SettingsGUIA:, ResizeUseDestDir
       GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
       GuiControlGet, userJpegQuality, SettingsGUIA:, userJpegQuality
       GuiControlGet, userActionConflictingFile, SettingsGUIA:, userActionConflictingFile

       userJpegQuality := clampInRange(userJpegQuality, 1, 100)
       INIaction(1, "userJpegQuality", "General")
       cleanResizeUserOptionsVars()
       If (ResizeMustPerform=0 && SimpleOperationsRotateAngle=1 && SimpleOperationsFlipV=0 && SimpleOperationsFlipH=0 && SimpleOperationsDoCrop=0)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "No image transformations selected or activated to perform.", 0, 0, "exclamation")
          Return
       }

       If ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<5 || SimpleOperationsScaleYimgFactor<5) && (ResizeMustPerform=1 && ResizeInPercentage=0))
       || ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<1 || SimpleOperationsScaleYimgFactor<1) && (ResizeMustPerform=1 && ResizeInPercentage=1))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
          Return
       }
    }
 
    initFIMGmodule()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       If (contextu!="extern")
          WriteSettingsResizeSimplePanel()
       batchSimpleProcessing(simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (contextu!="extern")
    {
       Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
       oImgW := (ResizeInPercentage=1) ? Round(oImgW*(SimpleOperationsScaleXimgFactor/100)) : SimpleOperationsScaleXimgFactor
       oImgH := (ResizeInPercentage=1) ? Round(oImgH*(SimpleOperationsScaleYimgFactor/100)) : SimpleOperationsScaleYimgFactor
       newImgSize := oImgH*oImgW
       If ((newImgSize>536848912) || (oImgW>32100) || (oImgH>32100) && ResizeMustPerform=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "The resulting image dimensions are very large... the resizing might fail, depending on the file format.`n`nW x H: " oImgW " x " oImgH " pixels.", 0, 0, "Exclamation")
       }

       If (!filesElected && !RegExMatch(imgPath, thisRegEX))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "This file format (." oExt ") cannot be processed in «Simple mode». Please use the «Advanced mode» which allows file format conversions.", 0, 0, "exclamation")
          Return
       }
    }

   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : imgPath
   If (dummy="no-prompt")
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save processed image as...", oExt " images (*." oExt ")")

   If file2save
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." oExt

      If !RegExMatch(file2save, thisRegEX)
      {
         SoundBeep, 300, 100
         If (dummy="no-prompt")
         {
            If (contextu="extern")
            {
               showTOOLtip("ERROR: unsupported image file write format")
               SoundBeep , 300, 100
               SetTimer, RemoveTooltip, % -msgDisplayTime
            } Else msgBoxWrapper(appTitle ": ERROR", "Unsupported file write format. Please use one of the allowed image file formats: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         } Else msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (nExt!=oExt && StrLen(nExt)>0)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "You cannot change the image file format from ." oExt " to ." nExt ". If you want to do this, please use the «Advanced mode».", 0, 0, "exclamation")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgu := "The image file format is currently unsupported, because the FreeImage library failed to properly initialize."
         SoundBeep, 300, 100
         If (contextu="extern")
         {
            showTOOLtip("ERROR: " msgu "`n" OutFileName)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else msgBoxWrapper(appTitle ": ERROR", msgu "`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && dummy!="no-prompt" && contextu!="extern")
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      If (contextu!="extern")
      {
         GuiControl, SettingsGUIA: Disable, mainBtnACT
         SetTimer, reactivateMainBtnACT, -950
      }

      showTOOLtip("Processing image, please wait")
      r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
      If r
      {
         SoundBeep, 300, 100
         If (contextu="extern")
            showTOOLtip("ERROR: Unable to save file, error code: " r "`n" OutFileName "`n" OutDir "\")
         Else
            msgBoxWrapper(appTitle ": ERROR", "Unable to save file, error code: " r ".`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      ForceRefreshNowThumbsList()
      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      If (contextu!="extern")
      {
         SetTimer, WriteSettingsResizeSimplePanel, -90
         SoundBeep, 900, 100
      }

      showTOOLtip("Processed image saved`n" OutFileName)
      If (dummy="no-prompt")
         SetTimer, RefreshImageFile, -150

      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

batchSimpleProcessing(rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " filesElected " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " filesElected " images, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresSimpleImgProcessing(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("Image processing in batch: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, thisRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If failedFiles
            etaTime := "`nFailed to process " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Processing image files, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutFileName

      If (ResizeUseDestDir=1)
      {
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
      If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

printLargeStrArray(whichArray, maxList, delim) {
  startZeit := A_TickCount
  trenchSize := 15000
  changeMcursor()
  If (maxList<trenchSize)
  {
     Loop, % maxList
     {
          rA := whichArray[A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu .= r delim
     }
     Return filesListu
  }

  doStartLongOpDance()
  splitParts := maxList//trenchSize
  Loop, % splitParts - 1
  {
      If (A_TickCount - startZeit>2500)
         executingCanceableOperation := A_TickCount

      changeMcursor()
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu%thisIndex% .= r delim
      }

      If (determineTerminateOperation()=1) ; && (A_TickCount - startZeit>2500)
      {
         abandonAll := 1
         Break
      }
  }

  If (abandonAll=1)
  {
     SoundBeep, 300, 100
     lastLongOperationAbort := A_TickCount
     Return
  }

  Loop, % maxList - trenchSize*(splitParts - 1)
  {
      rA := whichArray[trenchSize*(splitParts - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      filesListu%splitParts% .= r delim
  }

  filesListu%splitParts% := Trimmer(filesListu%splitParts%)
  Loop, % splitParts
      result .= filesListu%A_Index%

  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
  Return result
}

GetRes(ByRef bin, lib, res, type) {
  If !A_IsCompiled
     Return 0

  hL := 0
  If lib
     hM := DllCall("kernel32\GetModuleHandleW", "Str", lib, "Ptr")

  If !lib
  {
     hM := 0  ; current module
  } Else If !hM
  {
     If (!hL := hM := DllCall("kernel32\LoadLibraryW", "Str", lib, "Ptr"))
        Return
  }

  dt := (type+0 != "") ? "UInt" : "Str"
  hR := DllCall("kernel32\FindResourceW"
      , "Ptr" , hM
      , "Str" , res
      , dt , type
      , "Ptr")

  If !hR
  {
     fnOutputDebug("GetRes() ERR " FormatMessage(A_ThisFunc "(" lib ", " res ", " type ", " l ")", A_LastError))
     Return
  }

  hD := DllCall("kernel32\LoadResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "Ptr")
  hB := DllCall("kernel32\LockResource"
      , "Ptr" , hD
      , "Ptr")
  sz := DllCall("kernel32\SizeofResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "UInt")
  If !sz
  {
     fnOutputDebug("Error: resource size 0 in  " A_ThisFunc " ( " lib " ,  " res " ,  " type " )")
     DllCall("kernel32\FreeResource", "Ptr" , hD)
     If hL
        DllCall("kernel32\FreeLibrary", "Ptr", hL)
     Return
  }

  VarSetCapacity(bin, 0), VarSetCapacity(bin, sz, 0)
  DllCall("ntdll\RtlMoveMemory", "Ptr", &bin, "Ptr", hB, "UInt", sz)
  DllCall("kernel32\FreeResource", "Ptr" , hD)

  If hL
     DllCall("kernel32\FreeLibrary", "Ptr", hL)

  Return sz
}

FormatMessage(ctx, msg, arg="") {
  Global
  Local txt, buf
  SetFormat, Integer, H
  msg+=0
  SetFormat, Integer, D
  frmMsg := DllCall("kernel32\FormatMessageW"
          , "UInt" , 0x1100 ; FORMAT_MESSAGE_FROM_SYSTEM/ALLOCATE_BUFFER
          , "Ptr"  , 0      ; lpSource
          , "UInt" , msg    ; dwMessageId
          , "UInt" , 0      ; dwLanguageId (0x0418=RO)
          , "PtrP" , buf    ; lpBuffer
          , "UInt" , 0      ; nSize
          , "Str"  , arg)   ; Arguments

  txt := StrGet(buf, "UTF-16")
  lF := DllCall("kernel32\LocalFree", "Ptr", buf)
  Result := "Error " msg " in " ctx ":`n" txt
  Return Result
}

calcHistoAvgFile(xBitmap, returnObj, isFilter, imgIndex, zEffect:=0, originalBMP:=0) {
    Static numEntries, TotalPixelz := 122500
    
    If StrLen(xBitmap)<2
       Return 0

    If !numEntries
    {
       z := DllCall("gdiplus\GdipBitmapGetHistogramSize", "UInt", 3, "UInt*", numEntries)
       numEntries := numEntries
    }

    ; brLvlArray := []
    VarSetCapacity(ch0, numEntries * 4, 0)
    R := DllCall("gdiplus\GdipBitmapGetHistogram", "Ptr", xBitmap, "UInt", 3, "UInt", numEntries, "Ptr", &ch0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
    If R
    {
       fnOutputDebug(A_ThisFunc "() failed to retrieve histogram" )
       Return 0
    }

    medianValue := -1
    pixMinu := TotalPixelz
    modePointV := peakPointV := sumTotalBr := nrPixelz := thisSum := minBrLvlV := 0
    Loop, % numEntries
    {
        thisIndex := A_Index - 1
        nrPixelz := NumGet(&ch0+0, thisIndex * 4, "UInt")
        ; nrPixelz := brLvlArray[thisIndex]
        If (nrPixelz="")
           Continue

        If (nrPixelz>modePointV)
        {
           modePointV := nrPixelz
           modePointK := thisIndex
        }

        If (nrPixelz>0 && medianValue=-1)
        {
           thisSum += nrPixelz
           If (thisSum>TotalPixelz//2)
              medianValue := thisIndex
        }

        sumTotalBr += nrPixelz * A_Index
        If (nrPixelz>0)
        {
           peakPointK := thisIndex ; max range in histogram
           If !minBrLvlK
              minBrLvlK := thisIndex   ; min range in histogram
        }

        If (nrPixelz<pixMinu)
        {
           pixMinu := nrPixelz
           minPointK := thisIndex
        }
        pixRms += nrPixelz ** 2    ; root-mean square
    }
    ; pixContent := pixBorder := 1
    If (SLDtypeLoaded=3)
    {
       entireHash := ""
       zBitmap := Gdip_ResizeBitmap(originalBMP, 9, 8, 0, 7)

       If StrLen(zBitmap)>2
       {
          Gdip_BitmapApplyEffect(zBitmap, zEffect)
          E1 := Gdip_LockBits(zBitmap, 0, 0, 9, 8, Stride1, Scan01, BitmapData1)
          If !E1
          {
             Loop, 8
             {
                pY := A_Index - 1 ; y++
                Loop, 8
                {
                   pX := A_Index - 1 ; , pY := y - 1
                   R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
                   ; If (pX=7) ; it exceeds the width
                   ;    R2 := Gdip_RFromARGB(NumGet(Scan01+0, ((pX-3)*4)+(pY*Stride1), "UInt"))
                   ; Else
                      R2 := Gdip_RFromARGB(NumGet(Scan01+0, ((pX+1)*4)+(pY*Stride1), "UInt"))

                   If (pY=0 || pY=7 || pX=0 || pX=7)
                      pixBorder .= (R1<R2) ? 1 : 0
                   Else
                      pixContent .= (R1<R2) ? 1 : 0

                   entireHash .= (R1<R2) ? 1 : 0
                   ; pixContent .= Round(Gdip_RFromARGB(NumGet(Scan01+0, ((A_Index-1)*4)+((y - 1)*Stride1), "UInt"))*0.9)
                }
             }
             Gdip_UnlockBits(zBitmap, BitmapData1)
          } 
          Gdip_DisposeImage(zBitmap, 1)
       }
    }

    avgu := (sumTotalBr/TotalPixelz - 1)/2
    rmsu := Sqrt(pixRms / (peakPointK - minBrLvlK))
    entireAsh := ConvertBase(2, 16, entireHash)
    ; If InStr(entireAsh, "-")
    ;    entireAsh := StrReplace(entireAsh, "-", "9")

    If (returnObj=1)
    {
       r := []
       r.avg := Round((avgu + 1)/256, 5)
       r.median := Round((medianValue + 1)/256, 5)
       r.peak := Round((peakPointK + 1)/256, 5)
       r.low := Round((minBrLvlK + 1)/256, 5)
       r.rms := Round((rmsu + 1)/7000, 5)
       r.range := Round((peakPointK - minBrLvlK + 1)/256, 5)
       r.mode := Round((modePointK + 1)/256, 5)
       r.minu := Round((minPointK + 1)/256, 5)
       r.innerpixelz := pixContent
       r.outerpixelz := pixBorder
       r.entireH := entireAsh
       Return r
    } Else If isFilter
    {
       bckpResultedFilesList[imgIndex, 11] := 1
       bckpResultedFilesList[imgIndex, 18] := Round((avgu + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 19] := Round((medianValue + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 20] := Round((peakPointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 21] := Round((minBrLvlK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 24] := Round((rmsu + 1)/7000, 5)
       bckpResultedFilesList[imgIndex, 25] := Round((peakPointK - minBrLvlK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 26] := Round((modePointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 27] := Round((minPointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 28] := pixContent
       bckpResultedFilesList[imgIndex, 29] := pixBorder
       bckpResultedFilesList[imgIndex, 30] := entireAsh
    } Else
    {
       resultedFilesList[imgIndex, 11] := 1
       resultedFilesList[imgIndex, 18] := Round((avgu + 1)/256, 5)
       resultedFilesList[imgIndex, 19] := Round((medianValue + 1)/256, 5)
       resultedFilesList[imgIndex, 20] := Round((peakPointK + 1)/256, 5)
       resultedFilesList[imgIndex, 21] := Round((minBrLvlK + 1)/256, 5)
       resultedFilesList[imgIndex, 24] := Round((rmsu + 1)/7000, 5)
       resultedFilesList[imgIndex, 25] := Round((peakPointK - minBrLvlK + 1)/256, 5)
       resultedFilesList[imgIndex, 26] := Round((modePointK + 1)/256, 5)
       resultedFilesList[imgIndex, 27] := Round((minPointK + 1)/256, 5)
       resultedFilesList[imgIndex, 28] := pixContent
       resultedFilesList[imgIndex, 29] := pixBorder
       resultedFilesList[imgIndex, 30] := entireAsh
    }

    ; ToolTip, % medianValue "=" r.avg "=" peakPointK "=" minBrLvlK , , , 2
    Return 1
}

GetCachableHistogramFile(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, noFileInfos:=0, isFilter:=0, zEffect:=0) {
     If (!imgPath || !imgIndex)
     {
        fnOutputDebug(A_ThisFunc "() - wow error: " imgPath "-" imgIndex)
        Return
     }

     If !thumbBMP
     {
        wasGiven := 0
        thumbBMP := LoadBitmapFromFileu(imgPath, 1, 0, 0, 0, 350, 350, 0)
        If StrLen(thumbBMP)>2
        {
           If (returnObj=1)
           {
              imgInfosObju := []
              imgInfosObju.dpi := mainLoadedIMGdetails.dpi
              imgInfosObju.w := mainLoadedIMGdetails.Width
              imgInfosObju.h := mainLoadedIMGdetails.Height
              imgInfosObju.pixFmt := mainLoadedIMGdetails.PixelFormat
              imgInfosObju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
           } Else If isFilter
           {
              bckpResultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              bckpResultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              bckpResultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              bckpResultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              bckpResultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              bckpResultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              bckpResultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           } Else
           {
              resultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              resultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              resultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              resultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              resultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              resultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              resultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           }

           If (mainLoadedIMGdetails.OpenedWith="GDI+")
              zBitmap := trGdip_ResizeBitmap(A_ThisFunc, thumbBMP, 350, 350, 0, 3, "0x21808")
           Else
              Gdip_BitmapConvertFormat(thumbBMP, "0x21808", 2, 1, 0, 0, 0, 0, 0)

           If zBitmap
           {
              ; trGdip_DisposeImage(thumbBMP, 1)
              originalBMP := thumbBMP
              thumbBMP := zBitmap
           }

           If zEffect
              Gdip_BitmapApplyEffect(thumbBMP, zEffect)
        } Else imgInfosObju := 0
     } Else imgInfosObju := wasGiven := 1 ; image object to be disposed by caller

     histoObj := calcHistoAvgFile(thumbBMP, returnObj, isFilter, imgIndex, zEffect, originalBMP)
     If !wasGiven
     {
        trGdip_DisposeImage(thumbBMP, 1)
        trGdip_DisposeImage(originalBMP, 1)
     }

     If (noFileInfos=0)
     {
        fileInfos := GetFileAttributesEx(imgPath)
        If (isFilter && returnObj!=1)
        {
           bckpResultedFilesList[imgIndex, 6] := fileInfos.size
           bckpResultedFilesList[imgIndex, 7] := fileInfos.wTime
           bckpResultedFilesList[imgIndex, 8] := fileInfos.cTime
        } Else (returnObj!=1)
        {
           resultedFilesList[imgIndex, 6] := fileInfos.size
           resultedFilesList[imgIndex, 7] := fileInfos.wTime
           resultedFilesList[imgIndex, 8] := fileInfos.cTime
        }
     }

     If (IsObject(histoObj) && returnObj=1)
        Return [histoObj, imgInfosObju, fileInfos]
     Else
        Return histoObj
        ; fnOutputDebug(A_ThisFunc "() - no cache: " imgPath)
     ; } Else fnOutputDebug(A_ThisFunc "() - failed to generate histogram: " imgIndex " = " imgPath)
}

SaveFIMfile(file2save, pBitmap) {
  initFIMGmodule()
  If !wasInitFIMlib
     Return 1

  hFIFimgA := ConvertPBITMAPtoFIM(pBitmap)
  If !hFIFimgA
  {
     SoundBeep , 300, 100
     message := "Failed to convert GDI+ image object to FreeImage object..."
     addJournalEntry(message)
     Return message 
  }

  If FileExist(file2save)
  {
     Try FileSetAttrib, -R, % file2save
     Sleep, 0
     FileMove, % file2save, % file2save "-tmp"
     If !ErrorLevel
        tempFileExists := 1

     Sleep, 0
  }

  saveArg := 0
  If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
     saveArg :=  clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
  Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
     saveArg :=  clampInRange(Round(userJpegQuality), 1, 100)

  If RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$")
  {
     hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
     changeMcursor()
     r := FreeImage_Save(hFIFimgB, file2save, saveArg)
     FreeImage_UnLoad(hFIFimgB)
  } Else r := FreeImage_Save(hFIFimgA, file2save, saveArg)

  FreeImage_UnLoad(hFIFimgA)
  If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
  {
     r := 0
     FileDelete, % file2save
     Sleep, 0
     FileMove, % file2save "-tmp", % file2save
  } Else If (tempFileExists=1)
     FileDelete, % file2save "-tmp"

  Return !r
}

initFIMGmodule() {
  Static firstTimer := 1
  If (wasInitFIMlib!=1)
  {
     r := FreeImage_FoxInit(1) ; Load the FreeImage Dll
     wasInitFIMlib := (r && !InStr(r, "err")) ? 1 : 0
     If wasInitFIMlib
        addJournalEntry("FreeImage library initialized: v" FreeImage_GetVersion())
  }

  If InStr(r, "err - ")
  {
     alwaysOpenwithFIM := 0
     FIMfailed2init := 1
     If InStr(r, "err - 126")
        friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2013."
     Else If InStr(r, "err - 404")
        friendly := "`n`nThe FreeImage.dll file seems to be missing..."

     If (firstTimer=1 && hasInitSpecialMode!=1)
     {
        SoundBeep, 300, 100
        msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Some image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
     }
  } Else FIMfailed2init := 0

  firstTimer := 0
  Return r
}

GlobalMemoryStatusEx() {
; https://msdn.microsoft.com/en-us/library/aa366589(v=vs.85).aspx 
; by jNizM
; https://github.com/jNizM/MemoryInfo/blob/master/src/MemoryInfo.ahk
    static MSEX, init := NumPut(VarSetCapacity(MSEX, 64, 0), MSEX, "uint")
    if !(DllCall("GlobalMemoryStatusEx", "ptr", &MSEX))
       Return 0
       ;  throw Exception("Call to GlobalMemoryStatusEx failed: " A_LastError, -1)
    return { MemoryLoad: NumGet(MSEX, 4, "uint"), TotalPhys: NumGet(MSEX, 8, "uint64"), AvailPhys: NumGet(MSEX, 16, "uint64") }
}

GetProcessMemoryUsage(ProcessID) {
; by jNizM
; https://www.autohotkey.com/boards/viewtopic.php?t=62848
; modified by Marius Șucan

   static PMC_EX, size := NumPut(VarSetCapacity(PMC_EX, 8 + A_PtrSize * 9, 0), PMC_EX, "uint")

   if (hProcess := DllCall("OpenProcess", "uint", 0x1000, "int", 0, "uint", ProcessID))
   {
      if !(DllCall("GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
      {
         if !(DllCall("psapi\GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
            return (ErrorLevel := 2) & 0, DllCall("CloseHandle", "ptr", hProcess)
      }
      DllCall("CloseHandle", "ptr", hProcess)
      infos := []
      infos[0] := NumGet(PMC_EX, A_PtrSize, "uptr")   ; peak working set bytes
      infos[1] := NumGet(PMC_EX, 8 + A_PtrSize, "uptr")   ; working set bytes
      infos[8] := NumGet(PMC_EX, 8 + A_PtrSize*8, "uptr") ; private bytes
      Return infos
   }
   return (ErrorLevel := 1) & 0
}

LoadFimFile(imgPath, noBPPconv, noBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
  Critical, on
  sTime := A_tickcount  
  initFIMGmodule()
  If !wasInitFIMlib
     Return

  loadArgs := (noBPPconv=1 || noBMP=1) ? -1 : 0   ; FIF_LOAD_NOPIXELS
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := (userHQraw=1 && thumbsDisplaying=0) ? 0 : 5
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  changeMcursor()
  If ((GFT=18 || GFT=25) && loadArgs!=-1)
  {
     multiFlags := (GFT=25) ? 2 : 0
     hMultiBMP := FreeImage_OpenMultiBitmap(ImgPath, GFT, 0, 1, 1, multiFlags)
  }

  fimMultiPage := ""
  If StrLen(hMultiBMP)>1
  {
     totalFramesIndex := FreeImage_GetPageCount(hMultiBMP)
     If (totalFramesIndex<0 || !totalFramesIndex)
        totalFramesIndex := 0

     If (totalFramesIndex>1)
        fimMultiPage := (GFT=18) ? "tiff" : "gif"

     desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex - 1, 1)
     ; msgbox, % totalFramesIndex "==" desiredFrameIndex
     hPage := FreeImage_LockPage(hMultiBMP, desiredFrameIndex)
     hFIFimgA := FreeImage_Clone(hPage)
     hasMultiTrans := FreeImage_GetTransparencyCount(hFIFimgA)
     ; ToolTip, % hasMultiTrans "==" desiredFrameIndex "==" totalFramesIndex , , , 2
     FreeImage_UnlockPage(hMultiBMP, hPage, 0)
     FreeImage_CloseMultiBitmap(hMultiBMP, 0)
  } Else hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs) ; load image

  If !hFIFimgA
  {
     addJournalEntry("Failed to load image file using FreeImage library")
     Return
  }

  FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
  FreeImage_GetDPIresolution(hFIFimgA, dpiX, dpiY)
  If (forceW && forceH)
  {
     If (imgW>forceW || imgH>forceH)
     {
        If (keepAratio=1)
        {
           calcIMGdimensions(imgW, imgH, forceW, forceH, xForceW, xForceH)
           hFIFimgX := FreeImage_Rescale(hFIFimgA, xForceW, xForceH, 0)
        } Else
           hFIFimgX := FreeImage_Rescale(hFIFimgA, forceW, forceH, 0)
     }

     If hFIFimgX
     {
        FreeImage_UnLoad(hFIFimgA)
        hFIFimgA := hFIFimgX
     }
  }

  imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
  ColorsType := FreeImage_GetColorType(hFIFimgA)
  If (noBPPconv=0)
     alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)

  mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
  toneMapped := ""
  If (mustApplyToneMapping=1 && noBPPconv=0 && noBMP=0)
  {
     setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
     changeMcursor()
     hFIFimgB := FreeImage_ToneMapping(hFIFimgA, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
     toneMapped := " (TONE-MAPPED)"
  }

  fileType := FreeImage_GetFileType(imgPath, 1)
  If (fileType="raw" && userHQraw!=1)
     fileType .= " [LOW QUALITY]"

  imgType := FreeImage_GetImageType(hFIFimgA, 1)
  mainLoadedIMGdetails.File := imgPath
  mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
  mainLoadedIMGdetails.Width := imgW
  mainLoadedIMGdetails.Height := imgH
  mainLoadedIMGdetails.Frames := FreeImage_SimpleGetPageCount(hFIFimgA) - 1
  mainLoadedIMGdetails.HasAlpha := (InStr(ColorsType, "rgba") || hasMultiTrans) ? 1 : 0
  mainLoadedIMGdetails.RawFormat := fileType " | " imgType
  mainLoadedIMGdetails.PixelFormat := imgBPP "-" ColorsType toneMapped
  mainLoadedIMGdetails.OpenedWith := "FreeImage library"
  mainLoadedIMGdetails.TooLargeGDI := 0
  If (noBMP=1)
  {
     FreeImage_UnLoad(hFIFimgA)
     Return 1
  }

  hFIFimgZ := hFIFimgB ? hFIFimgB : hFIFimgA
  hFIFimgC := hFIFimgZ ? hFIFimgZ : hFIFimgA
  FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)

  If (noBPPconv=0)
  {
     capMaxGDIbmpSize32bits()
     If (imgW*imgH>maxGDIbmpSize)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        calcIMGdimensions(imgW, imgH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     } Else If (imgW>32500 || imgH>32500)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        calcIMGdimensions(imgW, imgH, 32500, 32500, nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     }

     If StrLen(hFIFimgKO)>2
     {
        hFIFimgC := hFIFimgKO
        mainLoadedIMGdetails.TooLargeGDI := 1
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     }

     setWindowTitle("Converting FreeImage object to GDI+ image bitmap")
     imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
     If (imgBPPc!=32)
        hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")

     hFIFimgE := hFIFimgD ? hFIFimgD : hFIFimgC
     If alphaBitmap
     {
        hFIFimgXu := FreeImage_ConvertTo(alphaBitmap, "Greyscale")
        eRR := FreeImage_GetHistogram(hFIFimgXu, 5, histoArray)
        mustInvert := eRR
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && A_Index>2)
               mustInvert := 0
        }
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 3, 254))
               HasAlpha := 1
        }

        ; ToolTip, % lola " = " eRR " - " mustInvert  " / " HasAlpha , , , 2
        If (mustInvert=1)
        {
           FreeImage_Invert(hFIFimgXu)
           FreeImage_SetChannel(hFIFimgE, hFIFimgXu, 4)
        }

        mainLoadedIMGdetails.HasAlpha := HasAlpha
        FreeImage_UnLoad(hFIFimgXu)
        FreeImage_UnLoad(alphaBitmap)
     }
     ; FreeImage_PreMultiplyWithAlpha(hFIFimgE)
     pBitmap := ConvertFIMtoPBITMAP(hFIFimgE)
  } Else pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)

  ; Gdip_GetImageDimensions(pBitmap, imgW2, imgH2)
  imgIDs := hFIFimgA "|" hFIFimgB "|" hFIFimgC "|" hFIFimgKO "|" hFIFimgD "|" hFIFimgE "|" hFIFimgZ
  Sort, imgIDs, UD|
  Loop, Parse, imgIDs, |
  {
      If A_LoopField
         FreeImage_UnLoad(A_LoopField)
  }

  eTime := A_TickCount - sTime
  ; ToolTip, % imgW ", " imgW2,,,2
  ; Tooltip, % etime "; " noPixels "; " GFT
  ; Tooltip, %r1% -- %r2% -- %pBits% ms ---`n %pbitmap% -- %hbitmap% -- %hfifimg%
  ; ToolTip, % Gdip_GetImagePixelFormat(pBitmap, 2) , , , 2
  Return pBitmap
}

changeMcursor(whichCursor:=0) {
  Static lastInvoked := 1, prevCursor := "none"
  If ((drawingShapeNow=1 || slideShowRunning=1 || animGIFplaying=1 || (A_TickCount - zeitSillyPrevent<300) || hasInitSpecialMode=1) && imageLoading!=1)
     Return

  If (whichCursor)
  {
     prevCursor := whichCursor
     interfaceThread.ahkPostFunction("changeMcursor", whichCursor)
  } Else If (A_TickCount - lastInvoked > 500) ; && (imageLoading!=1)
  {
     interfaceThread.ahkPostFunction("changeMcursor", "busy")
     ; interfaceThread.ahkassign("imageLoading", 1)
     ; Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
     lastInvoked := A_TickCount
  }
}

GetImgFileDimension(imgPath, ByRef W, ByRef H, fastWay:=1) {
   Static prevImgPath, prevW, prevH
   thisImgPath := generateThumbName(imgPath, 1) fastWay
   If (prevImgPath=thisImgPath && prevH>1 && prevW>1)
   {
      W := prevW
      H := prevH
      Return 1
   }

   prevImgPath := thisImgPath
   changeMcursor()
   pBitmap := LoadBitmapFromFileu(imgPath, fastWay)
   prevW := W := mainLoadedIMGdetails.Width
   prevH := H := mainLoadedIMGdetails.Height
   trGdip_DisposeImage(pBitmap, 1)

   changeMcursor("normal")
   r := (w>1 && h>1) ? 1 : 0
   Return r
}

isInRange(value, inputA, inputB) {
    If (value=inputA || value=inputB)
       Return 1

    Return (value>=min(inputA, inputB) && value<=max(inputA, inputB)) ? 1 : 0
}

ST_ReadLine(String, line, delim="`n", exclude="`r") {
   String := Trimmer(String, delim)
   StringReplace, String, String, %delim%, %delim%, UseErrorLevel
   TotalLcount := ErrorLevel + 1

   If (abs(line)>TotalLCount && (line!="L" || line!="R" || line!="M"))
      Return 0

   If (Line="R")
      Random, Rand, 1, %TotalLcount%
   Else If (line<=0)
      line := TotalLcount + line

   Loop, Parse, String, %delim%, %exclude%
   {
      out := (Line="R" && A_Index=Rand) ? A_LoopField
           : (Line="M" && A_Index=TotalLcount//2) ? A_LoopField
           : (Line="L" && A_Index=TotalLcount) ? A_LoopField
           : (A_Index=Line) ? A_LoopField : -1
      If (out!=-1) ; Something was found so stop searching.
         Break
   }
   Return out
}

triggerOwnDialogs() {
  If AnyWindowOpen
     Gui, SettingsGUIA: +OwnDialogs
  Else
     Gui, 1: +OwnDialogs
}

checkThumbExists(MD5name, imgPath, ByRef file2load) {
   file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
   If FileExist(file2save)
   {
      FileGetSize, fileSizu, % file2save
      If (fileSizu<3)
         Return 0

      file2load := file2save
      Return 1
   } Else If (thumbsSizeQuality>755)
   {
      file2load := imgPath
      Return 0
   } Else If (thumbsSizeQuality>=500)
   {
      file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : imgPath
   } Else If (thumbsSizeQuality>=245)
   {
      file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : imgPath
      }
   } Else If (thumbsSizeQuality>124)
   {
      file2test := thumbsCacheFolder "\245-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : 0
         If !file2load
         {
            file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
            file2load := FileExist(file2test) ? file2test : imgPath
         }
      }
   }
   FileGetSize, fileSizu, % file2load
   r := (imgPath=file2load || fileSizu<3) ? 0 : 1
   Return r
}

generateThumbName(imgPath, forceThis:=0, thumbsSizer:=0) {
   Static lastInvoked := 1, prevMD5name, prevImgPath := "null"

   If (A_TickCount - lastInvoked<50) && (imgPath=prevImgPath)
      Return prevMD5name

   If (enableThumbsCaching!=1 && forceThis=0)
      Return

   obju := GetFileAttributesEx(imgPath)
   MD5name := CalcStringHash(imgPath obj.size obju.wtime obju.ctime, 0x8003)
   ; If (thumbsSizer=1)
   ;    MD5name := thumbsSizeQuality "-" MD5name
   lastInvoked := A_TickCount
   prevMD5name := MD5name
   Return MD5name
}

CalcStringHash(string, algid, encoding = "UTF-8", byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; this calculates the MD5 hash
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    chrlength := (encoding = "CP1200" || encoding = "UTF-16") ? 2 : 1
    length := (StrPut(string, encoding) - 1) * chrlength
    VarSetCapacity(data, length, 0)
    StrPut(string, &data, floor(length / chrlength), encoding)
    Result := CalcAddrHash(&data, length, algid, hash, hashlength)
    Return Result
}

CalcAddrHash(addr, length, algid, byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    Static h := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f"]
         , b := h.minIndex()
    hProv := hHash := o := ""
    CAC := DllCall("advapi32\CryptAcquireContext", "Ptr*", hProv, "Ptr", 0, "Ptr", 0, "UInt", 24, "UInt", 0xf0000000)
    If CAC
    {
       CCH := DllCall("advapi32\CryptCreateHash", "Ptr", hProv, "UInt", algid, "UInt", 0, "UInt", 0, "Ptr*", hHash)
       If CCH
       {
          CHD := DllCall("advapi32\CryptHashData", "Ptr", hHash, "Ptr", addr, "UInt", length, "UInt", 0)
          If CHD
          {
             CGP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", 0, "UInt*", hashlength, "UInt", 0)
             If CGP
             {
                VarSetCapacity(hash, hashlength, 0)
                CGHP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", &hash, "UInt*", hashlength, "UInt", 0)
                If CGHP
                {
                   Loop, %hashlength%
                   {
                      v := NumGet(hash, A_Index - 1, "UChar")
                      o .= h[(v >> 4) + b] h[(v & 0xf) + b]
                   }
                }
             }
          }
          CDH := DllCall("advapi32\CryptDestroyHash", "Ptr", hHash)
       }
       CRC := DllCall("advapi32\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
    }
    Return o
}



reorderStoredHashes(a, b) {
    outsideLoop := insideLoop := 0
    Loop, 8
    {
       pY := A_Index - 1 ; y++
       Loop, 8
       {
          pX := A_Index - 1 ; , pY := y - 1
          If (pY=0 || pY=7 || pX=0 || pX=7)
          {
             outsideLoop++
             newHash .= SubStr(b, outsideLoop, 1)
          } Else
          {
             insideLoop++
             newHash .= SubStr(a, insideLoop, 1)
          }
          ; pixContent .= Round(Gdip_RFromARGB(NumGet(Scan01+0, ((A_Index-1)*4)+((y - 1)*Stride1), "UInt"))*0.9)
       }
    }
    ; Clipboard := newHash
    ; ToolTip, % newHash , , , 2
    Return newHash
}

ConvertBase(InputBase, OutputBase, nptr){
    ; source https://www.autohotkey.com/boards/viewtopic.php?t=3925
    static u := A_IsUnicode ? "_wcstoui64" : "_strtoui64"
    static v := A_IsUnicode ? "_i64tow"    : "_i64toa"
    VarSetCapacity(s, 256, 0)
    value := DllCall("msvcrt.dll\" u, "Str", nptr, "UInt", 0, "UInt", InputBase, "CDECL Int64")
    DllCall("msvcrt.dll\" v, "Int64", value, "Str", s, "UInt", OutputBase, "CDECL")
    ; ToolTip, % s , , , 2
    return s
}

WM_LBUTTONUP(wP, lP, msg, hwnd) {
    If (WinActive("A")=hQPVtoolbar)
    {
       If (AnyWindowOpen && imgEditPanelOpened!=1) || (AnyWindowOpen && imgEditPanelOpened=1 && panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%
       Else
          WinActivate, ahk_id %PVhwnd%
    } Else If (imgEditPanelOpened=1 && WinActive("A")=hSetWinGui && panelWinCollapsed=1)
       toggleImgEditPanelWindow()
}

OpenNewExternalCoreThread(thisIndex, args, thisList) {
   pidThread := 0
   Try FileDelete, %thumbsCacheFolder%\tempList%thisIndex%.txt
   Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
   Sleep, 0
   Try FileAppend, % thisList, %thumbsCacheFolder%\tempFilesList.txt, utf-16
   Catch wasErrorA
         Sleep, 1

   If wasErrorA
      Return 0

   Sleep, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, threadParams, %thisIndex%||%args%

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath%,,, pidThread
   Catch wasErrorB
       Sleep, 0

   If (wasErrorB || !pidThread)
   {
      Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
      Return 0
   } Else
   {
      WinWait, ahk_pid %pidThread%,,2
      WinGet, hwndThread, ID, ahk_pid %pidThread%
      Sleep, 10
      Loop, 500
      {
          RegRead, thisThreadStarted, %QPVregEntry%\multicore, ThreadRunning%thisIndex%
          If (thisThreadStarted=1 || thisThreadStarted=2 || thisThreadStarted=-1)
             Break
          Else
             Sleep, 15
      }

      allGood := (thisThreadStarted=1 || thisThreadStarted=2) ? 1 : 0
      If (allGood!=1)
      {
         Process, Close, % pidThread
         RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
         Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
         Return 0
      }
      Return pidThread
   }
}

initExternalCoreMode() {
  Critical, on
  hasInitSpecialMode := 1
  RegRead, mainThreadHwnd, %QPVregEntry%\multicore, mainThreadHwnd
  If !WinExist("ahk_id" mainThreadHwnd)
  {
     RegWrite, REG_SZ, %QPVregEntry%, Running, 0
     fatalError := 1
  }

  RegRead, threadParams, %QPVregEntry%\multicore, threadParams
  If !threadParams
     fatalError := 1

  args := StrSplit(threadParams, "||")
  coreThread := args[1]

  Try FileRead, filesList, %thumbsCacheFolder%\tempFilesList.txt
  If !filesList
     fatalError := 1

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, -1
     ForceExitNow()
     Return
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 1
  initFIMGmodule()
  RegRead, hGDIwin, %QPVregEntry%\multicore, mainWindowID
     ; MsgBox, % args[1] "--" args[3]
  If (args[2]="batch-jpegll")
     multiCoresJpegLL(args[1], args[3], filesList)
  Else If (args[2]="batch-simpleimgproc")
     multiCoresSimpleImgProcessing(args[1], args[3], filesList)
  Else If (args[2]="batch-fmtconv")
     multiCoresFormatConvert(args[1], filesList)

  ; msgbox, killaaaa
  ForceExitNow()
  Return
}



testResourcesMemoryLeaks() {
  Loop, 4500
  {
       pEffect3 := Gdip_CreateEffect(1, 20, 0, 0)
       Gdip_DisposeEffect(pEffect3)

       lolBrush := Gdip_BrushCreateSolid("0x77898898")
       Gdip_DeleteBrush(lolBrush)

       lolPen1 := Gdip_CreatePen("0xCCbbccbb", 5)
       Gdip_DeletePen(lolPen1)


       lolPath := Gdip_CreatePath()
       Gdip_AddPathEllipse(lolPath, 30, 30, 200, 200)
       Gdip_DeletePath(lolPath)

       ; lola := drawTextInBox("loWooWol", "Arial", 99, 1500, 1500, "ff0099", "EEff0099", 0)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, 900, 900, coreDesiredPixFmt)
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4)
       txtOptions := "x30 y30 center cEEff0099 r4 s10 Bold" 
       dimensions := Gdip_TextToGraphics(G3, "loooool", txtOptions, "Arial", 400, 400, 0, 0, 2)
       Gdip_DeleteGraphics(G3)
       trGdip_DisposeImage(pBitmap)
       trGdip_DisposeImage(lola)
  }
  MsgBox, lololol
}

GetInstalledPrinters(Delimiter="|",Default=True) {
;  Run, rundll32    shimgvw.dll    ImageView_PrintTo /pt   xxx.png   "printer name"
;  Run, mspaint /pt [image filename]


  if (Default = True)
  {
    regread,defaultPrinter,HKCU,Software\Microsoft\Windows NT\CurrentVersion\Windows,device
    stringsplit,defaultName,defaultPrinter,`,
    defaultName := defaultName1
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      if (A_LoopRegName = defaultname)
      printerlist = %printerlist%%A_loopRegName%%Delimiter%%Delimiter%
      else printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  else
  {
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  StringTrimRight, printerlist, printerlist, StrLen(Delimiter)
  return %printerlist%
}

PrinterGetMatchingBitmap(width, height, color:="0xffFFFFFF") {
  ; set background-color (default is white)
  pBitmap := trGdip_CreateBitmap(A_ThisFunc, width, height)
  If StrLen(pBitmap)<3
     Return

  G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
  If G
     trGdip_GraphicsClear(A_ThisFunc, G, color)

  Gdip_DeleteGraphics(G)
  return pBitmap
}

printImageNow(mainBMP, PrintOptions, previewMode) {
   If StrLen(mainBMP)<3
      Return

   pPrinterName := PrintOptions.pPrinterName
   adaptFit := PrintOptions.adaptFit
   userImgX := PrintOptions.userImgX
   userImgY := PrintOptions.userImgY
   userImgW := PrintOptions.userImgW
   userImgH := PrintOptions.userImgH
   colorsMode := PrintOptions.colorsMode
   imgOrient := PrintOptions.imgOrient
   copiez := PrintOptions.copiez
   flipuV := PrintOptions.flipuV
   flipuH := PrintOptions.flipuH
   applyFX := PrintOptions.applyFX

   ; pPrinterName := SGDIPrint_GetDefaultPrinter()
   ; hdcObj := SGDIPrint_GetHDCfromPrintDlg(PVhwnd)
   hdcObj := SGDIPrint_GetHDCfromPrinterName(pPrinterName, 1, Round(colorsMode + 1), copiez, PVhwnd)
   If (previewMode=1)
   {
      calcIMGdimensions(hdcObj.HDC_Width, hdcObj.HDC_Height, 248, 351, ResizedW, ResizedH)
   } Else
   {
      ResizedW := hdcObj.HDC_Width
      ResizedH := hdcObj.HDC_Height
   }

   ; - "print" to bitmap -
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If (previewMode!=1)
   {
      If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
         Return
   }

   gPrint := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
   E := trGdip_GraphicsClear(A_ThisFunc, gPrint, "0xFFffFFff")
   If (!pBitmap || !gPrint || E="fail")
      Return

   If (applyFX=1)
      decideGDIPimageFX(matrix, imageAttribs, pEffect)

   Gdip_GetImageDimensions(pBitmap, pageW, pageH)
   oimgPosX := imgPosX := Round(pageW*(userImgX/100))
   oimgPosY := imgPosY := Round(pageH*(userImgY/100))
   oimgNewW := imgNewW := Round(pageW*(userImgW/100))
   oimgNewH := imgNewH := Round(pageH*(userImgH/100))
   If (adaptFit=1)
   {
      imgNewH := pageH
      imgNewW := pageW
      imgPosX := imgPosY := 0
   }

   ; mainBMP := useGdiBitmap()
   If isInRange(imgOrient, 1, 359)
   {
      If (previewMode=1)
         imgToPrint := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, 600, 600, 1, 3, -1)
      whichBitmap := StrLen(imgToPrint)>3 ? imgToPrint : mainBMP
      newBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, imgOrient, 1)
      If StrLen(imgToPrint)>3
         imgToPrint := trGdip_DisposeImage(imgToPrint, 1)

      If StrLen(newBitmap)>3
      {
         hasRotated := 1
         imgToPrint := newBitmap
      }
   } 

   whichBitmap := (hasRotated=1) ? imgToPrint : mainBMP
   Gdip_GetImageDimensions(whichBitmap, realImgW, realImgH)
   If (PrintAdaptToFit=1 || PrintAdaptToFit=0 && PrintStrechedSize=0)
      calcIMGdimensions(realImgW, realImgH, imgNewW, imgNewH, imgNewW, imgNewH)
   ; Gdip_GetRotatedDimensions(imgNewW, imgNewH, imgOrient, rotImgW, rotImgH)
   newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgNewW, imgNewH, 0)
   trGdip_DisposeImage(imgToPrint, 1)

   failedResize := 0
   If StrLen(newBitmap)>3
      imgToPrint := newBitmap
   Else failedResize := 1

   If pEffect
   {
      Gdip_BitmapApplyEffect(imgToPrint, pEffect)
      Gdip_DisposeEffect(pEffect)
   }

   If (colorsMode!=1)
   {
      newBitmap := trGdip_BitmapConvertGray(imgToPrint)
      If StrLen(newBitmap)>3
      {
         trGdip_DisposeImage(imgToPrint, 1)
         imgToPrint := newBitmap
      }
   }
   If (flipuV=1)
      Gdip_ImageRotateFlip(imgToPrint, 6)
   If (flipuH=1)
      Gdip_ImageRotateFlip(imgToPrint, 4)

   If (adaptFit=1)
   {
      Gdip_GetImageDimensions(imgToPrint, imgNewW, imgNewH)
      imgPosX := (pageW - imgNewW)//2
      imgPosY := (pageH - imgNewH)//2
   }

   r4 := trGdip_DrawImage(A_ThisFunc, gPrint, imgToPrint, imgPosX, imgPosY,,,,,,,,, imageAttribs)
   previewScale := ResizedW / hdcObj.HDC_Width
   If StrLen(PrintOptions.text)>0
   {
      If (TextInAreaFontBold=1)
         thisStylu .= "Bold "
      If (TextInAreaFontItalic=1)
         thisStylu .= "Italic "
      If (TextInAreaFontUline=1)
         thisStylu .= "Underline "

      If (TextInAreaAlign=1)
         thisTxtAlignu := "Left "
      Else If (TextInAreaAlign=2)
         thisTxtAlignu := "Center "
      Else If (TextInAreaAlign=3)
         thisTxtAlignu := "Right "

      If (TextInAreaValign=1)
         thisTxtvAlignu := "Top "
      Else If (TextInAreaValign=2)
         thisTxtvAlignu := "vCenter "
      Else If (TextInAreaValign=3)
         thisTxtvAlignu := "Bottom "
      ; SoundBeep 
      ERR := Gdip_TextToGraphics(gPrint, PrintOptions.text, thisTxtAlignu thisTxtvAlignu thisStylu " s" Round(PrintTxtSize*previewScale) " cFF" TextInAreaFontColor, TextInAreaFontName, pageW, pageH)
      ; ToolTip, % ERR " == "  PrintOptions.text "`n" thisTxtAlignu thisTxtvAlignu " s" TextInAreaFontSize " c" TextInAreaFontColor " == " TextInAreaFontName " == " pageW " == " pageH , , , 2
   }

   If (previewMode=1 && PrintAdaptToFit=0)
   {
      Gdip_SetPenWidth(pPen1d, 2.5)
      Gdip_SetPenWidth(pPen1, 2.5)
      Gdip_DrawRectangle(gPrint, pPen1d, oimgPosX, oimgPosY, oimgNewW, oimgNewH)
      Gdip_DrawRectangle(gPrint, pPen1, oimgPosX + 2, oimgPosY + 2, oimgNewW, oimgNewH)
   }

   If (previewMode!=1 && r4!="fail" && failedResize!=1)
   {
      r := SGDIPrint_BeginDocument(hdcObj.HDC_ptr, appTitle " image file")
      If r
      {
         SGDIPrint_CopyBitmapToPrinterHDC(pBitmap, hdcObj.HDC_ptr, hdcObj.HDC_Width, hdcObj.HDC_Height)
         SGDIPrint_EndDocument(hdcObj.HDC_ptr) ; starts printing
      }
   } Else If (previewMode=1)
   {
      marginuX := hdcObj.HDC_PHYSICALOFFSETX/hdcObj.HDC_PHYSICALWIDTH
      marginuY := hdcObj.HDC_PHYSICALOFFSETY/hdcObj.HDC_PHYSICALHEIGHT
      marginuX := Ceil(ResizedW * marginuX)
      marginuY := Ceil(ResizedH * marginuY)
      newBitmap := SGDIPrint_GetMatchingBitmap(ResizedW + marginuX*2, ResizedH + marginuY*2)
      If newBitmap
      {
         gU := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
         If gU
         {
            r4 := trGdip_DrawImage(A_ThisFunc, gU, pBitmap, marginuX, marginuY)
            If (r4!="fail")
            {
               hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, newBitmap)
               SetImage(hCropCornersPic, hBitmap)
               Gdi_DeleteObject(hBitmap)
            }
            Gdip_DeleteGraphics(gU)
         }
         trGdip_DisposeImage(newBitmap, 1)
      }
      pageDPI := Round((hdcObj.hdc_xdpi + hdcObj.hdc_ydpi)/2)
      pageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi, 1)
      pageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi, 1)
      MMpageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi * 25.4)
      MMpageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi * 25.4)
      GuiControl, SettingsGUIA:, PrinterPageInfos, % "Page details:`n" pageWr " x " pageHr " in`n" MMpageWr " x " MMpageHr " mm`n" pageDPI " DPI"
   }

   Gdip_DeleteGraphics(gPrint)
   trGdip_DisposeImage(pBitmap, 1)
   trGdip_DisposeImage(imgToPrint, 1)
}

AcquireWIAimage() {
    Static deviceu
    If (thumbsDisplaying=1)
       Return

    setImageLoading()
    prevOpenedWindow := []
    showTOOLtip("Acquiring image, please wait")
    prevOpenedWindow := [-1, A_ThisFunc, 1, editingSelectionNow, 0, userimgQuality]
    addJournalEntry("Window opened: " A_ThisFunc "() [ WIA standard dialogs ]")

    Try obju := WIA_AcquireImage(deviceu)
    Catch errMsg
       Sleep, 1

    If IsObject(obju)
    {
       pBitmap := obju[1]
       If !deviceu
          deviceu := obju[2]
       ; ToolTip, % "l=" deviceu , , , 2
    }

    If (StrLen(pBitmap)<4 && (IsObject(obju) || StrLen(errMsg.message)>3))
    {
       ResetImgLoadStatus()
       ; showTOOLtip("Failed to acquire image`n" errMsg.message)
       RemoveTooltip()
       infos := SubStr(errMsg.message, 1, InStr(errMsg.message, "`nhelpfile:") - 1)
       infos := StrReplace(infos, "`t", A_Space)
       infos := StrReplace(infos, "  ", A_Space)
       msgBoxWrapper(appTitle ": ERROR", "An error has occured. Failed to acquire image from device.`n`nError details: " infos, 0, 0, "error")
       Return
    } Else If (obju<0 && !IsObject(obju))
    {
       RemoveTooltip()
       ResetImgLoadStatus()
    } Else
    {
       createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (imgW<5 || imgH<5)
       {
          ResetImgLoadStatus()
          hbmp := trGdip_DisposeImage(pBitmap, 1)
          showTOOLtip("Failed to acquire the correct image data`nPossibly malformed image format.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
       SoundBeep , 900, 100
       PasteClipboardIMG("scanner", pBitmap)
    }
}













testWICwhatever() {
/*
   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   IWICImagingFactory_Initialize(pWICimgFactory, 1)
   IWICImagingFactory_CreateDecoderFromFilename(pWICimgFactory, imgPath,,,, ppIDecoder)
   IWICImagingFactory_CreateBitmapScaler(pWICimgFactory, ppIBitmapScaler)

   IWICBitmapDecoder_GetFrameCount(ppIDecoder, fCount)
   IWICBitmapDecoder_GetFrame(ppIDecoder, 0, ppIBitmapSourceFrame)
   r := IWICBitmapScaler_Initialize(ppIBitmapScaler, ppIBitmapSourceFrame, mainWidth, mainHeight)
   IWICBitmapSource_GetSize(ppIBitmapScaler, puiWidth, puiHeight)
   IWICBitmapSource_GetPixelFormat(ppIBitmapSourceFrame, pPixelFormat)

   IWICImagingFactory_CreateFormatConverter(pWICimgFactory, ppIFormatConverter)
   zr := IWICFormatConverter_Initialize(ppIFormatConverter, ppIBitmapScaler, "GUID_WICPixelFormat32bppPBGRA", 0, NULL, 0.9, 0)

; puiWidth := mainWidth
; puiHeight := mainHeight

   pBitmap := Gdip_CreateBitmap(puiWidth, puiHeight)
   E1 := Gdip_LockBits(pBitmap, 0, 0, puiWidth, puiHeight, stride, scan0, data)
stride := 4* puiWidth
addJournalEntry("bmp created: " stride)
   IWICBitmapSource_CopyPixels(ppIBitmapSourceFrame, NULL, abs(stride), abs(stride) * puiHeight + 7 * puiHeight, scan0)

addJournalEntry("copy pixels executed")
   Gdip_UnlockBits(pBitmap, data)

addJournalEntry("bits unlocked")
   trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   Gdip_DrawImage(pBitmap, 30, 30)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
*/

   Gdip_DisposeImage(pBitmap, 1)

   MsgBox, % pWICimgFactory "`n" ppIDecoder "`n" fcount "`n" ppIBitmapSourceFrame "`nBMPscale" ppIBitmapScaler "`nFmtConv" ppIFormatConverter "`n scaler=" r "`nw/h:" puiWidth " // " puiHeight "`nPixFmt" pPixelFormat "`nfmtConversion zr:" zr
; https://stackoverflow.com/questions/8101203/wicbitmapsource-copypixels-to-gdi-bitmap-scan0
; https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/multimedia/wic/wicviewergdi/WicViewerGdi.cpp#L354
}

xxtestwhatever() {

   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x2
ppIDecoder := "lodekl"
   destroyGDIfileCache()
   wzFileName := getIDimage(currentFileIndex)

   thisObj := ComObjCreate("{cacaf262-9370-4615-a13b-9f5539da4c0a}", "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}")
      thisObj.ThrowHRerrors := 1

   ; hr := DllCall(NumGet(NumGet(thisObj+0)+14*A_PtrSize), "ptr", thisObj, "ptr*", ppIWICStream)
   ;    WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)


   ; hr := DllCall(NumGet(NumGet(thisObj+0)+15*A_PtrSize), "ptr", thisObj, "str", wzFileName, "uint", dwDesiredAccess)
   ; if hr or ErrorLevel
   ;    WIC_hr(hr, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)

/*
   hr := DllCall(vtable(thisObj, 3)
         ,"ptr", thisObj
         ,"str", wzFilename
         ,"ptr", NULL ; WIC_GUID(GUID,pguidVendor)
         ,"uint", dwDesiredAccess
         ,"uint", metadataOptions
         ,"ptr*", ppIDecoder)
      WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)
   MsgBox, % thisObj "`n" ppIDecoder "`n" vtable(thisObj, 3) ;  "`n" WIC_hr(HR, "init")
*/
}


gtestwhatever() {
; # dwDesiredAccess
; WIC_GENERIC_READ = 0x80000000
; WIC_GENERIC_WRITE = 0x40000000

; # WICBitmapCreateCacheOption
; WICBitmapNoCache = 0x0
; WICBitmapCacheOnDemand = 0x1
; WICBitmapCacheOnLoad = 0x2

; # WICDecodeOptions
; WICDecodeMetadataCacheOnDemand = 0x0
; WICDecodeMetadataCacheOnLoad = 0x1


   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x1

   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   DllCall("windowscodecs.dll\WICCreateImagingFactory_Proxy", "Uint", WinCodecSKDversion, "UPtr*", pWICimgFactory)

   HR := DllCall("windowscodecs.dll\IWICImagingFactory_CreateDecoderFromFilename_Proxy", "UPtr", pWICimgFactory, "Wstr", imgPath, "Ptr", GuidVendor, "Uint", dwDesiredAccess, "Uint", metadataOptions, "UPtr*", ppIDecoder)
   MsgBox, % pWICimgFactory "`n" ppIDecoder
}

SelectFolderEx(StartingFolder:="", DlgTitle:="", OwnerHwnd:=0, OkBtnLabel:="", comboList:="", desiredDefault:=1, comboLabel:="", CustomPlaces:="", pickFoldersOnly:=1, usrFilters:="", defIndexFilter:=1, FileMustExist:=1, defaultEditField:="") {
; ==================================================================================================================================
; Shows a dialog to select a folder.
; Depending on the OS version the function will use either the built-in FileSelectFolder command (XP and previous)
; or the Common Item Dialog (Vista and later).
;
; Parameter:
;     StartingFolder -  the full path of a folder which will be preselected.
;     DlgTitle       -  a text used as window title (Common Item Dialog) or as text displayed withing the dialog.
;     FileMustExist  -  [bool] to allow or not opening files that do not exist
;     ----------------  Common Item Dialog only:
;     OwnerHwnd      -  HWND of the Gui which owns the dialog. If you pass a valid HWND the dialog will become modal.
;     BtnLabel       -  a text to be used as caption for the apply button.
;     comboList      -  a string with possible drop-down options, separated by `n [new line]
;     desiredDefault -  the default selected drop-down row
;     comboLabel     -  the drop-down label to display
;     CustomPlaces   -  custom directories that will be displayed in the left pane of the dialog; missing directories will be omitted; a string separated by `n [newline]
;     pickFoldersOnly - boolean option [0, 1]
;     defaultEditField - the text to display in the edit field by default when the open dialog shows up
;
;  Return values:
;     On success the function returns an object with the full path of the selected/file folder
;     and combobox selected [if any]; otherwise it returns an empty string.
;
; MSDN:
;     Common Item Dialog -> msdn.microsoft.com/en-us/library/bb776913%28v=vs.85%29.aspx
;     IFileDialog        -> msdn.microsoft.com/en-us/library/bb775966%28v=vs.85%29.aspx
;     IShellItem         -> msdn.microsoft.com/en-us/library/bb761140%28v=vs.85%29.aspx
; ==================================================================================================================================
; Source https://www.autohotkey.com/boards/viewtopic.php?f=6&t=18939
; by «just me»
; modified by Marius Șucan on jeudi 7 mai 2020
; to allow ComboBox and CustomPlaces
;
; options flags
; FOS_OVERWRITEPROMPT  = 0x2,
; FOS_STRICTFILETYPES  = 0x4,
; FOS_NOCHANGEDIR  = 0x8,
; FOS_PICKFOLDERS  = 0x20,
; FOS_FORCEFILESYSTEM  = 0x40,
; FOS_ALLNONSTORAGEITEMS  = 0x80,
; FOS_NOVALIDATE  = 0x100,
; FOS_ALLOWMULTISELECT  = 0x200,
; FOS_PATHMUSTEXIST  = 0x800,
; FOS_FILEMUSTEXIST  = 0x1000,
; FOS_CREATEPROMPT  = 0x2000,
; FOS_SHAREAWARE  = 0x4000,
; FOS_NOREADONLYRETURN  = 0x8000,
; FOS_NOTESTFILECREATE  = 0x10000,
; FOS_HIDEMRUPLACES  = 0x20000,
; FOS_HIDEPINNEDPLACES  = 0x40000,
; FOS_NODEREFERENCELINKS  = 0x100000,
; FOS_OKBUTTONNEEDSINTERACTION  = 0x200000,
; FOS_DONTADDTORECENT  = 0x2000000,
; FOS_FORCESHOWHIDDEN  = 0x10000000,
; FOS_DEFAULTNOMINIMODE  = 0x20000000,
; FOS_FORCEPREVIEWPANEON  = 0x40000000,
; FOS_SUPPORTSTREAMABLEITEMS  = 0x80000000

; IFileDialog vtable offsets
; 0   QueryInterface
; 1   AddRef 
; 2   Release 
; 3   Show 
; 4   SetFileTypes 
; 5   SetFileTypeIndex 
; 6   GetFileTypeIndex 
; 7   Advise 
; 8   Unadvise 
; 9   SetOptions 
; 10  GetOptions 
; 11  SetDefaultFolder 
; 12  SetFolder 
; 13  GetFolder 
; 14  GetCurrentSelection 
; 15  SetFileName 
; 16  GetFileName 
; 17  SetTitle 
; 18  SetOkButtonLabel 
; 19  SetFileNameLabel 
; 20  GetResult 
; 21  AddPlace 
; 22  SetDefaultExtension 
; 23  Close 
; 24  SetClientGuid 
; 25  ClearClientData 
; 26  SetFilter


   Static OsVersion := DllCall("GetVersion", "UChar")
        , IID_IShellItem := 0
        , InitIID := VarSetCapacity(IID_IShellItem, 16, 0)
                  & DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
        , ShowDialog := A_PtrSize * 3
        , SetFileTypes := A_PtrSize * 4
        , SetFileTypeIndex := A_PtrSize * 5
        , SetOptions := A_PtrSize * 9
        , SetFolder := A_PtrSize * 12
        , SetDefaultEdit := A_PtrSize * 15 ; SetFileName
        , SetWinTitle := A_PtrSize * 17
        , SetOkButtonLabel := A_PtrSize * 18
        , GetResult := A_PtrSize * 20
        , AddPlaces := A_PtrSize * 21
        , ComDlgObj := {COMDLG_FILTERSPEC: ""}

   SelectedFolder := ""
   OwnerHwnd := DllCall("IsWindow", "Ptr", OwnerHwnd, "UInt") ? OwnerHwnd : 0
   Try FileDialog := ComObjCreate("{DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7}", "{42f85136-db7e-439c-85f1-e4075d135fc8}")
   If !FileDialog
   {
      thisOption := (FileMustExist=1) ? 3 : 2
      FileSelectFolder, SelectedFolder, *%StartingFolder%, % thisOption, % DlgTitle
      Return SelectedFolder
   }

   VTBL := NumGet(FileDialog + 0, "UPtr") ; virtual table addresses
   dialogOptions := 0x8 | 0x800  ;  FOS_NOCHANGEDIR | FOS_PATHMUSTEXIST
   If (pickFoldersOnly=1)
      dialogOptions |= 0x20      ; FOS_PICKFOLDERS

   If (FileMustExist=1)
      dialogOptions |=  0x1000   ; FOS_FILEMUSTEXIST

   DllCall(NumGet(VTBL + SetOptions, "UPtr"), "Ptr", FileDialog, "UInt", dialogOptions, "UInt")
   If StartingFolder
   {
      If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", StartingFolder, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", FolderItem)
         DllCall(NumGet(VTBL + SetFolder, "UPtr"), "Ptr", FileDialog, "Ptr", FolderItem, "UInt")
   }

   If DlgTitle
      DllCall(NumGet(VTBL + SetWinTitle, "UPtr"), "Ptr", FileDialog, "WStr", DlgTitle, "UInt")
   If OkBtnLabel
      DllCall(NumGet(VTBL + SetOkButtonLabel, "UPtr"), "Ptr", FileDialog, "WStr", OkBtnLabel, "UInt")

   If (pickFoldersOnly!=1)
   {
       Filters := IsObject(usrFilters) ? usrFilters : {"All files": "*.*"}
       ObjSetCapacity(ComDlgObj, "COMDLG_FILTERSPEC", 2*Filters.Count() * A_PtrSize)
       for Description, FileTypes in Filters
       {
           ObjRawSet(ComDlgObj, "#" . A_Index, Trimmer(Description))
           , ObjRawSet(ComDlgObj, "@" . A_Index, Trimmer(StrReplace(FileTypes,"`n")))
           , NumPut(ObjGetAddress(ComDlgObj,"#" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * 2*(A_Index-1))        ; COMDLG_FILTERSPEC.pszName
           , NumPut(ObjGetAddress(ComDlgObj,"@" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * (2*(A_Index-1)+1))    ; COMDLG_FILTERSPEC.pszSpec
       }

       ; IFileDialog::SetFileName method 
       ; https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ifiledialog-setfilename
       If defaultEditField
          DllCall(NumGet(VTBL + SetDefaultEdit), "UPtr", FileDialog, "WStr", defaultEditField)

       ; IFileDialog::SetFileTypes method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775980(v=vs.85).aspx
       DllCall(NumGet(VTBL + SetFileTypes), "UPtr", FileDialog, "UInt", Filters.Count(), "UPtr", ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC"))

       ; IFileDialog::SetFileTypeIndex method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775978(v=vs.85).aspx
       If defIndexFilter
          DllCall(NumGet(VTBL + SetFileTypeIndex), "UPtr", FileDialog, "UInt", defIndexFilter)
   }

   If CustomPlaces
   {
      Loop, Parse, CustomPlaces, `n
      {
          Directory := Trim(A_LoopField, "`r `n `t`f`v`b")
          If FolderExist(Directory)
          {
             foo := 1
             DllCall("Shell32.dll\SHParseDisplayName", "UPtr", &Directory, "Ptr", 0, "UPtrP", PIDL, "UInt", 0, "UInt", 0)
             DllCall("Shell32.dll\SHCreateShellItem", "Ptr", 0, "Ptr", 0, "UPtr", PIDL, "UPtrP", IShellItem)
             ObjRawSet(ComDlgObj, IShellItem, PIDL)
             ; IFileDialog::AddPlace method
             ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775946(v=vs.85).aspx
             DllCall(NumGet(VTBL + AddPlaces), "UPtr", FileDialog, "UPtr", IShellItem, "UInt", foo)
          }
      }
   }

   If (comboList && comboLabel)
   {
      Try If ((FileDialogCustomize := ComObjQuery(FileDialog, "{e6fdd21a-163f-4975-9c8c-a69f1ba37034}")))
      {
         groupId := 616 ; arbitrarily chosen IDs
         comboboxId := 93270
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+26*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", groupId, "WStr", comboLabel) ; IFileDialogCustomize::StartVisualGroup
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+6*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId) ; IFileDialogCustomize::AddComboBox
         ; DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", itemOneId, "WStr", "Current folder") ; IFileDialogCustomize::AddControlItem
         
         entriesArray := []
         Loop, Parse, comboList,`n
         {
             elementu := Trim(A_LoopField, "`r `n `t`f`v`b")
             If elementu
             {
                Random, varA, 2, 900
                Random, varB, 2, 900
                thisID := varA varB
                If (A_Index=desiredDefault)
                   desiredIDdefault := thisID

                entriesArray[thisId] := elementu
                DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", thisID, "WStr", elementu)
             }
         }

         DllCall(NumGet(NumGet(FileDialogCustomize+0)+25*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", desiredIDdefault) ; IFileDialogCustomize::SetSelectedControlItem
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+27*A_PtrSize), "Ptr", FileDialogCustomize) ; IFileDialogCustomize::EndVisualGroup
      }

   }

   If !DllCall(NumGet(VTBL + ShowDialog, "UPtr"), "Ptr", FileDialog, "Ptr", OwnerHwnd, "UInt")
   {
      If !DllCall(NumGet(VTBL + GetResult, "UPtr"), "Ptr", FileDialog, "PtrP", ShellItem, "UInt")
      {
         GetDisplayName := NumGet(NumGet(ShellItem + 0, "UPtr"), A_PtrSize * 5, "UPtr")
         If !DllCall(GetDisplayName, "Ptr", ShellItem, "UInt", 0x80028000, "PtrP", StrPtr) ; SIGDN_DESKTOPABSOLUTEPARSING
         {
            SelectedFolder := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         ObjRelease(ShellItem)
         if (FileDialogCustomize && entriesArray.Count())
         {
            if (DllCall(NumGet(NumGet(FileDialogCustomize+0)+24*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt*", selectedItemId) == 0)
            { ; IFileDialogCustomize::GetSelectedControlItem
               if selectedItemId
                  thisComboSelected := entriesArray[selectedItemId]
            }   
         }
      }
   }
   If (FolderItem)
      ObjRelease(FolderItem)

   if (FileDialogCustomize)
      ObjRelease(FileDialogCustomize)

   ObjRelease(FileDialog)
   r := []
   r.SelectedDir := SelectedFolder
   r.SelectedCombo := thisComboSelected
   Return r
}

recentOpenedFolders() {
   If (allowRecordHistory=1)
   {
      historyList := readRecentEntries()
      historyList .= readRecentFileDesties()
      Loop, Parse, historyList, `n
      {
         If (A_Index>30)
            Break

         entryu := StrReplace(A_LoopField, "|")
         If (!entryu || RegExMatch(entryu, sldsPattern))
            Continue

         If FolderExist(entryu)
            entriesList .= entryu "`n"
      }
      Sort, entriesList, UD`n
   }
   Return Trimmer(entriesList)
}


;------------------------------
;
; Function: Dlg_OpenSaveFile
;
; Description:
;
;   Internal function used by <Dlg_OpenFile> and <Dlg_SaveFile> to create an
;   Open or Save dialog.
;
; Type:
;
;   Internal function.  Subject to change.  Do not call directly.
;
; Parameters:
;
;   p_Type - [Internal function only] Set to "O" or "Open" to create a Open
;       dialog.  Set to "S" or "Save" to create a Save dialog.
;
;   hOwner - A handle to the window that owns the dialog box.  This parameter
;       can be any valid window handle or it can be set to 0 or null if the
;       dialog box has no owner.  Note: A valid window handle must be specified
;       if the OFN_SHOWHELP flag is included (explicitly or implicitly).
;
;   p_Title - A string to be placed in the title bar of the dialog box.  If set
;       to null (the default), the system uses the default title (that is,
;       "Open" or "Save As").
;
;   p_Filter - One or more filter strings that determine which files are
;       displayed. [Optional] Each filter string is composed of two parts.
;       The first part describes the filter.  For example: "Text Files".  The
;       second part specifies the filter pattern and must be enclosed in
;       parenthesis.  For example "(*.txt)".  To specify multiple filter
;       patterns for a single display string, use a semicolon to separate the
;       patterns.  For example: "(*.txt;*.doc;*.bak)".  A pattern string can be
;       a combination of valid file name characters and the asterisk ("*")
;       wildcard character.  Do not include spaces in the pattern string.
;       Multiple filter strings are delimited by the "|" character.  For
;       example: "Text Files (*.txt)|Backup Files (*.bak)".
;
;   p_FilterIndex - 1-based filter index.  If set to null (the default), 1 is
;       used.  The index determines which filter string is pre-selected in the
;       "File Types" control.
;
;   p_Root - Root (startup) directory and/or default file name.  To specify a
;       root directory only, include the full path of the directory with a
;       trailing "\" character.  Ex: "C:\Program Files\".  To specify a startup
;       directory and a default file, include the full path of the default file.
;       Ex: "C:\My Stuff\My Program.html".  To specify a default file only,
;       include the file name without the path.  Ex: "My Program.html".  If a
;       default file name is included, the file name (sans the path) is shown in
;       the dialog's "File name:" edit field. If this parameter is set to null
;       (the default), the startup directory will be set using the OS default
;       for this dialog.  See the documentation for the OPENFILENAME structure
;       (lpstrInitialDir member) for more information.
;
;   p_DfltExt - Extension to append when none is given.  Ex: "txt".  The string
;       should not contain a period (".").  If this parameter is null (the
;       default) and the user fails to type an extension, no extension is
;       appended.
;
;   r_Flags - Flags used to initialize the dialog. [Optional, Input/Output] See
;       the *Flags* section for the details.
;
;   p_HelpHandler - Name of a developer-created function that is called when the
;       the user presses the Help button on the dialog. [Optional] See the *Help
;       Handler* section for the details.  Note: The OFN_SHOWHELP flag is
;       automatically added if this parameter contains a valid function name.
;
; Flags:
;
;   On input, the r_Flags parameter contains flags that are used to initialize
;   and/or determine the behavior of the dialog.  If set to 0 or null and
;   p_Type="O" (Open dialog), the OFN_FILEMUSTEXIST and OFN_HIDEREADONLY flags
;   are added automatically.  If r_Flag contains an interger value, the
;   parameter is assumed to contain bit flags.  See the function's static
;   variables for a list a valid bit flags.  Otherwise, text flags are assumed.
;   The following space-delimited text flags can be used.
;
;   AllowMultiSelect - Specifies that the File Name list box allows multiple
;       selections.
;
;   CreatePrompt - [Open dialog only] If the user specifies a file that does not
;       exist, this flag causes the dialog to prompt the user for permission to
;       create the file.
;
;   DontAddToRecent - Prevents the system from adding a link to the selected
;       file in the file system directory that contains the user's most recently
;       used documents.
;
;   Ex_NoPlacesBar - If specified, the places bar is not displayed.  If not
;       specified, Explorer-style dialog boxes include a places bar containing
;       icons for commonly-used folders, such as Favorites and Desktop.
;
;   FileMustExist - [Open dialog only (with implicit exceptions)] This flag
;       ensures that the user can only type names of existing files in the File
;       Name entry.  A message box is generated if an invalid file is entered.
;       Opinion: This flag should be specified in most circumstances.
;       IMPORTANT: If this flag is specified (explicitly or implicitly), the
;       PathMustExist flag is also used.  See the PathMustExist flag for the
;       rules that are enforced for both the Open and Save dialogs.
;
;   ForceShowHidden - Forces the showing of system and hidden files, thus
;       overriding the user setting to show or not show hidden files.  However,
;       a file that is marked both system and hidden is not shown.  Observation:
;       This flag does not work as expected on Windows XP (may also occur on
;       other (or all) versions of Windows).  When a directory that includes a
;       hidden file is first displayed (including the initial directory), hidden
;       files are not shown.  Clicking on the "Open" or "Save" button without
;       selecting a file will redisplay the list of files to include the hidden
;       file(s).
;
;   HideReadOnly - [Open dialog only] Hides the Read Only check box.  This flag
;       should be specified in most circumstances.
;
;   NoChangeDir - Restores the current directory to its original value if the
;       user changed the directory while searching for files.
;
;   NoDereferenceLinks - Directs the dialog box to return the path and file name
;       of the selected shortcut (.LNK) file.  If this value is not specified,
;       the dialog box returns the path and file name of the file referenced by
;       the shortcut.  Observation: For shortcuts to OS files, this works as
;       expected.  However, for other types of shortcuts, Ex: shortcuts to a web
;       site, the return value may not be what is expected.  Test thoroughly
;       before using.
;
;   NoReadOnlyReturn - [Save dialog only] Prevents the dialog from returning
;       names of existing files that have the read-only attribute.  If a
;       read-only file is selected, a message dialog is generated.  The dialog
;       will persist until the selection does not include a file with read-only
;       attribute.
;
;   NoTestFileCreate - By default, the dialog box creates a zero-length test
;       file to determine whether a new file can be created in the selected
;       directory.  Set this flag to prevent the creation of this test file.
;       This flag should be specified if the application saves the file on a
;       network drive with Create but no Modify privileges.
;
;   NoValidate - Specifies that the common dialog boxes allow invalid characters
;       in the returned file name.
;
;   OverwritePrompt - [Save dialog only] Causes the dialog to generate a message
;       box if the selected file already exists.  The user must confirm whether
;       to overwrite the file.
;
;   PathMustExist - Specifies that the user can type only existing paths in the
;       File Name entry.  A message box is generated if an invalid path is
;       entered.  Note: This flag is automatically added if the FileMustExist
;       flag is used.
;
;   ReadOnly - [Open dialog only] Causes the Read Only check box to be selected
;       initially when the dialog box is created.
;
;   ShowHelp - Causes the dialog to display the Help button.
;
;   On output, the r_Flag parameter may contain bit flags that inform the
;   developer of conditions of the dialog at the time the dialog was closed.
;   The following bit flags can be set.
;
;   OFN_READONLY (0x1) - [Open dialog only] This flag is set if the Read Only
;       check box was checked when the dialog was closed.
;
;   OFN_EXTENSIONDIFFERENT (0x400) - This flag is set if the p_DfltExt parameter
;       is not null and the user selected or typed a file name extension that
;       differs from the p_DfltExt parameter.  Exception: This flag is not set
;       if multiple files are selected.
;
; Returns:
;
;   Selected file name(s) or null if cancelled.  If more then one file is
;   selected, each file is delimited by a new line ("`n") character.
;
; Remarks:
;
;   If the user changes the directory while using the Open or Save dialog, the
;   script's working directory will also be changed.  If desired, use the
;   "NoChangeDir" flag (r_Flags parameter) to prevent this from occurring or use
;   the *SetWorkingDir* command to restore the working directory after calling
;   this function.
;
; Help Handler:
;
;   The "Help Handler" is an optional developer-created function that is called
;   when the user presses the Help button on the dialog.
;
;   The handler function must have at least 2 parameters.  Additional parameters
;   are allowed but must be optional (defined with a default value).  The
;   required parameters are defined/used as follows, and in the following order:
;
;       hDialog - The handle to the dialog window.
;
;       lpInitStructure - A pointer to the initialization structure for the
;           common dialog box. For this handler, the pointer is to a
;           OPENFILENAME structure.
;
;   It's up to the developer to determine what commands are performed in this
;   function but displaying some sort of help message/document is what is
;   expected.
;
;   To avoid interference with the operation of the dialog, the handler should
;   either 1) finish quickly or 2) any dialogs displayed via the handler should
;   be modal.  See the scripts included with this project for an example.
;
;-------------------------------------------------------------------------------
Dlg_OpenSaveFile(p_Type,hOwner:=0,p_Title:="",p_Filter:="",p_FilterIndex:="",p_Root:="",p_DfltExt:="",ByRef r_Flags:=0,p_HelpHandler:="") {
; function source: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=462
; by jballi

    Static Dummy16963733
          ,s_strFileMaxSize:=32768
                ;-- This is the ANSI byte limit.  For consistency, this value
                ;   is also used to set the the maximum number characters that
                ;   used in Unicode.  Note: Only the first entry contains the
                ;   folder name so 32K characters can hold a very large number
                ;   of file names.

          ,HELPMSGSTRING:="commdlg_help"
                ;-- Registered message string for the Help button on common
                ;   dialogs

          ,OPENFILENAME
                ;-- Static OPENFILENAME structure.  Also used by the hook
                ;   callback and the help message.

          ;-- Open File Name flags
          ,OFN_ALLOWMULTISELECT    :=0x200
          ,OFN_CREATEPROMPT        :=0x2000
          ,OFN_DONTADDTORECENT     :=0x2000000
          ,OFN_ENABLEHOOK          :=0x20

          ,OFN_EXPLORER            :=0x80000
                ;-- This flag is set by default.  This function does not work
                ;   with the old-style dialog box.

          ,OFN_EXTENSIONDIFFERENT  :=0x400
                ;-- Output flag only.

          ,OFN_FILEMUSTEXIST       :=0x1000
          ,OFN_FORCESHOWHIDDEN     :=0x10000000
          ,OFN_HIDEREADONLY        :=0x4

          ,OFN_NOCHANGEDIR         :=0x8
          ,OFN_NODEREFERENCELINKS  :=0x100000

          ,OFN_NOREADONLYRETURN    :=0x8000
          ,OFN_NOTESTFILECREATE    :=0x10000
          ,OFN_NOVALIDATE          :=0x100
          ,OFN_OVERWRITEPROMPT     :=0x2
          ,OFN_PATHMUSTEXIST       :=0x800
          ,OFN_READONLY            :=0x1
          ,OFN_SHOWHELP            :=0x10

          ;-- Open File Name extended flags
          ,OFN_EX_NOPLACESBAR      :=0x1
                ;-- Note: This flag is only available as a text flag, i.e.
                ;   "NoPlacesBar".

          ;-- Misc.
          ,TCharSize:=A_IsUnicode ? 2:1

    ;[==============]
    ;[  Parameters  ]
    ;[==============]
    ;-- Type
    p_Type:=SubStr(p_Type,1,1)
    StringUpper p_Type,p_Type
        ;-- Convert to uppercase to simplify processing

    if p_Type not in O,S
        p_Type:="O"

    ;-- Filter
    if p_Filter is Space
        p_Filter:="All Files (*.*)"

    ;-- Flags
    l_Flags  :=OFN_EXPLORER
    l_FlagsEx:=0
    if not r_Flags  ;-- Zero, blank, or null
    {
        if (p_Type="O")  ;-- Open dialog only
            l_Flags|=OFN_FILEMUSTEXIST|OFN_HIDEREADONLY
    } else
    {
        ;-- Bit flags
        if r_Flags is Integer
        {
            l_Flags|=r_Flags
        } else
        {
            ;-- Convert text flags into bit flags
            Loop Parse,r_Flags,%A_Tab%%A_Space%,%A_Tab%%A_Space%
            {
                if A_LoopField is not Space
                {
                    if OFN_%A_LoopField% is Integer
                    {
                        if InStr(A_LoopField,"ex_")
                            l_FlagsEx|=OFN_%A_LoopField%
                        else
                            l_Flags|=OFN_%A_LoopField%
                    }
                }
            }
        }
    }

    if IsFunc(p_HelpHandler)
        l_Flags|=OFN_SHOWHELP

    ; if (p_Type="O") and (l_Flags & OFN_ALLOWMULTISELECT)
    ;     l_Flags|=OFN_ENABLEHOOK

    ;-- Create and, if needed, populate the buffer used to initialize the
    ;   File Name Edit control.  The dialog will also use this buffer to return
    ;   the file(s) selected.
    VarSetCapacity(strFile,s_strFileMaxSize*TCharSize,0)
    SplitPath p_Root,l_RootFileName,l_RootDir
    if l_RootFileName is not Space
    {
        DllCall("RtlMoveMemory"
            ,"Str",strFile
            ,"Str",l_RootFileName
            ,"UInt",(StrLen(l_RootFileName)+1)*TCharSize)
    }

    ;-- Convert p_Filter into the format required by the API
    VarSetCapacity(strFilter,StrLen(p_Filter)*(A_IsUnicode ? 5:3),0)
        ;-- Enough space for the full description _and_ file pattern(s) of all
        ;   filter strings (ANSI and Unicode) plus null characters between all
        ;   of the pieces and a double null at the end.

    l_Offset:=&strFilter
    Loop Parse,p_Filter,|
    {
        ;-- Break the filter string into 2 parts
        l_LoopField:=Trim(A_LoopField," `f`n`r`t`v")
            ;-- Assign and remove all leading/trailing white space

        l_Part1:=l_LoopField
            ;-- Part 1: The entire filter string which includes the description
            ;   and the file pattern(s) in parenthesis.  This is what is
            ;   displayed in  the "File Of Types" or the "Save As Type"
            ;   drop-down.

        l_Part2:=SubStr(l_LoopField,InStr(l_LoopField,"(")+1,-1)
            ;-- Part 2: File pattern(s) sans parenthesis.  The dialog uses this
            ;   to filter the files that are displayed.

        ;-- Calculate the length of the pieces
        l_lenPart1:=(StrLen(l_LoopField)+1)*TCharSize
            ;-- Size includes terminating null

        l_lenPart2:=(StrLen(l_Part2)+1)*TCharSize
            ;-- Size includes terminating null

        ;-- Copy the pieces to the filter string.  Each piece includes a
        ;   terminating null character.
        DllCall("RtlMoveMemory","Ptr",l_Offset,"Str",l_Part1,"UInt",l_lenPart1)
        DllCall("RtlMoveMemory","Ptr",l_Offset+l_lenPart1,"Str",l_Part2,"UInt",l_lenPart2)                          ;-- Length

        ;-- Calculate the offset of the next filter string
        l_Offset+=l_lenPart1+l_lenPart2
    }

    ;[==================]
    ;[  Pre-Processing  ]
    ;[==================]
    ;-- Create and populate the OPENFILENAME structure
    lStructSize:=VarSetCapacity(OPENFILENAME,(A_PtrSize=8) ? 152:88,0)
    NumPut(lStructSize,OPENFILENAME,0,"UInt")
        ;-- lStructSize
    NumPut(hOwner,OPENFILENAME,(A_PtrSize=8) ? 8:4,"Ptr")
        ;-- hwndOwner
    NumPut(&strFilter,OPENFILENAME,(A_PtrSize=8) ? 24:12,"Ptr")
        ;-- lpstrFilter
    NumPut(p_FilterIndex,OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
        ;-- nFilterIndex
    NumPut(&strFile,OPENFILENAME,(A_PtrSize=8) ? 48:28,"Ptr")
        ;-- lpstrFile
    NumPut(s_strFileMaxSize,OPENFILENAME,(A_PtrSize=8) ? 56:32,"UInt")
        ;-- nMaxFile
    NumPut(&l_RootDir,OPENFILENAME,(A_PtrSize=8) ? 80:44,"Ptr")
        ;-- lpstrInitialDir
    NumPut(&p_Title,OPENFILENAME,(A_PtrSize=8) ? 88:48,"Ptr")
        ;-- lpstrTitle
    NumPut(l_Flags,OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
        ;-- Flags
    NumPut(&p_DfltExt,OPENFILENAME,(A_PtrSize=8) ? 104:60,"Ptr")
        ;-- lpstrDefExt
    NumPut(l_FlagsEx,OPENFILENAME,(A_PtrSize=8) ? 148:84,"UInt")
        ;-- FlagsEx

    ;[===============]
    ;[  Show dialog  ]
    ;[===============]
    if (p_type="O")
        RC:=DllCall("comdlg32\GetOpenFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)
    else
        RC:=DllCall("comdlg32\GetSaveFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)

    ;[===================]
    ;[  Post-Processing  ]
    ;[===================]
    ;-- If needed, turn off monitoring of help message
    if l_HelpMsg
        OnMessage(l_HelpMsg,"")  ;-- Turn off monitoring

    ;-- Dialog canceled?
    if (RC=0)
        Return

    ;-- Rebuild r_Flags for output
    r_Flags  :=0
    l_Flags:=NumGet(OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
    n_FilterIndex := NumGet(OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
    ;-- Flags

    if p_DfltExt is not Space  ;-- Flag is ignored unless p_DfltExt contains a value
    {
        if l_Flags & OFN_EXTENSIONDIFFERENT
            r_Flags|=OFN_EXTENSIONDIFFERENT
    }

    if (p_Type="O")  ;-- i.e. flag is ignored if using the Save dialog
    {
        if l_Flags & OFN_ALLOWMULTISELECT
        {
            ; Hook was used to collect ReadOnly status.  Collect the ReadOnly
            ; status from the hook function.
            Sleep, 1
            ; if Dlg_OFNHookCallback("GetReadOnly","","","")
            ; r_Flags|=OFN_READONLY
        } else
        {
            ;-- Hook was NOT used to collect ReadOnly status.  Determine status from l_Flags
            if l_Flags & OFN_READONLY
                r_Flags|=OFN_READONLY
        }
    }

    ;-- Extract file(s) from the buffer
    l_FileList:=""
    l_Offset  :=&strFile
    Loop
    {
        ;-- Get next
        l_Next:=StrGet(l_Offset,-1)

        ;-- End of list?
        if not StrLen(l_Next)
        {
            ;-- If end-of-list occurs on the 2nd iteration, it means that only
            ;   one file was selected
            if (A_Index=2)
                l_FileList:=l_FileName
            Break
        }

        ;-- Assign to working variable
        l_FileName:=l_Next

        ;-- Update the offset for the next iteration
        l_Offset+=(StrLen(l_FileName)+1)*TCharSize

        ;-- If this is the first iteration, we have to wait until the next loop
        ;   before we can determine if this is a directory or file and if a
        ;   file, if it is the only file selected.
        if (A_Index=1)
        {
            l_Dir:=l_FileName
            ;-- Windows adds "\" character when in root of the drive but doesn't
            ;   add it otherwise.  Adjust if needed.
            if (StrLen(l_Dir)<>3)
                l_Dir.="\"

            ;-- Continue to next
            Continue
        }

        ;-- Add the file to the list
        l_FileList.=(StrLen(l_FileList) ? "`n":"") . l_Dir . l_FileName
    }
    ; ToolTip, % n_FilterIndex , , , 2
    ;-Return to sender
    Return l_FileList
}

SHGetKnownFolderPath(FOLDERID, KF_FLAG:=0) {                  ;   By SKAN on D356 @ tiny.cc/t-75602 
   ; FOLDERID_AccountPictures         := "{008ca0b1-55b4-4c56-b8a8-4de4b299d3be}" ; Windows  8
   ; FOLDERID_AddNewPrograms          := "{de61d971-5ebc-4f02-a3a9-6c82895e5c04}"  
   ; FOLDERID_AdminTools              := "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"  
   ; FOLDERID_AppDataDesktop          := "{B2C5E279-7ADD-439F-B28C-C41FE1BBF672}" ; Windows  10, version 1709
   ; FOLDERID_AppDataDocuments        := "{7BE16610-1F7F-44AC-BFF0-83E15F2FFCA1}" ; Windows  10, version 1709
   ; FOLDERID_AppDataFavorites        := "{7CFBEFBC-DE1F-45AA-B843-A542AC536CC9}" ; Windows  10, version 1709
   ; FOLDERID_AppDataProgramData      := "{559D40A3-A036-40FA-AF61-84CB430A4D34}" ; Windows  10, version 1709
   ; FOLDERID_ApplicationShortcuts    := "{A3918781-E5F2-4890-B3D9-A7E54332328C}" ; Windows  8
   ; FOLDERID_AppsFolder              := "{1e87508d-89c2-42f0-8a7e-645a0f50ca58}" ; Windows  8
   ; FOLDERID_AppUpdates              := "{a305ce99-f527-492b-8b1a-7e76fa98d6e4}"  
   ; FOLDERID_CameraRoll              := "{AB5FB87B-7CE2-4F83-915D-550846C9537B}" ; Windows  8.1
   ; FOLDERID_CDBurning               := "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"  
   ; FOLDERID_ChangeRemovePrograms    := "{df7266ac-9274-4867-8d55-3bd661de872d}"  
   ; FOLDERID_CommonAdminTools        := "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"  
   ; FOLDERID_CommonOEMLinks          := "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"  
   ; FOLDERID_CommonPrograms          := "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"  
   ; FOLDERID_CommonStartMenu         := "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"  
   ; FOLDERID_CommonStartup           := "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"  
   ; FOLDERID_CommonTemplates         := "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"  
   ; FOLDERID_ComputerFolder          := "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"  
   ; FOLDERID_ConflictFolder          := "{4bfefb45-347d-4006-a5be-ac0cb0567192}" ; Windows  Vista
   ; FOLDERID_ConnectionsFolder       := "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"  
   ; FOLDERID_Contacts                := "{56784854-C6CB-462b-8169-88E350ACB882}" ; Windows  Vista
   ; FOLDERID_ControlPanelFolder      := "{82A74AEB-AEB4-465C-A014-D097EE346D63}"  
   ; FOLDERID_Cookies                 := "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"  
   ; FOLDERID_Desktop                 := "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"  
   ; FOLDERID_DeviceMetadataStore     := "{5CE4A5E9-E4EB-479D-B89F-130C02886155}" ; Windows  7
   ; FOLDERID_Documents               := "{FDD39AD0-238F-46AF-ADB4-6C85480369C7}"  
   ; FOLDERID_DocumentsLibrary        := "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}" ; Windows  7
   ; FOLDERID_Downloads               := "{374DE290-123F-4565-9164-39C4925E467B}"  
   ; FOLDERID_Favorites               := "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"  
   ; FOLDERID_Fonts                   := "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"  
   ; FOLDERID_Games                   := "{CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}"  
   ; FOLDERID_GameTasks               := "{054FAE61-4DD8-4787-80B6-090220C4B700}" ; Windows  Vista
   ; FOLDERID_History                 := "{D9DC8A3B-B784-432E-A781-5A1130A75963}"  
   ; FOLDERID_HomeGroup               := "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}" ; Windows  7
   ; FOLDERID_HomeGroupCurrentUser    := "{9B74B6A3-0DFD-4f11-9E78-5F7800F2E772}" ; Windows  8
   ; FOLDERID_ImplicitAppShortcuts    := "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}" ; Windows  7
   ; FOLDERID_InternetCache           := "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"  
   ; FOLDERID_InternetFolder          := "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"  
   ; FOLDERID_Libraries               := "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}" ; Windows  7
   ; FOLDERID_Links                   := "{bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}"  
   ; FOLDERID_LocalAppData            := "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"  
   ; FOLDERID_LocalAppDataLow         := "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"  
   ; FOLDERID_LocalizedResourcesDir   := "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"  
   ; FOLDERID_Music                   := "{4BD8D571-6D19-48D3-BE97-422220080E43}"  
   ; FOLDERID_MusicLibrary            := "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}" ; Windows  7
   ; FOLDERID_NetHood                 := "{C5ABBF53-E17F-4121-8900-86626FC2C973}"  
   ; FOLDERID_NetworkFolder           := "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"  
   ; FOLDERID_Objects3D               := "{31C0DD25-9439-4F12-BF41-7FF4EDA38722}" ; Windows  10, version 1703
   ; FOLDERID_OriginalImages          := "{2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}" ; Windows  Vista
   ; FOLDERID_PhotoAlbums             := "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}" ; Windows  Vista
   ; FOLDERID_PicturesLibrary         := "{A990AE9F-A03B-4E80-94BC-9912D7504104}" ; Windows  7
   ; FOLDERID_Pictures                := "{33E28130-4E1E-4676-835A-98395C3BC3BB}"  
   ; FOLDERID_Playlists               := "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"  
   ; FOLDERID_PrintersFolder          := "{76FC4E2D-D6AD-4519-A663-37BD56068185}"  
   ; FOLDERID_PrintHood               := "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"  
   ; FOLDERID_Profile                 := "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"  
   ; FOLDERID_ProgramData             := "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"  
   ; FOLDERID_ProgramFiles            := "{905e63b6-c1bf-494e-b29c-65b732d3d21a}"  
   ; FOLDERID_ProgramFilesX64         := "{6D809377-6AF0-444b-8957-A3773F02200E}"  
   ; FOLDERID_ProgramFilesX86         := "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"  
   ; FOLDERID_ProgramFilesCommon      := "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"  
   ; FOLDERID_ProgramFilesCommonX64   := "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"  
   ; FOLDERID_ProgramFilesCommonX86   := "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"  
   ; FOLDERID_Programs                := "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"  
   ; FOLDERID_Public                  := "{DFDF76A2-C82A-4D63-906A-5644AC457385}"  
   ; FOLDERID_PublicDesktop           := "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"  
   ; FOLDERID_PublicDocuments         := "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"  
   ; FOLDERID_PublicDownloads         := "{3D644C9B-1FB8-4f30-9B45-F670235F79C0}" ; Windows  Vista
   ; FOLDERID_PublicGameTasks         := "{DEBF2536-E1A8-4c59-B6A2-414586476AEA}" ; Windows  Vista
   ; FOLDERID_PublicLibraries         := "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}" ; Windows  7
   ; FOLDERID_PublicMusic             := "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"  
   ; FOLDERID_PublicPictures          := "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"  
   ; FOLDERID_PublicRingtones         := "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}" ; Windows  7
   ; FOLDERID_PublicUserTiles         := "{0482af6c-08f1-4c34-8c90-e17ec98b1e17}" ; Windows  8
   ; FOLDERID_PublicVideos            := "{2400183A-6185-49FB-A2D8-4A392A602BA3}"  
   ; FOLDERID_QuickLaunch             := "{52a4f021-7b75-48a9-9f6b-4b87a210bc8f}"  
   ; FOLDERID_Recent                  := "{AE50C081-EBD2-438A-8655-8A092E34987A}"  
   ; FOLDERID_RecordedTV              := "{1A6FDBA2-F42D-4358-A798-B74D745926C5}" ; Windows  7
   ; FOLDERID_RecycleBinFolder        := "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"  
   ; FOLDERID_ResourceDir             := "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"  
   ; FOLDERID_Ringtones               := "{C870044B-F49E-4126-A9C3-B52A1FF411E8}" ; Windows  7
   ; FOLDERID_RoamingAppData          := "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"  
   ; FOLDERID_RoamedTileImages        := "{AAA8D5A5-F1D6-4259-BAA8-78E7EF60835E}" ; Windows  8
   ; FOLDERID_RoamingTiles            := "{00BCFC5A-ED94-4e48-96A1-3F6217F21990}" ; Windows  8
   ; FOLDERID_SampleMusic             := "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"  
   ; FOLDERID_SamplePictures          := "{C4900540-2379-4C75-844B-64E6FAF8716B}"  
   ; FOLDERID_SamplePlaylists         := "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}" ; Windows  Vista
   ; FOLDERID_SampleVideos            := "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"  
   ; FOLDERID_SavedGames              := "{4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}" ; Windows  Vista
   ; FOLDERID_SavedPictures           := "{3B193882-D3AD-4eab-965A-69829D1FB59F}"  
   ; FOLDERID_SavedPicturesLibrary    := "{E25B5812-BE88-4bd9-94B0-29233477B6C3}"  
   ; FOLDERID_SavedSearches           := "{7d1d3a04-debb-4115-95cf-2f29da2920da}"  
   ; FOLDERID_Screenshots             := "{b7bede81-df94-4682-a7d8-57a52620b86f}" ; Windows  8
   ; FOLDERID_SEARCH_CSC              := "{ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}"  
   ; FOLDERID_SearchHistory           := "{0D4C3DB6-03A3-462F-A0E6-08924C41B5D4}" ; Windows  8.1
   ; FOLDERID_SearchHome              := "{190337d1-b8ca-4121-a639-6d472d16972a}"  
   ; FOLDERID_SEARCH_MAPI             := "{98ec0e18-2098-4d44-8644-66979315a281}"  
   ; FOLDERID_SearchTemplates         := "{7E636BFE-DFA9-4D5E-B456-D7B39851D8A9}" ; Windows  8.1
   ; FOLDERID_SendTo                  := "{8983036C-27C0-404B-8F08-102D10DCFD74}"  
   ; FOLDERID_SidebarDefaultParts     := "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"  
   ; FOLDERID_SidebarParts            := "{A75D362E-50FC-4fb7-AC2C-A8BEAA314493}"  
   ; FOLDERID_SkyDrive                := "{A52BBA46-E9E1-435f-B3D9-28DAA648C0F6}" ; Windows  8.1
   ; FOLDERID_SkyDriveCameraRoll      := "{767E6811-49CB-4273-87C2-20F355E1085B}" ; Windows  8.1
   ; FOLDERID_SkyDriveDocuments       := "{24D89E24-2F19-4534-9DDE-6A6671FBB8FE}" ; Windows  8.1
   ; FOLDERID_SkyDrivePictures        := "{339719B5-8C47-4894-94C2-D8F77ADD44A6}" ; Windows  8.1
   ; FOLDERID_StartMenu               := "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"  
   ; FOLDERID_Startup                 := "{B97D20BB-F46A-4C97-BA10-5E3608430854}"  
   ; FOLDERID_SyncManagerFolder       := "{43668BF8-C14E-49B2-97C9-747784D784B7}" ; Windows  Vista
   ; FOLDERID_SyncResultsFolder       := "{289a9a43-be44-4057-a41b-587a76d7e7f9}" ; Windows  Vista
   ; FOLDERID_SyncSetupFolder         := "{0F214138-B1D3-4a90-BBA9-27CBC0C5389A}" ; Windows  Vista
   ; FOLDERID_System                  := "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"  
   ; FOLDERID_SystemX86               := "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"  
   ; FOLDERID_Templates               := "{A63293E8-664E-48DB-A079-DF759E0509F7}"  
   ; FOLDERID_TreeProperties          := "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}" ; Windows  7
   ; FOLDERID_UserProfiles            := "{0762D272-C50A-4BB0-A382-697DCD729B80}"  
   ; FOLDERID_UserProgramFiles        := "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}" ; Windows  7
   ; FOLDERID_UserProgramFilesCommon  := "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}" ; Windows  7
   ; FOLDERID_UsersFiles              := "{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}"  
   ; FOLDERID_UsersLibraries          := "{A302545D-DEFF-464b-ABE8-61C8648D939B}" ; Windows  7
   ; FOLDERID_Videos                  := "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"  
   ; FOLDERID_VideosLibrary           := "{491E922F-5643-4AF4-A7EB-4E7A138D8174}" ; Windows  7
   ; FOLDERID_Windows                 := "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"  
   ; function by Skan: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75602&sid=f29192e2e8a74e847f62a152afa55aa1
   Local CLSID, pPath:=""                                        ; Thanks teadrinker @ tiny.cc/p286094
   Return Format("{4:}", VarSetCapacity(CLSID, 16, 0)
        , DllCall("ole32\CLSIDFromString", "Str",FOLDERID, "Ptr",&CLSID)
        , DllCall("shell32\SHGetKnownFolderPath", "Ptr",&CLSID, "UInt",KF_FLAG, "Ptr",0, "PtrP",pPath)
        , StrGet(pPath, "utf-16")
        , DllCall("ole32\CoTaskMemFree", "Ptr",pPath))

}

processFlags(n, b:=32, d:="`n", f:="") {
; by SKAN @ tiny.cc/t-75877
; https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75877

   Loop %b%
   {
       f .= Format( n & 1 ? "0x{1:x}{2:}"  : ""
                  , n & 1 ? 2**(A_Index-1) : 0, d, n >>= 1)
   }
   Return RTrim(f, d) 
}


Class IDesktopWallpaper 
{
; class created by Flipeador
; source https://github.com/flipeador/Library-AutoHotkey/blob/master/device/IDesktopWallpaper.ahk

    ; ===================================================================================================================
    ; CONSTRUCTOR
    ; ===================================================================================================================
    __New() {
        this.IDesktopWallpaper := ComObjCreate("{C2CF3110-460E-4fc1-B9D0-8A1C0C9CC4BD}", "{B92B56A9-8B55-4E14-9A89-0199BBB6F93B}")

        For Each, Method in ["SetWallpaper","GetWallpaper","GetMonitorDevicePathAt","GetMonitorDevicePathCount","GetMonitorRECT","SetBackgroundColor","GetBackgroundColor","SetPosition","GetPosition","SetSlideshow", "GetSlideshow","SetSlideshowOptions","GetSlideshowOptions","AdvanceSlideshow","GetStatus","Enable"]
            ObjRawSet(this, "p" . Method, NumGet(NumGet(this.IDesktopWallpaper), (2 + A_Index) * A_PtrSize))
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775771(v=vs.85).aspx

    ; ===================================================================================================================
    ; DESTRUCTOR
    ; ===================================================================================================================
    __Delete() {
        Return ObjRelease(this.IDesktopWallpaper)
    }

    ; ===================================================================================================================
    ; PRIVATE METHODS
    ; ===================================================================================================================
    _R(R, pBuffer, ByRef Var := "", Error := "") {
        If (R == 0)
        {
            If (IsByRef(Var))
                Var := StrGet(pBuffer, "UTF-16")
            DllCall("Kernel32.dll\GlobalFree", "UPtr", pBuffer, "UPtr")
        }
        Else If (IsByRef(Var))
            Var := Error
        Return R
    }

    ; ===================================================================================================================
    ; PUBLIC METHODS
    ; ===================================================================================================================
    /*
        Establece el fondo de escritorio.
        Parámetros:
            MonitorID: El identificador del monitor. Este valor se puede obtener a través de GetMonitorDevicePathAt. Establezca este valor en NULL para establecer la imagen en todos los monitores.
            Wallpaper: La ruta completa del archivo de imagen de fondo de pantalla.
    */
    SetWallpaper(MonitorID, Wallpaper) {
        Return DllCall(this.pSetWallpaper, "UPtr", this.IDesktopWallpaper, "Ptr", MonitorID, "UPtr", &Wallpaper, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706962(v=vs.85).aspx

    /*
        Recupera el identificador de uno de los monitores del sistema.
        Parámetros:
            MonitorIndex: El número del monitor. LLame a GetMonitorDevicePathCount para determinar el número total de monitores.
            MonitorID   : Recibe el identificador del monitor.
    */
    GetMonitorDevicePathAt(MonitorIndex, ByRef MonitorID) {
        Return this._R(DllCall(this.pGetMonitorDevicePathAt, "UPtr", this.IDesktopWallpaper, "UInt", MonitorIndex, "UPtrP", pBuffer, "UInt"), pBuffer, MonitorID)
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706950(v=vs.85).aspx

    /*
        Recupera la cantidad de monitores que están asociados con el sistema.
        Parámetros:
            Count: Recibe la cantidad de monitores.
    */
    GetMonitorDevicePathCount(ByRef Count) {
        Return DllCall(this.pGetMonitorDevicePathCount, "UPtr", this.IDesktopWallpaper, "UIntP", Count, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706951(v=vs.85).aspx

} ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706946(v=vs.85).aspx




testeGDIspeed() {
   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(2)
   pa := A_TickCount - startZeit

   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(10)

   pb := A_TickCount - startZeit
   MsgBox, % pa "`n" pb
}

isFileLocked(imgPath) {
   If !FileRexists(imgPath)
      Return -1

   myFile := fileOpen(imgPath, "a")
   If IsObject(myFile)
   {
      myFile.Close()
      Return 0
   } Else Return 1
}

trGdip_CreateBitmap(funcu, Width, Height, PixelFormat:=0, Stride:=0, Scan0:=0) {
    ; PixelFormat := (PixelFormat="0xE200B") ? coreDesiredPixFmt : PixelFormat
    r := Gdip_CreateBitmap(Width, Height, PixelFormat, Stride, Scan0)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() called by " funcu "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() called by " funcu "() using w" Width " - h" Height " - pixFmt" PixelFormat " failed: " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateBitmapFromFile(sFile, useICM:=0) {
    r := Gdip_CreateBitmapFromFileSimplified(sFile, useICM)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() error: " Gdip_ErrorHandler(gdipLastError, 0) "`nFile to load:" sFile)

    Return r
}

trGdip_CreateBitmapFromHBITMAP(hBitmap, hPalette:=0) {
    r := Gdip_CreateBitmapFromHBITMAP(hBitmap, hPalette)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, hBitmap = " hBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateHBITMAPFromBitmap(funcu, pBitmap, bgr:=0) {
    r := Gdip_CreateHBITMAPFromBitmap(pBitmap, bgr)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If !r
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateARGBBitmapFromHBITMAP(hBitmap) {
    r := Gdip_CreateARGBBitmapFromHBITMAP(hBitmap)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed to create pBitmap from hBitmap = " hBitmap)

    Return r
}

trGdip_BitmapConvertGray(pBitmap, hue:=0, vibrance:=-40, brightness:=1, contrast:=0, KeepPixelFormat:=0) {
    r := Gdip_BitmapConvertGray(pBitmap, hue, vibrance, brightness, contrast, KeepPixelFormat)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "(): failed, pBitmap = " pBitmap)
    Return r
}

trGdip_CloneBitmapArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:="0xE200B", KeepPixelFormat:=0) {
    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("BMP to clone area: " k ". ID: " pBitmap ". Cloner invoked by: " funcu)
    r := Gdip_CloneBitmapArea(pBitmap, x, y, w, h, PixelFormat, KeepPixelFormat)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CloneBitmap(funcu, pBitmap) {
    ; addJournalEntry(A_ThisFunc "() invoked by " funcu "() , pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))
    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("BMP to clone: " k ". ID: " pBitmap ". Cloner invoked by: " funcu)
    r := Gdip_CloneBitmap(pBitmap)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_BlurBitmap(pBitmap, BlurAmount, usePARGB:=0, quality:=7) {
    If !pBitmap
       addJournalEntry("WARNING: no bitmap given to blur")

    r := Gdip_BlurBitmap(pBitmap, BlurAmount, usePARGB, quality)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RenderPixelsOpaque(pBitmap, pBrush:=0, alphaLevel:=0) {
    r := Gdip_RenderPixelsOpaque(pBitmap, pBrush, alphaLevel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RetrieveBitmapChannel(pBitmap, channel) {
    r := Gdip_RetrieveBitmapChannel(pBitmap, channel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Return r
}

trGdip_ResizeBitmap(funcu, pBitmap, givenW, givenH, KeepRatio, InterpolationMode:="", KeepPixelFormat:=0, checkTooLarge:=0) {
    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_ResizeBitmap(pBitmap, givenW, givenH, KeepRatio, InterpolationMode, thisPixFmt, checkTooLarge)
    If StrLen(r)<3
    {
       baseMsg := "Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Return r
}

trGdip_RotateBitmapAtCenter(funcu, pBitmap, Angle, pBrush:=0, InterpolationMode:=7, PixelFormat:=0) {
    If !Angle
    {
       newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc "() initially invoked by " funcu "()", pBitmap)
       Return newBitmap
    }

    thisPixFmt := (PixelFormat=-1) ? coreDesiredPixFmt : PixelFormat
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_RotateBitmapAtCenter(pBitmap, Angle, pBrush, InterpolationMode, thisPixFmt)
    If StrLen(r)<3
    {
       baseMsg := "Unable to rotate internal bitmap to given angle: " angle "° for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Return r
}

trGdip_DisposeImage(pBitmap, noErr:=1) {
    If StrLen(pBitmap)<2
       Return

    fnOutputDebug("BMP to dispose: " createdGDIobjsArray["x" pBitmap, 4] ". ID: " pBitmap)
    ; If (createdGDIobjsArray["x" pBitmap, 3]=1 && createdGDIobjsArray["x" pBitmap, 2]="bmp")
    r := Gdip_DisposeImage(pBitmap, 1)
    createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 0, 0]
    Return r
}

gdipObjectsStats(killAll:=0, filteru:=0) {
   For Key, Value in createdGDIobjsArray
   {
      If (value[2]="bmp")
      {
         totalBMPs++
         If (value[3]=1)
         {
            If (killAll=1)
            {
               If (!InStr(value[4], filteru) && filteru)
                  Continue

               If !filteru
                  fnOutputDebug("Possible memory leak: " value[4])
               trGdip_DisposeImage(value[1], 1)
            }
            UnremovedBMPs++
         }
      }
   }

   If (killAll=1 && !filteru)
   {
      imgThumbsCacheArray := []
      imgThumbsCacheIDsArray := []
      imgsListArrayThumbs := []
   }

   If (killAll!=1)
      msgbox, % totalBMPs " // " UnremovedBMPs
}

testMemCrash() {
   Global sillyArray := []
   imgPath := "E:\Sucan twins\photos test\SLDs\really-all-images-cached-mega-test.sld"
   SoundBeep 
   FileRead, OutputVar, % imgPath
   Loop, Parse, OutputVar, `n,`r
   {
      If A_LoopField
      {
         loopsOccured++
         ; If (loopsOccured<510100)
            sillyArray[A_Index] := [A_LoopField, "z" A_LoopField] ; "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; Else If (loopsOccured<990100)
         ;    sillyArrayC[A_Index] := A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; Else
         ;    sillyArrayB[A_Index] := A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; sillyArray[A_loopField] := A_LoopField "-" SubStr(A_LoopField, 4) "=====" A_LoopField "|||" SubStr(A_LoopField, 4)
         ; sillyArray[A_Index] := A_LoopField "-" SubStr(A_LoopField, 2) "==" A_LoopField "|" SubStr(A_LoopField, 2)
      }
   }
   ToolTip, % loopsOccured , , , 2
   SoundBeep 
}

giveWarningX64() {
   SoundBeep, 300, 100

   msgResult := msgBoxWrapper(appTitle ": WARNING", "You are currently running a 64-bits operating system, but you are executing " appTitle " developed for 32-bits operating systems. Please exit and run the 64-bits edition of QPV, for an optimal experience. The 32-bits edition is severely limited and prone to crash at any moment.`n`nThank you for your inevitable cooperation.", "&Yes|&Exit|&Ask later|Continue...", 1, "error")
   If InStr(msgResult, "Continue")
   {
      SoundBeep , 300, 900
      msgResult := msgBoxWrapper(appTitle ": WARNING", "Some Pandas are weeping now... enjoy!", "&Whatever|&Exit", 1, "error")
      If InStr(msgResult, "exit")
      {
         exitAppu()
      } Else
      {
         showTOOLtip("Oh, you are so naughty!")
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   } Else If InStr(msgResult, "ask")
      SetTimer, giveWarningX64, -29100
   Else
      exitAppu()
}

/*

testWicArkive() {



   ; AHK v1

   wic_IDs.Initialize()
   file_name := getIDimage(currentFileIndex)
   ; file_name := "C:\Users\Jeb8\Desktop\external-content.duckduckgo.com.gif"

   factory := IWICImagingFactory.New()

   dbg("test.ptr: " factory.ptr " / type: " factory.__Class)

   decoder := factory.CreateDecoderFromFilename(file_name)

   count := decoder.GetFrameCount()

   dbg( "frame_count: " count)

   frame := decoder.GetFrame(0)

   dbg("GetFrame() done : LA : " frame.LastError)

   dbg("frame info: name: " frame.__Class " / ptr: " frame.ptr)

   dims := frame.GetSize()

   dbg("dims: " dims.w " / " dims.h)

   dpi := frame.GetResolution()

   dbg("dpi: " dpi.x " / " dpi.y)

   pixFormat := frame.GetPixelFormat()
   dbg("GUID str: " pixFormat " lastErr " frame.lasterror)

   converter := factory.CreateFormatConverter()
   dbg("converter ptr/type: " converter.ptr " / " converter.__Class)

   r1 := converter.CanConvert(pixFormat, "GUID_WICPixelFormat32bppPBGRA")
   dbg("CanConvert() : " r1)
   ; [4780] AHK: GUID str: GUID_WICPixelFormat24bppBGR

   r2 := converter.Initialize(frame, "GUID_WICPixelFormat32bppPBGRA")
   dbg("convert result: " r2)

; robo code begins here

   pBitmap := Gdip_CreateBitmap(dims.w, dims.h)
   E1 := Gdip_LockBits(pBitmap, 0, 0, dims.w, dims.h, stride, iScan, iData)


   dbg("gdip bitmap created and locked, copy pixels now")
   ; buf := BufferAlloc(dims.w * dims.h * 4) ; 32-bit, 4 bytes per pixel?
   r3 := frame.CopyPixels(0, stride, stride* dims.h, iData) ; prc, cbStride, cbBufferSize, pbBuffer
   dbg("CopyPixels(): LE: " frame.LastError " / r3: " r3)
   Gdip_UnlockBits(pBitmap, iData)

   trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   Gdip_DrawImage(pBitmap, 30, 30)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)

   Gdip_DisposeImage(pBitmap, 1)

}

; ===========================================================================
; Windows Imaging Component Library
; ===========================================================================

BufferAlloc(bSize, FillByte:="") { ; AHK v1 wrapper
    If !FillByte
        VarSetCapacity(DummyVar,bSize)
    Else VarSetCapacity(DummyVar,bSize,FillByte)
    return {ptr:&DummyVar, size:bSize, value:DummyVar}
}

dbg(in_str) {
    ; OutputDebug "AHK: " in_str  ; AHK v2
    OutputDebug qpv: %in_str%   ; AHK v1
}

class wic_IDs {
    ; Access really_long_name by:  wic_IDs.really_long_name (ahk v1 and v2)
    ; Leave this Static alone for AHK v1!
    Static PixelFormats := Object("{6FDDC324-4E03-4BFE-B185-3D77768DC900}","GUID_WICPixelFormatDontCare" ; AHK v1 = Object() / AHK v2 = Map()
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC901}","GUID_WICPixelFormat1bppIndexed"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC902}","GUID_WICPixelFormat2bppIndexed"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC903}","GUID_WICPixelFormat4bppIndexed"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC904}","GUID_WICPixelFormat8bppIndexed"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC905}","GUID_WICPixelFormatBlackWhite"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC906}","GUID_WICPixelFormat2bppGray"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC907}","GUID_WICPixelFormat4bppGray"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC908}","GUID_WICPixelFormat8bppGray"
                             , "{E6CD0116-EEBA-4161-AA85-27DD9FB3A895}","GUID_WICPixelFormat8bppAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC909}","GUID_WICPixelFormat16bppBGR555"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90A}","GUID_WICPixelFormat16bppBGR565"
                             , "{05EC7C2B-F1E6-4961-AD46-E1CC810A87D2}","GUID_WICPixelFormat16bppBGRA5551"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90B}","GUID_WICPixelFormat16bppGray"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90C}","GUID_WICPixelFormat24bppBGR"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90D}","GUID_WICPixelFormat24bppRGB"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90E}","GUID_WICPixelFormat32bppBGR"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC90F}","GUID_WICPixelFormat32bppBGRA"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC910}","GUID_WICPixelFormat32bppPBGRA"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC911}","GUID_WICPixelFormat32bppGrayFloat"
                             , "{D98C6B95-3EFE-47D6-BB25-EB1748AB0CF1}","GUID_WICPixelFormat32bppRGB"
                             , "{F5C7AD2D-6A8D-43DD-A7A8-A29935261AE9}","GUID_WICPixelFormat32bppRGBA"
                             , "{3CC4A650-A527-4D37-A916-3142C7EBEDBA}","GUID_WICPixelFormat32bppPRGBA"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC915}","GUID_WICPixelFormat48bppRGB"
                             , "{E605A384-B468-46CE-BB2E-36F180E64313}","GUID_WICPixelFormat48bppBGR"
                             , "{A1182111-186D-4D42-BC6A-9C8303A8DFF9}","GUID_WICPixelFormat64bppRGB"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC916}","GUID_WICPixelFormat64bppRGBA"
                             , "{1562FF7C-D352-46F9-979E-42976B792246}","GUID_WICPixelFormat64bppBGRA"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC917}","GUID_WICPixelFormat64bppPRGBA"
                             , "{8C518E8E-A4EC-468B-AE70-C9A35A9C5530}","GUID_WICPixelFormat64bppPBGRA"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC913}","GUID_WICPixelFormat16bppGrayFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC914}","GUID_WICPixelFormat32bppBGR101010"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC912}","GUID_WICPixelFormat48bppRGBFixedPoint"
                             , "{49CA140E-CAB6-493B-9DDF-60187C37532A}","GUID_WICPixelFormat48bppBGRFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC918}","GUID_WICPixelFormat96bppRGBFixedPoint"
                             , "{E3FED78F-E8DB-4ACF-84C1-E97F6136B327}","GUID_WICPixelFormat96bppRGBFloat"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC919}","GUID_WICPixelFormat128bppRGBAFloat"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91A}","GUID_WICPixelFormat128bppPRGBAFloat"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91B}","GUID_WICPixelFormat128bppRGBFloat"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91C}","GUID_WICPixelFormat32bppCMYK"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91D}","GUID_WICPixelFormat64bppRGBAFixedPoint"
                             , "{356DE33C-54D2-4A23-BB04-9B7BF9B1D42D}","GUID_WICPixelFormat64bppBGRAFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC940}","GUID_WICPixelFormat64bppRGBFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91E}","GUID_WICPixelFormat128bppRGBAFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC941}","GUID_WICPixelFormat128bppRGBFixedPoint"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC93A}","GUID_WICPixelFormat64bppRGBAHalf"
                             , "{58AD26C2-C623-4D9D-B320-387E49F8C442}","GUID_WICPixelFormat64bppPRGBAHalf"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC942}","GUID_WICPixelFormat64bppRGBHalf"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC93B}","GUID_WICPixelFormat48bppRGBHalf"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC93D}","GUID_WICPixelFormat32bppRGBE"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC93E}","GUID_WICPixelFormat16bppGrayHalf"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC93F}","GUID_WICPixelFormat32bppGrayFixedPoint"
                             , "{25238D72-FCF9-4522-B514-5578E5AD55E0}","GUID_WICPixelFormat32bppRGBA1010102"
                             , "{00DE6B9A-C101-434B-B502-D0165EE1122C}","GUID_WICPixelFormat32bppRGBA1010102XR"
                             , "{604E1BB5-8A3C-4B65-B11C-BC0B8DD75B7F}","GUID_WICPixelFormat32bppR10G10B10A2"
                             , "{9C215C5D-1ACC-4F0E-A4BC-70FB3AE8FD28}","GUID_WICPixelFormat32bppR10G10B10A2HDR10"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC91F}","GUID_WICPixelFormat64bppCMYK"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC920}","GUID_WICPixelFormat24bpp3Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC921}","GUID_WICPixelFormat32bpp4Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC922}","GUID_WICPixelFormat40bpp5Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC923}","GUID_WICPixelFormat48bpp6Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC924}","GUID_WICPixelFormat56bpp7Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC925}","GUID_WICPixelFormat64bpp8Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC926}","GUID_WICPixelFormat48bpp3Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC927}","GUID_WICPixelFormat64bpp4Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC928}","GUID_WICPixelFormat80bpp5Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC929}","GUID_WICPixelFormat96bpp6Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92A}","GUID_WICPixelFormat112bpp7Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92B}","GUID_WICPixelFormat128bpp8Channels"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92C}","GUID_WICPixelFormat40bppCMYKAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92D}","GUID_WICPixelFormat80bppCMYKAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92E}","GUID_WICPixelFormat32bpp3ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC92F}","GUID_WICPixelFormat40bpp4ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC930}","GUID_WICPixelFormat48bpp5ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC931}","GUID_WICPixelFormat56bpp6ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC932}","GUID_WICPixelFormat64bpp7ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC933}","GUID_WICPixelFormat72bpp8ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC934}","GUID_WICPixelFormat64bpp3ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC935}","GUID_WICPixelFormat80bpp4ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC936}","GUID_WICPixelFormat96bpp5ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC937}","GUID_WICPixelFormat112bpp6ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC938}","GUID_WICPixelFormat128bpp7ChannelsAlpha"
                             , "{6FDDC324-4E03-4BFE-B185-3D77768DC939}","GUID_WICPixelFormat144bpp8ChannelsAlpha"
                             , "{91B4DB54-2DF9-42F0-B449-2909BB3DF88E}","GUID_WICPixelFormat8bppY"
                             , "{1339F224-6BFE-4C3E-9302-E4F3A6D0CA2A}","GUID_WICPixelFormat8bppCb"
                             , "{B8145053-2116-49F0-8835-ED844B205C51}","GUID_WICPixelFormat8bppCr"
                             , "{FF95BA6E-11E0-4263-BB45-01721F3460A4}","GUID_WICPixelFormat16bppCbCr"
                             , "{A355F433-48E8-4A42-84D8-E2AA26CA80A4}","GUID_WICPixelFormat16bppYQuantizedDctCoefficients"
                             , "{D2C4FF61-56A5-49C2-8B5C-4C1925964837}","GUID_WICPixelFormat16bppCbQuantizedDctCoefficients"
                             , "{2FE354F0-1680-42D8-9231-E73C0565BFC1}","GUID_WICPixelFormat16bppCrQuantizedDctCoefficients")
    
    ; Static __Item[key] { ; AHK v1 - comment these 3 liens out for AHK v1
        ; get => this.%key%
    ; }
    ; AHK v1 - remove "Static" from all methods() / properties[] for AHK v1 compatibility
    CLSIDFromString(obj_in) { ; thanks to lexikos - from VA.ahk - modded by TheArkive
        DllCall("ole32\CLSIDFromString", "str", obj_in, "ptr", (obj_out := BufferAlloc(16,0)).ptr)
        return obj_out
    }
    StringFromGUID2(guid) { ; thanks to lexikos - from VA.ahk - modded by TheArkive
        Static _iu := StrLen(Chr(0xFFFF)), fnc := "ole32\StringFromGUID2"
        DllCall(fnc, "ptr", guid.ptr, "ptr", (buf := BufferAlloc(_iu?78:39)).ptr, "int", 39)
        return StrGet(buf.ptr)
    }
    Initialize() { ; run this on startup -> wic_IDs.Initialize()
        For CLSID, friendly_name in this.PixelFormats {
            DllCall("ole32\CLSIDFromString","Str",CLSID,"Ptr",(buf := BufferAlloc(16)).ptr)
            ; wic_IDs.%friendly_name% := {str:CLSID, value:buf, name:friendly_name, ptr:buf.ptr}   ; AHK v2
            wic_IDs[friendly_name] := {str:CLSID, value:buf, name:friendly_name, ptr:buf.ptr}    ; AHK v1
        }
    }
}

; These are the basic methods that need to apply to every COM instance.
class Com_Base_Functions {
    ; https://docs.microsoft.com/en-us/windows/win32/wic/-wic-codec-native-pixel-formats
    ; Color context information is defined by the IWICColorContext interface for WIC. To retrieve the color context information for an image frame, use the GetColorContext method.

    ; In the absence of color space information for an image, the general rule for color space inference is that UINT RGB and grayscale formats use the standard RGB color space (sRGB), while fixed-point and floating-point RGB and grayscale formats use the extended RGB color space (scRGB). The CMYK color model uses an RWOP color space.

    static v := SubStr(A_AhkVersion,1,1)
    obj := "", ptr := 0, _LastError := 0
    
    __New(inPtr:=0) {
        If (Com_Base_Functions.v >= 2)
            this.ptr := (this.obj := (!inPtr) ? ComObjCreate(this.CLSID, this.IID) : ComObject(13,inPtr)).ptr
        Else this.ptr := this.obj := (!inPtr) ? ComObjCreate(this.CLSID, this.IID) : inPtr
    }
    __Delete() {
        If Com_Base_Functions.v < 2
            ObjRelease(this.ptr)
    }
    exec(index, p*) {
        return DllCall(NumGet(NumGet(this.ptr+0,"Ptr")+(index*A_PtrSize), "Ptr"), "Ptr", this.ptr+0, p*) ; +0 for AHK v1
    }
    LastError[] {
        get {
            return (this._LastError) ? Format("0x{:X}",this._LastError & 0xFFFFFFFF) : 0
        }
        set {
            this._LastError := value
        }
    }
    New(inPtr:=0) { ; for AHK v1
        n := this.__Class, new := "x", obj := New %n%(inPtr) ; [ new:="x" ] to make AHK v2 happy
        return obj                                           ; for calling "New Class()" in AHK v1 style.
    }
    ; vtbl(addr, index) {
        ; return NumGet(NumGet(addr+0,"Ptr")+(index*A_PtrSize), "Ptr") ; +0 for AHK v1
    ; }
    
    
}

; https://docs.microsoft.com/en-us/windows/desktop/api/wincodec/nn-wincodec-iwicbitmapsource
class IWICBitmapSource extends Com_Base_Functions {
    IID := "{00000120-a8f2-4877-ba0a-fd2b6645fb94}"
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapsource-getsize
    ; Returns obj with {w, h} properties.
    GetSize() { ; 3
        this.LastError := this.exec(3
        , "Ptr", (w:=BufferAlloc(4)).ptr, "Ptr", (h:=BufferAlloc(4)).ptr)
        return (!this.LastError) ? {w:NumGet(w.ptr,"UInt"), h:NumGet(h.ptr,"UInt")} : ""
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapsource-getpixelformat
    ; Returns friendly name string for GUID that represents the Pixel Format.
    GetPixelFormat() { ; 4
        this.LastError := this.exec(4
        , "Ptr", (pPixelFormat:=BufferAlloc(16)).ptr) ; GUID return type (16 bytes)
        UID_str := wic_IDs.StringFromGUID2(pPixelFormat)
        return (!this.LastError) ? wic_IDs.PixelFormats[UID_str] : ""
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapsource-getresolution
    GetResolution() { ; 5
        this.LastError := this.exec(5
        , "Ptr", (pDpiX:=BufferAlloc(8)).ptr, "Ptr", (pDpiY:=BufferAlloc(8)).ptr) ; "double" return type
        return (!this.LastError) ? {x:NumGet(pDpiX.ptr,"Double"), y:NumGet(pDpiY.ptr,"Double")} : ""
    }
    CopyPalette() { ; 6
        this.LastError := this.exec(6, "Ptr", (pIPalette:=BufferAlloc(A_PtrSize)).ptr)
        return (!this.LastError) ? IWICPalette.New(NumGet(pIPalette.ptr,"Ptr")) : ""
    }
    CopyPixels(prc, cbStride, cbBufferSize, pbBuffer) { ; 7
        If ((prc ? WI_ptr := (WIRect := BufferAlloc(16,0)).ptr : WI_ptr := 0)) { ; prc takes [x,y,w,h] as input
            For i, val in prc
                ; NumPut("Int", val, WI_ptr, 4*(A_Index-1)) ; AHK v2
                NumPut(val, WI_ptr+(4*(A_Index-1)), "Int") ; AHK v1
        }
        this.LastError := this.exec(7
        , "Ptr", WI_ptr, "UInt", cbStride, "UInt", cbBufferSize, "Ptr", pbBuffer)
        return (!this.LastError) ? true : ""
    }
}
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmap
    class IWICBitmap extends IWICBitmapSource { ; IWICBitmapSource -> this 
        IID := "{00000121-a8f2-4877-ba0a-fd2b6645fb94}"
        Lock() { ; 8
        }
        SetPalette() { ; 9
        }
        SetResolution() { ; 10
        }
    }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmapclipper
    class IWICBitmapClipper extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{E4FBCF03-223D-4e81-9333-D635556DD1B5}"
        Initialize() { ; 8
        }
    }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmapfliprotator
    class IWICBitmapFlipRotator extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{5009834F-2D6A-41ce-9E1B-17C5AFF7A782}"
        Initialize() { ; 8
        }
    }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmapframedecode
    class IWICBitmapFrameDecode extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{3B16811B-6A43-4ec9-A813-3D930C13B940}"
        GetMetadataQueryReader() { ; 8
        }
        GetColorContexts() { ; 9
        }
        GetThumbnail() { ; 10
        }
    }

        ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicdevelopraw
        class IWICDevelopRaw extends IWICBitmapFrameDecode { ; IWICBitmapSource -> IWICBitmapFrameDecode -> this
            IID := "{fbec5e44-f7be-4b65-b7f8-c0c81fef026d}"
            QueryRawCapabilitiesInfo() { ; 11
            }
            LoadParameterSet() { ; 12
            }
            GetCurrentParameterSet() { ; 13
            }
            SetExposureCompensation() { ; 14
            }
            GetExposureCompensation() { ; 15
            }
            SetWhitePointRGB() { ; 16
            }
            GetWhitePointRGB() { ; 17
            }
            SetNamedWhitePoint() { ; 18
            }
            GetNamedWhitePoint() { ; 19
            }
            SetWhitePointKelvin() { ; 20
            }
            GetWhitePointKelvin() { ; 21
            }
            GetKelvinRangeInfo() { ; 22
            }
            SetContrast() { ; 23
            }
            GetContrast() { ; 24
            }
            SetGamma() { ; 25
            }
            GetGamma() { ; 26
            }
            SetSharpness() { ; 27
            }
            GetSharpness() { ; 28
            }
            SetSaturation() { ; 29
            }
            GetSaturation() { ; 30
            }
            SetTint() { ; 31
            }
            GetTint() { ; 32
            }
            SetNoiseReduction() { ; 33
            }
            GetNoiseReduction() { ; 34
            }
            SetDestinationColorContext() { ; 35
            }
            SetToneCurve() { ; 36?
            }
            GetToneCurve() { ; 37?
            }
            SetRotation() { ; 38
            }
            GetRotation() { ; 39
            }
            SetRenderMode() { ; 40
            }
            GetRenderMode() { ; 41
            }
            SetNotificationCallback() { ; 42
            }
        }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmapscaler
    class IWICBitmapScaler extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{00000302-a8f2-4877-ba0a-fd2b6645fb94}"
        Initialize() { ; 8
        }
    }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwiccolortransform
    class IWICColorTransform extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{B66F034F-D0E2-40ab-B436-6DE39E321A94}"
        Initialize() { ; 8
        }
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicformatconverter
    class IWICFormatConverter extends IWICBitmapSource { ; IWICBitmapSource -> this
        IID := "{00000301-a8f2-4877-ba0a-fd2b6645fb94}"
        
        ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicformatconverter-initialize
        ; Performs / preps conversion from one pixel format to another.
        ; Dither options:                                      ; Palette options:
        ; WICBitmapDitherTypeNone              = 0             ; WICBitmapPaletteTypeCustom              = 0 
        ; WICBitmapDitherTypeSolid             = 1             ; WICBitmapPaletteTypeMedianCut           = 1 
        ; WICBitmapDitherTypeOrdered4x4        = 2             ; WICBitmapPaletteTypeFixedBW             = 2 
        ; WICBitmapDitherTypeOrdered8x8        = 3             ; WICBitmapPaletteTypeFixedHalftone8      = 3 
        ; WICBitmapDitherTypeOrdered16x16      = 4             ; WICBitmapPaletteTypeFixedHalftone27     = 4 
        ; WICBitmapDitherTypeSpiral4x4         = 5             ; WICBitmapPaletteTypeFixedHalftone64     = 5 
        ; WICBitmapDitherTypeSpiral8x8         = 6             ; WICBitmapPaletteTypeFixedHalftone125    = 6 
        ; WICBitmapDitherTypeDualSpiral4x4     = 7             ; WICBitmapPaletteTypeFixedHalftone216    = 7 
        ; WICBitmapDitherTypeDualSpiral8x8     = 8             ; WICBitmapPaletteTypeFixedWebPalette     = 8 
        ; WICBitmapDitherTypeErrorDiffusion    = 9             ; WICBitmapPaletteTypeFixedHalftone252    = 9 
        ; WICBITMAPDITHERTYPE_FORCE_DWORD      = 10            ; WICBitmapPaletteTypeFixedHalftone256    = 10
                                                               ; WICBitmapPaletteTypeFixedGray4          = 11
        ; pISource  = input IWICBitmapSource                   ; WICBitmapPaletteTypeFixedGray16         = 12
        ; dstFormat = destination format guid                  ; WICBitmapPaletteTypeFixedGray256        = 13
        ; alphaThresholdPercent = float, 1.0 max               ; WICBITMAPPALETTETYPE_FORCE_DWORD        = 14
        Initialize(pISource, dstFormat, dither:=0, pIPalette:=0, alphaThresholdPercent:=0, paletteTranslate:=0) { ; 8
            this.LastError := this.exec(8
            , "Ptr", pISource, "Ptr", wic_IDs[dstFormat].ptr, "Int", dither
            , "Ptr", pIPalette, "Double", alphaThresholdPercent, "Int", paletteTranslate)
            return (!this.LastError) ? true : "" ; return 1 on success
        }
        ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicformatconverter-canconvert
        ; Returns bool (true/false) if conversion from specified source to destination palette can be done.
        CanConvert(srcPixelFormat, dstPixelFormat) { ; 9
            uid1 := wic_IDs[srcPixelFormat], uid2 := wic_IDs[dstPixelFormat]
            this.LastError := this.exec(9
            , "Ptr", uid1.ptr, "Ptr", uid2.ptr, "Ptr", (buf:=BufferAlloc(4)).ptr)
            return (!this.LastError) ? NumGet(buf.ptr,"Int") : ""
        }
    }
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicplanarformatconverter
    class IWICPlanarFormatConverter extends IWICBitmapSource { ; IWICPlanarFormatConverter -> this
        IID := "{BEBEE9CB-83B0-4DCC-8132-B0AAA55EAC96}"
        Initialize() { ; 8
        }
        CanConvert() { ; 9
        }
    }

; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicimagingfactory
class IWICImagingFactory extends Com_Base_Functions { ; root obj
    CLSID := "{CACAF262-9370-4615-A13B-9F5539DA4C0A}"
    IID   := "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}"
    
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicimagingfactory-createdecoderfromfilename
    ; Creates / returns IWICBitmapDecoder.      ; metadataOptions:
    ; dwDesiredAccess:                          ; WICDecodeMetadataCacheOnDemand        = 0
    ; GENERIC_READ  := 0x80000000               ; WICDecodeMetadataCacheOnLoad          = 1
    ; GENERIC_WRITE := 0x40000000               ; WICMETADATACACHEOPTION_FORCE_DWORD    = 2
    CreateDecoderFromFilename(wzFilename, pguidVendor:=0, dwDesiredAccess:=0x80000000, metadataOptions:=0) { ; 3
        this.LastError := this.exec(3
        , "Str", wzFilename, "Ptr", pguidVendor, "UInt", dwDesiredAccess, "Int", metadataOptions, "Ptr", (buf := BufferAlloc(A_PtrSize)).ptr)
        return (!this.LastError) ? IWICBitmapDecoder.New(NumGet(buf.ptr,"Ptr")) : ""
    }
    CreateDecoderFromStream() { ; 4
    }
    CreateDecoderFromFileHandle() { ; 5
    }
    CreateComponentInfo() { ; 6
    }
    CreateDecoder() { ; 7
    }
    CreateEncoder() { ; 8
    }
    CreatePalette() { ; 9
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicimagingfactory-createformatconverter
    ; Returns / creates IWICFormatConverter.
    CreateFormatConverter() { ; 10
        this.LastError := this.exec(10
        , "Ptr", (buf:=BufferAlloc(A_PtrSize)).ptr)
        return (!this.LastError) ? IWICFormatConverter.New(NumGet(buf.ptr,"Ptr")) : ""
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicimagingfactory-createbitmapscaler
    ; Returns / creates IWICBitmapScaler.
    CreateBitmapScaler() { ; 11
        this.LastError := this.exec(11
        , "Ptr", (buf:=BufferAlloc(A_PtrSize)).ptr)
        return (!this.LastError) ? IWICBitmapScaler.New(NumGet(buf.ptr,"Ptr")) : ""
    }
    CreateBitmapClipper() { ; 12
    }
    CreateBitmapFlipRotator() { ; 13
    }
    CreateStream() { ; 14
    }
    CreateColorContext() { ; 15
    }
    CreateColorTransformer() { ; 16
    }
    CreateBitmap() { ; 17
    }
    CreateBitmapFromSource() { ; 18
    }
    CreateBitmapFromSourceRect() { ; 19
    }
    CreateBitmapFromMemory() { ; 20
    }
    CreateBitmapFromHBITMAP() { ; 21
    }
    CreateBitmapFromHICON() { ; 22
    }
    CreateComponentEnumerator() { ; 23
    }
    CreateFastMetadataEncoderFromDecoder() { ; 24
    }
    CreateFastMetadataEncoderFromFrameDecode() { ; 25
    }
    CreateQueryWriter() { ; 26
    }
    CreateQueryWriterFromReader() { ; 27
    }
}

    class IWICImagingFactory2 extends IWICImagingFactory { ; IWICImagingFactory -> this
        IID := "{7B816B45-1996-4476-B132-DE9E247C8AF0}"
        CreateImageEncoder() { ; 28
        }
    }

; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nn-wincodec-iwicbitmapdecoder
class IWICBitmapDecoder extends Com_Base_Functions { ; root obj
    IID := "{9EDDE9E7-8DEE-47ea-99DF-E6FAF2ED44BF}"
    QueryCapability() { ; 3
    }
    Initialize() { ; 4
    }
    GetContainerFormat() { ; 5
    }
    GetDecoderInfo() { ; 6
    }
    CopyPalette() { ; 7
    }
    GetMetadataQueryReader() { ; 8
    }
    GetPreview() { ; 9
    } 
    GetColorContexts() { ; 10
    }
    GetThumbnail() { ; 11
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapdecoder-getframecount
    GetFrameCount() { ; 12
        ; this.LastError := DllCall(this.vtbl(this.ptr,12), "Ptr", this.ptr, "UInt*", count:=0)
        ; return (!this.LastError) ? count : ""

        this.LastError := this.exec(12, "Ptr", (count := BufferAlloc(4)).ptr)
        return (!this.LastError) ? NumGet(count.ptr,"UInt") : ""
    }
    ; https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapdecoder-getframe
    ; Returns / creates IWICBitmapFrameDecode.
    GetFrame(index) { ; 13
        this.LastError := this.exec(13, "UInt", index, "Ptr", (ppIBitmapFrame := BufferAlloc(A_PtrSize)).ptr)
        return (!this.LastError) ? IWICBitmapFrameDecode.New(NumGet(ppIBitmapFrame.ptr,"Ptr")) : ""
    }
    
}

class IWICPalette extends Com_Base_Functions {
    IID := "{00000040-a8f2-4877-ba0a-fd2b6645fb94}"
    InitializePredefined() { ; 3
    }
    InitializeCustom() { ; 4
    }
    InitializeFromBitmap() { ; 5
    }
    InitializeFromPalette() { ; 6
    }
    GetType() { ; 7
    }
    GetColorCount() { ; 8
    }
    GetColors() { ; 9
    }
    IsBlackWhite() { ; 10
    }
    IsGrayscale() { ; 11
    }
    HasAlpha() { ; 12
    }
}
*/

ShellFileOperation(fileO, fSource, fTarget, flags, ghwnd:=0x0) {
/*
   Provides access to Windows built-in file operation system 
   (move / copy / rename / delete files or folders with the standard Windows dialog and error UI).  
   Utilizes the SHFileOperation shell function in Windows.

   For online documentation [broken link]
   See http://www.autohotkey.net/~Rapte_Of_Suzaku/Documentation/files/ShellFileOperation-ahk.html

   Function found on: https://github.com/denolfe/AutoHotkey/blob/master/lib/ShellFileOperation.ahk
   Release #3
   Joshua A. Kinnison
   2010-09-29, 15:12
*/
; modified by Marius Șucan

   ; AVAILABLE OPERATIONS [fileO]
   static FO_MOVE                   := 0x1
   static FO_COPY                   := 0x2
   static FO_DELETE                 := 0x3
   static FO_RENAME                 := 0x4

   ; AVAILABLE FLAGS
   static FOF_MULTIDESTFILES        := 0x1     ; Indicates that the to member specifies multiple destination files (one for each source file) rather than one directory where all source files are to be deposited.
   static FOF_CONFIRMMOUSE          := 0x2     ; ???
   static FOF_SILENT                := 0x4     ; Does not display a progress dialog box.
   static FOF_RENAMEONCOLLISION     := 0x8     ; Gives the file being operated on a new name (such as "Copy #1 of...") in a move, copy, or rename operation if a file of the target name already exists.
   static FOF_NOCONFIRMATION        := 0x10    ; Responds with "yes to all" for any dialog box that is displayed.
   static FOF_WANTMAPPINGHANDLE     := 0x20    ; returns info about the actual result of the operation
   static FOF_ALLOWUNDO             := 0x40    ; Preserves undo information, if possible. With del, uses recycle bin.
   static FOF_FILESONLY             := 0x80    ; Performs the operation only on files if a wildcard filename (*.*) is specified.
   static FOF_SIMPLEPROGRESS        := 0x100   ; Displays a progress dialog box, but does not show the filenames.
   static FOF_NOCONFIRMMKDIR        := 0x200   ; Does not confirm the creation of a new directory if the operation requires one to be created.
   static FOF_NOERRORUI             := 0x400   ; don't put up error UI
   static FOF_NOCOPYSECURITYATTRIBS := 0x800   ; dont copy file security attributes
   static FOF_NORECURSION           := 0x1000  ; Only operate in the specified directory. Don't operate recursively into subdirectories.
   static FOF_NO_CONNECTED_ELEMENTS := 0x2000  ; Do not move connected files as a group (e.g. html file together with images). Only move the specified files.
   static FOF_WANTNUKEWARNING       := 0x4000  ; Send a warning if a file is being destroyed during a delete operation rather than recycled. This flag partially overrides FOF_NOCONFIRMATION.
   static FOF_NORECURSEREPARSE      := 0x8000  ; treat reparse points as objects, not containers ?

   If !fSource
   {
      ret := []
      Return ret["error"] := -1
   }

   fileO := %fileO% ? %fileO% : fileO
   If (SubStr(flags, 0)="|")
      flags := SubStr(flags,1,-1)

   _flags := 0
   Loop Parse, flags, |
      _flags |= %A_LoopField%   

   flags := _flags ? _flags : (%flags% ? %flags% : flags)
   If (SubStr(fSource, 0)!= "|" )
      fSource := fSource . "|"

   If (SubStr(fTarget, 0)!="|")
      fTarget := fTarget . "|"
   
   char_size := A_IsUnicode ? 2 : 1
   char_type := A_IsUnicode ? "UShort" : "Char"
   
   fsPtr := &fSource
   Loop % StrLen(fSource)
   {
      if (NumGet(fSource, (A_Index-1)*char_size, char_type) = 124)
         NumPut(0, fSource, (A_Index-1)*char_size, char_type)
   }

   ftPtr := &fTarget
   Loop % StrLen(fTarget)
   {
      if (NumGet(fTarget, (A_Index-1)*char_size, char_type) = 124)
         NumPut(0, fTarget, (A_Index-1)*char_size, char_type)
   }
   
   VarSetCapacity(SHFILEOPSTRUCT, 60, 0 )                 ; Encoding SHFILEOPSTRUCT
   NextOffset := NumPut(ghwnd, &SHFILEOPSTRUCT )          ; hWnd of calling GUI
   NextOffset := NumPut(fileO, NextOffset+0    )          ; File operation
   NextOffset := NumPut(fsPtr, NextOffset+0    )          ; Source file / pattern
   NextOffset := NumPut(ftPtr, NextOffset+0    )          ; Target file / folder
   NextOffset := NumPut(flags, NextOffset+0, 0, "Short" ) ; options

   code    := DllCall("Shell32\SHFileOperationW", "UPtr", &SHFILEOPSTRUCT)
   aborted := NumGet(NextOffset+0)
   H2M_ptr := NumGet(NextOffset+4)
   
   ret              := []
   ret["mappings"]  := []
   ret["error"]     := code
   ret["aborted"]   := aborted

   if (FOF_WANTMAPPINGHANDLE & flags)
   {
      ; HANDLETOMAPPINGS 
      ret["num_mappings"]  := NumGet(H2M_ptr+0)
      map_ptr              := NumGet(H2M_ptr+4)
      
      Loop % ret["num_mappings"]
      {
         ; _SHNAMEMAPPING
         addr := map_ptr+(A_Index-1)*16 ;
         old  := StrGet(NumGet(addr+0))
         new  := StrGet(NumGet(addr+4))
         
         ret["mappings"][old] := new
      }
   }
   
   ; free mappings handle if it was requested
   if (FOF_WANTMAPPINGHANDLE & flags)
      DllCall("Shell32\SHFreeNameMappings", int, H2M_ptr)
   
   Return ret
}

checkDLLfiles() {
   Static lastInvoked := 0
   If (lastInvoked>1)
      Return

   lastInvoked++
   DllPathA := FreeImage_FoxGetDllPath("freeimage.dll")
   If !FileExist(DllPathA)
      freeIMGmissin := 1
   
   DllPathB := FreeImage_FoxGetDllPath("sqlite3.dll")
   If !FileExist(DllPathB)
      sqlMissin := 1

   If (sqlMissin=1 || freeIMGmissin=1)
      msgResult := msgBoxWrapper(appTitle ": ERROR", "It seems " appTitle " DLL files are missing. Some features of the application will not work. Please download the QPV portable ZIP package.", "&Download|&Cancel", 1, "ERROR")

   If (msgResult="Download")
      Try Run, https://github.com/marius-sucan/Quick-Picto-Viewer
}

/*

JusticeCombineTiles2colors() {
   disposeCacheIMGs()
   imgPath := getIDimage(currentFileIndex)
   FileName := "E:\Sucan twins\_misc-work\Justice Frangipane\stylus-hotkeys\the-script\v4\ini-presets\Preset Rebelle.ini"
   givenSection := "ArtistPad_medium"
   tilesList := JusticeSortTiles(fileName, givenSection)
   tilesArray := StrSplit(tilesList, "`n")
   colorsList := JusticeExtractTinyColors(imgPath, tilesArray.Count() - 1)
   colorsArray := StrSplit(colorsList, "`n")
   newList := ""
   Loop, % tilesArray.Count()
   {
       line := SubStr(tilesArray[A_Index], InStr(tilesArray[A_Index], "||") + 2)
       lr := StrSplit(line, ",")
       If (lr[1]="")
          Continue
       thisClr := SubStr(colorsArray[A_Index], InStr(colorsArray[A_Index], "||") + 2)
       newList .= "tile" Format("{:03}", A_Index - 1) "=" lr[1] "," lr[2] "," lr[3] "," lr[4] "," lr[5] "," lr[6] "," lr[7] "," lr[8] "," thisClr "`n"
   }

   Clipboard := newList
}

JusticeExtractTinyColors(imgPath, counts) {
   imgS := Ceil(sqrt(counts)) 
   pBitmap := Gdip_CreateBitmapFromFileSimplified(imgPath)
   smallBMP := Gdip_ResizeBitmap(pBitmap, imgS, imgS, 0, 7)

   pX := 0, pY := 1
   thisIndex := 0
   colorsArray := []
   Loop, % imgS**2
   {
      thisIndex++
      pX++
      If (pX>imgS)
      {
         pX := 1
         pY++
         If (pY>imgS)
            pY := 1
      }

      ARGBdec := Gdip_GetPixel(smallBMP, pX - 1, pY - 1)
      Gdip_FromARGB(ARGBdec, A, R, G, B)
      zR := R * 0.308
      zG := G * 0.650
      zB := B * 0.095
      Z := Round(snapToValues(zR + zG + zB, 0, 255, 2, 1))

      thisColor := Gdip_ToARGB("0xFF", R, G, B)
      clr := SubStr(Format("{1:#x}", thisColor), 5)
      colorsList .= z "||" clr "`n"
   }
   Gdip_DisposeImage(pBitmap)
   Gdip_DisposeImage(smallBMP)
   Sort, colorsList, ND`n
   ; Clipboard := counts "=" imgS "||" colorsList
   Return colorsList
}

JusticeSortTiles(fileName, givenSection) {
   newList := ""
   IniRead, OutputVarSection, % Filename, % givenSection
   Loop, Parse, OutputVarSection, `n,`r
   {
      If InStr(A_LoopField, ",")
      {
         line := SubStr(A_LoopField, InStr(A_LoopField, "=") + 1)
         lineArray := StrSplit(line, ",")
         newList .= lineArray[3] "||" line "`n"
      }
   }

   Sort, newList, ND`n
   Return newList
}
*/

tlbrAddNewIcon(obju, wi, he, IconSpacing, noSpacing, simpleRefresh) {
    Global
    Static indexBtn := 0, pickoBeat := 0
    indexBtn++
    icoFile := obju[1]
    actu := StrLen(obju[2])>2 ? obju[2] : ""
    actu2 := StrLen(obju[4])>2 ? obju[4] : ""
    btnID := obju[5]
    paramu := obju[6]
    btnName := obju[3]
    If (TLBRtwoColumns=1)
    {
       otherz := (pickoBeat=0) ? "xs y+" IconSpacing " " : "x+" IconSpacing " yp"
       If (indexBtn=1)
          otherz := "xm+" IconSpacing " y+" IconSpacing " Section"
    } Else otherz := (TLBRverticalAlign=1) ? "xm+" IconSpacing " y+" IconSpacing : "x+" IconSpacing " y" IconSpacing
    

    If (noSpacing=1)
    {
       indexBtn := 0
       pickoBeat := 1
       otherz := "x0 y0"
    }

    ; ToolTip, % pickoBeat " == " otherz , , , 2
    ; sleep, 950
    ; limitu := (indexBtn>3) ? 1 : 2
    ; If (indexBtn=4)
    ;    pickoBeat := 1
       pickoBeat := !pickoBeat
    ; pickoBeat := clampInRange(pickoBeat + 1, 0, limitu, 1)
    If (simpleRefresh=1)
    {
       hwndul := tlbrIconzList[indexBtn, 1]
       If (icoFile!=tlbrIconzList[indexBtn, 2])
          tlbrSetImageIcon(icoFile, hwndul, wi, he)
    } Else
    {
       Gui, OSDguiToolbar: Add, Text, h%he% w%wi% %otherz% BackgroundTrans +0xE vtlbrValueIcon%IndexBtn% +hwndhwndul gtlbrInvokeFunction, Image icon %indexBtn% ; Windows Narrator friendly buttons 
       tlbrSetImageIcon(icoFile, hwndul, wi, he)
    }

    ; Gui, OSDguiToolbar: Add, Text,  h%he% w%wi% %otherz% BackgroundTrans +0x1000 +0xE, %btnName% ; Windows Narrator friendly buttons 
    ; Gui, OSDguiToolbar: Add, Picture, vtlbrValueIcon%IndexBtn% AltSubmit  +hwndhwndul xp yp hp wp gtlbrInvokeFunction, %mainCompiledPath%\resources\toolbar\%icoFile%.png
    tlbrIconzList[indexBtn] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID]
    tlbrIconzList[hwndul] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID]
    tlbrIconzList[btnID] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID]
}

tlbrSetImageIcon(icoFile, hwnd, W, H) {
    If (icoFile="colorz-swatch")
    {
       pBitmap := Gdip_CreateBitmap(512, 512)
       Gu := Gdip_GraphicsFromImage(pBitmap)
       Gdip_GraphicsClear(Gu, "0xFF" ToolbarBgrColor)
       If (BrushToolUseSecondaryColor=1)
       {
          BrushA := Gdip_BrushCreateSolid("0xFF" BrushToolBcolor)
          BrushB := Gdip_BrushCreateSolid("0xFF" BrushToolAcolor)
       } Else
       {
          BrushA := Gdip_BrushCreateSolid("0xFF" BrushToolAcolor)
          BrushB := Gdip_BrushCreateSolid("0xFF" BrushToolBcolor)
       }

       pPenA := Gdip_CreatePen("0xFFffFFff", 10)
       pPenB := Gdip_CreatePen("0xFF101010", 25)
       posYu := (TLBRverticalAlign!=1) ? 55 : 33
       Gdip_FillEllipse(Gu, BrushB, 412//2, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenB, 412//2, posYu, 412//2, 400)
       Gdip_FillEllipse(Gu, BrushA, 80, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenB, 80, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenA, 80, posYu, 412//2, 400)
       Gdip_DeleteGraphics(Gu)
       Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeletePen(pPenA)
       Gdip_DeletePen(pPenB)
    } Else pbitmap := Gdip_CreateBitmapFromFileSimplified(mainCompiledPath "\resources\toolbar\" icoFile ".png")

    If StrLen(pBitmap)>2
    {
       ; IndexBtn := tlbrIconzList[hwnd, 5]
       ; btnName := tlbrIconzList[hwnd, 3]
       ; Sleep, 500
       ; ToolTip, % indexBtn "=" btnName "=" hwnd , , , 2
       ; If btnName
       ;    ControlSetText, , % btnName, ahk_id %hwnd%   ; nothing seems to work to change the control's text ; I do not know why
       ;    GuiControl, OSDguiToolbar:, tlbrValueIcon%IndexBtn%, % btnName
       icoBMP := Gdip_ResizeBitmap(pBitmap, w, h, 0, 7, 0, 0, "0xFF" ToolbarBgrColor)
       hBitmap := Gdip_CreateHBITMAPFromBitmap(icoBMP)
       SetImage(hwnd, hBitmap)
       Gdip_DisposeImage(pBitmap, 1)
       Gdip_DisposeImage(icoBMP, 1)
       Gdi_DeleteObject(hBitmap)
    }
}

tlbrInvokeFunction(a, b, c) {
   interfaceThread.ahkFunction("mouseTurnOFFtooltip")
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   If (AnyWindowOpen && imgEditPanelOpened!=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1 || AnyWindowOpen=24 || AnyWindowOpen=31)
   || (A_TickCount - lastOtherWinClose<500)
      Return

   SetTimer, drawWelcomeImg, Off
   If (c!="kbd")
      isToolbarKBDnav := 0

   hwnd := (c="kbd") ? a : Format("0x{1:x}", a)
   funcu := InStr(b, "right") ? tlbrIconzList[hwnd, 6] : tlbrIconzList[hwnd, 4]
   ; ToolTip, % z "=" a "=" b "=" c "=" funcu , , , 2
   paramu := tlbrIconzList[hwnd, 9]
   If funcu
      addJournalEntry("Toolbar action: " tlbrIconzList[hwnd, 3] " | " funcu "(" paramu ")")

   If IsFunc(funcu)
   {
      If paramu
         z := %funcu%(hwnd, paramu)
      Else
         z := %funcu%()
   } Else
   {
      z := "m"
      If funcu
         invokeTlbrContextMenu()
   }

    If (InStr(b, "right") || z="m") && (c!="kbd")
    {
       If (AnyWindowOpen && imgEditPanelOpened!=1) || (AnyWindowOpen && imgEditPanelOpened=1 && panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%
       Else
          WinActivate, ahk_id %PVhwnd%
    }
}

OnLButtonDblClk(wParam, lParam, msg, hwnd) {
; function by Lexikos; work-around for double-click on Gui Picture Controls
; from https://autohotkey.com/board/topic/94962-doubleclick-on-gui-pictures-puts-their-path-in-your-clipboard/
    Critical, On
    WinGetClass, WinClass, ahk_id %hwnd%
    If (WinClass="Static")
    {
        If !A_Gui
           Return 0  ; Just prevent Clipboard change.
        ; Send a WM_COMMAND message to the Gui to trigger the control's g-label.
        Gui, +LastFound
        gID := DllCall("GetDlgCtrlID", "ptr", hwnd) ; Requires AutoHotkey v1.1.
        Static STN_DBLCLK := 1
        PostMessage, 0x111, gID | (STN_DBLCLK << 16), hwnd
        ; Return a value to prevent the default handling of this message.
        Return 0
    }
}

isImgEditingNow() {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (StrLen(whichBitmap)>2 && imgPath && thumbsDisplaying!=1) ? 1 : 0
   Return infoImgEditingNow
}

tlbrInvokeEditMenu() {
   If (!AnyWindowOpen || imgEditPanelOpened=1)
   {
      If isImgEditingNow()
         invokeSelectionAreaMenu("DoubleClick")
      Else
         InitSecondMenu()
      Return "m"
   }
}

tlbrInvokeInterfaceMenu() {
   If (!AnyWindowOpen || imgEditPanelOpened=1)
   {
      OpenUImenu()
      Return "m"
   }
}

OSDguiToolbarGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
     If isRightClick
        tlbrInvokeFunction(CtrlHwnd, "Right", 1)
}

tlbrPlaySlides() {
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
 
   SetTimer, dummyInfoToggleSlideShowu, -250
}

tlbrInsertTextArea() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      PanelEditImgCaption()
      Return
   }

   If (isImgEditingNow()!=1 || AnyWindowOpen=32)
   {
      If (thumbsDisplaying=1)
         PanelSearchIndex()
      Return
   }

   PanelInsertTextArea()
}

tlbrEraserTool() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      singleInListEntriesRemover()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelEraseSelectedArea()
}

tlbrActColorsSwatch() {
   oldColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
   newColor := createStandardColorzDialog(whichWin, oldColor)
   If (BrushToolUseSecondaryColor=1)
      BrushToolBcolor := newColor
   Else 
      BrushToolAcolor := newColor

   updateToolColorsBasedToolbar(newColor, oldColor)
   updateTlbrColorsSwatch()
   INIaction(1, "BrushToolAcolor", "General")
   INIaction(1, "BrushToolBcolor", "General")
   If (imgEditPanelOpened=1 && AnyWindowOpen && isImgEditingNow()=1)
      livePreviewsImageEditing()
}

updateToolColorsBasedToolbar(newColor, oldColor) {
    If (imgEditPanelOpened!=1 || isImgEditingNow()!=1)
       Return

    If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
    {
       GuiControl, SettingsGUIA: +Background%newColor%, % SubStr(thisColor, 6)
    } Else If (AnyWindowOpen=23)
    {
       If (oldColor=FillArea2ndColor)
       {
          FillArea2ndColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, FillArea2ndColor
       } Else
       {
          FillAreaColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, FillAreaColor
       }
    } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
    {
       GuiControl, SettingsGUIA: +Background%newColor%, DrawLineAreaColor
       DrawLineAreaColor := newColor
    } Else If (AnyWindowOpen=32)
    {
       If (oldColor=TextInAreaBgrColor)
       {
          TextInAreaBgrColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, TextInAreaBgrColor
       } Else
       {
          TextInAreaFontColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, TextInAreaFontColor
       }
    }
}

tlbrCutImg() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      MenuExplorerCutFiles()
      Return "m"
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      CutSelectedArea()
}

tlbrMoveFiles() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelMoveCopyFiles()
}

tlbrClonerBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(3, "e")
      Else
         toggleBrushTypeCloner()
   }
}

tlbrMainBrushSoft() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(2, "e")
      Else
         togglePresetsBrushes(4)
   }
}

tlbrMainBrushHard() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(1, "e")
      Else
         togglePresetsBrushes(5)
   }
}

tlbrFXbrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(5, "fx")
      Else
         togglePresetsBrushes(2)
   }
}

tlbrWetBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
      {
         PanelBrushTool(2, "w")
      } Else
      {
         GetPhysicalCursorPos(oX, oY)
         While, (determineLClickstate()=1)
         {
            GetPhysicalCursorPos(mX, mY)
            dir := (oY<mY) ? -1 : 1
            If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
               Continue

            cX := mX, cY := mY
            togglePresetsBrushes(3, dir)
            Sleep, 150
         }
      }
   }
}

tlbrDecreaseWetBrush() {
   If (isImgEditingNow()=1 && AnyWindowOpen!=64)
      togglePresetsBrushes(3, -1)
}

tlbrChangeOSDfontSize() {
   If !AnyWindowOpen
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeOSDfontSize(dir)
         Sleep, 100
      }
   }
}

tlbrDecreaseOSDfontSize() {
   If !AnyWindowOpen
      changeOSDfontSize(-1)
}

tlbrChangeBrushSoft() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64 && BrushToolType!=1)
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeBrushSoftness(dir)
         Sleep, 100
      }
   }
}

tlbrDecreaseBrushSoft() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64 && BrushToolType!=1)
      changeBrushSoftness(-1)
}

tlbrChangeBrushOpacity() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? 1 : -1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeBrushOpacity(dir, 0)
         Sleep, 150
      }
   }
}

tlbrDecreaseBrushOpacity() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
      changeBrushOpacity(-1, 0)
}

tlbrChangeBrushSize() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeBrushSize(dir)
         Sleep, % (brushToolSize<50) ? 150 : 50
      }
   }
}

tlbrChangeBrushAngle() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeBrushRatioAngle(dir, 2)
         Sleep, 100
      }
   }
}

tlbrChangeBrushRatio() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
   {
      GetPhysicalCursorPos(oX, oY)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue

         cX := mX, cY := mY
         changeBrushRatioAngle(dir, 1)
         Sleep, 100
      }
   }
}

tlbrEraserBrush() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      DeletePicture()
   } Else If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(4, "e")
      Else
         toggleBrushTypeEraser()
   }
}

tlbrBlurBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
      {
         PanelBrushTool(5, "b")
      } Else
      {
         GetPhysicalCursorPos(oX, oY)
         While, (determineLClickstate()=1 || A_Index=1)
         {
            GetPhysicalCursorPos(mX, mY)
            dir := (oY<mY) ? -1 : 1
            If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
               Continue

            cX := mX, cY := mY
            togglePresetsBrushes(1, dir)
            Sleep, 150
         }
      }
   }
}

tlbrPenFill() {
   If isImgEditingNow()
   {
      MenuStartDrawingShapes("draw")
      Return "m"
   }
}

tlbrPenOutline() {
   If isImgEditingNow()
   {
      MenuStartDrawingLines("draw")
      Return "m"
   }
}

tlbrPipette() {
   ; If (isImgEditingNow()=1 && AnyWindowOpen=64)
   If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen)
      changeBrushColorPicker()
}

tlbrSwitchColors() {
   ; If isImgEditingNow()
   If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen)
      ToggleBrushColors()
}

tlbrCropImg() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      PanelSimpleResizeRotate()
   } Else If isImgEditingNow()
   {
      If (editingSelectionNow=1)
         CropImageInViewPortToSelection()
      Else If !AnyWindowOpen
         PanelAdjustImageCanvasSize()
   }
}

tlbrViewPortGridu() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      toggleListViewModeThumbs()
   Else
      toggleViewPortGridu()
}

tlbrConfigVPgrid() {
   If (isImgEditingNow()=1 && !AnyWindowOpen)
      PanelConfigVPgrid()
}

tlbrResizeImage() {
   If (isImgEditingNow()=1 && editingSelectionNow!=1)
      ToggleEditImgSelection()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      ResizeIMGviewportSelection()
}

tlbrRotateImg() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      filesListFlipRotatePlus()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      vPselRotation := clampInRange(Round(vPselRotation + 45), 0, 360 - 41, 1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
      SetTimer, dummyShowSelCoordsInfos, -20
   } Else If (isImgEditingNow()=1)
   {
      vpIMGrotation :=  clampInRange(Round(vpIMGrotation + 45), 0, 360 - 41, 1)
      dummyChangeVProtation()
      SetTimer, RefreshImageFile, -750
   }
}

tlbrResetRotation() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      filesListFlipRotateMinus()
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1 && vPselRotation!=0)
   {
      vPselRotation := 0
      SetTimer, dummyRefreshImgSelectionWindow, -10
      SetTimer, dummyShowSelCoordsInfos, -20
   } Else If (isImgEditingNow()=1 && vpIMGrotation!=0)
      changeImgRotationInVP(1, 45, 1)
}

tlbrTransformSelection() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      importEditGivenImageFile()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1 && !AnyWindowOpen)
      PanelTransformSelectedArea()
}

tlbrOpenImg() {
   If !AnyWindowOpen
      OpenDialogFiles()
   Return "m"
}

tlbrOpenMenu() {
   If !AnyWindowOpen
      InvokeOpenRecentMenu()
   Return "m"
}

tlbrBlurArea() {
   If (isImgEditingNow()=1 && !AnyWindowOpen)
      PanelBlurSelectedArea()
}

tlbrSaveImg() {
   If (isImgEditingNow()=1 && !AnyWindowOpen)
      PanelSaveImg()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSaveSlideShowu()
}

tlbrOpenAnnotations(){
   imgPath := getIDimage(currentFileIndex)
   If (isImgEditingNow()=1 && FileExist(imgPath) && !AnyWindowOpen)
      PanelEditImgCaption()
}

tlbrOpenVPcolors(){
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSetThumbColumnOptions()
   Else If (isImgEditingNow()=1 && (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen=10))
      PanelColorsAdjusterWindow()
}

tlbrFlipSelectionH() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      VPflipImgH()
   Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1)
      flipWHcustomShape("H")
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      VPflipImgH()
}

tlbrFlipSelectionV() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      VPflipImgV()
   Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1)
      flipWHcustomShape("V")
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      VPflipImgV()
}

tlbrFlipStuffH(){
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      filesListFlipHimage()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      FlipSelectedAreaH()
   Else If (isImgEditingNow()=1)
      VPflipImgH()
}

tlbrFlipStuffV(){
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      filesListFlipVimage()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      FlipSelectedAreaV()
   Else If (isImgEditingNow()=1)
      VPflipImgV()
}

tlbrFillShape() {
   If (isImgEditingNow()=1 && AnyWindowOpen=23)
   {
      UIcycleFillShapes()
   } Else If (isImgEditingNow()=1)
   {
      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelFillSelectedArea("tlbr", FillAreaShape)
   }
}

tlbrOutlineShape() {
   If (isImgEditingNow()=1 && AnyWindowOpen=65)
   {
      UIcycleFillShapes()
   } Else If (isImgEditingNow()=1)
   {
      If (editingSelectionNow!=1)
         ToggleEditImgSelection()

      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelDrawShapesInArea("tlbr", FillAreaShape)
   }
}

tlbrOpenLinesPanel() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelDrawLines()
}

tlbrZoomIN() {
   If (thumbsDisplaying=1 && maxFilesIndex>3 && CurrentSLD)
   || (isImgEditingNow()=1)
   {
      GetPhysicalCursorPos(oX, oY)
      cX := 0, cY := 0
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
         {
            ; oX := cX, oY := cY
            Continue
         }

         cX := mX, cY := mY
         ChangeZoom(dir) 
         Sleep, % (thumbsDisplaying=1) ? 10 : 1
      }
   }
   Return "m"
}

tlbrZoomToggle() {
   If (thumbsDisplaying=1 && maxFilesIndex>3 && CurrentSLD)
      ToggleThumbsAratio()
   Else If (isImgEditingNow()=1)
      ToggleImageSizingMode()
}

tlbrPasteQuick() {
   If (thumbsDisplaying=1)
      MenuPasteHDropFiles()
   Else If (isImgEditingNow()=1)
      PasteClipboardIMG()
}

tlbrDropSelection() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) 
   {
      deleteMenus()
      createMenuFilesSelections()
      showThisMenu("PVfileSel")
      Return "m"
   } Else If (isImgEditingNow()=1)
   {
      ToggleEditImgSelection() 
   }
}

tlbrSelectShape() {
   Static shape := 0, prevHwnd
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      markThisFileNow()
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      toggleEllipseSelection()
      ; ToolTip, % EllipseSelectMode "=" hwnd "=" paramu , , , 2
   } Else If (isImgEditingNow()=1)
   {
      ToggleEditImgSelection()
   }
}

decideIconBTNselectShape() {
   initialIcon := tlbrIconzList["BTNselectShape", 2]
   thisHwnd := tlbrIconzList["BTNselectShape", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
   If (thumbsDisplaying=1)
      icoFile := "select-rect"
   Else If (EllipseSelectMode=2)
      icoFile := "select-freeform"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNselectShape", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}


decideIconBTNthumbsList() {
   initialIcon := tlbrIconzList["BTNthumbsList", 2]
   thisHwnd := tlbrIconzList["BTNthumbsList", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]

   If (thumbsListViewMode=1)
      icoFile := "thumbs-list"
   Else If (thumbsListViewMode=2)
      icoFile := "files-list-simple"
   Else ; If (thumbsListViewMode>=3)
      icoFile := "files-list-details"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNthumbsList", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNmainTooler() {
   initialIcon := tlbrIconzList["BTNmainTooler", 2]
   thisHwnd := tlbrIconzList["BTNmainTooler", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (AnyWindowOpen && imgEditPanelOpened=1) ? "main-tool" : "go-back"
   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNmainTooler", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNpaintBrushSelect() {
   initialIcon := tlbrIconzList["BTNpaintSelection", 2]
   thisHwnd := tlbrIconzList["BTNpaintSelection", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
   If (BrushToolOutsideSelection=3)
      icoFile := "paint-outside"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNpaintSelection", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

tlbrtoggleBrushDrawModes() {
   If (isImgEditingNow()=1 && AnyWindowOpen=64)
      toggleBrushDrawInOutModes()
      ; ToolTip, % EllipseSelectMode "=" hwnd "=" paramu , , , 2
}

tlbrSaveList() {
   If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSaveSlideShowu()
}

tlbrSelectFreeform() {
   If isImgEditingNow()
   {
      If (editingSelectionNow!=1 || EllipseSelectMode!=2)
         MenuStartDrawingSelectionArea()
      Else
         MenuResumeDrawingShapes()
      Return "m"
   }
}

tlbrInvokeShapesMenu() {
   If isImgEditingNow()
   {
      deleteMenus()
      createMenuSelectSizeShapes()
      showThisMenu("PVselSize")
      Return "m"
   }
}

tlbrUndoAction() {
   If isImgEditingNow()
   {
      While, (determineLClickstate()=1 || A_Index=1)
      {
         ImgUndoAction()
         Sleep, % (A_Index<10) ? 200 : 90
      }
   }
}

tlbrPanIMG() {
   If (isImgEditingNow()=1 && IMGlargerViewPort=1)
   {
      IMGresizingMode := 4
      simplePanIMGonClick()
   }
}

tlbrCloseWindow() {
   If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      ToggleThumbsMode()
   Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
      BtnCloseWindow()
}

tlbrApplyImgEditFunc() {
   If (isImgEditingNow()=1 && imgEditPanelOpened=1)
      applyIMGeditFunction()
   Else If !AnyWindowOpen
      openPreviousPanel()
}

tlbrRedoAction() {
   If isImgEditingNow()
   {
      While, (determineLClickstate()=1 || A_Index=1)
      {
         ImgRedoAction()
         Sleep, % (A_Index<10) ? 200 : 90
      }
   }
}

tlbrNewImage() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      addNewFile2list()
   Else If !AnyWindowOpen
      PanelNewImage()
}

tlbrAcquireimage() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      addNewFolder2list()
   Else If !AnyWindowOpen
      AcquireWIAimage()
}

invokeSortListMenu(){
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      deleteMenus()
      createMenuFilesSort()
      showThisMenu("PVsort")
      Return "m"
   }
}

CoreGUItoolbar() {
    Static BTNrotateTlbr := ["rotate-tlbr", "TLBRswitchAlign", "Toggle vertical or horizontal toolbar alignment", "BTNrotateTlbr"]
         , BTNdragTlbr := ["dragger", "TLBRdraggyNow", "Reposition toolbar", "invokeTlbrContextMenu", "BTNdragTlbr"]
         , BTNcloseTlbr := ["close", "toggleAppToolbar", "Close toolbar", 0, "BTNcloseTlbr"]
         , BTNsettings := ["menu", "tlbrInvokeEditMenu", "Quick settings menu", "OpenUImenu", "BTNsettings"]
         , BTNcopyImg := ["copy", "MenuCopyAction", "Copy to clipboard", "CopyImagePath", "BTNcopyImg"]
         , BTNnewImg := ["new-image", "tlbrNewImage", "New image", "tlbrAcquireimage", "BTNnewImg"]
         , BTNpasteImg := ["paste-clip", "tlbrPasteQuick", "Paste from clipboard", "PanelPasteInPlace", "BTNpasteImg"]
         , BTNundoImg := ["undo", "tlbrUndoAction", "Undo image action", "ImgSelUndoAct", "BTNundoImg"]
         , BTNredoImg := ["redo", "tlbrRedoAction", "Redo image action", "ImgSelRedoAct", "BTNredoImg"]
         , BTNtextTool := ["add-text", "tlbrInsertTextArea", "Insert text into image", "tlbrOpenAnnotations", "BTNtextTool"]
         , BTNeraserTool := ["eraser", "tlbrEraserBrush", "Eraser brush", "tlbrEraserTool", "BTNeraserTool"]
         , BTNblurTool := ["brush-blur", "tlbrBlurBrush", "Blur brush", "tlbrBlurArea", "BTNblurTool"]
         , BTNclonerTool := ["brush-cloner", "tlbrClonerBrush", "Cloner brush", "BtnSetClonerBrushSource", "BTNclonerTool"]
         , BTNbrushMtool := ["brush-main", "tlbrMainBrushSoft", "Brush tool", "tlbrMainBrushHard", "BTNbrushMtool"]
         , BTNFXbrush := ["brush-fx", "tlbrFXbrush", "Color effects soft brush", 0, "BTNFXbrush"]
         , BTNwetbrush := ["brush-wet", "tlbrWetBrush", "Soft edges wet Brush", "tlbrDecreaseWetBrush", "BTNwetbrush"]
         , BTNpenVector := ["pen-vector", "tlbrPenFill", "Draw freeform shape", "tlbrPenOutline", "BTNpenVector"]
         , BTNpipette := ["pipette", "tlbrPipette", "Pick color", "tlbrSwitchColors", "BTNpipette"]
         , BTNcolorsSwatch := ["colorz-swatch", "tlbrActColorsSwatch", "Choose colors", "tlbrSwitchColors", "BTNcolorsSwatch"]
         , BTNcrop := ["crop", "tlbrCropImg", "Crop image to selection", "tlbrResizeImage", "BTNcrop"]
         , BTNsave := ["save-disk", "tlbrSaveImg", "Save image to disk", "tlbrSaveList", "BTNsave"]
         , BTNopen := ["open", "tlbrOpenImg", "Open image", "tlbrOpenMenu", "BTNopen"]
         , BTNcutImg := ["cut", "tlbrCutImg", "Cut selection", "tlbrMoveFiles", "BTNcutImg"]
         , BTNadjustColors := ["adjust-colors", "tlbrOpenVPcolors", "Adjust viewport colors", "ResetImageView", "BTNadjustColors"]
         , BTNtlbrflipH := ["flip-h", "tlbrFlipStuffH", "Flip horizontally", "tlbrFlipSelectionH", "BTNtlbrflipH"]
         , BTNtlbrflipV := ["flip-v", "tlbrFlipStuffV", "Flip vertically", "tlbrFlipSelectionV", "BTNtlbrflipV"]
         , BTNtransformArea := ["transform-img", "tlbrTransformSelection", "Transform selected area", 0, "BTNtransformArea"]
         , BTNrotateStuff := ["rotation", "tlbrRotateImg", "Rotate by 45 degrees", "tlbrResetRotation", "BTNrotateStuff"]
         , BTNfillShape := ["fill-shape", "tlbrFillShape", "Fill selection area", 0, "BTNfillShape"]
         , BTNoutlineShape := ["outline-shape", "tlbrOutlineShape", "Draw shape contours", "tlbrOpenLinesPanel", "BTNoutlineShape"]
         , BTNselectShape := ["select-rect", "tlbrSelectShape", "Create selection area", "tlbrDropSelection", "BTNselectShape"]
         , BTNselectFreeform := ["create-freeform", "tlbrSelectFreeform", "Create freeform selection", "tlbrInvokeShapesMenu", "BTNselectFreeform"]
         , BTNloupe := ["loupe", "tlbrZoomIN", "Zoom in / out", "tlbrZoomToggle", "BTNloupe"]
         , BTNpreviewBox := ["view", "ToggleImgNavBox", "Toggle image preview", "ToggleImgNavSizeBox", "BTNpreviewBox"]
         , BTNsearch := ["search", "PanelSearchIndex", "Search", "PanelSearchAndReplaceIndex", "BTNsearch"]
         , BTNmodifyEntry := ["modify-entry", "PanelRenameThisFile", "Rename file[s]", "PanelUpdateThisFileIndex", "BTNmodifyEntry"]
         , BTNfilterList := ["filter", "PanelEnableFilesFilter", "Filter files list", "MenuRemFilesListFilter", "BTNfilterList"]
         , BTNstatsList := ["statistics", "PanelWrapperFilesStats", "Indexed files statistics", "PanelFindDupes", "BTNstatsList"]
         , BTNsortList := ["sort-list", "invokeSortListMenu", "Sort files list", 0, "BTNsortList"]
         , BTNrefreshList := ["refresh", "RefreshFilesList", "Refresh files list", "DeepRefreshThumbsNow", "BTNrefreshList"]
         , BTNfolderTree := ["folder-tree", "MenuPanelFoldersTree", "Folder tree view", "invokeFoldersListerMenu", "BTNfolderTree"]
         , BTNinfozHud := ["infos", "ToggleInfoBoxu", "Show image information", "PanelImageInfos", "BTNinfozHud"]
         , BTNmngFolderz := ["manage-folders", "PanelDynamicFolderzWindow", "Manage folders", "PanelStaticFolderzManager", "BTNmngFolderz"]
         , BTNfntSize := ["font-size", "tlbrChangeOSDfontSize", "Change OSD font size", "tlbrDecreaseOSDfontSize", "BTNfntSize"]
         , BTNfaves := ["star", "ToggleImgFavourites", "Add/remove from favourites", "InvokeFavesMenu", "BTNfaves"]
         , BTNpanImg := ["pan-img", "tlbrPanIMG", "Pan image in viewport", "ToggleImgNavBox", "BTNpanImg"]
         , BTNmainTooler := ["main-tool", "tlbrApplyImgEditFunc", "Apply current tool and deactivate it", "tlbrCloseWindow", "BTNmainTooler"]
         , BTNplaySlides := ["play", "tlbrPlaySlides", "Play slideshow", "PanelDefineEntireSlideshowLength", "BTNplaySlides"]
         , BTNchangeBrushSoft := ["brush-set-soft", "tlbrChangeBrushSoft", "Change brush softness", "tlbrDecreaseBrushSoft", "BTNchangeBrushSoft"]
         , BTNchangeBrushOpacity := ["brush-set-opacity", "tlbrChangeBrushOpacity", "Change brush opacity", "tlbrDecreaseBrushOpacity", "BTNchangeBrushOpacity"]
         , BTNchangeBrushSize := ["brush-set-size", "tlbrChangeBrushSize", "Change brush size", "toggleBrushDoubleSize", "BTNchangeBrushSize"]
         , BTNchangeBrushAngle := ["brush-set-angle", "tlbrChangeBrushAngle", "Change brush angle", "toggleBrushMouseAngle", "BTNchangeBrushAngle"]
         , BTNchangeBrushRatio := ["brush-set-ratio", "tlbrChangeBrushRatio", "Change brush ratio", "resetBrushAsRatio", "BTNchangeBrushRatio"]
         , BTNpaintSelection := ["paint-outside", "tlbrtoggleBrushDrawModes", "Toggle brush selection area mode", 0, "BTNpaintSelection"]
         , BTNvpGrid := ["vp-grid", "tlbrViewPortGridu", "Viewport grid", "tlbrConfigVPgrid", "BTNvpGrid"]
         , BTNthumbsList := ["thumbs-list", "tlbrViewPortGridu", "Viewport grid", "ToggleIMGalign", "BTNthumbsList"]
         , prevState := 0

    BTNmainTooler[1] := (AnyWindowOpen && imgEditPanelOpened=1) ? "main-tool" : "go-back"
    icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
    If (BrushToolOutsideSelection=3)
       icoFile := "paint-outside"
    BTNpaintSelection[1] := icoFile

    icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
    If (thumbsDisplaying=1)
       icoFile := "select-rect"
    Else If (EllipseSelectMode=2)
       icoFile := "select-freeform"
    BTNselectShape[1] := icoFile

   If (thumbsListViewMode=1)
      friendly := "thumbs-list"
   Else If (thumbsListViewMode=2)
      friendly := "files-list-simple"
   Else If (thumbsListViewMode>=3)
      friendly := "files-list-details"
    BTNthumbsList[1] := friendly

    TlbrGuiMarginH := ToolBarBtnWidth//5
    TlbrGuiMarginV := TlbrGuiMarginH
    IconSpacing := (TLBRverticalAlign=1) ? TlbrGuiMarginH//1.3 : TlbrGuiMarginH//1.3
    handleWidth := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth//2
    handleHeight := (TLBRverticalAlign=1) ? ToolBarBtnWidth//3 : ToolBarBtnWidth + IconSpacing*2
    handleClrW := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth
    handleClrH := (TLBRverticalAlign=1) ? ToolBarBtnWidth : ToolBarBtnWidth + IconSpacing*2
    If (TLBRtwoColumns=1)
    {
       handleWidth := handleWidth*2 - IconSpacing
       handleClrW := handleWidth - IconSpacing*2
       handleClrH += IconSpacing
       handleHeight := Round(handleHeight*1.5)
    } Else If (TLBRverticalAlign!=1)
    {
       handleClrW := handleClrW*2 + IconSpacing*3
    } Else If (TLBRverticalAlign=1)
       handleClrH := handleClrH - Ceil(IconSpacing*2.5)

    totalIconz := 32
    TouchToolbarGUIcreated := 1
    thisState := "a" ToolBarBtnWidth totalIconz TLBRverticalAlign ToolbarScaleFactor TLBRtwoColumns 
    simpleRefresh := (thisState=prevState) ? 1 : 0
    If (simpleRefresh=0)
    {
       Gui, OSDguiToolbar: Destroy
       Sleep, 10
       Gui, OSDguiToolbar: Default
       Gui, OSDguiToolbar: Margin, 0, 0
       Gui, OSDguiToolbar: -DPIScale -Caption +ToolWindow +hwndhQPVtoolbar +Owner%PVhwnd%
       Gui, OSDguiToolbar: Color, % ToolbarBgrColor, % ToolbarBgrColor
    }
    ; Gui, OSDguiToolbar: Font, s1

    tlbrAddNewIcon(BTNdragTlbr, handleWidth, handleHeight, 0, 1, simpleRefresh)
    tlbrAddNewIcon(BTNsettings, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNmainTooler, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    If (thumbsDisplaying=1)
    {
       tlbrAddNewIcon(BTNplaySlides, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNfntSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else
    {
       tlbrAddNewIcon(BTNundoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNredoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }
    If (AnyWindowOpen=64)
    {
       tlbrAddNewIcon(BTNchangeBrushSoft, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNchangeBrushOpacity, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNchangeBrushSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNchangeBrushAngle, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNchangeBrushRatio, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNpaintSelection, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else
    {
       tlbrAddNewIcon(BTNopen, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNsave, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNcutImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNcopyImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNpasteImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNnewImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    tlbrAddNewIcon(BTNcrop, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNselectShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    If (thumbsDisplaying!=1)
    {
       tlbrAddNewIcon(BTNselectFreeform, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNfillShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNoutlineShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNpipette, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNbrushMtool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNFXbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNwetbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNblurTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNclonerTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else
    {
       tlbrAddNewIcon(BTNfaves, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNmngFolderz, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNsearch, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNmodifyEntry, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNfilterList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNstatsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNsortList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNrefreshList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNfolderTree, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    tlbrAddNewIcon(BTNeraserTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    If (thumbsDisplaying=1)
       tlbrAddNewIcon(BTNinfozHud, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    Else
       tlbrAddNewIcon(BTNpenVector, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

    tlbrAddNewIcon(BTNtextTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNtlbrflipV, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNtlbrflipH, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNtransformArea, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNrotateStuff, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNadjustColors, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNloupe, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    If (thumbsDisplaying=1)
    {
       tlbrAddNewIcon(BTNthumbsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNpreviewBox, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else
    {
       tlbrAddNewIcon(BTNvpGrid, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNpanImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    tlbrAddNewIcon(BTNcolorsSwatch, handleClrW, handleClrH, 0, 0, simpleRefresh)
    ; tlbrAddNewIcon(BTNrotateTlbr, handleWidth, handleHeight, 0)
    toolbarY := UserToolbarY, toolbarX := UserToolbarX
    todisplay := (ShowAdvToolbar=1) ? "" : "hide"
    prevState := thisState
    If (simpleRefresh=0)
       Gui, OSDguiToolbar: Show, x0 y0 AutoSize, QPV toolbar

    ; Sleep, 1
    ; Gui, OSDguiToolbar: Show, %todisplay% x%toolbarX% y%toolbarY%, QPV toolbar
    ; adjustWin2MonLimits(hQPVtoolbar, toolbarX, toolbarY, rX, rY, tlbrWid, tlbrHeig)
    ; Gui, OSDguiToolbar: Show, %todisplay% x%rX% y%rY%, QPV toolbar
    ; WinSet, AlwaysOnTop, On, QPVadvToolbar
    ; ToolTip, % tlbrIconzList[2,1] "=" tlbrIconzList[2,4] , , , 2
    ; If (ToolbarOpacity<250)
    ; WinSet, Transparent, %ToolbarOpacity%, ahk_id %hQPVtoolbar%
    ; WinSet, Style, +0x40000, ahk_id %hQPVtoolbar%
}

createGUItoolbar(dummy:=0) {
   Static prevState, hasEverDisplayed
   If (ShowAdvToolbar=0)
   {
      interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
      If (TouchToolbarGUIcreated=1)
         Gui, OSDguiToolbar: Hide
      Return
   }

   If !hasEverDisplayed
   {
      ; GetPhysicalCursorPos(UserToolbarX, UserToolbarY)
      JEE_ClientToScreen(hPicOnGui1, 1, 1, UserToolbarX, UserToolbarY)
      UserToolbarX--
      UserToolbarY--
      hasEverDisplayed := 1
   }
   INIaction(0, "TLBRverticalAlign", "General", 1)
   ; INIaction(0, "ToolBarBtnWidth", "General", 2, 16, 512)
   INIaction(0, "ToolbarScaleFactor", "General", 2, 0.2, 5)
   INIaction(0, "TLBRtwoColumns", "General", 1)
   INIaction(0, "BrushToolAcolor", "General")
   INIaction(0, "BrushToolBcolor", "General")
   INIaction(0, "BrushToolUseSecondaryColor", "General")

   isPaintPanel := (AnyWindowOpen=64) ? 1 : 0
   ToolBarBtnWidth := Round(OSDfntSize*1.5 * ToolbarScaleFactor)
   currState := "a" ToolBarBtnWidth TLBRverticalAlign TLBRtwoColumns isPaintPanel thumbsDisplaying
   ; msgbox, %currstateSimple%`n%prevStateSimple%
   If (prevState!=currState || dummy="forced")
   {
      TouchToolbarGUIcreated := 0
      CoreGUItoolbar()
      prevState := currState
   }

   interfaceThread.ahkassign("hQPVtoolbar", hQPVtoolbar)
   interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
   If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
   {
      thisOpacity := ToolbarOpacity
      If (AnyWindowOpen && imgEditPanelOpened!=1 || drawingShapeNow=1 || slideShowRunning=1 || AnyWindowOpen=24 || AnyWindowOpen=31)
         thisOpacity := 100

      Sleep, 1
      ; WinMove, ahk_id %hQPVtoolbar%,, 100, 100
      WinSet, Transparent, %thisOpacity%, ahk_id %hQPVtoolbar%
      Gui, OSDguiToolbar: Show, NoActivate x%UserToolbarX% y%UserToolbarY%, QPV toolbar
      whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
      WinActivate, ahk_id %whichWin%
   } Else If (ShowAdvToolbar=0)
   {
      Gui, OSDguiToolbar: Hide
   }

   WinGetPos, , , ToolbarWinW, ToolbarWinH, ahk_id %hQPVtoolbar%
}

tlbrResetPosition() {
  JEE_ClientToScreen(hPicOnGui1, 1, 1, UserToolbarX, UserToolbarY)
  UserToolbarX--
  UserToolbarY--
  Gui, OSDguiToolbar: Show, NoActivate x%UserToolbarX% y%UserToolbarY%, QPV toolbar
  Return "m"
}

tlbrDecideTooltips(hwnd) {
   icoFile := tlbrIconzList[hwnd, 2]
   btnID := tlbrIconzList[hwnd, 10]
   f := (markedSelectFile>1) ? "s" : ""
   If InStr(icoFile, "dragger")
   {
      msgu := "L: Reposition toolbar`nR: Toolbar options menu"
   } Else If InStr(icoFile, "menu")
   {
      msgu :=  (thumbsDisplaying=1) ? "L: Quick actions menu [Shift + AppsKey]`nR: Interface options menu" : "L: Edit image menu`nR: Interface options menu"
   } Else If InStr(icoFile, "copy")
   {
      friendly := (editingSelectionNow=1) ? "selection area " : ""
      msgu :=  (thumbsDisplaying=1) ? "L: Copy file" f " to... [C]`nR: Copy file" f " path" f " [Ctrl + Shift + C]" : "L: Copy image " friendly "to clipboard [Ctrl + C]`nR: Copy file" f " path" f " [Ctrl + Shift + C]"
   } Else If InStr(icoFile, "new-image")
   {
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu :="L: Import list or insert file[s] into list [Insert]`nR: Add folder[s] into current list [Shift + Insert]"
      Else
         msgu :="L: Create new image [Ctrl + N]`nR: Acquire image from scanner"
   } Else If InStr(icoFile, "paste-clip")
   {
      msgu := (thumbsDisplaying=1) ? "Paste files from clipboard into current list [Ctrl + V]" : "L: Paste image from clipboard [Ctrl + V]`nR: Paste into selection area [Ctrl + Shift + V]"
   } Else If InStr(icoFile, "undo")
   {
      msgu := "L: Undo image [Ctrl + Z]`nR: Undo selection area [Ctrl + Shift + Z]"
   } Else If InStr(icoFile, "redo")
   {
      msgu := "L: Redo image [Ctrl + Y]`nR: Redo selection area [Ctrl + Shift + Y]"
   } Else If InStr(icoFile, "add-text")
   {
      msgu := (thumbsDisplaying=1) ? "Edit image caption [Shift + N]" : "L: Insert text into image [Shift + T]`nR: Edit image caption [Shift + N]"
   } Else If InStr(icoFile, "eraser")
   {
      keyu := (AnyWindowOpen=64) ? " [R]" : ""
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L; Delete file" f " [Delete]`nR: Remove focused index entry [Alt + Delete]" : "L: Eraser - soft brush" keyu
      If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu .= "`nR: Erase or fade image selected area [Delete]"
   } Else If InStr(icoFile, "brush-blur")
   {
      msgu := "Blur - soft brush: " BrushToolBlurStrength "%"
   } Else If InStr(icoFile, "brush-cloner")
   {
      keyu := (AnyWindowOpen=64) ? " [J]" : ""
      keyu2 := (AnyWindowOpen=64) ? " [D]" : ""
      friendly := (AnyWindowOpen=64 && BrushToolType=3) ? "Toggle dynamic cloner source coordinates" : "Cloner - soft brush"
      msgu := "L: " friendly keyu "`nR: Define cloner source" keyu2
   } Else If InStr(icoFile, "brush-main")
   {
      keyu := (AnyWindowOpen=64) ? " [B]" : " [P]"
      msgu := "L: Soft paint brush" keyu "`nR: Hard paint brush" keyu
   } Else If InStr(icoFile, "brush-fx")
   {
      keyu := (AnyWindowOpen=64) ? " [Q]" : ""
      msgu := "Color effects - soft brush" keyu
   } Else If InStr(icoFile, "brush-wet")
   {
      msgu := "Soft wet brush: " BrushToolWetness
   } Else If InStr(icoFile, "pen-vector")
   {
      msgu := "L: Draw freeform filled shape [Shift + P]`nR: Draw freeform poly or curve line [Alt + P]"
   } Else If InStr(icoFile, "pipette")
   {
      keyu := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [C]" : ""
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [X]" : ""
      msgu := "L: Pick color" keyu "`nR: Switch primary / secondary color" keyu2
   } Else If InStr(icoFile, "colorz-swatch")
   {
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [X]" : ""
      msgu := "L: Choose color`nR: Switch primary / secondary color" keyu2
   } Else If InStr(icoFile, "crop")
   {
      If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu := "L: Crop image to selection area [Shift + Enter]`nR: Resize image to selection area [Alt + R]"
      Else
         msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "Resize / crop / rotate image" f " [Ctrl + R]" : "Adjust image canvas size [Alt + A]"
   } Else If InStr(icoFile, "save-disk")
   {
      msgu := (thumbsDisplaying=1) ? "Save files list [Ctrl + S]" : "L: Save image to disk [Ctrl + S]`nR: Save files list [Ctrl + Shift + S]"
   } Else If InStr(icoFile, "open")
   {
      msgu := "L: Open image or folder dialog [Ctrl + O]`nR: Recents menu"
   } Else If InStr(icoFile, "cut")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L: Cut file" f " (Explorer mode) [Ctrl + X]`nR: Move file" f " to.. [M]" : "Cut image selected area [Ctrl + X]"
   } Else If InStr(icoFile, "adjust-colors")
   {
      msgu := "L: Adjust viewport colors and more [U]`nR: Reset viewport adjustments [ \ ]"
   } Else If InStr(icoFile, "transform-img")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "Import selected image into currently opened one" : "Transform image selected area [Ctrl + T]"
   } Else If InStr(icoFile, "flip-h")
   {
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip horizontally [Shift + H]"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu := "Image selected area - flip horizontally [Shift + H]"
      Else If (isImgEditingNow()=1)
         msgu := "Viewport - flip horizontally [H]"
      Else
         msgu := "Flip horizontally"

      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu2 := "Viewport - flip horizontally [H]"
      Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1)
         msgu2 := "Freeform selection shape - flip horizontally"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu2 := "Viewport - flip horizontally [H]"

      If msgu2
         msgu := "L: " msgu "`nR: " msgu2
   } Else If InStr(icoFile, "flip-v")
   {
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip vertically [Shift + V]"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu := "Image selected area - flip vertically [Shift + V]"
      Else If (isImgEditingNow()=1)
         msgu := "Viewport - flip vertically [V]"
      Else
         msgu := "Flip vertically"

      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu2 := "Viewport - flip vertically [V]"
      Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1)
         msgu2 := "Freeform selection shape - flip vertically"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu2 := "Viewport - flip vertically [V]"

       If msgu2
          msgu := "L: " msgu "`nR: " msgu2 
   } Else If InStr(icoFile, "rotation")
   {
      friendly := (editingSelectionNow=1) ? "L: Image selection area" : "L: Viewport"
      keyu := (editingSelectionNow=1) ? " [Shift + R]" : " [9, 0]"
      keyu2 := (editingSelectionNow=1) ? " [Shift + \]" : " [\]"
      msgu := friendly " - rotate by 45 degrees" keyu "`nR: Reset rotation" keyu2
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "L: Rotate image file by +90° [Shift + 0]`nR: Rotate image file by -90° [Shift + 9]"
   } Else If InStr(icoFile, "fill-shape")
   {
      msgu := (AnyWindowOpen=23)? "Cycle through shapes - fill selection area [Alt + BackSpace]" : "Fill selection area [Alt + Backspace]"
   } Else If InStr(icoFile, "outline-shape")
   {
      msgu := (AnyWindowOpen=65) ? "Cycle through shapes - draw shape contours" : "L: Draw shape contours`nR: Draw simple predefined selection area related lines [Ctrl + L]"
   } Else If (btnID="BTNselectShape")
   {
      friendly := (editingSelectionNow=1) ? "Cycle selection area types [Shift + E]" : "Create image selection area [E]"
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu :=  "L: Select / deselect focused index entry [Tab]`nR: Files selection options menu"
      Else
         msgu := (editingSelectionNow=1 && isImgEditingNow()=1) ? "L: " friendly "`nR: Toggle image selection area [E]" : friendly
   } Else If InStr(icoFile, "create-freeform")
   {
      friendly := (editingSelectionNow!=1 || EllipseSelectMode!=2) ? "Create new" : "Modify"
      msgu := "L: " friendly " freeform selection area [Shift + L]`nR: Selection area shapes options menu"
   } Else If InStr(icoFile, "loupe")
   {
      friendly := (thumbsDisplaying=1) ? "Cycle thumbnails aspect ratios" : "Cycle adapt image to window modes"
      friendly2 := (thumbsDisplaying=1) ? "thumbnails" : "image"
      msgu := "L: Zoom in / out " friendly2 " [-, =]`nR: " friendly " [T]"
   } Else If InStr(icoFile, "pan-img")
   {
      msgu := "L: Pan image in viewport`nR: Toggle image navigator [Z]"
   } Else If (btnID="BTNmainTooler")
   {
      friendly := (thumbsDisplaying=1) ? "image view [Enter]" : defineListViewModes() " list mode [Enter]"
      msgu := !AnyWindowOpen ? "L: Open previous panel [F8]`nR: Switch to " friendly : "L: Apply current tool and deactivate it [Enter]`nR: Abandon current tool [Escape]"
   } Else If InStr(icoFile, "brush-set-soft")
   {
      msgu := "Change brush softness: " BrushToolSoftness "% [Shift + [, Shift + ]]"
   } Else If InStr(icoFile, "brush-set-opacity")
   {
      thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      msgu := "Change brush opacity: " Round((thisOpacity / 255) * 100) "% [ 0 - 9 ]"
   } Else If InStr(icoFile, "brush-set-size")
   {
      friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
      friendly2 := (brushToolDoubleSize!=1) ? "RADIUS" : "DIAMETER"
      msgu := "L: Change brush " friendly ": " brushToolSize " px [ [, ] ] `nR: Switch to setting the " friendly2 " [D]"
   } Else If InStr(icoFile, "brush-set-angle")
   {
      If (BrushToolAutoAngle=1)
         msgu := "Deactivate mouse movements based angle for the brush"
      Else
         msgu := "L: Change brush angle: " BrushToolAngle "°`nR: Activate mouse movements based angle"
   } Else If InStr(icoFile, "brush-set-ratio")
   {
      msgu := "L: Change brush aspect ratio:" BrushToolAspectRatio "`nR: Reset brush aspect ratio"
   } Else If (btnID="BTNpaintSelection")
   {
      friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
      If (BrushToolOutsideSelection=3)
         friendly := "OUTSIDE"
      msgu := "Paint " Friendly " image selection area`nCycle through options [K]"
   } Else If InStr(icoFile, "vp-grid")
   {
      msgu := "L: Toggle viewport grid`nR: Configure viewport grid"
   } Else If (btnID="BTNthumbsList")
   {
      msgu := "Cycle through list view modes [L]"
      If (thumbsListViewMode=1)
         msgu := "L: " msgu "`nR: Toggle centered alignment for thumbnails [A]"
   } Else If InStr(icoFile, "view") 
   {
       msgu := "L: Toggle image preview [Z]`nR: Toggle preview area double-size"
   } Else If InStr(icoFile, "search") 
   {
      msgu := "L: Search indexed files [Ctrl + F3]`nR: Search and replace in the files list [Ctrl + H]"
   } Else If InStr(icoFile, "modify-entry") 
   {
      msgu := "L: Rename file" f " [F2]`nR: Modify focused index entry [Ctrl + F2]"
   } Else If InStr(icoFile, "filter") 
   {
      msgu := "L: Filter files list [Ctrl + F]`nR: Deactivate files list filter [Ctrl + Space]"
   } Else If InStr(icoFile, "statistics") 
   {
      msgu := "L: Files list statistics`nR: Find image duplicates"
   } Else If InStr(icoFile, "sort-list") 
   {
      msgu := "Sort files list menu"
   } Else If InStr(icoFile, "refresh") 
   {
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      msgu := "L: Refresh the files list [F5]`nR: " friendly " [Alt + F5]"
   } Else If InStr(icoFile, "folder-tree") 
   {
      msgu := "L: Folders tree view panel [F4]`nR: Explore file location menu [Shift + F4]"
   } Else If InStr(icoFile, "infos") 
   {
      msgu := "L: Image and viewport details [I]`nR: Files information panel [Alt + Enter]"
   } Else If InStr(icoFile, "star") 
   {
      friendly := resultedFilesList[currentFileIndex, 5] ? "Remove from" : "Add to"
      msgu := "L: " friendly " favourites [B]`nR: Favourites menu"
   } Else If InStr(icoFile, "manage-folders") 
   {
      If (RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         friendly := "`nR: Update files list selectively [Ctrl + U]"
      msgu := "L: Manage folders list to be indexed [Alt + U]" friendly
   } Else If InStr(icoFile, "font-size") 
   {
      msgu := "Change viewport font size: " OSDfntSize " [Ctrl + -/=]"
   } Else If InStr(icoFile, "play") 
   {
      friendly := DefineSlideShowType()
      msgu := "L: Play " friendly " slideshow`nR: Slideshow duration settings [Shift + /]"
   } ; Else msgu := "N/A"

   Return msgu
}

ResetLbtn() {
  LbtnDwn := 0
}

WM_MOUSEMOVE(wP, lP, msg, hwnd) {
  Static lastInvoked := 1, prevCtrlHover, prevState, prevMsg
  If (A_TickCount - scriptStartTime < 900) || (AnyWindowOpen && imgEditPanelOpened!=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1 || AnyWindowOpen=24 || AnyWindowOpen=31 || drawingShapeNow=1)
     Return

  MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, OutputVarControl, 2
  thisState := "ä" OutputVarWin OutputVarControl OutputVarX OutputVarY
  If (thisState!=prevState && OutputVarWin=hQPVtoolbar) && (A_TickCount - zeitSillyPrevent>150)
  {
     ctrlHover := OutputVarControl
     msgu := tlbrDecideTooltips(ctrlHover)
     If !msgu
        interfaceThread.ahkFunction("mouseTurnOFFtooltip")

     If (A_TickCount - lastInvoked > 155) && msgu ; && (thisPos!=prevPos)
     {
        ; isThisWin :=(OutputVarWin=PVhwnd) ? 1 : 0
        If (slideShowRunning!=1 && imageLoading!=1 && runningLongOperation!=1 && prevCtrlHover!=ctrlHover && prevMsg!=msgu)
        {
           prevCtrlHover := ctrlHover
           prevMsg := msgu
           prevState := thisState
           thisSize := OSDfntSize//3 + 2
           interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, thisSize)
        }
        ; prevPos := mX "-" mY
        lastInvoked := A_TickCount
     }
        ; ToolTip, % lastInvoked "=" ctrlHover "`n" msgu , , , 2

     ; A := WinActive("A")
     ; okay := (A=PVhwnd || A=hGDIwin || A=hGDIthumbsWin) ? 1 : 0
     If (wP&0x1)
     {
        LbtnDwn := 1
        SetTimer, ResetLbtn, -55
     }
  }
}

TLBRverticalAlign() {
  TLBRverticalAlign := !TLBRverticalAlign
  If (TLBRtwoColumns=1)
     TLBRverticalAlign := 0

  TLBRtwoColumns := 0
  ShowAdvToolbar := 1
  INIaction(1, "TLBRverticalAlign", "General")
  INIaction(1, "TLBRtwoColumns", "General")
  INIaction(1, "ShowAdvToolbar", "General")
  createGUItoolbar()
}


TLBRapplyTwoColumns() {
  TLBRverticalAlign := 1
  TLBRtwoColumns := !TLBRtwoColumns
  ShowAdvToolbar := 1
  INIaction(1, "TLBRverticalAlign", "General")
  INIaction(1, "TLBRtwoColumns", "General")
  INIaction(1, "ShowAdvToolbar", "General")
  createGUItoolbar()
}

TLBRdraggyNow() {

   GetPhysicalCursorPos(oX, oY)
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   Dx := Dy := 0
   lastInvoked := A_TickCount
   ; ToolTip, % "l=" thisZL , , , 2
   While, (determineLClickstate()=1)
   {
      Global zeitSillyPrevent := A_TickCount
      GetPhysicalCursorPos(mX, mY)
      Dx := mX - oX
      Dy := mY - oY
      WinMove, ahk_id %hQPVtoolbar%, , % winX + Dx, % winY + Dy
      Sleep, -1
   }
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   UserToolbarY := winY
   UserToolbarX := winX

   If (isInRange(Dx, -2, 2) && isInRange(Dy, -2, 2) && (A_tickcount - lastInvoked<300))
   {
      invokeTlbrContextMenu()
      Return "m"
   }
   ; createGUItoolbar("forced")
}

invokeKbdToolbarAct(direction) {
   If (isToolbarKBDnav!=1)
   {
       isToolbarKBDnav := 0
       WinActivate, ahk_id %PVhwnd%
       Return
   }

   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   If hwndu
   {
      tlbrInvokeFunction(hwndu, direction, "kbd")
   } Else
   {
      currentKbdBTNtlbr := 0
      moveMouseToolbar(1, 1)
      displayNowToolbarHelp(1)
   }
}

displayNowToolbarHelp(msgu) {
   calcScreenLimits()
   v := OSDfntSize//2
   If (msgu=1)
      msgu := "The toolbar can be navigated with the arrow keys.`nPress Enter to execute the main action.`nPress Shift + Enter for the secondary action."
   Else If (msgu=2)
      msgu := "The toolbar has keyboard focus. Press H for help."
   Else If (msgu=3)
      msgu := "The main window has keyboard focus now"
   interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, v)
}

moveMouseToolbar(direction, stepu) {
   If (isToolbarKBDnav!=1)
   {
       isToolbarKBDnav := 0
       WinActivate, ahk_id %PVhwnd%
       Return
   }

   If (direction=1)
      currentKbdBTNtlbr += stepu
   Else
      currentKbdBTNtlbr -= stepu

   Global zeitSillyPrevent := A_TickCount
   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   If !hwndu
      currentKbdBTNtlbr := (direction=1) ? 0 : 2

   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   If hwndu
   {
      w := tlbrIconzList[hwndu, 7]
      h := tlbrIconzList[hwndu, 8]
      WinGetPos, X, Y, Width, Height, ahk_id %hwndu%
      If (x>ResolutionWidth - ToolBarBtnWidth*2)
         x := ResolutionWidth - ToolBarBtnWidth*2
      If (y>ResolutionHeight - ToolBarBtnWidth*2)
         y := ResolutionHeight - ToolBarBtnWidth*2
      MouseMove, % X + w - 4, % Y + h - 4, 1
   }

   msgu := tlbrDecideTooltips(hwndu)
   thisSize := OSDfntSize//3 + 2
   If msgu
      interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, thisSize)
}

/*
#If, GetKeyState("CapsLock", "T")
\::
SoundBeep 
SendInput, {RButton}
Sleep, 50
SendInput, s
Sleep, 590
SendInput, {LButton}
Sleep, 125
SendInput, ^{f4}
Sleep, 50

Return

LButton::
If GetKeyState("CapsLock", "T")
{
Sleep, 50
SendInput, {LButton}
Sleep, 300
SendInput, ^{PgDn}
SoundBeep , 900, 100
}
Return
#If
*/


