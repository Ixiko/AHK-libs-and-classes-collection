class CppWrapper {

__New(file) 
	{
		fileread, rawcontent , % file			
		this.filefullpath := file
		this.filename :=  "" RegExReplace(file, ".*\\", "")	
		this.filename :=  "" RegExReplace(this.filename, "\.h", "")			
		fileappend, % "CrappyCppHeaderParser is pocessing file: " this.filename ".h`n", *
		this.rawcontent := rawcontent
		this.code := ""
		this.preproc := ""
		this.constants := {}	
		this.error_constants := {}	
		this.GUIDs := []
		this.rawstructs := []
		this.rawinterfaces := []
		this.interfaces := []
		this.enums := []
		this._1stpass()
		this._2ndpass()
		this._3rdpass()
		this._5thpass()
		this.process_interfaces()		
		this._6thpass()
		this._7thpass()
		;this._8thpass()
		this.patch()
		this._1stpass_code := ""
		this._2ndpass_code := ""		
	}
		
save(file_)
{
	File := fileopen(file_, "w")
	name := this.filename
	this.ahkcode := ";File automatically generated by CrappyCppHeaderParser.ahk (Copyright@ peixoto)`n`n"
	this.ahkcode .= "Global " name . " := {}`n"
	
	for k, v in this.GUIDs
		this.ahkcode .= name "." v[1] " := " v[2] "`n"
	
	for k, v in this.interfaces {
		this.ahkcode .= "`n" . name "." v[1] ":= {}"
		this.ahkcode .= "`n" . name "." v[1] ".name := """ v[1] """"
		this.ahkcode .= "`n" . name "." v[1] ".def :=`n( " v[2] """`n)`n"
	}
	
	;for k, v in this.enums {
		;this.ahkcode .= "`n" . name "." k " := {}"
		;for  kk, vv in v
			;this.ahkcode .= "`n" . name "." k "." kk " := " vv
		;this.ahkcode .= "`n"
	;}
	
	this.ahkcode .= "`n" name ".constant := {}"
	for k, v in this.constants 
		this.ahkcode .= "`n" name ".constant[" v " . """"] := " """" k """"
	
	this.ahkcode .= "`n`n" 
	for k, v in this.constants 
		this.ahkcode .= "`nGlobal " k " := " v 
			
	this.ahkcode .= "`n"
	
	this.ahkcode .= "`n" name ".result := {}"
	for k, v in this.error_constants
		this.ahkcode .= "`n" name ".result[" v " . """"] := " """" k """"
	
	this.ahkcode .= "`n`n" ;name ".result_ := {}"	
	for k, v in this.error_constants
		this.ahkcode .= "`nGlobal " k " := " v 
	
	file.write(this.ahkcode)
	file.close()		
}
		
_1stpass()
	{
		fileappend,	% this.filename ".h: Pass1 - " 
		. "Removing comments and spliting preprocessos directives/code`n", *
		contents := regexreplace(this.rawcontent, "\\`r`n") ; join lines			
		loop, parse, contents, `n
			{
				;remove comment blocks
				token := trim(A_loopfield)
				if instr(token, "/*")
					in_comment := 1
			
				if instr(A_loopfield, "*/")
					{
						in_comment := 0
						continue
					}
				if in_comment = 1
					continue
					
				;remove single line comments
				if instr(token, "//") = 1
					continue
					
				;preprocessor
				if instr(token, "#") = 1
					{
						this.preproc .= A_loopfield . "`n"
						continue
					}						
				this.code .= A_loopfield . "`n"
			}	
		this._1stpass_code := this.code		
	}
		
_2ndpass()	
	{	
		fileappend,	% this.filename ".h: Pass2 - Removing  same line comments`n", *
		;removes same line comments			
		contents := this.code
		this.code := ""
		loop, parse, contents, `;
			{					
				stringsplit, field, A_loopfield, `n
				loop % field0
					{
						if not instr(Trim(field%A_index%), "//") = 1
							{
								if not A_index = field0
									this.code .= field%A_index% "`n"
								else this.code .= field%A_index% ";`n"
							}	
					}					
			}
		this._2ndpass_code := this.code				
	}
		
_3rdpass()
	{
		fileappend,	% this.filename ".h: Pass3 - Retriving GUIDs definitions`n", *
		;Get GUIDs definitions
		contents := this.code
		loop, parse, contents, `;
			{
				token := trim(A_loopfield)
				if instr(token, "DEFINE_GUID")
					{
						stringreplace, token, token, DEFINE_GUID(, ,
						stringreplace, token, token, ), ,
						token := trim(regexreplace(token, "s).*{"), "`n`r")
						token := regexreplace(token, "`n")
						token := regexreplace(token, "`r")
						value := """{"
						loop, parse, token, `,
							{	
								tk := trim(A_loopfield)
								if strlen(tk) < 4
									tk := regexreplace(tk, "0x", "0x0")
								if A_index = 1
									key := a_loopfield									
								else if (1 < A_index and A_index < 5)
									value.= regexreplace(tk, "0x") . "-"			
								else if (5 <= A_index and A_index < 7)
									value.= regexreplace(tk, "0x")
								else if A_index = 7
									value.= "-" . regexreplace(tk, "0x") 
								else  
									value.= regexreplace(tk, "0x")						
							} value .= "}"""
						this.GUIDs.insert([Trim(key), trim(value)])		
					}
			}	
	}
	
_5thpass() ;Process interface definitions
	{
		fileappend,	% this.filename ".h: Pass5 - Retriving COM inerfaces definitions`n", *	
		contents := this.code				
		in_interface := 0
		n := 0
		loop, parse, contents, `;
			{
				token := Ltrim(A_loopfield)
				tab_ := "    "
				stringreplace, token, token, %tab_%, ,
				if instr(token, "DECLARE_INTERFACE_") 
					{
						in_interface := 1	
						name := regexreplace(token, "s),.*", "")
						stringreplace, name, name, DECLARE_INTERFACE_(, ,
						name := regexreplace(name, "`r`n", "")
						name := regexreplace(name, "`t", "")
						name := regexreplace(name, "`n", "")
						stringreplace, name, name, %A_space%, ,
						n += 1
						this.rawinterfaces[n] := [name, ""]						
						;continue						
					}
				if in_interface	
					this.rawinterfaces[n][2] .= A_loopfield ";"
		
				if instr(token, "}") 	
					{
						in_interface := 0
						this.rawinterfaces[n][2] := regexreplace(this.rawinterfaces[n][2], "`r`n", "")
					}	
			}
	}	
	
process_interfaces()	
	{
		fileappend,	% this.filename ".h: Processing interfaces definitions for use with" 
		. " the COM interface parser`n", *	

		for k, v in this.rawinterfaces
			{
				this.interfaces[k] := [v[1], v[2]]
				this.interfaces[k][2] := regexreplace(v[2], "s)DECLARE_INTERFACE_.*{", """`n", "" ,1)
				this.interfaces[k][2] := regexreplace(this.interfaces[k][2], "`t", "")
				this.interfaces[k][2] := regexreplace(this.interfaces[k][2], "};", "")
			}				
	}
	
_6thpass() ;process constants
{
	fileappend,	% this.filename ".h: Pass6 - Retriving Constants definitions`n", *
	preproc := this.preproc
	loop, parse, preproc, "`n"
		{
			token := regexreplace(A_loopfield, "\s+", " ")
			stringsplit, token_, token, %A_space%
			if not token_3 
				continue
			stringreplace, token_3, token_3, L, 
			if token_3 is not xdigit 
				continue
			if instr(token_1, "#define") {
					;fileappend, % A_loopfield, *
					this.constants[token_2] := token_3	
				}	
		}	
			
}	

_7thpass() { ;process errocodes on headers that use the MAKE_HRESULT macro
	fileappend,	% this.filename ".h: Retriving error codes definitions`n", *
	return
}

_8thpass() 
{
	fileappend,	% this.filename ".h: Pass3 - Retriving enums`n", *
	;Get enums
	contents := this.code
	loop, parse, contents, `;
		{
			token := trim(A_loopfield)
			stringreplace, token, token, `n, , 1
			stringreplace, token, token, `r, , 1
			if instr(token, "typedef enum")
				{
					name := regexreplace(token, "{.*")
					name := regexreplace(name, ".*_")
					if name and not this.enums[name]
						this.enums[name] := {}
					
					token := regexreplace(token, "}.*")
					token := regexreplace(token, ".*{")
					
					loop, parse, contents, `,
					{
					    tk := regexreplace(A_loopfield, "//.*")
						var := trim(regexreplace(A_loopfield, "=.*"))
						val := regexreplace(A_loopfield, "=.*")
					}	
										
					;loop, parse, token
									
					;token := tk
					fileappend,	% "enum" name token "`n", *	
				}
		}	
		
	for k, v in this.enums
	{
		fileappend,	% "enum" k "`n", *	
		for  kk, vv in v
			fileappend,	% kk "=" vv "`n", *	
	}		
	
}	

patch() {
	return
}
}


